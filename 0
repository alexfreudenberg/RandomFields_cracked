Binary file kaust/dataset_2.RDS matches
Binary file kaust/dataset_update_10.RDS matches
Binary file kaust/dataset_12.RDS matches
Binary file kaust/dataset_13.RDS matches
Binary file kaust/dataset_update_12.RDS matches
Binary file kaust/dataset_10.RDS matches
Binary file kaust/dataset_6.RDS matches
Binary file kaust/dataset_update_11.RDS matches
Binary file kaust/dataset_update_7.RDS matches
Binary file kaust/dataset_9.RDS matches
Binary file kaust/dataset_update_1.RDS matches
Binary file kaust/dataset_8.RDS matches
kaust/fit_kaust.R:  print(system.time(model <- RFfit(RMmatern(nu=NA,scale=NA,var=NA) + RMnugget(var=NA),
Binary file kaust/dataset_update_4.RDS matches
Binary file kaust/dataset_update_2.RDS matches
kaust/fit_kaust2.R:  print(system.time(model <- RFfit(RMmatern(nu=NA,scale=NA,var=NA) + RMnugget(var=NA),
Binary file kaust/dataset_update_15.RDS matches
Binary file kaust/dataset_4.RDS matches
Binary file kaust/dataset_update_8.RDS matches
Binary file kaust/dataset_update_14.RDS matches
Binary file kaust/dataset_update_13.RDS matches
Binary file kaust/dataset_3.RDS matches
Binary file kaust/dataset_update_9.RDS matches
Binary file kaust/dataset_5.RDS matches
kaust/predict.R:## FIRST EXAMPLE: full rank matrix
kaust/predict.R:M <- exp(-as.matrix(dist(x) / n)) 
kaust/predict.R:b <- M %*% b0 + runif(n)
kaust/predict.R:print(system.time(z <- solvex(M, b)))
kaust/predict.R:print(range(b - M %*% z))
kaust/predict.R:stopifnot(all(abs((b - M %*% z)) < 2e-11))
Binary file kaust/dataset_1.RDS matches
Binary file kaust/dataset_update_5.RDS matches
Binary file kaust/dataset_update_16.RDS matches
Binary file kaust/dataset_update_6.RDS matches
Binary file kaust/dataset_update_3.RDS matches
RandomFields/config.log:hostname = afreuden-OMEN-by-HP-Laptop-17-cb1xxx
RandomFields/config.log:uname -v = #70-Ubuntu SMP Tue Jan 12 12:45:47 UTC 2021
RandomFields/config.log:warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
RandomFields/config.log:OFFLOAD_TARGET_NAMES=nvptx-none:hsa
RandomFields/config.log:Configured with: ../src/configure -v --with-pkgversion='Ubuntu 9.3.0-17ubuntu1~20.04' --with-bugurl=file:///usr/share/doc/gcc-9/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++,gm2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-9 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-9-HskZEa/gcc-9-9.3.0/debian/tmp-nvptx/usr,hsa --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
RandomFields/config.log:configure:2317: checking which SIMD flags can be recognized
RandomFields/config.log:  CONFIG_COMMANDS = 
RandomFields/config.log:on afreuden-OMEN-by-HP-Laptop-17-cb1xxx
RandomFields/config.log:config.status:720: creating src/Makevars
RandomFields/config.log:DEFS='-DPACKAGE_NAME=\"RandomFields\" -DPACKAGE_TARNAME=\"randomfields\" -DPACKAGE_VERSION=\"3.5\" -DPACKAGE_STRING=\"RandomFields\ 3.5\" -DPACKAGE_BUGREPORT=\"\" -DPACKAGE_URL=\"\"'
RandomFields/config.log:PACKAGE_NAME='RandomFields'
RandomFields/config.log:PACKAGE_TARNAME='randomfields'
RandomFields/config.log:RANDOMFIELDS_CXXFLAGS='  -msse2 -mssse3 -mavx2'
RandomFields/config.log:RANDOMFIELDS_LIBFLAGS=''
RandomFields/config.log:docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
RandomFields/config.log:#define PACKAGE_NAME "RandomFields"
RandomFields/config.log:#define PACKAGE_TARNAME "randomfields"
RandomFields/config.status:## M4sh Initialization. ##
RandomFields/config.status:DUALCASE=1; export DUALCASE # for MKS sh
RandomFields/config.status:  NULLCMD=:
RandomFields/config.status:# We did not find ourselves, most probably we were run as `sh COMMAND'
RandomFields/config.status:for as_var in BASH_ENV ENV MAIL MAILPATH
RandomFields/config.status:as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
RandomFields/config.status:    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
RandomFields/config.status:## Main body of $CONFIG_STATUS script. ##
RandomFields/config.status:  CONFIG_COMMANDS = $CONFIG_COMMANDS
RandomFields/config.status:config_files=" src/Makevars"
RandomFields/config.status:      --file=FILE[:TEMPLATE]
RandomFields/config.status:    "src/Makevars") CONFIG_FILES="$CONFIG_FILES src/Makevars" ;;
RandomFields/config.status:# Have a temporary directory for convenience.  Make it in the build tree
RandomFields/config.status:  tmp=./conf$$-$RANDOM
RandomFields/config.status:S["RANDOMFIELDS_LIBFLAGS"]=""
RandomFields/config.status:S["RANDOMFIELDS_CXXFLAGS"]="  -msse2 -mssse3 -mavx2"
RandomFields/config.status:S["DEFS"]="-DPACKAGE_NAME=\\\"RandomFields\\\" -DPACKAGE_TARNAME=\\\"randomfields\\\" -DPACKAGE_VERSION=\\\"3.5\\\" -DPACKAGE_STRING=\\\"RandomFields\\ 3.5\\\" -DPACKAGE_BUGREP"\
RandomFields/config.status:S["docdir"]="${datarootdir}/doc/${PACKAGE_TARNAME}"
RandomFields/config.status:S["PACKAGE_TARNAME"]="randomfields"
RandomFields/config.status:S["PACKAGE_NAME"]="RandomFields"
RandomFields/config.status:# FIXME: This hack should be removed a few years after 2.60.
RandomFields/config.status:  s&@docdir@&${datarootdir}/doc/${PACKAGE_TARNAME}&g
RandomFields/inst/CITATION:bibentry(bibtype="Manual",
RandomFields/inst/CITATION:         author = c(person("Martin", "Schlather", role=c("cre", "aut")),
RandomFields/inst/CITATION:             person("Alexander", "Malinowski", role="aut"),
RandomFields/inst/CITATION:             person("Marco", "Oesting", role="aut"),
RandomFields/inst/CITATION:             person("Johannes", "Martini", role="aut"),
RandomFields/inst/CITATION:             person("Olga", "Moreva", role="aut"),
RandomFields/inst/CITATION:             person(given=c("Peter", "J"), family="Menck",  role="ctr"),
RandomFields/inst/CITATION:  title        = "Analysis, Simulation and Prediction of Multivariate Random Fields with Package {RandomFields}",
RandomFields/inst/CITATION:  author       = personList(as.person("Martin Schlather"),
RandomFields/inst/CITATION:                   as.person("Alexander Malinowski"),
RandomFields/inst/CITATION:                   as.person("Peter J. Menck"),
RandomFields/inst/CITATION:                   as.person("Marco Oesting"),
RandomFields/inst/CITATION:  paste("Martin Schlather, Alexander Malinowski, Peter J. Menck, Marco Oesting, Kirstin Strokorb (2015).",
RandomFields/inst/CITATION:        "Analysis, Simulation and Prediction of Multivariate Random Fields with Package RandomFields.",
RandomFields/DESCRIPTION:Author: Martin Schlather [aut, cre], Alexander Malinowski [aut], Marco Oesting [aut], Daphne Boecker [aut], Kirstin Strokorb [aut], Sebastian Engelke [aut], Johannes Martini [aut], Felix Ballani [aut], Olga Moreva [aut], Jonas Auel[ctr], Peter Menck [ctr], Sebastian Gross [ctr], Ulrike Ober [ctb], Felix Reinbot [ctb], Paulo Ribeiro [ctb], Brian Dmake. Ripley [ctb], Richard Singleton [ctb], Ben Pfaff [ctb], R Core Team [ctb]
RandomFields/DESCRIPTION:Maintainer: Martin Schlather <schlather@math.uni-mannheim.de>
RandomFields/DESCRIPTION:Description: Methods for the inference on and the simulation of Gaussian fields are provided, as well as methods for the simulation of extreme value random fields. Main geostatistical parts are based on the books by Christian Lantuejoul <doi:10.1007/978-3-662-04808-5>, Jean-Paul Chiles and Pierre Delfiner <doi:10.1002/9781118136188> and Noel A. Cressie <doi:10.1002/9781119115151>. For the extreme value random fields see Oesting, Schlather, Schillings (2019) <doi.org/10.1002/sta4.228> and Schlather (2002) <doi.org/10.1023/A:1020977924878>.
RandomFields/DESCRIPTION:        Likelihoodratio.R Methods-aux.R Methods-RFsp.R
RandomFields/DESCRIPTION:        RFempvario-Methods-plots.R RFempvario.R RFfit.R RFgui.R
RandomFields/DESCRIPTION:        simu-plots.R rf.R RMmodels-Methods-plots.R RMmodelsBasics.R
RandomFields/DESCRIPTION:        RMmodels.R RMmodelsSpecial.R RMmodelsConvenience.R RQmodels.R
RandomFields/man/RFgetMethodNames.Rd:\name{RFgetMethodNames}
RandomFields/man/RFgetMethodNames.Rd:\alias{RFgetMethodNames}
RandomFields/man/RFgetMethodNames.Rd: \command{\link{RFgetMethodNames}} prints and returns a list of currently
RandomFields/man/RFgetMethodNames.Rd:RFgetMethodNames()
RandomFields/man/RFgetMethodNames.Rd: Modified circulant embedding method so that exact simulation is guaranteed
RandomFields/man/RFgetMethodNames.Rd: hypermodel, see \command{\link{RMmodel}}, and \eqn{A=B} there.
RandomFields/man/RFgetMethodNames.Rd: Modified circulant embedding so that exact simulation is guaranteed
RandomFields/man/RFgetMethodNames.Rd: hypermodel, see \command{\link{RMmodel}}, and \eqn{A=B} there.
RandomFields/man/RFgetMethodNames.Rd: \item Marked point processes.\cr
RandomFields/man/RFgetMethodNames.Rd: \item \code{add.MPP} (Random coins).\cr
RandomFields/man/RFgetMethodNames.Rd: \item \code{max.MPP} (Boolean functions).\cr
RandomFields/man/RFgetMethodNames.Rd: \item \code{spectral TBM} (Spectral turning bands).\cr
RandomFields/man/RFgetMethodNames.Rd: The principle of \code{spectral TBM}
RandomFields/man/RFgetMethodNames.Rd: spectral technique (Mantoglou and Wilson, 1982).
RandomFields/man/RFgetMethodNames.Rd: \item \code{TBM2}, \code{TBM3} (Turning bands methods; turning layers).\cr
RandomFields/man/RFgetMethodNames.Rd: (\code{TBM2}) directly
RandomFields/man/RFgetMethodNames.Rd: \code{TBM3}) and taking a 2-dimensional cross-section.
RandomFields/man/RFgetMethodNames.Rd: TBM3 allows for multiplicative models; in case of anisotropy the
RandomFields/man/RFgetMethodNames.Rd: \code{TBM2} and \code{TBM3} allow for arbitrary points, and
RandomFields/man/RFgetMethodNames.Rd: depend heavily on \code{TBM*.linesimustep} and
RandomFields/man/RFgetMethodNames.Rd: \code{TBM*.linesimufactor}
RandomFields/man/RFgetMethodNames.Rd: \code{TBM*.linesimufactor=2} is too small.
RandomFields/man/RFgetMethodNames.Rd:\note{Most methods possess additional arguments,
RandomFields/man/RFgetMethodNames.Rd: Gneiting, T. and Schlather, M. (2004)
RandomFields/man/RFgetMethodNames.Rd: Schlather, M. (1999) \emph{An introduction to positive definite
RandomFields/man/RFgetMethodNames.Rd: Technical report ST 99-10, Dept. of Maths and Statistics,
RandomFields/man/RFgetMethodNames.Rd: Stein, M.L. (2002)
RandomFields/man/RFgetMethodNames.Rd: Gneiting, T., Sevcikova, H., Percival, D.B., Schlather, M. and
RandomFields/man/RFgetMethodNames.Rd: \item Markov Gaussian Random Field:
RandomFields/man/RFgetMethodNames.Rd: Rue, H. (2001) Fast sampling of Gaussian Markov random fields.
RandomFields/man/RFgetMethodNames.Rd: Rue, H., Held, L. (2005) \emph{Gaussian Markov Random Fields:
RandomFields/man/RFgetMethodNames.Rd: Monographs on Statistics and Applied Probability, no \bold{104},
RandomFields/man/RFgetMethodNames.Rd: \item Turning bands method (TBM), turning layers:
RandomFields/man/RFgetMethodNames.Rd: Mantoglou, A. and Wilson, J.L. (1982) The turning bands method for
RandomFields/man/RFgetMethodNames.Rd: Matheron, G. (1973)
RandomFields/man/RFgetMethodNames.Rd: Schlather, M. (2004)
RandomFields/man/RFgetMethodNames.Rd: Matheron, G. (1967) \emph{Elements pour une Theorie des Milieux
RandomFields/man/RFgetMethodNames.Rd: Poreux}. Paris: Masson.
RandomFields/man/RFgetMethodNames.Rd: \command{\link{RMmodel}},
RandomFields/man/RFgetMethodNames.Rd:RFgetMethodNames()
RandomFields/man/RFformula.Rd:\alias{RMformula}
RandomFields/man/RFformula.Rd: \item to describe models in the \dQuote{Linear Mixed
RandomFields/man/RFformula.Rd: Models}-framework %including fixed and random effects
RandomFields/man/RFformula.Rd: the expression \command{\link{RMfixed}} and the function
RandomFields/man/RFformula.Rd: \command{\link{RMshape}}. In simple cases, the trend can also
RandomFields/man/RFformula.Rd: components are adressed by objects of class \code{\link[=RMmodel-class]{RMmodel}}, which
RandomFields/man/RFformula.Rd: Models given by formulae can be plotted only by \link{RFplot}.
RandomFields/man/RFformula.Rd: Define all formulae with \code{params}. Within the \code{RMmodel}, use
RandomFields/man/RFformula.Rd: E.g., \code{RMmodel(var = V)} is correct; but
RandomFields/man/RFformula.Rd: \code{RMmodel(sc=V, var=V)},  \code{RMmodel(var=2 * V)}
RandomFields/man/RFformula.Rd: \code{RMmodel1(sc=S, var=V)} is correct.
RandomFields/man/RFformula.Rd: \code{RMmodel(sc=V,  var=V)}, this variable must be \command{RMdeclare}d, e.g.
RandomFields/man/RFformula.Rd: \code{RMmodel(sc=V, var=V) + RMdeclare(X=X)}.
RandomFields/man/RFformula.Rd:% optional, should be a sum (using \command{\link[=RMplus]{+}})%%check link
RandomFields/man/RFformula.Rd:% of components either of the form \code{X@RMfixed(beta)} or
RandomFields/man/RFformula.Rd:% \code{\link{RMshape}(...)} with \eqn{X} being a design matrix 
RandomFields/man/RFformula.Rd:% \command{\link{RMfixed}} and \command{\link{RMshape}}).\cr
RandomFields/man/RFformula.Rd:% \code{X@RMfixed(beta=NA)} by default (and \eqn{\beta} is estimated
RandomFields/man/RFformula.Rd:% optional, should be a sum (using \command{\link[=RMplus]{+}})%%check link
RandomFields/man/RFformula.Rd:%class \code{\link[=RMmodel-class]{RMmodel}}.\cr
RandomFields/man/RFformula.Rd: optional, should be of the form \code{\link{RMnugget}(...)}.
RandomFields/man/RFformula.Rd: \command{\link{RMnugget}} describes a vector
RandomFields/man/RFformula.Rd:\section{IMPORTANT}{
RandomFields/man/RFformula.Rd: \item Chiles, J.-P. and P. Delfiner (1999) \emph{Geostatistics. Modeling
RandomFields/man/RFformula.Rd: \item McCulloch, C. E., Searle, S. R. and Neuhaus, J. M. (2008)
RandomFields/man/RFformula.Rd: \item Ruppert, D. and Wand, M. P. and Carroll, R. J. (2003)
RandomFields/man/RFformula.Rd:  \command{\link{RMmodel}},
RandomFields/man/RFformula.Rd:M <- 3
RandomFields/man/RFformula.Rd:model <- RMexp(var=V, scale=s) + M
RandomFields/man/RFformula.Rd:model <- ~ Mean + RMexp(var=Var, scale=Sc)
RandomFields/man/RFformula.Rd:simulated2 <- RFsimulate(model = model,x=x, y=y, Var=V, Sc=s, Mean=M)
RandomFields/man/RFformula.Rd:model <- ~ M + RMexp(var=var, scale=sc)
RandomFields/man/RFformula.Rd:                         param=list(var=V, sc=s, M=M))
RandomFields/man/RFformula.Rd:model.na <- ~ NA + RMexp(var=NA, scale=NA)
RandomFields/man/RFformula.Rd:# compare sample mean of data with ML estimate, which is very similar:
RandomFields/man/RFformula.Rd:C <- RMplus(RMexp(var=3), RMgauss(var=1.5), Aniso=matrix(c(2,0,0,1),nrow=2))
RandomFields/man/RFformula.Rd:C <- RMS(RMexp(var=3) + RMgauss(var=1.5), anisoT=matrix(c(2,0,0,1),nrow=2))
RandomFields/man/RFformula.Rd:model <- RMshape(RMpolynome(1, value=c(2, 1.5, -3), dim=2)) + C # ~ optional
RandomFields/man/RFformula.Rd:Cest <- RMS(RMexp(var=2) + RMgauss(var=2),
RandomFields/man/RFformula.Rd:model.na <- ~  RMpolynome(1, dim=2) + Cest
RandomFields/man/RMmodel.Rd:\name{RMmodel}
RandomFields/man/RMmodel.Rd:\alias{RMmodel}
RandomFields/man/RMmodel.Rd:\alias{RMmodels}
RandomFields/man/RMmodel.Rd:\alias{[,RMmodel,ANY,ANY-method} %]
RandomFields/man/RMmodel.Rd:\alias{[<-,RMmodel,ANY,ANY-method} %]
RandomFields/man/RMmodel.Rd:\title{Covariance and Variogram Models in \pkg{RandomFields} (RM commands)}
RandomFields/man/RMmodel.Rd: \deqn{RM_name_(..., var, scale, Aniso, proj)}
RandomFields/man/RMmodel.Rd: \code{Aniso} an optional anisotropy matrix \eqn{A} or given by \command{\link{RMangle}}, and
RandomFields/man/RMmodel.Rd: See \command{\link{RMS}} for more details.
RandomFields/man/RMmodel.Rd: \command{RM_name_} must be a function of class
RandomFields/man/RMmodel.Rd: \command{\link[=RMmodelgenerator-class]{RMmodelgenerator}}.
RandomFields/man/RMmodel.Rd: The return value of all functions \command{RM_name_} is of class
RandomFields/man/RMmodel.Rd: \command{\link[=RMmodel-class]{RMmodel}}.\cr
RandomFields/man/RMmodel.Rd: (cf. \command{\link{RFgetModelNames}}):
RandomFields/man/RMmodel.Rd: \command{\link{RMcauchy}} \tab Cauchy family \cr
RandomFields/man/RMmodel.Rd: \command{\link{RMexp}} \tab exponential model \cr
RandomFields/man/RMmodel.Rd: \command{\link{RMgencauchy}} \tab generalized Cauchy family \cr
RandomFields/man/RMmodel.Rd: \command{\link{RMgauss}} \tab Gaussian model \cr
RandomFields/man/RMmodel.Rd: \command{\link{RMgneiting}} \tab differentiable model with compact support \cr
RandomFields/man/RMmodel.Rd: \command{\link{RMmatern}} \tab Whittle-Matern model \cr
RandomFields/man/RMmodel.Rd: \command{\link{RMnugget}} \tab nugget effect model \cr
RandomFields/man/RMmodel.Rd: \command{\link{RMspheric}} \tab spherical model \cr
RandomFields/man/RMmodel.Rd: \command{\link{RMstable}} \tab symmetric stable family or powered exponential model \cr
RandomFields/man/RMmodel.Rd: \command{\link{RMwhittle}} \tab Whittle-Matern model, alternative
RandomFields/man/RMmodel.Rd: \command{\link{RMfbm}} \tab fractal Brownian motion\cr
RandomFields/man/RMmodel.Rd: \command{\link{RMmult}}, \code{*} \tab product of covariance models \cr
RandomFields/man/RMmodel.Rd: \command{\link{RMplus}}, \code{+} \tab sum of covariance models or variograms\cr
RandomFields/man/RMmodel.Rd:% \command{\link{RMfixcov}} \tab constant pre-defined covariance \cr
RandomFields/man/RMmodel.Rd:% \command{\link{RMfixed}} \tab fixed or trend effects;
RandomFields/man/RMmodel.Rd:% caution: \link{RMfixed} is not
RandomFields/man/RMmodel.Rd:% %\command{\link{RMmixed}} \tab Mixture of fixed, mixed, and random effect
RandomFields/man/RMmodel.Rd:   \command{\link{RMshape}} \tab trend \cr
RandomFields/man/RMmodel.Rd:   \command{\link{RMangle}} \tab defines a 2x2 anisotropy matrix by
RandomFields/man/RMmodel.Rd:% \bold{See \link{RMmodelsAdvanced} for many more, advanced models.\cr
RandomFields/man/RMmodel.Rd: \emph{Geostatistics. Modeling Spatial Uncertainty.}
RandomFields/man/RMmodel.Rd: % \item Gneiting, T. and Schlather, M. (2004)
RandomFields/man/RMmodel.Rd: \item Schlather, M. (1999) \emph{An introduction to positive definite
RandomFields/man/RMmodel.Rd: Technical report ST 99-10, Dept. of Maths and Statistics,
RandomFields/man/RMmodel.Rd: \item Schlather, M. (2011) Construction of covariance functions and
RandomFields/man/RMmodel.Rd: unconditional simulation of random fields. In Porcu, E., Montero, J.M.
RandomFields/man/RMmodel.Rd: and Schlather, M., \emph{Space-Time Processes and Challenges Related
RandomFields/man/RMmodel.Rd: \item Yaglom, A.M. (1987) \emph{Correlation Theory of Stationary and
RandomFields/man/RMmodel.Rd: \item Wackernagel, H. (2003) \emph{Multivariate Geostatistics.} Berlin:
RandomFields/man/RMmodel.Rd:\author{Alexander Malinowski; \martin}
RandomFields/man/RMmodel.Rd:  \link{RM} for an overview over more advanced classes of models\cr
RandomFields/man/RMmodel.Rd:  \command{\link{RMmodelsAdvanced}},
RandomFields/man/RMmodel.Rd:  \command{\link{RMmodelsAuxiliary}},
RandomFields/man/RMmodel.Rd:model <- RMexp(var=1.6, scale=0.5) + RMnugget(var=0) #exponential + nugget
RandomFields/man/RPtbm.Rd: \command{\link{RMtbm}}.
RandomFields/man/RPtbm.Rd: For details see \command{\link{RMtbm}}.
RandomFields/man/RPtbm.Rd:  \item{phi}{object of class \code{\link[=RMmodel-class]{RMmodel}};
RandomFields/man/RPtbm.Rd:    (see \code{RFgetModelNames(type="positive definite",
RandomFields/man/RPtbm.Rd:    traditional TBM is not applicable.
RandomFields/man/RPtbm.Rd:    \code{points} gives the number of points simulated on the TBM
RandomFields/man/RPtbm.Rd:    some special models such as \command{\link{RMnsst}}, and
RandomFields/man/RPtbm.Rd: \code{RPtbm} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RPtbm.Rd:    \emph{Geostatistical Simulation: Models and Algorithms.}
RandomFields/man/RPtbm.Rd:    Matheron, G. (1973).
RandomFields/man/RPtbm.Rd:    Strokorb, K., Ballani, F., and  Schlather, M. (2014)
RandomFields/man/RPtbm.Rd:    \item Schlather, M. (2011) Construction of covariance functions and
RandomFields/man/RPtbm.Rd:    unconditional simulation of random fields. In Porcu, E., Montero, J.M.
RandomFields/man/RPtbm.Rd:    and Schlather, M., \emph{Space-Time Processes and Challenges Related
RandomFields/man/RPtbm.Rd:model <- RPtbm(RMstable(s=1, alpha=1.8))
RandomFields/man/RPtbm.Rd:model <- RPtbm(RMexp(Aniso=matrix(nc=2, rep(1,4))))
RandomFields/man/RPtbm.Rd:model <- RMgneiting(orig=FALSE, scale=0.4)
RandomFields/man/RPtbm.Rd:plot(z, MARGIN.slices=4, MARGIN.movie=3)
RandomFields/man/RMrotat.Rd:\name{RMrotat}
RandomFields/man/RMrotat.Rd:\alias{RMrotat}
RandomFields/man/RMrotat.Rd:\alias{RMrotation}
RandomFields/man/RMrotat.Rd:  \command{RMrotat} and \command{RMrotation} are
RandomFields/man/RMrotat.Rd:RMrotat(speed, phi) 
RandomFields/man/RMrotat.Rd:RMrotation(phi)
RandomFields/man/RMrotat.Rd: \command{\link{RMrotat}} and \command{\link{RMrotation}} are
RandomFields/man/RMrotat.Rd: \command{\link{RMrotat}} and \command{\link{RMrotation}} return an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMrotat.Rd:  \command{\link{RMmodel}},
RandomFields/man/RMschlather.Rd:\name{RMschlather}
RandomFields/man/RMschlather.Rd:\alias{RMschlather}
RandomFields/man/RMschlather.Rd:\title{Covariance Model for binary field based on Gaussian field}
RandomFields/man/RMschlather.Rd:  \command{RMschlather} gives
RandomFields/man/RMschlather.Rd:RMschlather(phi, var, scale, Aniso, proj)
RandomFields/man/RMschlather.Rd: \item{phi}{covariance function of class \code{\link[=RMmodel-class]{RMmodel}}.}
RandomFields/man/RMschlather.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMschlather.Rd: \command{\link{RMschlather}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMschlather.Rd: \command{\link{RMmodel}},
RandomFields/man/RMschlather.Rd:model <- RMgneiting()
RandomFields/man/RMschlather.Rd:plot(model, model.tail.corr.fct=RMschlather(model),  xlim=c(0, 5))
RandomFields/man/RMschlather.Rd:## Note that in RFsimulate R-P-schlather was called, not R-M-schlather.
RandomFields/man/RMschlather.Rd:z <- RFsimulate(RMschlather(model), x)
RandomFields/man/RFgetModelNames.Rd:\name{RFgetModelNames}
RandomFields/man/RFgetModelNames.Rd:\alias{RFgetModelNames}
RandomFields/man/RFgetModelNames.Rd:%\alias{PrintModelList}
RandomFields/man/RFgetModelNames.Rd:  variogram models (see \command{\link{RMmodel}}) and returns them as a
RandomFields/man/RFgetModelNames.Rd:  \command{\link[=RMmodelgenerator-class]{RMmodelgenerator}}
RandomFields/man/RFgetModelNames.Rd:RFgetModelNames(type = RC_TYPE_NAMES, domain = RC_DOMAIN_NAMES,
RandomFields/man/RFgetModelNames.Rd:                isotropy = RC_ISO_NAMES, operator = c(TRUE, FALSE),
RandomFields/man/RFgetModelNames.Rd:                monotone = RC_MONOTONE_NAMES,
RandomFields/man/RFgetModelNames.Rd:    see \link{constants} for the definition of \code{RC_TYPE_NAMES},
RandomFields/man/RFgetModelNames.Rd:    \code{RC_DOMAIN_NAMES}, etc.
RandomFields/man/RFgetModelNames.Rd:    See also \code{\link[=RMmodelgenerator-class]{RMmodelgenerator}}.
RandomFields/man/RFgetModelNames.Rd:    \command{\link{RFgetModelNames}} behaves very differently.
RandomFields/man/RFgetModelNames.Rd:  \command{\link{RFgetModelNames}} prints a table of the currently
RandomFields/man/RFgetModelNames.Rd:    if \code{TRUE} also \code{\link{RMmodels}} are listed that are
RandomFields/man/RFgetModelNames.Rd:    list notation is chosen; see  \link{Advanced RMmodels} for the
RandomFields/man/RFgetModelNames.Rd: The plain call \code{\link{RFgetModelNames}()} simply gives back a
RandomFields/man/RFgetModelNames.Rd: \command{\link[=RMmodelgenerator-class]{RMmodelgenerator}}.
RandomFields/man/RFgetModelNames.Rd:     \command{\link[=RMmodelgenerator-class]{RMmodelgenerator}}
RandomFields/man/RFgetModelNames.Rd:     \command{\link[=RMmodelgenerator-class]{RMmodelgenerator}}
RandomFields/man/RFgetModelNames.Rd:     \command{\link[=RMmodelgenerator-class]{RMmodelgenerator}}
RandomFields/man/RFgetModelNames.Rd:     e.g. \command{\link[=RMplus]{+}} or
RandomFields/man/RFgetModelNames.Rd:     \command{\link{RMdelay}} are operators; see
RandomFields/man/RFgetModelNames.Rd:     \command{\link[=RMmodelgenerator-class]{RMmodelgenerator}}
RandomFields/man/RFgetModelNames.Rd:     scale mixture, the latter including \command{\link{RMexp}} or
RandomFields/man/RFgetModelNames.Rd:     \command{\link{RMcauchy}}; see
RandomFields/man/RFgetModelNames.Rd:     \command{\link[=RMmodelgenerator-class]{RMmodelgenerator}}
RandomFields/man/RFgetModelNames.Rd:     model has finite range, e.g. \command{\link{RMcircular}} or
RandomFields/man/RFgetModelNames.Rd:     \command{\link{RMnugget}} have covariances with finite range; see
RandomFields/man/RFgetModelNames.Rd:     \command{\link[=RMmodelgenerator-class]{RMmodelgenerator}}.
RandomFields/man/RFgetModelNames.Rd:     on the parameters of the \command{\link{RMmodel}} object;
RandomFields/man/RFgetModelNames.Rd:     \command{\link[=RMmodelgenerator-class]{RMmodelgenerator}}
RandomFields/man/RFgetModelNames.Rd:     \command{\link{RMmodel}} object;
RandomFields/man/RFgetModelNames.Rd:     \command{\link[=RMmodelgenerator-class]{RMmodelgenerator}}
RandomFields/man/RFgetModelNames.Rd: \code{\link[=RMmodelgenerator-class]{RMmodelgenerator}}.
RandomFields/man/RFgetModelNames.Rd: \command{\link{RFgetModelNames}} prints a table of the currently
RandomFields/man/RFgetModelNames.Rd: \command{\link{RFgetModelNames}} returns \code{NULL}.
RandomFields/man/RFgetModelNames.Rd: \code{\link[=RMmodelgenerator-class]{RMmodelgenerator}},
RandomFields/man/RFgetModelNames.Rd: \code{\link{RMmodel}},
RandomFields/man/RFgetModelNames.Rd: \link{RC_DOMAIN_NAMES}, \link{RC_ISO_NAMES}
RandomFields/man/RFgetModelNames.Rd:RFgetModelNames()
RandomFields/man/RFgetModelNames.Rd:RFgetModelNames(type="positive definite", exact.match=TRUE)
RandomFields/man/RFgetModelNames.Rd:\dontrun{RFgetModelNames(type="positive definite")}
RandomFields/man/RFgetModelNames.Rd:RFgetModelNames(type="positive definite", domain="single variable",
RandomFields/man/RFgetModelNames.Rd:\dontrun{RFgetModelNames(type="positive definite", domain="single variable")}
RandomFields/man/RFgetModelNames.Rd:RFgetModelNames(group.by=NULL)
RandomFields/man/RFgetModelNames.Rd:str(RFgetModelNames(type="positive definite", domain="single variable",
RandomFields/man/RFgetModelNames.Rd:RFgetModelNames(type=c("tail correlation function",
RandomFields/man/RFgetModelNames.Rd:str(RFgetModelNames(type=c("positive definite", "variogram", "process"),
RandomFields/man/RFoptionsMessages.Rd:\name{RFoptionsMessages}
RandomFields/man/RFoptionsMessages.Rd:\alias{RFoptionsMessages}
RandomFields/man/RFoptionsMessages.Rd:Most of the options below change their value in a session
RandomFields/man/RFoptionsMessages.Rd:    result obtained by MLE. So this result is extracted.
RandomFields/man/RFoptionsMessages.Rd:    Minor problem when trying to detect whether it is a grid
RandomFields/man/RFoptionsMessages.Rd:    More severe problem when trying to detect whether it is a grid
RandomFields/man/RFoptionsMessages.Rd:    The definition of \command{\link{RMconstant}} has changed.
RandomFields/man/RFcrossvalidate.Rd:  \item{model,params}{\argModel }
RandomFields/man/RFcrossvalidate.Rd:\section{Methods}{
RandomFields/man/RFcrossvalidate.Rd:    \emph{Model selection and Multi-Model Inference: A Practical
RandomFields/man/RFcrossvalidate.Rd: of the covariance model as given in \command{\link{RMmodel}}.
RandomFields/man/RFcrossvalidate.Rd:  \command{\link{RMmodel}},
RandomFields/man/RFcrossvalidate.Rd:model <- RMgencauchy(alpha=1, beta=2)
RandomFields/man/RFcrossvalidate.Rd:estmodel <- RMgencauchy(var=NA, scale=NA, alpha=NA, beta=2) +
RandomFields/man/RFcrossvalidate.Rd:            RMshape(mean=NA)
RandomFields/man/RMexp.Rd:\name{RMexp}
RandomFields/man/RMexp.Rd:\alias{RMexp}
RandomFields/man/RMexp.Rd:\title{Exponential Covariance Model}
RandomFields/man/RMexp.Rd: \command{\link{RMexp}} is a stationary isotropic covariance model whose
RandomFields/man/RMexp.Rd:RMexp(var, scale, Aniso, proj)
RandomFields/man/RMexp.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMexp.Rd: This model is a special case of the Whittle covariance model (see \command{\link{RMwhittle}}) if \eqn{\nu=\frac{1}{2}}{\nu=0.5} and of the symmetric stable family (see \command{\link{RMstable}}) if \eqn{\nu = 1}{\nu=1}. Moreover,
RandomFields/man/RMexp.Rd: \command{\link{RMexp}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMexp.Rd:    \item Gelfand, A. E., Diggle, P., Fuentes, M. and Guttorp,
RandomFields/man/RMexp.Rd:    \item Strokorb, K., Ballani, F., and  Schlather, M. (2014)
RandomFields/man/RMexp.Rd: \command{\link{RMwhittle}},
RandomFields/man/RMexp.Rd: \command{\link{RMstable}},
RandomFields/man/RMexp.Rd: \command{\link{RMmodel}},
RandomFields/man/RMexp.Rd:model <- RMexp()
RandomFields/man/RFloglikelihood.Rd: ML of the linear model is returned.
RandomFields/man/RFloglikelihood.Rd: \item{model,params}{\argModel}
RandomFields/man/RFloglikelihood.Rd: \command{\link{RMmodel}},
RandomFields/man/RFloglikelihood.Rd:model <- RMexp()
RandomFields/man/RFloglikelihood.Rd:#trend <- RMshape(mean=0)
RandomFields/man/RFloglikelihood.Rd:model <- 2 * RMexp() + trend
RandomFields/man/RFloglikelihood.Rd:model <- 2 * RMexp() + trend
RandomFields/man/RMmqam.Rd:\name{RMmqam}
RandomFields/man/RMmqam.Rd:\alias{RMmqam}
RandomFields/man/RMmqam.Rd:\alias{RMmqam}
RandomFields/man/RMmqam.Rd: \command{\link{RMmqam}} is a multivariate stationary covariance model depending
RandomFields/man/RMmqam.Rd:RMmqam(phi, C1, C2, C3, C4, C5, C6, C7, C8, C9, theta, var, scale, Aniso, proj)
RandomFields/man/RMmqam.Rd:  \item{phi}{a valid covariance \command{\link{RMmodel}}
RandomFields/man/RMmqam.Rd:    \code{\link{RFgetModelNames}(monotone="normal mixture")}
RandomFields/man/RMmqam.Rd: \item{C1, C2, C3, C4, C5, C6, C7, C8, C9}{optional further stationary \command{\link{RMmodel}}s}
RandomFields/man/RMmqam.Rd: \item{var,scale,Aniso,proj}{optional arguments; same meaning for any \command{\link{RMmodel}}. If not passed, the above covariance function remains unmodified.}
RandomFields/man/RMmqam.Rd: e.g. \command{\link{RMstable}}, \command{\link{RMgauss}}, \command{\link{RMexponential}}.
RandomFields/man/RMmqam.Rd: \command{\link{RMmqam}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMmqam.Rd: \item Porcu, E., Mateu, J. & Christakos, G. (2009) Quasi-arithmetic
RandomFields/man/RMmqam.Rd: space-time data. \emph{Journal of Multivariate Analysis}, \bold{100},
RandomFields/man/RMmqam.Rd: \command{\link{RMqam}},
RandomFields/man/RMmqam.Rd: \command{\link{RMmodel}},
RandomFields/man/RMmqam.Rd:model <- RMmqam(phi=RMgauss(),RMgauss(),RMexp(),theta=c(0.4, 0.6), scale=0.5)
RandomFields/man/RC.Rd:\alias{RC_ISO_NAMES}
RandomFields/man/RC.Rd:\alias{RC_TYPE_NAMES}
RandomFields/man/RC.Rd:\alias{RC_DOMAIN_NAMES}
RandomFields/man/RC.Rd:\alias{RC_MONOTONE_NAMES}
RandomFields/man/RC.Rd:\alias{RC_GNOMONIC_PROJ}
RandomFields/man/RC.Rd:\alias{RC_OPTIMISER_NAMES}
RandomFields/man/RC.Rd:\alias{RC_NLOPTR_NAMES}
RandomFields/man/RC.Rd:\alias{RC_LIKELIHOOD_NAMES}
RandomFields/man/RC.Rd:\alias{RC_METHOD_NAMES}
RandomFields/man/RC.Rd:  the use of some functions easier, e.g. \command{\link{RFgetModelNames}}.
RandomFields/man/RC.Rd:  \code{RC_TYPE_NAMES = c(
RandomFields/man/RC.Rd:  \code{RC_DOMAIN_NAMES = c("single variable", "kernel",
RandomFields/man/RC.Rd:  \code{RC_ISO_NAMES = c("isotropic", "space-isotropic",
RandomFields/man/RC.Rd:  \code{RC_MONOTONE_NAMES = c(
RandomFields/man/RC.Rd:  \code{RC_GNOMONIC_PROJ} gives the numerical code for
RandomFields/man/RC.Rd:  \code{RC_OPTIMISER_NAMES} and \code{RC_NLOPTR_NAMES} give the
RandomFields/man/RC.Rd:  \code{RC_LIKELIHOOD_NAMES = c("auto", "full", "composite",
RandomFields/man/RC.Rd:  gives the names of the ML variants: (i) internal
RandomFields/man/RC.Rd:  \code{RC_METHOD_NAMES = c("circulant", "cutoff", "intrinsic", "tbm", 
RandomFields/man/RC.Rd:  \code{RC_MAXSTABLE_NAMES = c("brownresnick", "opitz", "schlather", "smith")}
RandomFields/man/RC.Rd:  \link{RF},   \link{RM},  \link{RP}, \link{RR}, \link{R.},
RandomFields/man/RC.Rd:  \command{\link{RFgetModelNames}},
RandomFields/man/RC.Rd:  \link{RMmodelgenerator-class},
RandomFields/man/RC.Rd:  \command{\link{RMtrafo}}.
RandomFields/man/RC.Rd:RC_ISO_NAMES
RandomFields/man/RC.Rd:RC_ISO_NAMES[RC_ISOTROPIC:RC_CARTESIAN_COORD + 1]
RandomFields/man/RC.Rd:RFgetModelNames(isotropy=RC_ISO_NAMES[RC_ISOTROPIC:RC_CARTESIAN_COORD +
RandomFields/man/RF.Rd:\section{Functionals of \code{\link{RMmodels}}}{
RandomFields/man/RF.Rd:    The user's \code{\link{RMmodel}} is supplemented internally by
RandomFields/man/RF.Rd:    \command{\link{RFgetMethodNames}} \tab
RandomFields/man/RF.Rd:    \command{\link{RFgetModel}} \tab
RandomFields/man/RF.Rd:    \command{\link{RFgetModelInfo}} \tab
RandomFields/man/RF.Rd:    similar to \command{\link{RFgetModel}}, but with detailed
RandomFields/man/RF.Rd:    \command{\link{RFgetModelNames}} \tab
RandomFields/man/RF.Rd:   \link{RC}, \link{RM}, \link{RP},
RandomFields/man/RF.Rd: \code{\link[=RMmodelgenerator-class]{RMmodelgenerator}}
RandomFields/man/RF.Rd:z <- RFsimulate(model=RMexp(), 1:10)
RandomFields/man/RF.Rd:RFgetModel(RFsimulate, show.call = TRUE)  # user's definition
RandomFields/man/RF.Rd:RFgetModel(RFsimulate, show.call = FALSE) # main internal part
RandomFields/man/RMbr2eg.Rd:\name{RMbr2eg}
RandomFields/man/RMbr2eg.Rd:\alias{RMbr2eg}
RandomFields/man/RMbr2eg.Rd:RMbr2eg(phi, var, scale, Aniso, proj)
RandomFields/man/RMbr2eg.Rd: \item{phi}{covariance function of class \code{\link[=RMmodel-class]{RMmodel}}.}
RandomFields/man/RMbr2eg.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMbr2eg.Rd: object of class \code{\link[=RMmodel-class]{RMmodel}}
RandomFields/man/RMbr2eg.Rd:  \command{\link{RMbr2eg}} \cr
RandomFields/man/RMbr2eg.Rd:  simulated with \code{\link{RMbr2eg}(\link{RMmodel}())} has
RandomFields/man/RMbr2eg.Rd:  variogram \command{\link{RMmodel}}.
RandomFields/man/RMbr2eg.Rd:    \item    Strokorb, K., Ballani, F., and  Schlather, M. (2014)
RandomFields/man/RMbr2eg.Rd:  \command{\link{RMbr2bg}},
RandomFields/man/RMbr2eg.Rd:  \command{\link{RMmodel}},
RandomFields/man/RMbr2eg.Rd:  \command{\link{RMm2r}},
RandomFields/man/RMbr2eg.Rd:model <- RMexp(var=1.62 / 2) 
RandomFields/man/RMbr2eg.Rd:binary.model <- RPbernoulli(RMbr2bg(model))
RandomFields/man/RMgneiting.Rd:\name{RMgneiting}
RandomFields/man/RMgneiting.Rd:\alias{RMgneiting}
RandomFields/man/RMgneiting.Rd:\title{Gneiting Covariance Model}
RandomFields/man/RMgneiting.Rd: \command{\link{RMgneiting}} is a stationary isotropic covariance model
RandomFields/man/RMgneiting.Rd: For a generalized model see also \command{\link{RMgengneiting}}.
RandomFields/man/RMgneiting.Rd:RMgneiting(orig, var, scale, Aniso, proj)
RandomFields/man/RMgneiting.Rd:   \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMgneiting.Rd:   the \code{\link{RMgengneiting}} model C(s r) with \code{kappa=3} as above, but with \code{mu = 2.683509} and \code{s=0.2745640815} is used.
RandomFields/man/RMgneiting.Rd: This model is an alternative to \command{\link{RMgauss}} as its graph is hardly distinguishable from the 
RandomFields/man/RMgneiting.Rd:It is a special case of \command{\link{RMgengneiting}} for the choice \eqn{\kappa=3, \mu=1.5}{\kappa=3, \mu=1.5}.
RandomFields/man/RMgneiting.Rd: \command{\link{RMgneiting}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMgneiting.Rd: \emph{Q. J. Roy. Meteor. Soc} Part A \bold{125}, 2449-2464.
RandomFields/man/RMgneiting.Rd: \command{\link{RMbigneiting}},
RandomFields/man/RMgneiting.Rd: \command{\link{RMgengneiting}},
RandomFields/man/RMgneiting.Rd: \command{\link{RMgauss}},
RandomFields/man/RMgneiting.Rd: \command{\link{RMmodel}},
RandomFields/man/RMgneiting.Rd:plot(RMgneiting(), model2=RMgneiting(orig=FALSE), model3=RMgauss(), 
RandomFields/man/RMgneiting.Rd:plot(RMgneiting(), model2=RMgneiting(orig=FALSE), model3=RMgauss(), 
RandomFields/man/RMgneiting.Rd:model <- RMgneiting(orig=FALSE, scale=0.4)
RandomFields/man/RMgneiting.Rd:plot(z, MARGIN.slices=4, MARGIN.movie=3)
RandomFields/man/RMfbm.Rd:\name{RMfbm}
RandomFields/man/RMfbm.Rd:\alias{RMfbm}
RandomFields/man/RMfbm.Rd:\title{Variogram Model of Fractal Brownian Motion}
RandomFields/man/RMfbm.Rd: \command{\link{RMfbm}} is an intrinsically stationary isotropic variogram
RandomFields/man/RMfbm.Rd: For a generalized model see also \command{\link{RMgenfbm}}.
RandomFields/man/RMfbm.Rd:RMfbm(alpha, var, scale, Aniso, proj)
RandomFields/man/RMfbm.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMfbm.Rd:we get a variogram corresponding to a standard Brownian Motion.
RandomFields/man/RMfbm.Rd: \command{\link{RMfbm}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMfbm.Rd: \item Chiles, J.-P. and P. Delfiner (1999) \emph{Geostatistics. Modeling
RandomFields/man/RMfbm.Rd: \item Stein, M.L. (2002) Fast and exact simulation of fractional
RandomFields/man/RMfbm.Rd: \command{\link{RMgenfbm}},
RandomFields/man/RMfbm.Rd: \command{\link{RMmodel}},
RandomFields/man/RMfbm.Rd:model <- RMfbm(alpha=1)
RandomFields/man/Bayesian.Rd:\name{Hierarchical Modelling}
RandomFields/man/Bayesian.Rd:\alias{Hierarchical Modelling}
RandomFields/man/Bayesian.Rd:\alias{Bayesian Modelling}
RandomFields/man/Bayesian.Rd:\title{Bayesian Spatial Modelling}
RandomFields/man/Bayesian.Rd:  \link{RMmatern} model.
RandomFields/man/Bayesian.Rd:    \item implicitly, e.g. \code{RMwhittle(nu=exp())} or    
RandomFields/man/Bayesian.Rd:    \code{RMwhittle(nu=RRdistr(exp()))}.
RandomFields/man/Bayesian.Rd:  \link{RMmodelsAdvanced}.
RandomFields/man/Bayesian.Rd:## the following model defines the argument nu of the Whittle-Matern
RandomFields/man/Bayesian.Rd:  model <- ~ 1 + RMwhittle(scale=NA, var=NA, nu=exp(rate=5)) + RMnugget(var=NA)
RandomFields/man/Bayesian.Rd:} else model <- 1 + RMwhittle(scale=NA, var=NA, nu=exp(rate=5))
RandomFields/man/RRunif.Rd: \command{\link{RRunif}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RRunif.Rd: \command{\link{RMmodel}},
RandomFields/man/RMcubic.Rd:\name{RMcubic}
RandomFields/man/RMcubic.Rd:\alias{RMcubic}
RandomFields/man/RMcubic.Rd:\title{Cubic Covariance Model}
RandomFields/man/RMcubic.Rd: \command{\link{RMcubic}} is a stationary isotropic covariance model
RandomFields/man/RMcubic.Rd:RMcubic(var, scale, Aniso, proj)
RandomFields/man/RMcubic.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMcubic.Rd: \command{\link{RMcubic}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMcubic.Rd: \emph{Geostatistics. Modeling Spatial Uncertainty.}
RandomFields/man/RMcubic.Rd: \command{\link{RMmodel}},
RandomFields/man/RMcubic.Rd:model <- RMcubic()
RandomFields/man/RFfit.Rd:  \item{model,params}{\argModel
RandomFields/man/RFfit.Rd: Type \code{\link{RFgetModelNames}(type="variogram")} to get all options
RandomFields/man/RFfit.Rd:    of the covariance model as given in \command{\link{RMmodel}}.
RandomFields/man/RFfit.Rd: \command{\link{RMmodel}},
RandomFields/man/RFfit.Rd:model <- RMgencauchy(alpha=1, beta=2)
RandomFields/man/RFfit.Rd:estmodel <- RMgencauchy(var=NA, scale=NA, alpha=NA, beta=2) +
RandomFields/man/RFfit.Rd:            RMshape(mean=NA)
RandomFields/man/RFfit.Rd:estmodel <- RMgencauchy(var=NA, scale=NA, alpha=NA, beta=NA) +
RandomFields/man/RFfit.Rd:            RMnugget(var=NA) + RMshape(mean=NA)
RandomFields/man/RFfit.Rd:model <- RMexp(Aniso=matrix(nc=2, c(4,2,-2,1)), var=1.5)
RandomFields/man/RFfit.Rd:estmodel <- RMexp(Aniso=matrix(nc=2, c(NA,NA,-2,1)), var=NA) +
RandomFields/man/RFfit.Rd:            RMshape(mean=NA)
RandomFields/man/RMnugget.Rd:\name{RMnugget}
RandomFields/man/RMnugget.Rd:\alias{RMnugget}
RandomFields/man/RMnugget.Rd:\alias{RM_NUGGET}
RandomFields/man/RMnugget.Rd:\title{Nugget Effect Covariance Model}
RandomFields/man/RMnugget.Rd:  \command{\link{RMnugget}} is a multivariate stationary isotropic covariance model
RandomFields/man/RMnugget.Rd:RMnugget(tol, vdim, var, Aniso, proj)
RandomFields/man/RMnugget.Rd: \item{vdim}{Must be set only for multivariate models (advanced).} 
RandomFields/man/RMnugget.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMnugget.Rd: \command{\link{RMnugget}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMnugget.Rd: \command{\link{RMmodel}},
RandomFields/man/RMnugget.Rd:model <- RMnugget(var = 100)
RandomFields/man/RFfitOptimiser.Rd:  \code{"NLOPT_GN_CRS2_LM"}, 
RandomFields/man/RFfitOptimiser.Rd:  \code{"NLOPT_LN_NELDERMEAD"}, 
RandomFields/man/RFfitOptimiser.Rd:   model <- moisture ~ 1 + RMwhittle(scale=NA, var=NA, nu=NA) + RMnugget(var=NA)
RandomFields/man/RFfitOptimiser.Rd:} else model <- moisture ~ 1 + RMnugget(var=NA)
RandomFields/man/RFfitOptimiser.Rd:algorithm <- RC_NLOPTR_NAMES
RandomFields/man/RFfitOptimiser.Rd:\dontshow{if(!interactive()) algorithm <- RC_NLOPTR_NAMES[1]}
RandomFields/man/RPgauss.Rd: Returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RPgauss.Rd: \item{phi}{the \command{\link{RMmodel}}.}
RandomFields/man/RPgauss.Rd: The function returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RPgauss.Rd: See \command{\link{RFgetMethodNames}} for further information.
RandomFields/man/RPgauss.Rd: or variogram models, see \code{\link{RFgetModelNames}(intern=FALSE)}.
RandomFields/man/RPgauss.Rd: Simulating with trend can be done by including \command{\link{RMshape}}
RandomFields/man/RPgauss.Rd: variogram model, i.e. of class \code{\link[=RMmodel-class]{RMmodel}}, a
RandomFields/man/RPgauss.Rd: see \command{\link{RMmodel}} for a list of all available models. 
RandomFields/man/RPgauss.Rd: \command{\link{RMmodel}},
RandomFields/man/RPgauss.Rd: Do not mix up with \command{\link{RMgauss}} or \command{\link{RRgauss}}.
RandomFields/man/RPgauss.Rd:model <- RMexp()
RandomFields/man/RMintern.Rd:\name{RMintern}
RandomFields/man/RMintern.Rd:\alias{RMintern}
RandomFields/man/RMintern.Rd:\alias{RMmixed}
RandomFields/man/RMintern.Rd:\alias{RMnull}
RandomFields/man/RMintern.Rd:\alias{RMSpower}
RandomFields/man/RMintern.Rd:\alias{RMselect}
RandomFields/man/RMintern.Rd:\alias{RMSpower}
RandomFields/man/RMintern.Rd:\alias{RMmult_inverse} 
RandomFields/man/RMintern.Rd:\alias{RMsetparam}
RandomFields/man/RMintern.Rd:\alias{RMshape.ave}
RandomFields/man/RMintern.Rd:\alias{RMshape.stp}
RandomFields/man/RMintern.Rd:\alias{RMr3binner}
RandomFields/man/RMintern.Rd:\alias{RMptsGivenShape}
RandomFields/man/RMintern.Rd:\alias{RMstandardShape}
RandomFields/man/RMintern.Rd:\alias{RMstatShape}
RandomFields/man/RMintern.Rd:   \item \code{RMmixed} : internal representation of a \link[=formula]{mixed model}
RandomFields/man/RMintern.Rd:   \item \code{RMselect} : will be obsolete in future
RandomFields/man/RMintern.Rd:   \item \code{RMsetparam}, \code{RMptsGivenShape}, \code{RMstandardShape}, \code{RMstatShape} :
RandomFields/man/RMintern.Rd:   \link{RMS} and  \link{RMplus} etc. (For those covariance models that
RandomFields/man/RMintern.Rd:   \item \command{\link{RMS}} : internal representation of
RandomFields/man/RMintern.Rd:z <- RFsimulate(RPspecific(RMexp() + RMnugget()), x)
RandomFields/man/RMintern.Rd:RFgetModelInfo(which="internal", level=0)
RandomFields/man/RMbessel.Rd:\name{RMbessel}
RandomFields/man/RMbessel.Rd:\alias{RMbessel}
RandomFields/man/RMbessel.Rd:\alias{RMjbessel}
RandomFields/man/RMbessel.Rd:\title{Bessel Family Covariance Model}
RandomFields/man/RMbessel.Rd: \command{\link{RMbessel}} is a stationary isotropic covariance model
RandomFields/man/RMbessel.Rd:RMbessel(nu, var, scale, Aniso, proj)
RandomFields/man/RMbessel.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMbessel.Rd: and which is only valid for \eqn{d=1}{d=1}. This equals \command{\link{RMdampedcos}} for \eqn{\lambda = 0}, there.
RandomFields/man/RMbessel.Rd: This coincides with \command{\link{RMwave}}. 
RandomFields/man/RMbessel.Rd: \command{\link{RMbessel}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMbessel.Rd:    \emph{Geostatistics. Modeling Spatial Uncertainty.}
RandomFields/man/RMbessel.Rd:    \item Gelfand, A. E., Diggle, P., Fuentes, M. and Guttorp,
RandomFields/man/RMbessel.Rd: \command{\link{RMdampedcos}},
RandomFields/man/RMbessel.Rd: \command{\link{RMwave}},
RandomFields/man/RMbessel.Rd: \command{\link{RMmodel}},
RandomFields/man/RMbessel.Rd:model <- RMbessel(nu=1, scale=0.1)
RandomFields/man/RFsimulate.more.examples.Rd:RFgetModelNames(type="variogram") ## the complete list covariance models
RandomFields/man/RFsimulate.more.examples.Rd:## our choice is RMstable
RandomFields/man/RFsimulate.more.examples.Rd:model <- RMshape(mean=0.5) + # mean
RandomFields/man/RFsimulate.more.examples.Rd:RMstable(alpha=1, var=4, scale=10) +
RandomFields/man/RFsimulate.more.examples.Rd:# see help("RMstable")
RandomFields/man/RFsimulate.more.examples.Rd:RMnugget(var=1) # nugget
RandomFields/man/RFsimulate.more.examples.Rd:model <- RMstable(alpha=1.5)
RandomFields/man/RFsimulate.more.examples.Rd:model <- RMexp(var=0.3) +
RandomFields/man/RFsimulate.more.examples.Rd:RMshape(arbitraryfct = function(x,y) 2*sin(x)*cos(y))
RandomFields/man/RFsimulate.more.examples.Rd:model1 <- RMexp() + RMshape(plane=c(3,-1), fctcoeff=1)
RandomFields/man/RFsimulate.more.examples.Rd:model2 <- RMexp() + RMshape(arbitraryfct=function(x,y) 3*x-y)
RandomFields/man/RFsimulate.more.examples.Rd:simulated <- RFsimulate(model = RMfbm(alpha=alpha),
RandomFields/man/RFsimulate.more.examples.Rd:## Example 5: Models that depend on "submodels"; ##
RandomFields/man/RFsimulate.more.examples.Rd:RFgetModelNames(operator=TRUE) ## list all models
RandomFields/man/RFsimulate.more.examples.Rd:## our choice is RMcoxisham
RandomFields/man/RFsimulate.more.examples.Rd:D <- as.matrix(1) # a 1x1-correlation matrix for RMcoxisham
RandomFields/man/RFsimulate.more.examples.Rd:submodel <- RMwhittle(nu=0.3)  # submodel on which the operator
RandomFields/man/RFsimulate.more.examples.Rd:##                                model RMcoxisham will be applied
RandomFields/man/RFsimulate.more.examples.Rd:model <- RMcoxisham(submodel, mu=0, D=D, beta=2)
RandomFields/man/RFsimulate.more.examples.Rd:#model2 <- RMcoxisham(RMintexp(RMdewijsian(alpha=1)),
RandomFields/man/RFsimulate.more.examples.Rd:## addition of random fields using RMplus
RandomFields/man/RFsimulate.more.examples.Rd:model1 <- RMexp(var=5) + RMwhittle(nu=1, var=5)
RandomFields/man/RFsimulate.more.examples.Rd:## can be included in the RMplus model:
RandomFields/man/RFsimulate.more.examples.Rd:model2 <- RMplus(C0 = RMexp(), C1 = RMwhittle(nu=1), var=5)
RandomFields/man/RFsimulate.more.examples.Rd:RFgetModelNames(vdim=2) ## list all bivariate models
RandomFields/man/RFsimulate.more.examples.Rd:## our choice is RMbiWM
RandomFields/man/RFsimulate.more.examples.Rd:model <- RMbiwm(nudiag=c(1.3, 0.7), nured=2.5,
RandomFields/man/RFsimulate.more.examples.Rd:dta <- RFsimulate(model = RMexp(), x=x, y=y, grid=FALSE)
RandomFields/man/RFsimulate.more.examples.Rd:cond.simulated <- RFsimulate(RMexp(), x=x.seq.cond, y=y.seq.cond, data=dta)
RandomFields/man/RFsimulate.more.examples.Rd:cond.simulated.2 <- RFsimulate(RMexp(), x=x.seq.cond, y=y.seq.cond,
RandomFields/man/RFsimulate.more.examples.Rd:   RFsimulate(model = RMwhittle(nu=1.1), x=x.seq.cond, y=y.seq.cond,
RandomFields/man/RFsimulate.more.examples.Rd:cond.simulated <- RFsimulate(model=RMwhittle(nu=1.4),
RandomFields/man/RFsimulate.more.examples.Rd:# err.model specifies the error model, typically RMnugget
RandomFields/man/RFsimulate.more.examples.Rd:  RFsimulate(model=RMexp(), x=x.seq.cond, y=y.seq.cond,
RandomFields/man/RFsimulate.more.examples.Rd:             data=dta, err.model=RMnugget(var=1))
RandomFields/man/RMmodelsTrend.Rd:\name{Trend Modelling}
RandomFields/man/RMmodelsTrend.Rd:\alias{RMmodelsTrend}
RandomFields/man/RMmodelsTrend.Rd:\title{Trend Modelling}
RandomFields/man/RMmodelsTrend.Rd:  See \link{RFcalc}, \link{RMshape} and also the examples below
RandomFields/man/RMmodelsTrend.Rd:  \link{RFcalc}, \link{RM}, \link{RMmodels}, \link{RMshape}, \link{RMmodelsMultivariate}.
RandomFields/man/RMmodelsTrend.Rd:M <- RMexp(var=NA, scale=NA) + RMnugget(var=NA)
RandomFields/man/RMmodelsTrend.Rd:\dontshow{if (!interactive()) M <- RMexp(var=NA, scale=NA)} % ok
RandomFields/man/RMmodelsTrend.Rd:ca20.RFmod02 <- ~ 1 + altitude + M
RandomFields/man/RMmodelsTrend.Rd:(ca20.fit02.RF <- RFfit(ca20.RFmod02, data=ca20.df, M=M))
RandomFields/man/RMmodelsTrend.Rd:ca20.RFmod02 <- NA + NA*RMcovariate(ca20.df$altitude) + M 
RandomFields/man/RMmodelsTrend.Rd:ca20.RFmod02 <- M + NA + ca20.df$altitude 
RandomFields/man/RMmodelsTrend.Rd:### The following does NOT work, as R assumes (NA + ca20.df$altitude) + M
RandomFields/man/RMmodelsTrend.Rd:(ca20.RFmod02 <- NA + ca20.df$altitude + M) 
RandomFields/man/RMmodelsTrend.Rd:ca20.RFmod03 <- ~ 1 + area + M ### 
RandomFields/man/RMmodelsTrend.Rd:(ca20.fit03.RF <- RFfit(ca20.RFmod03, data=ca20.df, M=M))
RandomFields/man/RMplus.Rd:\name{RMplus}
RandomFields/man/RMplus.Rd:\alias{RMplus}
RandomFields/man/RMplus.Rd:\alias{RMshapeplus}
RandomFields/man/RMplus.Rd:\alias{RM_PLUS}
RandomFields/man/RMplus.Rd:\title{Addition of Random Field Models}
RandomFields/man/RMplus.Rd: \command{\link{RMplus}} is an additive covariance model which depends on
RandomFields/man/RMplus.Rd: In general, realizations of the created \command{\link{RMmodel}} are pointwise
RandomFields/man/RMplus.Rd:RMplus(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, trend,
RandomFields/man/RMplus.Rd:RMshapeplus(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, add.na=FALSE,
RandomFields/man/RMplus.Rd: \item{C0}{an \command{\link{RMmodel}}. See also  Details.}
RandomFields/man/RMplus.Rd:   \command{\link{RMmodel}}.}
RandomFields/man/RMplus.Rd:   \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMplus.Rd: \command{\link{RMmodel}}s can also be summed up via the
RandomFields/man/RMplus.Rd: The global arguments \code{var,scale,Aniso,proj} of \command{\link{RMplus}}
RandomFields/man/RMplus.Rd: \code{RMshapeplus} behaves as \code{RMplus}, but with argument
RandomFields/man/RMplus.Rd: \command{\link{RMplus}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMplus.Rd: \command{\link{RMmult}},
RandomFields/man/RMplus.Rd: \command{\link{RMmodel}},
RandomFields/man/RMplus.Rd: \command{\link{RMsum}},
RandomFields/man/RMplus.Rd:model <- RMplus(RMgauss(), RMnugget(), var=0.5) ## common variance parameter
RandomFields/man/RMplus.Rd:model2<- RMgauss() + RMnugget(var=0.1)
RandomFields/man/RMspheric.Rd:\name{RMspheric}
RandomFields/man/RMspheric.Rd:\alias{RMspheric}
RandomFields/man/RMspheric.Rd:\title{The Spherical Covariance Model}
RandomFields/man/RMspheric.Rd: \command{\link{RMspheric}} is a stationary isotropic covariance model
RandomFields/man/RMspheric.Rd:RMspheric(var, scale, Aniso, proj)
RandomFields/man/RMspheric.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMspheric.Rd: \command{\link{RMspheric}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMspheric.Rd: Gelfand, A. E., Diggle, P., Fuentes, M. and Guttorp,
RandomFields/man/RMspheric.Rd: \command{\link{RMmodel}},
RandomFields/man/RMspheric.Rd:model <- RMspheric()
RandomFields/man/RMpower.Rd:\name{RMpower}
RandomFields/man/RMpower.Rd:\alias{RMpower}
RandomFields/man/RMpower.Rd:\alias{RMpower}
RandomFields/man/RMpower.Rd: \command{\link{RMpower}} yields a variogram or covariance model 
RandomFields/man/RMpower.Rd:RMpower(phi, alpha, var, scale, Aniso, proj)
RandomFields/man/RMpower.Rd: \item{phi}{a valid \command{\link{RMmodel}}; either a variogram model or a
RandomFields/man/RMpower.Rd: \item{var,scale,Aniso,proj}{optional arguments; same meaning for any \command{\link{RMmodel}}. If not passed, the above covariance function remains unmodified.}
RandomFields/man/RMpower.Rd: \command{\link{RMpower}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMpower.Rd: Schlather, M. (2012) Construction of covariance functions and
RandomFields/man/RMpower.Rd: Porcu, E., Montero, J. M., Schlather, M. 
RandomFields/man/RMpower.Rd: \emph{Advances and Challenges in Space-time Modelling of Natural Events},
RandomFields/man/RMpower.Rd: \command{\link{RMmodel}},
RandomFields/man/RMpower.Rd:model <- RMpower(RMgauss(), alpha=0.5)
RandomFields/man/RMnsst.Rd:\name{RMnsst}
RandomFields/man/RMnsst.Rd:\alias{RMnsst}
RandomFields/man/RMnsst.Rd: \command{\link{RMnsst}} is a univariate stationary spaceisotropic covariance model
RandomFields/man/RMnsst.Rd:RMnsst(phi, psi, delta, var, scale, Aniso, proj)
RandomFields/man/RMnsst.Rd: \item{phi}{is a normal mixture \command{\link{RMmodel}},  cf.\cr
RandomFields/man/RMnsst.Rd:    \code{RFgetModelNames(monotone="normal mixture")}
RandomFields/man/RMnsst.Rd: \item{psi}{is a variogram \command{\link{RMmodel}}.}
RandomFields/man/RMnsst.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMnsst.Rd: \command{\link{RMnsst}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMnsst.Rd: \item Gneiting, T. and Schlather, M. (2001)
RandomFields/man/RMnsst.Rd: \item Schlather, M. (2010)
RandomFields/man/RMnsst.Rd:  \command{\link{RMgennsst}},
RandomFields/man/RMnsst.Rd:\command{\link{RMmodel}},
RandomFields/man/RMnsst.Rd:model <- RMnsst(phi=RMgauss(), psi=RMfbm(alpha=1), delta=2)
RandomFields/man/RMvector.Rd:\name{RMvector}
RandomFields/man/RMvector.Rd:\alias{RMvector}
RandomFields/man/RMvector.Rd:\title{Vector Covariance Model}
RandomFields/man/RMvector.Rd: \command{\link{RMvector}} is a multivariate covariance model which depends on
RandomFields/man/RMvector.Rd:RMvector(phi, a, Dspace, var, scale, Aniso, proj)
RandomFields/man/RMvector.Rd: \item{phi}{an \command{\link{RMmodel}}; has two components \eqn{h}{h} (2- or 3-dimensional and stationary) and \eqn{t}{t} (arbitrary dimension).}
RandomFields/man/RMvector.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMvector.Rd: \command{\link{RMvector}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMvector.Rd: \item Scheuerer, M. and Schlather, M. (2012)
RandomFields/man/RMvector.Rd: Covariance Models for Divergence-Free and Curl-Free Random Vector Fields.
RandomFields/man/RMvector.Rd: \emph{Stochastic Models} \bold{28:3}.
RandomFields/man/RMvector.Rd: \command{\link{RMcurlfree}},
RandomFields/man/RMvector.Rd: \command{\link{RMdivfree}},
RandomFields/man/RMvector.Rd: \command{\link{RMmodel}},
RandomFields/man/RMvector.Rd:model <- RMvector(RMgauss(), scale=0.3)
RandomFields/man/RMstp.Rd:\name{RMstp}
RandomFields/man/RMstp.Rd:\alias{RMstp}
RandomFields/man/RMstp.Rd:\alias{RMstp}
RandomFields/man/RMstp.Rd:  \command{\link{RMstp}} is a univariate covariance model which depends on
RandomFields/man/RMstp.Rd:    Q(x,y) = c^2 - m^2 + h^t (S_x + 2(m + c)M) A^{-1} (S_y + 2
RandomFields/man/RMstp.Rd:    (m-c)M)h,
RandomFields/man/RMstp.Rd:    A = S_x + S_y + 4 M h h^t M 
RandomFields/man/RMstp.Rd:    m = h^t M h
RandomFields/man/RMstp.Rd:RMstp(xi, phi, S, z, M, var, scale, Aniso, proj) 
RandomFields/man/RMstp.Rd: \item{phi}{an \command{\link{RMmodel}} that is a normal mixture model,
RandomFields/man/RMstp.Rd:    \code{RFgetModelNames(monotone="normal mixture")}
RandomFields/man/RMstp.Rd: \item{M}{an arbitrary, symmetric \eqn{d \times d}{d x d} matrix}
RandomFields/man/RMstp.Rd: \item{var,scale,Aniso,proj}{optional arguments; same meaning for any \command{\link{RMmodel}}. If not passed, the above covariance function remains unmodified.}
RandomFields/man/RMstp.Rd: \command{\link{RMstp}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMstp.Rd:    \item Paciorek C.J., and Schervish, M.J. (2006)
RandomFields/man/RMstp.Rd:    \item Schlather, M. (2010)
RandomFields/man/RMstp.Rd: \command{\link{RMmodel}},
RandomFields/man/RMstp.Rd:model <- RMstp(xi = RMrotat(phi= -2 * pi, speed=1),
RandomFields/man/RMstp.Rd:               phi = RMwhittle(nu = 1),
RandomFields/man/RMstp.Rd:               M=matrix(nc=3, rep(0, 9)),
RandomFields/man/RMstp.Rd:               S=RMetaxxa(E=rep(1, 3), alpha = -2 * pi,
RandomFields/man/RMSadvanced.Rd:\name{RMSadvanced}
RandomFields/man/RMSadvanced.Rd:\alias{RMSadvanced}
RandomFields/man/RMSadvanced.Rd:RMS(phi, var, scale, Aniso, proj, anisoT)
RandomFields/man/RMSadvanced.Rd:      and \command{\link{RMuser}} for defining arbitrary functions.
RandomFields/man/RMSadvanced.Rd:      given by one of the functions \command{\link{RMbubble}} or
RandomFields/man/RMSadvanced.Rd:      \command{\link{RMscale}}. In case none of them are given,
RandomFields/man/RMSadvanced.Rd:      \command{\link{RMscale}} is assumed with scale penality
RandomFields/man/RMSadvanced.Rd:    \item{Aniso}{matrix or \code{\link{RMmodel}}.
RandomFields/man/RMSadvanced.Rd: \command{\link{RMSadvanced}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMSadvanced.Rd:    \item Bonat, W.H., Ribeiro, P. Jr. and Schlather, M. (2019)
RandomFields/man/RMSadvanced.Rd:    Modelling non-stationarity in scale. In preparation.
RandomFields/man/RMSadvanced.Rd:  \command{\link{RMS}},
RandomFields/man/RMSadvanced.Rd:  \command{\link{RMblend}} for a different approach on modelling
RandomFields/man/RMSadvanced.Rd:scale <- RMcovariate(data=as.double(d) * 2 + 0.5, raw=TRUE)
RandomFields/man/RMSadvanced.Rd:S <- RMexp(scale = scale)
RandomFields/man/RMbernoulli.Rd:\name{RMbernoulli}
RandomFields/man/RMbernoulli.Rd:\alias{RMbernoulli}
RandomFields/man/RMbernoulli.Rd:\title{Covariance Model for binary field based on a Gaussian field}
RandomFields/man/RMbernoulli.Rd:  \command{RMbernoulli} gives
RandomFields/man/RMbernoulli.Rd:RMbernoulli(phi, threshold, correlation, centred, var, scale, Aniso, proj)
RandomFields/man/RMbernoulli.Rd: \item{phi}{covariance function of class \code{\link[=RMmodel-class]{RMmodel}}.}
RandomFields/man/RMbernoulli.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMbernoulli.Rd: \command{\link{RMbernoulli}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMbernoulli.Rd: \command{\link{RMmodel}},
RandomFields/man/RMbernoulli.Rd:GaussModel <- RMgneiting()
RandomFields/man/RMbernoulli.Rd:z <- RFsimulate(RPbernoulli(GaussModel, threshold=threshold), x=x, n=n)
RandomFields/man/RMbernoulli.Rd:model <- RMbernoulli(RMgauss(), threshold=threshold, correlation=FALSE)
RandomFields/man/RPcoin.Rd:  \item{phi}{object of class \code{\link[=RMmodel-class]{RMmodel}};
RandomFields/man/RPcoin.Rd:  \item{shape}{object of class \code{\link[=RMmodel-class]{RMmodel}};
RandomFields/man/RPcoin.Rd: \command{\link{RPcoins}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RPcoin.Rd:   \item Ballani, F, Schlather, M (2020). In preparation,
RandomFields/man/RPcoin.Rd: \emph{Geostatistical Simulation: Models and Algorithms.}
RandomFields/man/RPcoin.Rd:z <- RFsimulate(RPcoins(RMcircular(), intensity=0.1), x, x)
RandomFields/man/RPcoin.Rd:model <- RPcoins(RMspheric())
RandomFields/man/RPcoin.Rd: z <- RFsimulate(x=x, model=RPcoins(RMspheric(), intensity = intensity))
RandomFields/man/RFgridDataFrame-class.Rd:\section{Methods}{
RandomFields/man/RFgridDataFrame-class.Rd: \code{MARGIN}; to get different slices in a third direction, the
RandomFields/man/RFgridDataFrame-class.Rd: argument \code{MARGIN.slices} can be used;
RandomFields/man/RFgridDataFrame-class.Rd: Methods \command{summary} and \command{dimensions}
RandomFields/man/RFgridDataFrame-class.Rd:\author{Alexander Malinowski, \martin}
RandomFields/man/RFgridDataFrame-class.Rd:f <- RFsimulate(model=RMgauss(), x=x, n=3)
RandomFields/man/RPdirect.Rd:\title{Methods relying on square roots of the covariance matrix}
RandomFields/man/RPdirect.Rd: Methods relying on square roots of the covariance matrix
RandomFields/man/RPdirect.Rd:  \item{phi}{object of class \code{\link[=RMmodel-class]{RMmodel}};
RandomFields/man/RPdirect.Rd: \command{\link{RPdirect}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RPdirect.Rd: Schlather, M. (1999) \emph{An introduction to positive definite
RandomFields/man/RPdirect.Rd: Technical report ST 99-10, Dept. of Maths and Statistics,
RandomFields/man/RPdirect.Rd:model <- RMgauss(var=10, s=10) + RMnugget(var=0.01)
RandomFields/man/RP.Rd:\title{Models for classes of random fields (RP commands)}
RandomFields/man/RP.Rd:    Max-stable Random Fields \tab see \link{Maxstable}\cr
RandomFields/man/RP.Rd:  \link{RC}, \link{RR}, \link{RM}, \link{RF}, \link{R.}
RandomFields/man/RP.Rd:model <- RMexp()
RandomFields/man/conventional2RFspDataFrame.Rd:\author{Alexander Malinowski, \martin}
RandomFields/man/conventional2RFspDataFrame.Rd:z <- RFsimulate(RMexp(), x, spConform=FALSE)
RandomFields/man/RRgauss.Rd: \command{\link{RRgauss}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RRgauss.Rd: \command{\link{RMmodel}},
RandomFields/man/RRgauss.Rd: Do not mix up \command{RRgauss} with \command{\link{RMgauss}} or
RandomFields/man/RMbcw.Rd:\name{RMbcw}
RandomFields/man/RMbcw.Rd:\alias{RMbcw}
RandomFields/man/RMbcw.Rd:\title{Model bridging stationary and intrinsically stationary processes}
RandomFields/man/RMbcw.Rd:  \command{\link{RMbcw}} is a variogram model
RandomFields/man/RMbcw.Rd:  \command{\link{RMgenfbm}} \sQuote{b}, \command{\link{RMgencauchy}} \sQuote{c}
RandomFields/man/RMbcw.Rd:  and \command{\link{RMdewijsian}} \sQuote{w}.
RandomFields/man/RMbcw.Rd:RMbcw(alpha, beta, const, var, scale, Aniso, proj)
RandomFields/man/RMbcw.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMbcw.Rd:  we have the generalized fractal Brownian motion \command{\link{RMgenfbm}},
RandomFields/man/RMbcw.Rd:  the generalized Cauchy model \command{\link{RMgencauchy}},
RandomFields/man/RMbcw.Rd:  and the de Wisjian model \command{\link{RMdewijsian}}, respectively.
RandomFields/man/RMbcw.Rd: \command{\link{RMbcw}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}
RandomFields/man/RMbcw.Rd: \item Schlather, M (2014) A parametric variogram model bridging
RandomFields/man/RMbcw.Rd: % \item Martin's Toledo-Chapter: Construction of covariance functions
RandomFields/man/RMbcw.Rd:  \command{\link{RMlsfbm}} is equipped with Matheron's constant \eqn{c} for
RandomFields/man/RMbcw.Rd:  \command{\link{RMgenfbm}},
RandomFields/man/RMbcw.Rd:  \command{\link{RMgencauchy}},
RandomFields/man/RMbcw.Rd:  \command{\link{RMdewijsian}},
RandomFields/man/RMbcw.Rd:  \command{\link{RMmodel}},
RandomFields/man/RMbcw.Rd:model <- RMbcw(alpha=1, beta=0.5)
RandomFields/man/RMgengneiting.Rd:\name{RMgengneiting}
RandomFields/man/RMgengneiting.Rd:\alias{RMgengneiting}
RandomFields/man/RMgengneiting.Rd:\alias{RMwendland}
RandomFields/man/RMgengneiting.Rd:\title{Gneiting-Wendland Covariance Models}
RandomFields/man/RMgengneiting.Rd: \command{\link{RMgengneiting}} is a stationary isotropic covariance model family whose elements 
RandomFields/man/RMgengneiting.Rd: equals the Askey model \command{\link{RMaskey}},
RandomFields/man/RMgengneiting.Rd: A special case of this model is \command{\link{RMgneiting}}.
RandomFields/man/RMgengneiting.Rd:RMgengneiting(kappa, mu, var, scale, Aniso, proj)
RandomFields/man/RMgengneiting.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMgengneiting.Rd:A special case of this family is \command{\link{RMgneiting}} (with \eqn{s = 1}{s = 1} there) for the choice \eqn{\kappa = 3, \mu = 3/2}{\kappa = 3, \mu = 3/2}.
RandomFields/man/RMgengneiting.Rd: \command{\link{RMgengneiting}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMgengneiting.Rd: \emph{Q. J. Roy. Meteor. Soc} Part A \bold{125}, 2449-2464.
RandomFields/man/RMgengneiting.Rd: Cambridge Monogr. Appl. Comput. Math.
RandomFields/man/RMgengneiting.Rd: \command{\link{RMaskey}},
RandomFields/man/RMgengneiting.Rd: \command{\link{RMbigneiting}},
RandomFields/man/RMgengneiting.Rd: \command{\link{RMgneiting}},
RandomFields/man/RMgengneiting.Rd: \command{\link{RMmodel}},
RandomFields/man/RMgengneiting.Rd:model <- RMgengneiting(kappa=1, mu=1.5)
RandomFields/man/RMgengneiting.Rd:model2 <- RMgengneiting(kappa=3, mu=1.5, scale= 1 / 0.301187465825)
RandomFields/man/RMgengneiting.Rd:plot(RMgneiting(), model2=model2, type=c("p", "l"), pch=20)
RandomFields/man/RMpenta.Rd:\name{RMpenta}
RandomFields/man/RMpenta.Rd:\alias{RMpenta}
RandomFields/man/RMpenta.Rd:\title{Penta Covariance Model}
RandomFields/man/RMpenta.Rd: \command{\link{RMpenta}} is a stationary isotropic covariance model, which is only valid for dimensions 
RandomFields/man/RMpenta.Rd:RMpenta(var, scale, Aniso, proj)
RandomFields/man/RMpenta.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMpenta.Rd: \command{\link{RMpenta}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMpenta.Rd: \emph{Geostatistics. Modeling Spatial Uncertainty.}
RandomFields/man/RMpenta.Rd: \command{\link{RMmodel}},
RandomFields/man/RMpenta.Rd:model <- RMpenta()
RandomFields/man/RMlgd.Rd:\name{RMlgd}
RandomFields/man/RMlgd.Rd:\alias{RMlgd}
RandomFields/man/RMlgd.Rd:\title{Local-Global Distinguisher Family Covariance Model}
RandomFields/man/RMlgd.Rd: \command{\link{RMlgd}} is a stationary isotropic covariance model,
RandomFields/man/RMlgd.Rd:RMlgd(alpha, beta, var, scale, Aniso, proj)
RandomFields/man/RMlgd.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMlgd.Rd:can be chosen independently (compare also \command{\link{RMgencauchy}}):
RandomFields/man/RMlgd.Rd: \command{\link{RMlgd}} returns an object of class
RandomFields/man/RMlgd.Rd: \command{\link{RMmodel}}.
RandomFields/man/RMlgd.Rd: \item Gneiting, T. and Schlather, M. (2004)
RandomFields/man/RMlgd.Rd: \emph{SIAM review} \bold{46}, 269--282.
RandomFields/man/RMlgd.Rd: \command{\link{RMmodel}},
RandomFields/man/RMlgd.Rd:model <- RMlgd(alpha=0.7, beta=4, scale=0.5)
RandomFields/man/RRdistr.Rd:\alias{RM_DISTR}
RandomFields/man/RRdistr.Rd: \command{\link{RRdistr}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RRdistr.Rd:  See \link{Bayesian Modelling} for a less technical introduction to
RandomFields/man/RRdistr.Rd:  \command{\link{RMmodel}},
RandomFields/man/RRdistr.Rd:model <- RMgauss(scale=exp(rate=1))
RandomFields/man/RRdistr.Rd:## model <- RMgauss(scale=exp())
RandomFields/man/RRdistr.Rd:## model <- RMgauss(scale=exp(1))   # fixed to 2.7181
RandomFields/man/RRdistr.Rd:## model <- RMgauss(scale=exp(x=1)) # fixed to 2.7181
RandomFields/man/RRdistr.Rd:model <- RMmatern(nu=unif(min=0.1, max=2)) # random
RandomFields/man/RRdistr.Rd:(model1 <- RMgauss(var=exp(3), scale=exp(rate=1)))
RandomFields/man/RRdistr.Rd:(model2 <- RMgauss(var=exp(3), scale=RRdistr("exp", rate=1)))
RandomFields/man/RMcovariate.Rd:\name{RMcovariate}
RandomFields/man/RMcovariate.Rd:\alias{RMcovariate}
RandomFields/man/RMcovariate.Rd:\alias{RM_COVARIATE}
RandomFields/man/RMcovariate.Rd:\title{Model for covariates}
RandomFields/man/RMcovariate.Rd:RMcovariate(formula=NULL, data, x, y=NULL, z=NULL, T=NULL, grid, raw, %norm,
RandomFields/man/RMcovariate.Rd:%    \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMcovariate.Rd:%    estimated through ML
RandomFields/man/RMcovariate.Rd:    This parameter must be set in particular when \command{RMcovariate}
RandomFields/man/RMcovariate.Rd:  Formally, \command{\link{RMcovariate}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMcovariate.Rd: \command{\link{RMfixcov}},
RandomFields/man/RMcovariate.Rd: \command{\link{RMmodel}},
RandomFields/man/RMcovariate.Rd: \command{\link{RMshape}}
RandomFields/man/RMcovariate.Rd:RFfctn(RMcovariate(z), 1:10)
RandomFields/man/RMcovariate.Rd:RFfctn(RMcovariate(data=z, x=1:10), c(2, 2.1, 2.5, 3))
RandomFields/man/RMaskey.Rd:\name{RMaskey}
RandomFields/man/RMaskey.Rd:\alias{RMaskey}
RandomFields/man/RMaskey.Rd:\alias{RMtent}
RandomFields/man/RMaskey.Rd:RMaskey(alpha, var, scale, Aniso, proj)
RandomFields/man/RMaskey.Rd:RMtent(var, scale, Aniso, proj)
RandomFields/man/RMaskey.Rd: \command{\link{RMmodel}}. If not passed, the above covariance
RandomFields/man/RMaskey.Rd: \command{\link{RMaskey}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMaskey.Rd:    Technical report, Research Center, University of Wisconsin-Madison.
RandomFields/man/RMaskey.Rd:    \emph{Anal. Math.} 7, 161-184. 
RandomFields/man/RMaskey.Rd:    analysis. \emph{Quart. J. Roy. Meteor. Soc.}, 125:2449-2464.
RandomFields/man/RMaskey.Rd:    \emph{J. Multivar. Anal.}, 83:493-508.
RandomFields/man/RMaskey.Rd:    functions of minimal degree. Adv. Comput. Math., 4:389-396, 1995.
RandomFields/man/RMaskey.Rd:    \item Strokorb, K., Ballani, F., and  Schlather, M. (2014)
RandomFields/man/RMaskey.Rd: \command{\link{RMmodel}},
RandomFields/man/RMaskey.Rd: \command{\link{RMbigneiting}},
RandomFields/man/RMaskey.Rd: \command{\link{RMgengneiting}},
RandomFields/man/RMaskey.Rd: \command{\link{RMgneiting}},
RandomFields/man/RMaskey.Rd:model <- RMtent()
RandomFields/man/papers.SS11.Rd:\title{Covariance Models for Random Vector Fields}
RandomFields/man/papers.SS11.Rd: Here, the code of the paper on \sQuote{Covariance Models for Random
RandomFields/man/papers.SS11.Rd: Scheuerer, M. and Schlather, M. (2012) Covariance Models for Random
RandomFields/man/papers.SS11.Rd: Vector Fields. \emph{Stochastic Models}, \bold{82}, 433-451.
RandomFields/man/papers.SS11.Rd: % Schlather, M. (2001) Simulation of stationary and isotropic random
RandomFields/man/RMexponential.Rd:\name{RMexponential}
RandomFields/man/RMexponential.Rd:\alias{RMexponential}
RandomFields/man/RMexponential.Rd:\alias{RMexponential}
RandomFields/man/RMexponential.Rd: \command{\link{RMexponential}} yields a covariance model 
RandomFields/man/RMexponential.Rd:RMexponential(phi, n, standardised, var, scale, Aniso, proj)
RandomFields/man/RMexponential.Rd: \item{phi}{a valid \command{\link{RMmodel}}; either a variogram model or a
RandomFields/man/RMexponential.Rd: \item{var,scale,Aniso,proj}{optional arguments; same meaning for any \command{\link{RMmodel}}. If not passed, the above covariance function remains unmodified.}
RandomFields/man/RMexponential.Rd: \command{\link{RMexponential}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMexponential.Rd:   Sasvari, Z. (2013) \emph{Multivariate Characteristic and Correlation
RandomFields/man/RMexponential.Rd:   \item Schlather, M. (2010) \emph{Some covariance models based on
RandomFields/man/RMexponential.Rd:   \item Schlather, M. (2012) Construction of covariance functions and
RandomFields/man/RMexponential.Rd:   Porcu, E., Montero, J. M., Schlather, M. 
RandomFields/man/RMexponential.Rd:   \emph{Advances and Challenges in Space-time Modelling of Natural Events},
RandomFields/man/RMexponential.Rd: \command{\link{RMmodel}},
RandomFields/man/RMexponential.Rd:model <- RMexponential(RMfbm(alpha=1))  ## identical to RMexp()
RandomFields/man/RMexponential.Rd:plot(RMexp(), model=model, type=c("p", "l"), pch=20) 
RandomFields/man/RFfractaldim.Rd: \command{\link{RMmodel}}, \command{\link{RFhurst}}
RandomFields/man/RFfractaldim.Rd:z <- RFsimulate(RMexp(), x)
RandomFields/man/RMnatsc.Rd:\name{RMnatsc}
RandomFields/man/RMnatsc.Rd:\alias{RMnatsc}
RandomFields/man/RMnatsc.Rd: \command{\link{RMnatsc}} is a stationary isotropic covariance model that
RandomFields/man/RMnatsc.Rd: where the argument \code{s} is chosen by \command{\link{RMnatsc}}
RandomFields/man/RMnatsc.Rd:RMnatsc(phi, var, scale, Aniso, proj)
RandomFields/man/RMnatsc.Rd: \item{phi}{a stationary isotropic covariance \command{\link{RMmodel}}.}
RandomFields/man/RMnatsc.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMnatsc.Rd: \command{\link{RMnatsc}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMnatsc.Rd: \command{\link{RMmodel}},
RandomFields/man/RMnatsc.Rd:model <- RMnatsc(RMexp())
RandomFields/man/RMnatsc.Rd:plot(RMexp(), model=model)
RandomFields/man/RFempVariog-class.Rd:% \command{\link[=RMmodelgenerator-class]{RMmodelgenerator}}
RandomFields/man/RFempVariog-class.Rd:  \item{model}{\argModel. Or a list of such models. Tit gives the
RandomFields/man/RFempVariog-class.Rd:\section{Methods}{
RandomFields/man/RFempVariog-class.Rd:\author{Alexander Malinowski, \martin}
RandomFields/man/RFratiotest.Rd:  a Monte Carlo likelihood ratio test
RandomFields/man/RFratiotest.Rd:    a covariance model, see \command{\link{RMmodel}} or
RandomFields/man/RFratiotest.Rd:    type \code{\link{RFgetModelNames}(type="variogram")} to get all options.
RandomFields/man/RFratiotest.Rd:    a Monte Carlo ratio test is performed.
RandomFields/man/RFratiotest.Rd:    \code{\link[=RMmodelFit-class]{RMmodelFit}}
RandomFields/man/RFratiotest.Rd:\section{Methods}{
RandomFields/man/RFratiotest.Rd: of the covariance model as given in \command{\link{RMmodel}}.
RandomFields/man/RFratiotest.Rd: \command{\link{RMmodel}},
RandomFields/man/RFratiotest.Rd:model <- moisture ~ 1 + RMwhittle(scale=NA, var=NA, nu=NA) + RMnugget(var=NA)
RandomFields/man/RFratiotest.Rd:submodel <- moisture ~ 1 + RMwhittle(scale=NA, var=NA, nu=NA) + RMnugget(var=0)
RandomFields/man/RPspecific.Rd:\title{Methods that are specific to certain covariance models}
RandomFields/man/RPspecific.Rd: \item{phi}{object of class \code{\link[=RMmodel-class]{RMmodel}};
RandomFields/man/RPspecific.Rd:  \itemize{ % i.W. alle Modele mit struct und do Funktion
RandomFields/man/RPspecific.Rd:    \item{\command{\link{RMplus}}}{
RandomFields/man/RPspecific.Rd:      a trend model \command{\link{RMshape}} is involved.
RandomFields/man/RPspecific.Rd:    \item{\command{\link{RMmult}}} {
RandomFields/man/RPspecific.Rd:      \command{RMmult} simulates the random fields
RandomFields/man/RPspecific.Rd:    \item{\command{\link{RMS}}}{
RandomFields/man/RPspecific.Rd:      \code{\link{RPspecific}(\link{RMS}())} is called internally when
RandomFields/man/RPspecific.Rd:    \item{\command{\link{RMmppplus}}}{
RandomFields/man/RPspecific.Rd:    \item{\command{\link{RMshape}}}{
RandomFields/man/RPspecific.Rd:    % \item{\command{\link{RM}}}{}
RandomFields/man/RPspecific.Rd: \command{RPspecific} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RPspecific.Rd: Schlather, M. (1999) \emph{An introduction to positive definite
RandomFields/man/RPspecific.Rd: Technical report ST 99-10, Dept. of Maths and Statistics,
RandomFields/man/RPspecific.Rd:model <- RMgauss(var=10, s=10) + RMnugget(var=0.1)
RandomFields/man/RPspecific.Rd:## In particular, it can be seen that RPspecific is applied to RMplus.
RandomFields/man/RPspecific.Rd:RFgetModelInfo(level=0, which="internal")
RandomFields/man/RPspecific.Rd:model <- RPspecific(RMS(var=unif(min=0, max=100), RMgauss()))
RandomFields/man/RFsimulateAdvanced.Rd: \item{model}{object of class \code{\link[=RMmodel-class]{RMmodel}},
RandomFields/man/RFsimulateAdvanced.Rd: \item if of class \code{\link[=RMmodel-class]{RMmodel}}, \code{model}
RandomFields/man/RFsimulateAdvanced.Rd:   type \code{\link{RFgetModelNames}(type="variogram")}
RandomFields/man/RFsimulateAdvanced.Rd:   for a list of available models; see also \command{\link{RMmodel}}.
RandomFields/man/RFsimulateAdvanced.Rd:   \code{\link{RFgetModelNames}(type='shape')} for a list of
RandomFields/man/RFsimulateAdvanced.Rd: \code{err.model=\link{RMnugget}()};
RandomFields/man/RFsimulateAdvanced.Rd: \code{\link{RFgetModelNames}(type="variogram",
RandomFields/man/RFsimulateAdvanced.Rd:% Gneiting, T. and Schlather, M. (2004)
RandomFields/man/RFsimulateAdvanced.Rd: Schlather, M. (1999) \emph{An introduction to positive definite
RandomFields/man/RFsimulateAdvanced.Rd: Technical report ST 99-10, Dept. of Maths and Statistics,
RandomFields/man/RFsimulateAdvanced.Rd: Stein, M.L. (2002)
RandomFields/man/RFsimulateAdvanced.Rd: Gneiting, T., Sevcikova, H., Percival, D.B., Schlather, M. and
RandomFields/man/RFsimulateAdvanced.Rd: \item Markov Gaussian Random Field:
RandomFields/man/RFsimulateAdvanced.Rd: Rue, H. (2001) Fast sampling of Gaussian Markov random fields.
RandomFields/man/RFsimulateAdvanced.Rd: Rue, H., Held, L. (2005) \emph{Gaussian Markov Random Fields:
RandomFields/man/RFsimulateAdvanced.Rd: Monographs on Statistics and Applied Probability, no \bold{104},
RandomFields/man/RFsimulateAdvanced.Rd: \item Turning bands method (TBM), turning layers:
RandomFields/man/RFsimulateAdvanced.Rd: Mantoglou, A. and Wilson, J.L. (1982) The turning bands method for
RandomFields/man/RFsimulateAdvanced.Rd: Matheron, G. (1973)
RandomFields/man/RFsimulateAdvanced.Rd: Schlather, M. (2004)
RandomFields/man/RFsimulateAdvanced.Rd: Matheron, G. (1967) \emph{Elements pour une Theorie des Milieux
RandomFields/man/RFsimulateAdvanced.Rd: Poreux}. Paris: Masson.
RandomFields/man/RFsimulateAdvanced.Rd: \command{\link{RMmodel}},
RandomFields/man/RFsimulateAdvanced.Rd: ## -- the complete list is obtained by RFgetMethodNames()
RandomFields/man/RFsimulateAdvanced.Rd: model <- RMstable(alpha=1.5)
RandomFields/man/RFsimulateAdvanced.Rd:model <- RMstable(alpha=1.5)
RandomFields/man/RFsimulateAdvanced.Rd: z <- RFsimulate(model=RPpoisson(RMgauss()), x=x, mpp.intensity = 100)
RandomFields/man/RFsimulateAdvanced.Rd: z <- RFsimulate(x=x, model=RPpoisson(RMball()), mpp.intensity = 0.1)
RandomFields/man/RFsimulateAdvanced.Rd:model <- RMfbm(alpha=0.5, Aniso=matrix(nrow=1, c(1, 0))) + 
RandomFields/man/RFsimulateAdvanced.Rd:         RMfbm(alpha=0.9, Aniso=matrix(nrow=1, c(0, 1)))
RandomFields/man/RFsimulateAdvanced.Rd:z <- RFsimulate(x=x, y=x, model=RMfbm(alpha=alpha))
RandomFields/man/RFsimulateAdvanced.Rd: model=RMfbm(alpha=alpha))
RandomFields/man/RFsimulateAdvanced.Rd:z <- RFsimulate(RMexp(Aniso = Aniso) + 10, x, x)
RandomFields/man/RFfit-class.Rd:%logLik.RF_fit(object, REML = FALSE, ..., method="ml")
RandomFields/man/RFfit-class.Rd:    \command{\link[=RMmodel-class]{RMmodel}}; in the latter case, \code{x} can
RandomFields/man/RFfit-class.Rd: \item{\code{autostart}:}{RMmodelFit; contains the estimation results
RandomFields/man/RFfit-class.Rd: \item{\code{internal1}:}{RMmodelFit; analog to slot 'autostart'} 
RandomFields/man/RFfit-class.Rd: \item{\code{internal2}:}{RMmodelFit; analog to slot 'autostart'} 
RandomFields/man/RFfit-class.Rd: \item{\code{internal3}:}{RMmodelFit; analog to slot 'autostart'} 
RandomFields/man/RFfit-class.Rd: \item{\code{lowerbounds}:}{RMmodel; covariance model in which each
RandomFields/man/RFfit-class.Rd: \item{\code{ml}:}{RMmodelFit; analog to slot 'autostart'
RandomFields/man/RFfit-class.Rd: \item{\code{plain}:}{RMmodelFit; analog to slot 'autostart'} 
RandomFields/man/RFfit-class.Rd:   Various functions, e.g. \command{print.RMmodelFit}, use
RandomFields/man/RFfit-class.Rd: \item{\code{self}:}{RMmodelFit; analog to slot 'autostart'} 
RandomFields/man/RFfit-class.Rd: \item{\code{sd.inv}:}{RMmodelFit; analog to slot 'autostart'} 
RandomFields/man/RFfit-class.Rd: \item{\code{sqrt.nr}:}{RMmodelFit; analog to slot 'autostart'} 
RandomFields/man/RFfit-class.Rd: \item{\code{upperbounds}:}{RMmodel; see slot 'lowerbounds'} 
RandomFields/man/RFfit-class.Rd: \item{\code{users.guess}:}{RMmodelFit; analog to slot 'autostart'} 
RandomFields/man/RFfit-class.Rd: \item{\code{ml}:}{RMmodelFit; analog to slot 'autostart'; with maximum
RandomFields/man/RFfit-class.Rd:\section{Methods}{
RandomFields/man/RFfit-class.Rd:\author{Alexander Malinowski; \martin}
RandomFields/man/RFfit-class.Rd: \code{\link{RMmodel-class}},
RandomFields/man/RFfit-class.Rd: \code{\link{RMmodelFit-class}},
RandomFields/man/RFfit-class.Rd:    \item Hurvich, C.M. and Tsai, C.-L. (1989)
RandomFields/man/RFfit-class.Rd:    Regression and Time Series Model Selection in Small Samples
RandomFields/man/BRmethods.Rd: \item{phi,variogram}{object of class \code{\link[=RMmodel-class]{RMmodel}};
RandomFields/man/BRmethods.Rd:  point process used in the M3 representation, cf. Thm. 6 and Remark 7
RandomFields/man/BRmethods.Rd:  taken into account for the simulation of the shape function in the M3 
RandomFields/man/BRmethods.Rd:  for simulation via the mixed moving maxima (M3) representation; see
RandomFields/man/BRmethods.Rd:  numerical values or given an \code{\link{RMmodel}}, in particular by an
RandomFields/man/BRmethods.Rd:  \code{\link{RMshape}} model. 
RandomFields/man/BRmethods.Rd:  \item{\code{RPbrmixed}}{simulation using M3 representation (method
RandomFields/man/BRmethods.Rd: \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/BRmethods.Rd:   \item  Oesting, M., Kabluchko, Z. and Schlather M. (2012)
RandomFields/man/BRmethods.Rd:model <- RPbrshifted(RMfbm(alpha=1.5), xi=0)
RandomFields/man/BRmethods.Rd: \command{\link{RMmodel}},
RandomFields/man/RPbernoulli.Rd:  \item{phi}{the \command{\link{RMmodel}}.
RandomFields/man/RPbernoulli.Rd: The function returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RPbernoulli.Rd:  \command{\link{Auxiliary RMmodels}},
RandomFields/man/RPbernoulli.Rd: \command{\link{RMbernoulli}}.
RandomFields/man/RPbernoulli.Rd:model <- RPbernoulli(RMexp(), threshold=0)
RandomFields/man/RPbernoulli.Rd:model <- RPbernoulli(RPbrownresnick(RMexp(), xi=1), threshold=1)
RandomFields/man/RFsp-class.Rd:\section{Methods}{
RandomFields/man/RFsp-class.Rd:\author{Alexander Malinowski; \martin}
RandomFields/man/RFsp-class.Rd:model <- RMcauchy(gamma=4, var=0.1, scale=2)
RandomFields/man/RMmppplus.Rd:\name{RMmppplus}
RandomFields/man/RMmppplus.Rd:\alias{RMmppplus}
RandomFields/man/RMmppplus.Rd:\title{Mixture of shape functions}
RandomFields/man/RMmppplus.Rd: \command{\link{RMmppplus}} is a multivariate covariance model which depends on
RandomFields/man/RMmppplus.Rd:RMmppplus(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, p)%, var,scale,Aniso,proj)
RandomFields/man/RMmppplus.Rd: \item{C0}{an \command{\link{RMmodel}}}
RandomFields/man/RMmppplus.Rd: \item{C1,C2,C3,C4,C5,C6,C7,C8,C9}{optional; each an \command{\link{RMmodel}}}
RandomFields/man/RMmppplus.Rd:% \item{var,scale,Aniso,proj}{optional arguments; same meaning for any \command{\link{RMmodel}}. If not passed, the above model remains unmodified.}
RandomFields/man/RMmppplus.Rd: \command{\link{RMmppplus}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMmppplus.Rd: \command{\link{RMplus}},
RandomFields/man/RMmppplus.Rd: \command{\link{RMmodel}},
RandomFields/man/RMmppplus.Rd:%model <- RPcoins(RMmppplus(p=c(0.8, 0.2), RMgauss(), RMexp()), intensity=1)
RandomFields/man/RMpoissonpoly.Rd:\name{RMpolygon}
RandomFields/man/RMpoissonpoly.Rd:\alias{RMpolygon}
RandomFields/man/RMpoissonpoly.Rd:\title{RMpolygon}
RandomFields/man/RMpoissonpoly.Rd:  \command{RMpolygon} refers to the indicator function of
RandomFields/man/RMpoissonpoly.Rd:RMpolygon(lambda)
RandomFields/man/RMpoissonpoly.Rd:  \command{\link{RMball}},
RandomFields/man/RMpoissonpoly.Rd:  \command{\link{RMspheric}},
RandomFields/man/RMpoissonpoly.Rd:  \command{\link{RMmodel}}.
RandomFields/man/RMpoissonpoly.Rd:    \emph{Geostatistical Simulation: Models and Algorithms.}
RandomFields/man/RMpoissonpoly.Rd:  Mixed Poisson storm process
RandomFields/man/RMpoissonpoly.Rd:    \item  Strokorb, K., Ballani, F., and  Schlather, M. (2014)
RandomFields/man/RMpoissonpoly.Rd:model <- RPcoins(shape=RMpolygon())
RandomFields/man/RMcov.Rd:\name{RMcov}
RandomFields/man/RMcov.Rd:\alias{RMcov}
RandomFields/man/RMcov.Rd:\alias{RMcov}
RandomFields/man/RMcov.Rd:\alias{RMCOV_X}
RandomFields/man/RMcov.Rd:RMcov(gamma, x, y=NULL, z=NULL, T=NULL, grid, a,
RandomFields/man/RMcov.Rd:  \command{\link{RMmodel}}. If not passed, the above covariance function
RandomFields/man/RMcov.Rd: \command{\link{RMcov}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}
RandomFields/man/RMcov.Rd:\author{Martin Schlather, \email{schlather@math.uni-mannheim.de}
RandomFields/man/RMcov.Rd: \command{\link{RMmodel}},
RandomFields/man/RMcov.Rd:bm <- RMfbm(alpha=1)
RandomFields/man/RMcov.Rd:z1 <- RFsimulate(RMcov(bm), x)
RandomFields/man/RMcov.Rd:z2 <- RFsimulate(RMcov(bm, "center"), x)
RandomFields/man/RMcov.Rd:z3 <- RFsimulate(RMcov(bm, "extremals"), x)
RandomFields/man/RMmodelsAdvanced.Rd:\name{RMmodelsAdvanced}
RandomFields/man/RMmodelsAdvanced.Rd:\alias{RMmodelsAdvanced}
RandomFields/man/RMmodelsAdvanced.Rd:\alias{Advanced RMmodels}
RandomFields/man/RMmodelsAdvanced.Rd: Here, further models and advanced comments for \command{\link{RMmodel}}
RandomFields/man/RMmodelsAdvanced.Rd: are given. See also \command{\link{RFgetModelNames}}.
RandomFields/man/RMmodelsAdvanced.Rd:\command{\link{RMaskey}} \tab Askey model (generalized test or triangle model) \cr
RandomFields/man/RMmodelsAdvanced.Rd:\command{\link{RMbcw}} \tab bridging model between
RandomFields/man/RMmodelsAdvanced.Rd:                       \command{\link{RMcauchy}} and \command{\link{RMgenfbm}} \cr
RandomFields/man/RMmodelsAdvanced.Rd:\command{\link{RMbessel}} \tab Bessel family \cr
RandomFields/man/RMmodelsAdvanced.Rd:\command{\link{RMcircular}} \tab circular model \cr
RandomFields/man/RMmodelsAdvanced.Rd:\command{\link{RMconstant}} \tab spatially constant model \cr
RandomFields/man/RMmodelsAdvanced.Rd:\command{\link{RMcubic}} \tab cubic model (see Chiles and Delfiner) \cr
RandomFields/man/RMmodelsAdvanced.Rd:\command{\link{RMdagum}} \tab Dagum model \cr
RandomFields/man/RMmodelsAdvanced.Rd:\command{\link{RMdampedcos}} \tab exponentially damped cosine \cr
RandomFields/man/RMmodelsAdvanced.Rd:\command{\link{RMqexp}} \tab variant of the exponential model \cr
RandomFields/man/RMmodelsAdvanced.Rd:\command{\link{RMfractdiff}} \tab fractionally differenced process \cr
RandomFields/man/RMmodelsAdvanced.Rd:\command{\link{RMfractgauss}} \tab fractional Gaussian noise \cr
RandomFields/man/RMmodelsAdvanced.Rd:\command{\link{RMgengneiting}} \tab generalized Gneiting model \cr
RandomFields/man/RMmodelsAdvanced.Rd:\command{\link{RMgneitingdiff}} \tab Gneiting model for tapering \cr
RandomFields/man/RMmodelsAdvanced.Rd:\command{\link{RMhyperbolic}} \tab generalized hyperbolic model \cr
RandomFields/man/RMmodelsAdvanced.Rd:\command{\link{RMlgd}} \tab Gneiting's local-global distinguisher\cr
RandomFields/man/RMmodelsAdvanced.Rd:\command{\link{RMlsfbm}} \tab locally stationary fractal Brownian motion \cr
RandomFields/man/RMmodelsAdvanced.Rd:\command{\link{RMpenta}} \tab penta model (see Chiles and Delfiner) \cr
RandomFields/man/RMmodelsAdvanced.Rd:\command{\link{RMpower}} \tab Golubov's model \cr
RandomFields/man/RMmodelsAdvanced.Rd:\command{\link{RMwave}} \tab cardinal sine \cr
RandomFields/man/RMmodelsAdvanced.Rd:\command{\link{RMbcw}} \tab bridging model between
RandomFields/man/RMmodelsAdvanced.Rd:                       \command{\link{RMcauchy}} and \command{\link{RMgenfbm}} \cr
RandomFields/man/RMmodelsAdvanced.Rd:\command{\link{RMdewijsian}} \tab generalized version of the DeWijsian model \cr
RandomFields/man/RMmodelsAdvanced.Rd:\command{\link{RMgenfbm}} \tab generalized fractal Brownian motion \cr
RandomFields/man/RMmodelsAdvanced.Rd:\command{\link{RMflatpower}} \tab similar to fractal Brownian motion but
RandomFields/man/RMmodelsAdvanced.Rd:% \command{\link{RMCauchy}} \tab Cauchy like transform -- TO BE PROGRAMMED (includes \code{ma1})) \cr
RandomFields/man/RMmodelsAdvanced.Rd:\command{\link{RMbernoulli}} \tab Correlation function of a binary field
RandomFields/man/RMmodelsAdvanced.Rd: \command{\link{RMexponential}} \tab exponential of a covariance model \cr
RandomFields/man/RMmodelsAdvanced.Rd: \command{\link{RMintexp}} \tab integrated exponential of a covariance model (INCLUDES \code{ma2})\cr
RandomFields/man/RMmodelsAdvanced.Rd: \command{\link{RMpower}} \tab powered variograms\cr
RandomFields/man/RMmodelsAdvanced.Rd: \command{\link{RMqam}} \tab Porcu's quasi-arithmetic-mean model\cr
RandomFields/man/RMmodelsAdvanced.Rd: \command{\link{RMS}} \tab details on the optional transformation
RandomFields/man/RMmodelsAdvanced.Rd: \command{\link{RMcutoff}} \tab Gneiting's modification towards finite range\cr
RandomFields/man/RMmodelsAdvanced.Rd: \command{\link{RMintrinsic}} \tab Stein's modification towards finite range\cr
RandomFields/man/RMmodelsAdvanced.Rd: \command{\link{RMnatsc}} \tab practical range\cr
RandomFields/man/RMmodelsAdvanced.Rd: \command{\link{RMstein}} \tab Stein's modification towards finite range\cr 
RandomFields/man/RMmodelsAdvanced.Rd:% \command{\link{RMtbm2}} \tab Turning bands operator in two (spatial)
RandomFields/man/RMmodelsAdvanced.Rd: \command{\link{RMtbm}}\tab Turning bands operator
RandomFields/man/RMmodelsAdvanced.Rd:See \link{RMmodelsSpaceTime}.
RandomFields/man/RMmodelsAdvanced.Rd:See \link{RMmodelsNonstationary}.
RandomFields/man/RMmodelsAdvanced.Rd:\command{\link{RMsum}} \tab a non-stationary variogram model\cr
RandomFields/man/RMmodelsAdvanced.Rd:\bold{Models related to max-stable random fields (tail correlation
RandomFields/man/RMmodelsAdvanced.Rd:See \link{RMmodelsTailCorrelation}.
RandomFields/man/RMmodelsAdvanced.Rd:  \command{\link{RMcov}} \tab covariance structure given by a variogram\cr 
RandomFields/man/RMmodelsAdvanced.Rd:  \command{\link{RMfixcov}} \tab User defined covariance structure\cr 
RandomFields/man/RMmodelsAdvanced.Rd: \command{\link{RMuser}} \tab User defined model \cr
RandomFields/man/RMmodelsAdvanced.Rd:  \code{\link[=RMS]{Aniso}} \tab for space transformation (not really
RandomFields/man/RMmodelsAdvanced.Rd:  \command{\link{RMcovariate}} \tab spatial covariates\cr
RandomFields/man/RMmodelsAdvanced.Rd:  \command{\link{RMprod}} \tab to model variability of the variance\cr
RandomFields/man/RMmodelsAdvanced.Rd:  \command{\link{RMpolynome}} \tab easy modelling of polynomial trends \cr
RandomFields/man/RMmodelsAdvanced.Rd:  \command{\link{RMshape}} \tab for explicit trend modelling\cr
RandomFields/man/RMmodelsAdvanced.Rd: See \bold{\link{Auxiliary RMmodels}.}
RandomFields/man/RMmodelsAdvanced.Rd:    \code{Aniso} can be given also by \command{\link{RMangle}}
RandomFields/man/RMmodelsAdvanced.Rd:    or any other \command{\link{RMmodel}} instead of a matrix
RandomFields/man/RMmodelsAdvanced.Rd:    abbreviations to the model names, see \command{PrintModelList()}).
RandomFields/man/RMmodelsAdvanced.Rd:    \command{\link{RMS}}. 
RandomFields/man/RMmodelsAdvanced.Rd:      \code{model <- RMexp(scale=2, var=5)}
RandomFields/man/RMmodelsAdvanced.Rd:      \code{model <- list("RMS", scale=2, var=5, list("RMexp"))}
RandomFields/man/RMmodelsAdvanced.Rd:      \code{print(RMexp(scale=2, var=5))}
RandomFields/man/RMmodelsAdvanced.Rd:      \code{model <- RMnsst(phi=RMgauss(var=7), psi=RMfbm(alpha=1.5),
RandomFields/man/RMmodelsAdvanced.Rd:	\code{model <- list("RMS", scale=2, var=5,} \cr
RandomFields/man/RMmodelsAdvanced.Rd:	\code{list("RMnsst", phi=list("RMS", var=7, list("RMgauss")),} \cr
RandomFields/man/RMmodelsAdvanced.Rd:	\code{psi=list("RMfbm", alpha=1.5))
RandomFields/man/RMmodelsAdvanced.Rd:    See \code{\link{RFgetModelNames}(internal=FALSE)} for
RandomFields/man/RMmodelsAdvanced.Rd:%\section{Methods}{
RandomFields/man/RMmodelsAdvanced.Rd: \emph{Geostatistics. Modeling Spatial Uncertainty.}
RandomFields/man/RMmodelsAdvanced.Rd: % \item Gneiting, T. and Schlather, M. (2004)
RandomFields/man/RMmodelsAdvanced.Rd: \item Schlather, M. (1999) \emph{An introduction to positive definite
RandomFields/man/RMmodelsAdvanced.Rd: Technical report ST 99-10, Dept. of Maths and Statistics,
RandomFields/man/RMmodelsAdvanced.Rd: \item Schlather, M. (2011) Construction of covariance functions and
RandomFields/man/RMmodelsAdvanced.Rd: unconditional simulation of random fields. In Porcu, E., Montero, J.M.
RandomFields/man/RMmodelsAdvanced.Rd: and Schlather, M., \emph{Space-Time Processes and Challenges Related
RandomFields/man/RMmodelsAdvanced.Rd: % \item Schlather, M. (2002) Models for stationary max-stable
RandomFields/man/RMmodelsAdvanced.Rd:   Schlather, M., Malinowski, A., Menck, P.J., Oesting, M. and
RandomFields/man/RMmodelsAdvanced.Rd: \item Yaglom, A.M. (1987) \emph{Correlation Theory of Stationary and
RandomFields/man/RMmodelsAdvanced.Rd: New York: Springer. \item Wackernagel, H. (2003) \emph{Multivariate Geostatistics.} Berlin:
RandomFields/man/RMmodelsAdvanced.Rd:  \link{RM},
RandomFields/man/RMmodelsAdvanced.Rd:  \command{\link{RMmodels}},
RandomFields/man/RMmodelsAdvanced.Rd:  \command{\link{RMmodelsAuxiliary}}.
RandomFields/man/RMmodelsAdvanced.Rd:\author{Alexander Malinowski; \martin}
RandomFields/man/RMmodelsAdvanced.Rd:model <- RMwhittle(nu=0.8 + 1.5 * R.is(R.p(new="isotropic"), "<=", 0.5))
RandomFields/man/RMcutoff.Rd:\name{RMcutoff}
RandomFields/man/RMcutoff.Rd:\alias{RMcutoff}
RandomFields/man/RMcutoff.Rd: \command{\link{RMcutoff}} is a functional on univariate stationary
RandomFields/man/RMcutoff.Rd:RMcutoff(phi, diameter, a, var, scale, Aniso, proj)
RandomFields/man/RMcutoff.Rd:    \code{RFgetModelNames(type="positive definite",
RandomFields/man/RMcutoff.Rd:   \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMcutoff.Rd: For certain models \eqn{\phi}{phi}, e.g. \command{\link{RMstable}},
RandomFields/man/RMcutoff.Rd: \command{\link{RMwhittle}} and \command{\link{RMgencauchy}}, some
RandomFields/man/RMcutoff.Rd: \command{\link{RMcutoff}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMcutoff.Rd: \item Gneiting, T., Sevecikova, H, Percival, D.B., Schlather M.,
RandomFields/man/RMcutoff.Rd: \item Stein, M.L. (2002) Fast and exact simulation of fractional
RandomFields/man/RMcutoff.Rd: \command{\link{RMmodel}},
RandomFields/man/RMcutoff.Rd:model <- RMexp()
RandomFields/man/RMcutoff.Rd:plot(model, model.cutoff=RMcutoff(model, diameter=1), xlim=c(0, 4))
RandomFields/man/RMcutoff.Rd:model <- RMstable(alpha = 0.8)
RandomFields/man/RMcutoff.Rd:plot(model, model.cutoff=RMcutoff(model, diameter=2), xlim=c(0, 5))
RandomFields/man/RMcutoff.Rd:plot(RFsimulate(RMcutoff(model), x=x, y = y))
RandomFields/man/RMwave.Rd:\name{RMwave}
RandomFields/man/RMwave.Rd:\alias{RMwave}
RandomFields/man/RMwave.Rd:\alias{RMcardinalsine}
RandomFields/man/RMwave.Rd:\title{Wave Covariance Model / Cardinal Sine}
RandomFields/man/RMwave.Rd: \command{\link{RMwave}} is a stationary isotropic covariance model, which is valid only for dimensions 
RandomFields/man/RMwave.Rd: It is a special case of \command{\link{RMbessel}}.
RandomFields/man/RMwave.Rd:RMwave(var, scale, Aniso, proj)
RandomFields/man/RMwave.Rd:RMcardinalsine(var, scale, Aniso, proj)
RandomFields/man/RMwave.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMwave.Rd:special case of \command{\link{RMbessel}} for \eqn{\nu = 0.5}{\nu = 0.5}.
RandomFields/man/RMwave.Rd: \command{\link{RMwave}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMwave.Rd: \emph{Geostatistics. Modeling Spatial Uncertainty.}
RandomFields/man/RMwave.Rd: \command{\link{RMbessel}},
RandomFields/man/RMwave.Rd: \command{\link{RMmodel}},
RandomFields/man/RMwave.Rd:model <- RMwave(scale=0.1)
RandomFields/man/RMbrownresnick.Rd:\name{RMbrownresnick}
RandomFields/man/RMbrownresnick.Rd:\alias{RMbrownresnick}
RandomFields/man/RMbrownresnick.Rd:  \command{RMbrownresnick} defines
RandomFields/man/RMbrownresnick.Rd:RMbrownresnick(phi, var, scale, Aniso, proj)
RandomFields/man/RMbrownresnick.Rd: \item{phi}{variogram of class \code{\link[=RMmodel-class]{RMmodel}}.}
RandomFields/man/RMbrownresnick.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMbrownresnick.Rd: object of class \code{\link[=RMmodel-class]{RMmodel}}
RandomFields/man/RMbrownresnick.Rd: For a given \command{\link{RMmodel}} the function
RandomFields/man/RMbrownresnick.Rd: \code{\link{RMbrownresnick}(\link{RMmodel}())} 'returns' the tail correlation
RandomFields/man/RMbrownresnick.Rd: function of a Brown-Resnick process with variogram \command{\link{RMmodel}}.
RandomFields/man/RMbrownresnick.Rd:    \item Kabluchko, Z., Schlather, M. & de Haan, L (2009)
RandomFields/man/RMbrownresnick.Rd:    \item Strokorb, K., Ballani, F., and  Schlather, M. (2014)
RandomFields/man/RMbrownresnick.Rd: \command{\link{RMm2r}}, \command{\link{RMm3b}}, \command{\link{RMmps}},
RandomFields/man/RMbrownresnick.Rd: \command{\link{RMmodel}}.
RandomFields/man/RMbrownresnick.Rd:#plot covariance model of type RMbrownresnick
RandomFields/man/RMbrownresnick.Rd:RMmodel <- RMfbm(alpha=1.5, scale=0.2)
RandomFields/man/RMbrownresnick.Rd:plot(RMbrownresnick(RMmodel))
RandomFields/man/RMbrownresnick.Rd:z <- RFsimulate(RMbrownresnick(RMmodel), x=x, y=x)
RandomFields/man/RFsimulate.Rd: \item{model,params}{\argModel
RandomFields/man/RFsimulate.Rd:%     \item if of class \code{\link[=RMmodel-class]{RMmodel}}, \code{model}
RandomFields/man/RFsimulate.Rd:%     type \code{\link{RFgetModelNames}(type="variogram")} for a list of
RandomFields/man/RFsimulate.Rd:%     available models; see also \command{\link{RMmodel}}.
RandomFields/man/RFsimulate.Rd: Simulating with trend can be done by including \command{\link{RMshape}}
RandomFields/man/RFsimulate.Rd: result is of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RFsimulate.Rd: \command{\link{RFgetModelInfo}},
RandomFields/man/RFsimulate.Rd: \command{\link{RMmodel}},
RandomFields/man/RFsimulate.Rd:## ONLY TWO VERY BASIC EXAMPLES ARE GIVEN HERE ##
RandomFields/man/RFsimulate.Rd:## ?RMsimulate.more.examples ##
RandomFields/man/RFsimulate.Rd:RFgetModelNames(type="positive definite", domain="single variable",
RandomFields/man/RFsimulate.Rd:model <- RMexp(var=5, scale=10) + # with variance 4 and scale 10
RandomFields/man/RFsimulate.Rd: RMnugget(var=1) + # nugget
RandomFields/man/RFsimulate.Rd: RMshape(mean=0.5) # and mean
RandomFields/man/RFsimulate.Rd:dta <- RFsimulate(model = RMexp(), x=x, y=y, grid=FALSE)
RandomFields/man/RFsimulate.Rd:model <- RMexp()
RandomFields/man/RFfctn.Rd: \item{model,params}{\argModel }
RandomFields/man/RFfctn.Rd: \command{\link{RMmodel}},
RandomFields/man/RFfctn.Rd:model <- RMexp() - 1
RandomFields/man/RMchoquet.Rd:\name{RMchoquet}
RandomFields/man/RMchoquet.Rd:\alias{RMchoquet}
RandomFields/man/RMchoquet.Rd:  \command{\link{RMchoquet}} is an isotropic covariance model. The
RandomFields/man/RMchoquet.Rd:RMchoquet(b)
RandomFields/man/RMchoquet.Rd:  others like Menegatto, Chen, Sun,  Oliveira and Peron, the class
RandomFields/man/RMchoquet.Rd:  \command{\link{RMmultiquad}}) and the model of the sine power function (see
RandomFields/man/RMchoquet.Rd:  \command{\link{RMsinepower}}).
RandomFields/man/RMchoquet.Rd: \command{\link{RMchoquet}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMchoquet.Rd:  \emph{Positive definite functions on spheres.} Duke Math.J.,\bold{9}, 96-108.
RandomFields/man/RMchoquet.Rd:  \item Menegatto, V.A. (1994)
RandomFields/man/RMchoquet.Rd:  \item Chen, D., Menegatto, V.A., and Sun, X. (2003)
RandomFields/man/RMchoquet.Rd:  Proc. Amer. Math. Soc.,\bold{131}, 2733-2740.
RandomFields/man/RMchoquet.Rd:  \item Menegatto, V.A., Oliveira, C.P. and Peron, A.P. (2006)
RandomFields/man/RMchoquet.Rd:    plane.} Comput. Math. Appl., \bold{51}, 1233-1250.
RandomFields/man/RMchoquet.Rd: \command{\link{RMmodel}},
RandomFields/man/RMchoquet.Rd: \command{\link{RMmultiquad}},
RandomFields/man/RMchoquet.Rd: \command{\link{RMsinepower}}
RandomFields/man/RMchoquet.Rd:#model <- RMchoquet(b=b)
RandomFields/man/RMscale.Rd:\name{RMscale}
RandomFields/man/RMscale.Rd:\alias{RMscale}
RandomFields/man/RMscale.Rd:RMscale(phi, scaling, penalty, var, scale, Aniso, proj)
RandomFields/man/RMscale.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMscale.Rd: \command{\link{RMscale}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMscale.Rd:    \item Bonat, W.H. , Ribeiro, P. Jr. and Schlather, M. (2019)
RandomFields/man/RMscale.Rd:    Modelling non-stationarity in scale. In preparation.
RandomFields/man/RMscale.Rd:  \command{\link{RMSadvanced}},
RandomFields/man/RMscale.Rd:  \command{\link{RMblend}},
RandomFields/man/RMscale.Rd:  \command{\link{RMbubble}}
RandomFields/man/RMscale.Rd:scale <- RMcovariate(x=c(0,1), y=c(1,0),#2 areas separated by the 1st bisector
RandomFields/man/RMscale.Rd:model <- RMscale(RMexp(), scaling = scale, penalty=RMidcoord() / 2)
RandomFields/man/fitgauss.Rd:\section{Maximum likelihood}{
RandomFields/man/RMmodel-class.Rd:\name{RMmodel-class}
RandomFields/man/RMmodel-class.Rd:\alias{RMmodel-class}
RandomFields/man/RMmodel-class.Rd:\alias{show,RMmodel-method}
RandomFields/man/RMmodel-class.Rd:\alias{print.RMmodel}
RandomFields/man/RMmodel-class.Rd:\alias{plot,RMmodel,missing-method}
RandomFields/man/RMmodel-class.Rd:\alias{persp,RMmodel-method}
RandomFields/man/RMmodel-class.Rd:\alias{image,RMmodel-method}
RandomFields/man/RMmodel-class.Rd:\alias{points,RMmodel-method}
RandomFields/man/RMmodel-class.Rd:\alias{lines,RMmodel-method}
RandomFields/man/RMmodel-class.Rd:\alias{points.RMmodel}
RandomFields/man/RMmodel-class.Rd:\alias{lines.RMmodel}
RandomFields/man/RMmodel-class.Rd:\alias{str.RMmodel}
RandomFields/man/RMmodel-class.Rd:\alias{[,RMmodel-method}
RandomFields/man/RMmodel-class.Rd:\alias{[,RMmodel,ANY,ANY,ANY-method}
RandomFields/man/RMmodel-class.Rd:\alias{[<-,RMmodel-method}
RandomFields/man/RMmodel-class.Rd:\alias{[<-,RMmodel,ANY,ANY,ANY-method}
RandomFields/man/RMmodel-class.Rd:\alias{+,RMmodel,RMmodel-method}
RandomFields/man/RMmodel-class.Rd:\alias{+,numeric,RMmodel-method}
RandomFields/man/RMmodel-class.Rd:\alias{+,logical,RMmodel-method}
RandomFields/man/RMmodel-class.Rd:\alias{+,RMmodel,numeric-method}
RandomFields/man/RMmodel-class.Rd:\alias{+,RMmodel,logical-method}
RandomFields/man/RMmodel-class.Rd:\alias{*,RMmodel,RMmodel-method}
RandomFields/man/RMmodel-class.Rd:\alias{*,numeric,RMmodel-method}
RandomFields/man/RMmodel-class.Rd:\alias{*,logical,RMmodel-method}
RandomFields/man/RMmodel-class.Rd:\alias{*,RMmodel,logical-method}
RandomFields/man/RMmodel-class.Rd:\alias{*,RMmodel,numeric-method}
RandomFields/man/RMmodel-class.Rd:\alias{-,RMmodel,RMmodel-method}
RandomFields/man/RMmodel-class.Rd:\alias{-,numeric,RMmodel-method}
RandomFields/man/RMmodel-class.Rd:\alias{-,logical,RMmodel-method}
RandomFields/man/RMmodel-class.Rd:\alias{-,RMmodel,logical-method}
RandomFields/man/RMmodel-class.Rd:\alias{-,RMmodel,numeric-method}
RandomFields/man/RMmodel-class.Rd:\alias{/,RMmodel,RMmodel-method}
RandomFields/man/RMmodel-class.Rd:\alias{/,numeric,RMmodel-method}
RandomFields/man/RMmodel-class.Rd:\alias{/,logical,RMmodel-method}
RandomFields/man/RMmodel-class.Rd:\alias{/,RMmodel,numeric-method}
RandomFields/man/RMmodel-class.Rd:\alias{/,RMmodel,logical-method}
RandomFields/man/RMmodel-class.Rd:\alias{^,RMmodel,RMmodel-method}
RandomFields/man/RMmodel-class.Rd:\alias{^,numeric,RMmodel-method}
RandomFields/man/RMmodel-class.Rd:\alias{^,logical,RMmodel-method}
RandomFields/man/RMmodel-class.Rd:\alias{^,RMmodel,numeric-method}
RandomFields/man/RMmodel-class.Rd:\alias{^,RMmodel,logical-method}
RandomFields/man/RMmodel-class.Rd:\alias{c,RMmodel-method}
RandomFields/man/RMmodel-class.Rd:\alias{RFplotModel}
RandomFields/man/RMmodel-class.Rd:\title{Class \code{RMmodel}}
RandomFields/man/RMmodel-class.Rd:RFplotModel(x, y, dim=1,
RandomFields/man/RMmodel-class.Rd:           fct.type=NULL, MARGIN, fixed.MARGIN, maxchar=15, ...,
RandomFields/man/RMmodel-class.Rd:\S4method{plot}{RMmodel,missing}(x, y, ...)
RandomFields/man/RMmodel-class.Rd:\S4method{points}{RMmodel}(x, ..., type="p")
RandomFields/man/RMmodel-class.Rd:\S4method{lines}{RMmodel}(x, ..., type="l")
RandomFields/man/RMmodel-class.Rd:\S4method{image}{RMmodel}(x, ..., dim=2)
RandomFields/man/RMmodel-class.Rd:\S4method{persp}{RMmodel}(x, ..., dim=2, zlab="")
RandomFields/man/RMmodel-class.Rd:    \command{\link[=RMmodel-class]{RMmodel}}; in the latter case, \code{x} can
RandomFields/man/RMmodel-class.Rd:  \item{MARGIN}{vector of two; two integer values giving the coordinate
RandomFields/man/RMmodel-class.Rd:%  \item{MARGIN.slices}{integer value; if \eqn{[space-time-dimension>2]},
RandomFields/man/RMmodel-class.Rd:%    \code{MARGIN.slices} can specify a third dimension w.r.t. which a
RandomFields/man/RMmodel-class.Rd:  \item{fixed.MARGIN}{only for \code{class(x)==CLASS_CLIST} and if
RandomFields/man/RMmodel-class.Rd:  \item{maxchar}{integer. Maximum number of characters to print the
RandomFields/man/RMmodel-class.Rd: \code{\link[=RMmodelgenerator-class]{RMmodelgenerator}}.
RandomFields/man/RMmodel-class.Rd:\section{Methods}{
RandomFields/man/RMmodel-class.Rd: covariance models; internally calls \command{\link{RMplus}}.}
RandomFields/man/RMmodel-class.Rd:  functions given here as they call \command{RFplotModel} immediately.
RandomFields/man/RMmodel-class.Rd:\author{Alexander Malinowski, \martin}
RandomFields/man/RMmodel-class.Rd:  \code{\link[=RMmodelgenerator-class]{RMmodelgenerator}}
RandomFields/man/RMmodel-class.Rd:  \link{RMmodel}
RandomFields/man/RMmodel-class.Rd:# see RMmodel for introductory examples
RandomFields/man/RMmodel-class.Rd:model <- RMexp(scale=2) + RMnugget(var=3)
RandomFields/man/RFcovmatrix.Rd:  \item{model,params}{\argModel }
RandomFields/man/RFcovmatrix.Rd: \command{\link{RMmodel}},
RandomFields/man/RFcovmatrix.Rd:model <- RMexp() # the covariance function C(x,y)=C(r) of this model
RandomFields/man/CoordinateSystems.Rd:	is given, see \command{\link{RMtrafo}}.
RandomFields/man/CoordinateSystems.Rd:    \code{\link{RMuser}} only.  
RandomFields/man/CoordinateSystems.Rd:    \item Schlather, M. (2011) Construction of covariance functions and
RandomFields/man/CoordinateSystems.Rd:    unconditional simulation of random fields. In Porcu, E., Montero, J.M.
RandomFields/man/CoordinateSystems.Rd:    and Schlather, M., \emph{Space-Time Processes and Challenges Related
RandomFields/man/CoordinateSystems.Rd:    \item Strokorb, K., Ballani, F., and  Schlather, M. (2014)
RandomFields/man/CoordinateSystems.Rd:  \command{\link{RMtrafo}},
RandomFields/man/CoordinateSystems.Rd:model <- RMwhittle(nu=0.5)
RandomFields/man/CoordinateSystems.Rd:RFcov(RMS(model, s= 1 / 180 * pi), x, y, grid=FALSE,
RandomFields/man/CoordinateSystems.Rd:(z1 <- RFcov(RMS(model, s= 6350 / 180 * pi), x, y, grid=FALSE,
RandomFields/man/CoordinateSystems.Rd:(z2 <- RFcov(RMS(model, s= 6350 / 1.609344 / 180 * pi), x, y, grid=FALSE,
RandomFields/man/CoordinateSystems.Rd:(z1 <- RFcov(RMS(model, s= 6350 / 180 * pi), x, y, grid=FALSE,
RandomFields/man/CoordinateSystems.Rd:(z2 <- RFcov(RMS(model, s= 6350 / 1.609344 / 180 * pi), x, y, grid=FALSE,
RandomFields/man/RMmatern.Rd:\name{RMwhittlematern}
RandomFields/man/RMmatern.Rd:\alias{RMwhittle}
RandomFields/man/RMmatern.Rd:\alias{RMkbessel}
RandomFields/man/RMmatern.Rd:\alias{RMmatern}
RandomFields/man/RMmatern.Rd:\alias{RMhandcock}
RandomFields/man/RMmatern.Rd:\title{Whittle-Matern Covariance Model}
RandomFields/man/RMmatern.Rd:  The models \code{RMmatern}, \code{RMwhittle} and \code{RMhandcock}
RandomFields/man/RMmatern.Rd: The Matern model is given by
RandomFields/man/RMmatern.Rd:RMwhittle(nu, notinvnu, var, scale, Aniso, proj)
RandomFields/man/RMmatern.Rd:RMmatern(nu, notinvnu, var, scale, Aniso, proj)
RandomFields/man/RMmatern.Rd:RMhandcock(nu, notinvnu, var, scale, Aniso, proj)
RandomFields/man/RMmatern.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMmatern.Rd: The Matern model or the Handcock-Wallis parametrisation
RandomFields/man/RMmatern.Rd: The Whittle-Matern model is the model of choice if the smoothness of a
RandomFields/man/RMmatern.Rd:  \item the Matern model and the Whittle equal \command{\link{RMexp}}.
RandomFields/man/RMmatern.Rd:  \code{\link{RMexp}(scale=sqrt(0.5))}, i.e., \eqn{\exp(-\sqrt{2}\|h\|)}.
RandomFields/man/RMmatern.Rd:  \item the Matern model equals \code{\link{RMgauss}(scale=sqrt(2))}, i.e.,
RandomFields/man/RMmatern.Rd:  \item the Handcock model equals  \command{\link{RMgauss}}, i.e.,
RandomFields/man/RMmatern.Rd:model \command{\link{RMgauss}} %\eqn{C(r) = -r^2}
RandomFields/man/RMmatern.Rd: The Whittle-Matern model is a normal scale mixture.
RandomFields/man/RMmatern.Rd: The functions return an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMmatern.Rd:    \emph{Geostatistics. Modeling Spatial Uncertainty.}
RandomFields/man/RMmatern.Rd:    \item Gelfand, A. E., Diggle, P., Fuentes, M. and Guttorp,
RandomFields/man/RMmatern.Rd:    history of probability and statistics. XLIX. On the Matern
RandomFields/man/RMmatern.Rd:    \item Handcock, M. S. and Wallis, J. R. (1994) An approach to
RandomFields/man/RMmatern.Rd:    \item Stein, M. L. (1999) \emph{Interpolation of Spatial Data --
RandomFields/man/RMmatern.Rd:    \item Strokorb, K., Ballani, F., and  Schlather, M. (2014)
RandomFields/man/RMmatern.Rd: \item \command{\link{RMexp}}, \command{\link{RMgauss}} for special
RandomFields/man/RMmatern.Rd: \item \command{\link{RMhyperbolic}} for a univariate
RandomFields/man/RMmatern.Rd: \item \command{\link{RMbiwm}} for a multivariate generalization
RandomFields/man/RMmatern.Rd: \item \command{\link{RMnonstwm}}, \command{\link{RMstein}} for anisotropic (space-time) generalizations
RandomFields/man/RMmatern.Rd: \item \command{\link{RMmodel}},
RandomFields/man/RMmatern.Rd:model <- RMwhittle(nu=1, Aniso=matrix(nc=2, c(1.5, 3, -3, 4)))
RandomFields/man/RMbr2bg.Rd:\name{RMbr2bg}
RandomFields/man/RMbr2bg.Rd:\alias{RMbr2bg}
RandomFields/man/RMbr2bg.Rd:RMbr2bg(phi, var, scale, Aniso, proj)
RandomFields/man/RMbr2bg.Rd: \item{phi}{covariance function of class \code{\link[=RMmodel-class]{RMmodel}}.}
RandomFields/man/RMbr2bg.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMbr2bg.Rd: object of class \code{\link[=RMmodel-class]{RMmodel}}
RandomFields/man/RMbr2bg.Rd:  \command{\link{RMbr2bg}} \cr
RandomFields/man/RMbr2bg.Rd:  simulated with \code{\link{RMbr2bg}(\link{RMmodel}())} has
RandomFields/man/RMbr2bg.Rd:    variogram \command{\link{RMmodel}}.
RandomFields/man/RMbr2bg.Rd:    \item Strokorb, K., Ballani, F., and  Schlather, M. (2014)
RandomFields/man/RMbr2bg.Rd:  \command{\link{RMbr2eg}},
RandomFields/man/RMbr2bg.Rd:  \command{\link{RMmodel}},
RandomFields/man/RMbr2bg.Rd:  \command{\link{RMm2r}},
RandomFields/man/RMbr2bg.Rd:model <- RMexp(var=1.62 / 2) 
RandomFields/man/RMbr2bg.Rd:z <- RFsimulate(RPschlather(RMbr2eg(model)), x, x)
RandomFields/man/RPsmith.Rd:\alias{M2}
RandomFields/man/RPsmith.Rd:\alias{M3}
RandomFields/man/RPsmith.Rd:\title{(Mixed) Moving Maxima}
RandomFields/man/RPsmith.Rd: \item{shape}{an \command{\link{RMmodel}} giving the spectral function}
RandomFields/man/RPsmith.Rd: \item{tcf}{an \command{\link{RMmodel}} specifying the
RandomFields/man/RPsmith.Rd:   constructed via the \command{\link{RMm2r}} construction of
RandomFields/man/RPsmith.Rd:  IMPORTANT: For consistency reasons with the geostatistical definitions
RandomFields/man/RPsmith.Rd:    \item Smith, R.L. (1990) Max-stable processes and spatial extremes
RandomFields/man/RPsmith.Rd:    Unpublished Manuscript.
RandomFields/man/RPsmith.Rd:  \command{\link{Advanced RMmodels}},
RandomFields/man/RPsmith.Rd:  \command{\link{Auxiliary RMmodels}},
RandomFields/man/RPsmith.Rd:  \command{\link{RMmodel}},
RandomFields/man/RPsmith.Rd:model <- RMball()
RandomFields/man/RPsmith.Rd:model <- RMgauss(scale = sqrt(2)) # !! cf. definition of RMgauss
RandomFields/man/RPsmith.Rd:model <- RMexp(s=exp())
RandomFields/man/RPsmith.Rd:model <- RMcauchy(s=exp(), gamma=2)
RandomFields/man/RPsmith.Rd:model <- RMgauss(scale = sqrt(2)) # !! cf. definition of RMgauss
RandomFields/man/RPt.Rd: \item{phi}{the \command{\link{RMmodel}}. If a model for the
RandomFields/man/RPt.Rd: The function returns an object of class \code{\link[=RMmodel]{RMmodel}}.
RandomFields/man/RPt.Rd:  \command{\link{Auxiliary RMmodels}},
RandomFields/man/RPt.Rd:model <- RPt(RMexp(), nu=2)
RandomFields/man/RMuser.Rd:\name{RMuser}
RandomFields/man/RMuser.Rd:\alias{RMuser}
RandomFields/man/RMuser.Rd:\alias{RM_USER}
RandomFields/man/RMuser.Rd:  \command{RMuser} allows for a user-defined covariance function, variogram
RandomFields/man/RMuser.Rd:  \bold{RMuser is very slow -- users should avoid this model whenever possible.}
RandomFields/man/RMuser.Rd:RMuser(type, domain, isotropy, vdim, beta,
RandomFields/man/RMuser.Rd:  \item{type}{ See \code{\link[=RMmodelgenerator-class]{RMmodelgenerator}} for
RandomFields/man/RMuser.Rd:  \item{domain}{ See \code{\link[=RMmodelgenerator-class]{RMmodelgenerator}} for
RandomFields/man/RMuser.Rd:    \code{\link[=RMmodelgenerator-class]{RMmodelgenerator}} for 
RandomFields/man/RMuser.Rd:    Just the names of the variables. More variable names might
RandomFields/man/RMuser.Rd:    \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMuser.Rd: \command{\link{RMuser}} returns an object of class
RandomFields/man/RMuser.Rd: \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMuser.Rd:    The use of \command{RMuser} is completely on the risk of the
RandomFields/man/RMuser.Rd:    \command{\link{RMuser}} may not be used in connection with obsolete
RandomFields/man/RMuser.Rd:  \command{\link{RMcovariate}},
RandomFields/man/RMuser.Rd:  \command{\link{RMfixcov}},
RandomFields/man/RMuser.Rd:  \code{\link[=RMmodelgenerator-class]{RMmodelgenerator}},
RandomFields/man/RMuser.Rd:  \command{\link{RMmodel}},
RandomFields/man/RMuser.Rd:  \link{RC_ISO_NAMES}, \link{RC_DOMAIN_NAMES}.
RandomFields/man/RMuser.Rd:## Alternatively to 'model <- RMexp()' one may define the following
RandomFields/man/RMuser.Rd:model <- RMuser(type="positive definite", domain="single variable",
RandomFields/man/RMuser.Rd:## the kernel, which is the scalar product (see RMprod)
RandomFields/man/RMuser.Rd:model <- RMnugget(var=1e-5) +
RandomFields/man/RMuser.Rd:         RMuser(type="positive definite", domain="kernel",
RandomFields/man/RFpar.Rd:  of \code{RMmodels}, simulations and estimations.
RandomFields/man/RFpar.Rd:plot(RMexp())
RandomFields/man/RFformulaAdvanced.Rd:    \item any formulae and expressions within the \code{RMmodel}
RandomFields/man/RFformulaAdvanced.Rd:    \item arguments in \code{RMmodel} that are identical to
RandomFields/man/RFformulaAdvanced.Rd:  RMexp(scale=4, # '4' will be immediately evaluated
RandomFields/man/RFformulaAdvanced.Rd:  RMgauss(scale=X, # evaluated immediately
RandomFields/man/RFformulaAdvanced.Rd:  RMspheric(scale = Z, # see in params
RandomFields/man/RFformulaAdvanced.Rd:  RMdeclare(# a dummy RMmodel just added to the genuine model used
RandomFields/man/RFformulaAdvanced.Rd:    ##            model, RMdeclare must be added, see above
RandomFields/man/RFformulaAdvanced.Rd:      lower=lower, upper=upper, # 'B' in RMdeclare must be given bound
RandomFields/man/RFformulaAdvanced.Rd:(RFgetModelInfo(RFfit)) # NA indicates parameter values to be optimized
RandomFields/man/RFformulaAdvanced.Rd:  \command{\link{RMdeclare}}}
RandomFields/man/RFformulaAdvanced.Rd:M <- 3
RandomFields/man/RFformulaAdvanced.Rd:model <- RMexp(var=V, scale=S) + M
RandomFields/man/RFformulaAdvanced.Rd:model <- ~ M + RMexp(var=var, scale=sc)
RandomFields/man/RFformulaAdvanced.Rd:p <- list(var=V, sc=S, M=M)
RandomFields/man/RFformulaAdvanced.Rd:model <- ~ RMexp(var=var, sc=sc) + RMnugget(var=nugg)
RandomFields/man/RFformulaAdvanced.Rd:RFgetModel(RFsimulate) ## note that V * abs(cos(S) equals  9.553365
RandomFields/man/RFformulaAdvanced.Rd:model <- ~ RMexp(var=var, sc=sc) + RMnugget(var=var * abs(cos(sc)))
RandomFields/man/RFformulaAdvanced.Rd:model <- ~ RMexp(var=var, sc=sc) + RMnugget(var=nugg)
RandomFields/man/RFformulaAdvanced.Rd:M <- 3
RandomFields/man/RFformulaAdvanced.Rd:model <- ~  RMexp(sc=sc1, var=var) + RMgauss(var=var2, sc=sc2) +
RandomFields/man/RFformulaAdvanced.Rd:            RMdeclare(u) ## introduces dummy variable 'u'
RandomFields/man/RMeaxxa.Rd:\name{RMeaxxa}
RandomFields/man/RMeaxxa.Rd:\alias{RMeaxxa}
RandomFields/man/RMeaxxa.Rd:\alias{RMetaxxa}
RandomFields/man/RMeaxxa.Rd:  \command{RMeaxxa} and \command{RMetaxxa} define the auxiliary functions
RandomFields/man/RMeaxxa.Rd:RMeaxxa(E, A) 
RandomFields/man/RMeaxxa.Rd:RMetaxxa(E, A, alpha)
RandomFields/man/RMeaxxa.Rd: \command{\link{RMeaxxa}} is defined in space and returns an m-variate model.
RandomFields/man/RMeaxxa.Rd: \command{\link{RMetaxxa}} is a space-time model with two spatial dimensions.
RandomFields/man/RMeaxxa.Rd: \command{\link{RMeaxxa}} and \command{\link{RMetaxxa}} return an
RandomFields/man/RMeaxxa.Rd: object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMeaxxa.Rd: \item Schlather, M. (2010)
RandomFields/man/RMeaxxa.Rd: \command{\link{RMmodel}},
RandomFields/man/RMbicauchy.Rd:\name{RMbicauchy}
RandomFields/man/RMbicauchy.Rd:\alias{RMbicauchy}
RandomFields/man/RMbicauchy.Rd:\title{Bivariate Cauchy Model}
RandomFields/man/RMbicauchy.Rd: \command{\link{RMbicauchy}} is a bivariate stationary isotropic covariance model
RandomFields/man/RMbicauchy.Rd:RMbicauchy(alpha, beta, s, rho, var, scale, Aniso, proj)
RandomFields/man/RMbicauchy.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMbicauchy.Rd: \command{\link{RMbicauchy}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMbicauchy.Rd: \item Moreva, O., Schlather, M. (2016) Modelling and simulation of bivariate Gaussian random fields.
RandomFields/man/RMbicauchy.Rd: \command{\link{RMcauchy}},
RandomFields/man/RMbicauchy.Rd: \link{Multivariate RMmodels}.
RandomFields/man/ca20.Rd:  The data was collected by researchers from PESAGRO and EMBRAPA-Solos, Rio
RandomFields/man/ca20.Rd:  and provided by Dra. Maria Cristina Neves de Oliveira.
RandomFields/man/ca20.Rd:  Capeche, C.L.; Macedo, J.R.; Manzatto, H.R.H.; Silva, E.F. (1997)
RandomFields/man/ca20.Rd:  Oliveira, M.C.N. (2003) \emph{Metodos de estimacao de parametros
RandomFields/man/RMtrafo.Rd:\name{RMtrafo}
RandomFields/man/RMtrafo.Rd:\alias{RMtrafo}
RandomFields/man/RMtrafo.Rd:  \command{RMtrafo} is the internal basic function that also allows
RandomFields/man/RMtrafo.Rd:RMtrafo(phi, new)
RandomFields/man/RMtrafo.Rd:    %    SYMMETRIC,
RandomFields/man/RMtrafo.Rd:    \code{\link[=constants]{RC_GNOMONIC_PROJ}},
RandomFields/man/RMtrafo.Rd:    or the corresponding \code{\link[=constants]{RC_ISONAMES}}.
RandomFields/man/RMtrafo.Rd:    Note that \command{RMtrafo} only allows for integer values.
RandomFields/man/RMtrafo.Rd:  The function \command{RMtrafo} returns a matrix, in general. For
RandomFields/man/RMtrafo.Rd: \command{\link{RMangle}},
RandomFields/man/RMtrafo.Rd: \command{\link{RMidcoord}},
RandomFields/man/RMtrafo.Rd: \command{\link{RMidmodel}}.
RandomFields/man/RMtrafo.Rd:(z <- RFfctn(RMtrafo(new=RC_CARTESIAN_COORD), coord))
RandomFields/man/RMtrafo.Rd:Print(yy <- RFfctn(RMtrafo(new=RC_CARTESIAN_COORD), xx), units="miles")
RandomFields/man/RMderiv.Rd:\name{RMderiv}
RandomFields/man/RMderiv.Rd:\alias{RMderiv}
RandomFields/man/RMderiv.Rd: \command{\link{RMderiv}}
RandomFields/man/RMderiv.Rd: \command{RMderiv} equals
RandomFields/man/RMderiv.Rd:RMderiv(phi, which, var, scale, Aniso, proj)
RandomFields/man/RMderiv.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMderiv.Rd: \command{\link{RMderiv}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMderiv.Rd: \item Matheron
RandomFields/man/RMderiv.Rd: \command{\link{RMcurlfree}},
RandomFields/man/RMderiv.Rd: \command{\link{RMdivfree}},
RandomFields/man/RMderiv.Rd: \command{\link{RMvector}}
RandomFields/man/RMderiv.Rd:model <- RMderiv(RMgauss(), scale=4)
RandomFields/man/RRloc.Rd:\title{Location and Scale Modification of A Distribution}
RandomFields/man/RRloc.Rd:  \item{phi}{distribution \command{\link{RMmodel}}}
RandomFields/man/RRloc.Rd: \command{\link{RRloc}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RRloc.Rd: \command{\link{RMmodel}},
RandomFields/man/RMfractgauss.Rd:\name{RMfractgauss}
RandomFields/man/RMfractgauss.Rd:\alias{RMfractgauss}
RandomFields/man/RMfractgauss.Rd:\title{Fractal Gaussian Model Family}
RandomFields/man/RMfractgauss.Rd: \command{\link{RMfractgauss}} is a stationary isotropic covariance model.
RandomFields/man/RMfractgauss.Rd:RMfractgauss(alpha,var, scale, Aniso, proj)
RandomFields/man/RMfractgauss.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMfractgauss.Rd: \command{\link{RMfractgauss}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMfractgauss.Rd: \item Gneiting, T. and Schlather, M. (2004)
RandomFields/man/RMfractgauss.Rd: \emph{SIAM review} \bold{46}, 269--282.
RandomFields/man/RMfractgauss.Rd: \command{\link{RMmodel}},
RandomFields/man/RMfractgauss.Rd:model <- RMfractgauss(alpha=0.5, scale=0.2)
RandomFields/man/internal.Rd:\alias{rfGenerateModels}
RandomFields/man/internal.Rd:\alias{rfGenerateMaths}
RandomFields/man/internal.Rd:\alias{showManpages}
RandomFields/man/internal.Rd:\alias{RM_DEFAULT}
RandomFields/man/internal.Rd:rfGenerateModels(package = "RandomFields", assigning,
RandomFields/man/internal.Rd:                 RMmodels.file=paste(RFpath, "R/RMmodels.R", sep="/"),
RandomFields/man/internal.Rd:rfGenerateMaths(package = "RandomFields",
RandomFields/man/internal.Rd:                            Cfile = "QMath",
RandomFields/man/internal.Rd:showManpages(path="/home/schlather/svn/RandomFields/RandomFields/man")
RandomFields/man/internal.Rd:  \item{package,assigning, RFpath, RMmodels.file, PL}{internal}
RandomFields/man/papers.SBS14.Rd: Strokorb, K., Ballani, F. and Schlather, M. (2014)
RandomFields/man/papers.SBS14.Rd:model <- RMfbm(alpha=1, var=4) ## not 8 as in the paper, since semi-variogram
RandomFields/man/papers.SBS14.Rd:bm <- RMbrownresnick(model)
RandomFields/man/papers.SBS14.Rd:# Fig. 2, Monotone functions
RandomFields/man/papers.SBS14.Rd:z2 <- RFsimulate(RPsmith(RMm2r(bm), xi=0), x, x, 0)
RandomFields/man/papers.SBS14.Rd:z3 <- RFsimulate(RPsmith(RMm3b(bm)), x, x, 0, eps_zhou=0.1)
RandomFields/man/papers.SBS14.Rd:z4 <- RFsimulate(RPsmith(RMmps(bm)), x, x, eps_zhou=0.1)
RandomFields/man/papers.SBS14.Rd:model <- RMexp(var=1.62) 
RandomFields/man/papers.SBS14.Rd:bm <- RMbrownresnick(model)
RandomFields/man/papers.SBS14.Rd:model <- RMfbm(var=4, alpha=1) ## not 8 as in the paper as
RandomFields/man/papers.SBS14.Rd:## SEMI-variograms are used in RandomFields, not variograms
RandomFields/man/papers.SBS14.Rd:sm <- RMm2r(RMbrownresnick(model))
RandomFields/man/papers.SBS14.Rd:z <- RFsimulate(RPsmith(RMm2r(RMbrownresnick(model)), xi=0),
RandomFields/man/papers.SBS14.Rd:z <- RFsimulate(RPsmith(RMm2r(RMbrownresnick(model)), xi=0),
RandomFields/man/papers.SBS14.Rd:z <- RFsimulate(RPsmith(RMm2r(RMbrownresnick(model)), xi=0),
RandomFields/man/RMid.Rd:\name{RMidcoord}
RandomFields/man/RMid.Rd:\alias{RMidcoord}
RandomFields/man/RMid.Rd:\alias{RMid} % obsolete !!
RandomFields/man/RMid.Rd:\title{Identical Model}
RandomFields/man/RMid.Rd:  \command{RMidcoord} is the identical function \eqn{f(x) = x}
RandomFields/man/RMid.Rd:RMidcoord()%var, scale, Aniso, proj)
RandomFields/man/RMid.Rd:RMid() ## obsolete
RandomFields/man/RMid.Rd:%   \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMid.Rd: \command{\link{RMidcoord}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMid.Rd:  \command{\link{RMmodel}}.
RandomFields/man/RMid.Rd:  \command{RMidcoord},
RandomFields/man/RMid.Rd:  \command{RMtrafo},
RandomFields/man/RMid.Rd:  \command{RMprod}
RandomFields/man/RMid.Rd:RFcov(RMprod(RMidcoord()), as.matrix(1:10), as.matrix(1:10), grid=FALSE)
RandomFields/man/RMS.Rd:\name{RMS}
RandomFields/man/RMS.Rd:\alias{RMS}
RandomFields/man/RMS.Rd: \command{\link{RMS}} is an operator that modifies the variance and the
RandomFields/man/RMS.Rd: \bold{Most users will never call \command{\link{RMS}} directly, see
RandomFields/man/RMS.Rd: nearly all models. See \code{\link{RMSadvanced}} for advanced use of
RandomFields/man/RMS.Rd:RMS(phi, var, scale, Aniso, proj, anisoT)
RandomFields/man/RMS.Rd:  \item{Aniso}{matrix or \code{\link{RMmodel}}.
RandomFields/man/RMS.Rd: \command{\link{RMS}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMS.Rd: to be replaced by a valid \command{\link{RMmodel}}.
RandomFields/man/RMS.Rd: Most users will never call \command{\link{RMS}} directly.
RandomFields/man/RMS.Rd:  \command{\link{RMSadvanced}},
RandomFields/man/RMS.Rd:  \command{\link{RMmodel}},
RandomFields/man/RMS.Rd:  \command{\link{RMprod}} for an alternative way to define
RandomFields/man/RMS.Rd:  deviation is given so that \command{\link{RMprod}} might be used
RandomFields/man/RMS.Rd:model1 <- RMS(RMexp(), scale=2)
RandomFields/man/RMS.Rd:model2 <- RMexp(scale=2)
RandomFields/man/RMdewijsian.Rd:\name{RMdewijsian}
RandomFields/man/RMdewijsian.Rd:\alias{RMdewijsian}
RandomFields/man/RMdewijsian.Rd:\title{Modified De Wijsian Variogram Model}
RandomFields/man/RMdewijsian.Rd:  The modified \command{RMdewijsian} model
RandomFields/man/RMdewijsian.Rd:RMdewijsian(alpha, var, scale, Aniso, proj)
RandomFields/man/RMdewijsian.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMdewijsian.Rd: The modified \code{RMdewijsian} model
RandomFields/man/RMdewijsian.Rd: \command{\link{RMdewijsian}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMdewijsian.Rd:% \emph{Geostatistics. Modeling Spatial Uncertainty.}
RandomFields/man/RMdewijsian.Rd: \item Wackernagel, H. (2003) \emph{Multivariate Geostatistics.} Berlin:
RandomFields/man/RMdewijsian.Rd: % \item Martin's Toledo-Chapter: Construction of covariance functions
RandomFields/man/RMdewijsian.Rd: \command{\link{RMmodel}},
RandomFields/man/RMdewijsian.Rd:model <- RMdewijsian(alpha=1)
RandomFields/man/RandomFields.Rd:    \item{\bold{model estimation (ML) and inference (tests)}}
RandomFields/man/RandomFields.Rd:    \item \bold{Bayesian Modelling}
RandomFields/man/RandomFields.Rd:      \item See \link{Bayesian Modelling} for an introduction to
RandomFields/man/RandomFields.Rd:      \item \code{\link{weather}} : UWME weather data
RandomFields/man/RandomFields.Rd:    \item \bold{Models}
RandomFields/man/RandomFields.Rd:      \link{RMmodels}.
RandomFields/man/RandomFields.Rd:      \bold{geostatistical} purposes-- see \link{RM}. More
RandomFields/man/RandomFields.Rd:      functions and variogram models see \command{\link{RM}}.
RandomFields/man/RandomFields.Rd:  in \link{MajorRevisions}.
RandomFields/man/RandomFields.Rd:% \item \command{\link{ShowModels}}
RandomFields/man/RandomFields.Rd:% \item Harvard Rue's Markov fields 
RandomFields/man/RandomFields.Rd:  See also  \link{RF}, \link{RM}, \link{RP}, \link{RR}, \link{RC}, \link{R.}
RandomFields/man/RandomFields.Rd:    Schlather, M., Malinowski, A., Menck, P.J., Oesting, M. and
RandomFields/man/RandomFields.Rd:    Alexander Malinowski (Univ. Mannheim; S3, S4 classes 2011-13)\cr
RandomFields/man/RandomFields.Rd:    Juliane Manitz (Univ. Goettingen; testing, 2012)\cr
RandomFields/man/RandomFields.Rd:    Johannes Martini (Univ. Goettingen; RFvariogram,
RandomFields/man/RandomFields.Rd:    Marco Oesting (Univ. Mannheim; Brown-Resnick processes, Kriging, Trend,
RandomFields/man/RandomFields.Rd:    Kirstin Strokorb (Univ. Mannheim; help pages, 2011-13)\cr
RandomFields/man/RandomFields.Rd:    Peter Menck (Univ. Goettingen; multivariate circulant embedding)\cr
RandomFields/man/RandomFields.Rd:    Ben Pfaff, 12167 Airport Rd, DeWitt MI 48820, USA making available
RandomFields/man/RandomFields.Rd:  Martin Maechler : advice for Version 1
RandomFields/man/RandomFields.Rd: Modeling of Complex Systems and Processes --- Advanced Nonparametric
RandomFields/man/RandomFields.Rd: the project \sQuote{WEX-MOP} (2011-2014).
RandomFields/man/RandomFields.Rd: and 1023 \sQuote{Identification in Mathematical Models} (2008-13).
RandomFields/man/RandomFields.Rd: the German Federal Ministry of Research and Technology 
RandomFields/man/RandomFields.Rd: (BMFT) grant PT BEO 51-0339476C during 2000-03.
RandomFields/man/RandomFields.Rd: V1.0 has been financially supported by the EU TMR network
RandomFields/man/RandomFields.Rd: ERB-FMRX-CT96-0095 on
RandomFields/man/RandomFields.Rd:model <- RMexp()
RandomFields/man/RandomFields.Rd:estmodel <- RMexp(var=NA, scale=NA)
RandomFields/man/RFhurst.Rd: \item Peng, C.K., Buldyrev, S.V., Havlin, S., Simons, M., Stanley,
RandomFields/man/RFhurst.Rd: Mosaic organization of DNA nucleotides
RandomFields/man/RFhurst.Rd: \item Taqqu, M.S. and Teverovsky, V. (1998)
RandomFields/man/RFhurst.Rd: Taqqu, M.S. \emph{A Practical Guide to Heavy Tails, Statistical
RandomFields/man/RFhurst.Rd: Taqqu, M.S. and Teverovsky, V. and Willinger, W. (1995)
RandomFields/man/RFhurst.Rd: \emph{Spectral Analysis for Physical Applications: Multitaper and
RandomFields/man/RFhurst.Rd: \command{\link{RMmodel}}, \command{\link{RFfractaldim}}
RandomFields/man/RFhurst.Rd:% LocalWords: lm sm Schlather url ealso RMmodel
RandomFields/man/RFinterpolate.Rd: \item{model,params}{\argModel}
RandomFields/man/RFinterpolate.Rd:%  NOT TRUE ANYMORE:
RandomFields/man/RFinterpolate.Rd:%  NOT TRUE ANYMORE:
RandomFields/man/RFinterpolate.Rd:  \subsection{Author(s) of the code:}{ \martin; Alexander Malinowski; \marco}
RandomFields/man/RFinterpolate.Rd: \command{\link{RMmodel}},
RandomFields/man/RFinterpolate.Rd:model <- RMexp() + RMshape(mean=1)
RandomFields/man/RFinterpolate.Rd:model <- RMexp()
RandomFields/man/RFinterpolate.Rd:model <- RMexp(scale=2) + RMshape(mean=4)
RandomFields/man/RFinterpolate.Rd:model <- RMexp() + RMshape(mean=NA)
RandomFields/man/RFinterpolate.Rd:model <- RMparswmX(nudiag=c(0.5, 0.5), rho=rho)
RandomFields/man/RFinterpolate.Rd:model <- RMfbm(a=1)
RandomFields/man/RFinterpolate.Rd:model <- RMfbm(a=1) + RMshape(polydeg=2)
RandomFields/man/RFinterpolate.Rd:model <- RMexp() + RMshape(arbit=function(X1,X2) sin(X1+X2)) +
RandomFields/man/RFinterpolate.Rd: RMshape(mean=1)
RandomFields/man/RFinterpolate.Rd:model <- RMexp() + RMshape(arbit=function(x,y) x^2 + y^2) +
RandomFields/man/RFinterpolate.Rd: RMshape(arbit=function(x,y) (x^2 + y^2)^0.5) + RMshape(mean=1)
RandomFields/man/RMcauchy.Rd:\name{RMcauchy}
RandomFields/man/RMcauchy.Rd:\alias{RMcauchy}
RandomFields/man/RMcauchy.Rd:\title{Cauchy Family Covariance Model}
RandomFields/man/RMcauchy.Rd: \command{\link{RMcauchy}} is a stationary isotropic covariance model
RandomFields/man/RMcauchy.Rd: See also \command{\link{RMgencauchy}}.
RandomFields/man/RMcauchy.Rd:RMcauchy(gamma, var, scale, Aniso, proj)
RandomFields/man/RMcauchy.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMcauchy.Rd: The generalized Cauchy Family (see \command{\link{RMgencauchy}})
RandomFields/man/RMcauchy.Rd: The generalized Hyperbolic Family (see \command{\link{RMhyperbolic}})
RandomFields/man/RMcauchy.Rd: \command{\link{RMcauchy}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMcauchy.Rd: \item Gneiting, T. and Schlather, M. (2004)
RandomFields/man/RMcauchy.Rd: \emph{SIAM review} \bold{46}, 269--282.
RandomFields/man/RMcauchy.Rd: \item Gelfand, A. E., Diggle, P., Fuentes, M. and Guttorp,
RandomFields/man/RMcauchy.Rd: \command{\link{RMcauchytbm}},
RandomFields/man/RMcauchy.Rd: \command{\link{RMgencauchy}},
RandomFields/man/RMcauchy.Rd: \command{\link{RMmodel}},
RandomFields/man/RMcauchy.Rd:model <- RMcauchy(gamma=1)
RandomFields/man/RRrectangular.Rd:  is used, else MCMC.
RandomFields/man/RRrectangular.Rd: \command{\link{RRrectangular}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RRrectangular.Rd: \command{\link{RMmodel}},
RandomFields/man/RRrectangular.Rd:distr <- RRrectangular(RMgauss(), approx=FALSE)
RandomFields/man/RRrectangular.Rd:distr <- RRrectangular(RMspheric(), approx=FALSE)
RandomFields/man/RRrectangular.Rd:lines(x, 4/3 * RFcov(RMspheric(), x))
RandomFields/man/RMcoxisham.Rd:\name{RMcoxisham}
RandomFields/man/RMcoxisham.Rd:\alias{RMcoxisham}
RandomFields/man/RMcoxisham.Rd:\title{Cox Isham Covariance Model}
RandomFields/man/RMcoxisham.Rd: \command{\link{RMcoxisham}} is a stationary covariance model
RandomFields/man/RMcoxisham.Rd:RMcoxisham(phi,mu,D,beta,var, scale, Aniso, proj)
RandomFields/man/RMcoxisham.Rd: \command{\link{RMmodel}} whose \code{monotone} property equals
RandomFields/man/RMcoxisham.Rd: \code{\link{RFgetModelNames}(monotone="normal mixture")}
RandomFields/man/RMcoxisham.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMcoxisham.Rd: (cf. Schlather, M. (2010), Example 9).
RandomFields/man/RMcoxisham.Rd: \command{\link{RMcoxisham}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMcoxisham.Rd: \item Schlather, M. (2010)
RandomFields/man/RMcoxisham.Rd: \command{\link{RMmodel}},
RandomFields/man/RMcoxisham.Rd:model <- RMcoxisham(RMgauss(), mu=1, D=1)
RandomFields/man/RFpointsDataFrame-class.Rd:\section{Methods}{
RandomFields/man/RFpointsDataFrame-class.Rd: \code{MARGIN}; to get different slices in a third direction, the
RandomFields/man/RFpointsDataFrame-class.Rd: argument \code{MARGIN.slices} can be used;
RandomFields/man/RFpointsDataFrame-class.Rd: Methods \command{summary} and \command{dimensions}
RandomFields/man/RFpointsDataFrame-class.Rd:\author{Alexander Malinowski, \martin}
RandomFields/man/RFpointsDataFrame-class.Rd:f <- RFsimulate(model=RMexp(), x=x, n=3)
RandomFields/man/RMgneitingdiff.Rd:\name{RMgneitingdiff}
RandomFields/man/RMgneitingdiff.Rd:\alias{RMgneitingdiff}
RandomFields/man/RMgneitingdiff.Rd:\title{Gneiting Covariance Model Used as Tapering Function}
RandomFields/man/RMgneitingdiff.Rd: \command{\link{RMgneitingdiff}} is a stationary isotropic covariance model
RandomFields/man/RMgneitingdiff.Rd: where \eqn{C_0} is Gneiting's model \command{\link{RMgneiting}}
RandomFields/man/RMgneitingdiff.Rd: and \eqn{W_\nu} is the Whittle model \command{\link{RMwhittle}}.
RandomFields/man/RMgneitingdiff.Rd:RMgneitingdiff(nu, taper.scale, scale, var, Aniso, proj)
RandomFields/man/RMgneitingdiff.Rd: \item{nu}{see \command{\link{RMwhittle}} }
RandomFields/man/RMgneitingdiff.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMgneitingdiff.Rd: \command{\link{RMgneitingdiff}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMgneitingdiff.Rd: \emph{Q. J. Roy. Meteor. Soc} Part A \bold{125}, 2449-2464.
RandomFields/man/RMgneitingdiff.Rd: \command{\link{RMbigneiting}},
RandomFields/man/RMgneitingdiff.Rd: \command{\link{RMgneiting}},
RandomFields/man/RMgneitingdiff.Rd: \command{\link{RMgengneiting}},
RandomFields/man/RMgneitingdiff.Rd: \command{\link{RMgauss}},
RandomFields/man/RMgneitingdiff.Rd: \command{\link{RMmodel}},
RandomFields/man/RMgneitingdiff.Rd: \command{\link{RMwhittle}},
RandomFields/man/RMgneitingdiff.Rd:model <- RMgneitingdiff(nu=2, taper.scale=1, scale=0.2)
RandomFields/man/RMdelay.Rd:\name{RMdelay}
RandomFields/man/RMdelay.Rd:\alias{RMdelay}
RandomFields/man/RMdelay.Rd: \command{\link{RMdelay}} is a \eqn{(m+1)}-variate stationary covariance model.
RandomFields/man/RMdelay.Rd:RMdelay(phi,s,var, scale, Aniso, proj)
RandomFields/man/RMdelay.Rd: \command{\link{RMmodel}} whose \command{vdim} equals 1.}
RandomFields/man/RMdelay.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMdelay.Rd: \command{\link{RMdelay}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMdelay.Rd: \item Schlather, M., Malinowski, A., Menck, P.J., Oesting, M. and
RandomFields/man/RMdelay.Rd: \item Wackernagel, H. (2003) \emph{Multivariate Geostatistics.} Berlin:
RandomFields/man/RMdelay.Rd: \command{\link{RMmodel}},
RandomFields/man/RMdelay.Rd:model <- RMdelay(RMstable(alpha=1.9, scale=2), s=c(4,4))
RandomFields/man/RMfixed.Rd:\name{RMfixed}
RandomFields/man/RMfixed.Rd:\alias{RMfixed}
RandomFields/man/RMfixed.Rd:\title{Fixed Effect Model}
RandomFields/man/RMfixed.Rd:\description{ Modelling not possible, currently
RandomFields/man/RMfixed.Rd:%\description{Expressions of the form \code{X@RMfixed(beta)} can be used
RandomFields/man/RMfixed.Rd:% that specifies the Linear Mixed Model.
RandomFields/man/RMfixed.Rd:%%2 Important remark: \code{RMfixed} is NOT a function although
RandomFields/man/RMfixed.Rd:% \code{X@RMfixed(beta=NA)} by default (and \eqn{\beta} is estimated
RandomFields/man/RMfixed.Rd:% Note that the \code{1} in an expression \code{1@RMfixed(beta)} is
RandomFields/man/RMfixed.Rd:% Modelling Spatial Uncertainty.} New York: John Wiley & Sons.
RandomFields/man/RMfixed.Rd: \command{\link{RMmodel}},
RandomFields/man/QMath.Rd:% This file has been created automatically by 'rfGenerateMaths'
RandomFields/man/QMath.Rd:\name{Mathematial C functions}
RandomFields/man/QMath.Rd:\alias{\%\%,ANY,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{\%\%,RMmodel,ANY-method}
RandomFields/man/QMath.Rd:\alias{*,RMmodel,character-method}
RandomFields/man/QMath.Rd:\alias{*,character,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{+,RMmodel,character-method}
RandomFields/man/QMath.Rd:\alias{+,RMmodel,factor-method}
RandomFields/man/QMath.Rd:\alias{+,RMmodel,list-method}
RandomFields/man/QMath.Rd:\alias{+,character,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{+,data.frame,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{+,factor,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{-,RMmodel,character-method}
RandomFields/man/QMath.Rd:\alias{-,character,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{/,RMmodel,character-method}
RandomFields/man/QMath.Rd:\alias{/,character,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{^,ANY,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{^,RMmodel,ANY-method}
RandomFields/man/QMath.Rd:\alias{^,RMmodel,character-method}
RandomFields/man/QMath.Rd:\alias{^,character,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{abs,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{acosh,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{asin,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{asinh,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{atan2,ANY,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{atan2,RMmodel,ANY-method}
RandomFields/man/QMath.Rd:\alias{atan,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{atanh,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{ceiling,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{cos,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{cosh,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{exp,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{expm1,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{floor,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{lgamma,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{log1p,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{log2,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{log,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{round,RMmodel,missing-method}
RandomFields/man/QMath.Rd:\alias{sin,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{sinh,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{sqrt,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{tan,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{tanh,RMmodel-method}
RandomFields/man/QMath.Rd:\alias{trunc,RMmodel-method}
RandomFields/man/QMath.Rd:  The functions provide mathematical c functions as \link{RMmodels}
RandomFields/man/QMath.Rd:\S4method{\%\%}{ANY,RMmodel}(e1,e2)
RandomFields/man/QMath.Rd:\S4method{\%\%}{RMmodel,ANY}(e1,e2)
RandomFields/man/QMath.Rd:\S4method{*}{RMmodel,character}(e1,e2)
RandomFields/man/QMath.Rd:\S4method{*}{character,RMmodel}(e1,e2)
RandomFields/man/QMath.Rd:\S4method{+}{RMmodel,character}(e1,e2)
RandomFields/man/QMath.Rd:\S4method{+}{RMmodel,factor}(e1,e2)
RandomFields/man/QMath.Rd:\S4method{+}{RMmodel,list}(e1,e2)
RandomFields/man/QMath.Rd:\S4method{+}{character,RMmodel}(e1,e2)
RandomFields/man/QMath.Rd:\S4method{+}{data.frame,RMmodel}(e1,e2)
RandomFields/man/QMath.Rd:\S4method{+}{factor,RMmodel}(e1,e2)
RandomFields/man/QMath.Rd:\S4method{-}{RMmodel,character}(e1,e2)
RandomFields/man/QMath.Rd:\S4method{-}{character,RMmodel}(e1,e2)
RandomFields/man/QMath.Rd:\S4method{/}{RMmodel,character}(e1,e2)
RandomFields/man/QMath.Rd:\S4method{/}{character,RMmodel}(e1,e2)
RandomFields/man/QMath.Rd:\S4method{^}{ANY,RMmodel}(e1,e2)
RandomFields/man/QMath.Rd:\S4method{^}{RMmodel,ANY}(e1, e2)
RandomFields/man/QMath.Rd:\S4method{^}{RMmodel,character}(e1,e2)
RandomFields/man/QMath.Rd:\S4method{^}{character,RMmodel}(e1,e2)
RandomFields/man/QMath.Rd:\S4method{abs}{RMmodel}(x)
RandomFields/man/QMath.Rd:\S4method{acosh}{RMmodel}(x)
RandomFields/man/QMath.Rd:\S4method{asin}{RMmodel}(x)
RandomFields/man/QMath.Rd:\S4method{asinh}{RMmodel}(x)
RandomFields/man/QMath.Rd:\S4method{atan2}{ANY,RMmodel}(y,x)
RandomFields/man/QMath.Rd:\S4method{atan2}{RMmodel,ANY}(y,x)
RandomFields/man/QMath.Rd:\S4method{atan}{RMmodel}(x)
RandomFields/man/QMath.Rd:\S4method{atanh}{RMmodel}(x)
RandomFields/man/QMath.Rd:\S4method{ceiling}{RMmodel}(x)
RandomFields/man/QMath.Rd:\S4method{cos}{RMmodel}(x)
RandomFields/man/QMath.Rd:\S4method{cosh}{RMmodel}(x)
RandomFields/man/QMath.Rd:\S4method{exp}{RMmodel}(x)
RandomFields/man/QMath.Rd:\S4method{expm1}{RMmodel}(x)
RandomFields/man/QMath.Rd:\S4method{floor}{RMmodel}(x)
RandomFields/man/QMath.Rd:\S4method{lgamma}{RMmodel}(x)
RandomFields/man/QMath.Rd:\S4method{log1p}{RMmodel}(x)
RandomFields/man/QMath.Rd:\S4method{log2}{RMmodel}(x)
RandomFields/man/QMath.Rd:\S4method{log}{RMmodel}(x)
RandomFields/man/QMath.Rd:\S4method{round}{RMmodel,missing}(x,digits)
RandomFields/man/QMath.Rd:\S4method{sin}{RMmodel}(x)
RandomFields/man/QMath.Rd:\S4method{sinh}{RMmodel}(x)
RandomFields/man/QMath.Rd:\S4method{sqrt}{RMmodel}(x)
RandomFields/man/QMath.Rd:\S4method{tan}{RMmodel}(x)
RandomFields/man/QMath.Rd:\S4method{tanh}{RMmodel}(x)
RandomFields/man/QMath.Rd:\S4method{trunc}{RMmodel}(x)
RandomFields/man/QMath.Rd:  \item{model,params}{\argModel
RandomFields/man/QMath.Rd:    \code{\link[=RMmodel-class]{RMmodel}}, in particular
RandomFields/man/QMath.Rd:    \code{\link[=RC_ISO_NAMES]{kind of isotropy}}
RandomFields/man/QMath.Rd:  \item{digits}{number of digits. Does not work with a \link{RMmodel}}
RandomFields/man/QMath.Rd:%  \item{\code{signature(x = "RMmodel")}}{an \link{RMmodel}, especially a
RandomFields/man/QMath.Rd:%  \item{\code{signature(x = "ANY")}}{numeric or  RMmodel }
RandomFields/man/QMath.Rd:\code{\link[=RMmodel-class]{RMmodel}}, except for
RandomFields/man/QMath.Rd:  \item please use the functions given in \command{\link{RMmodels}}
RandomFields/man/QMath.Rd:       for definite functions (for \code{cos} see \command{\link{RMbessel}})
RandomFields/man/QMath.Rd:	function is ambiguous, see the example in \command{\link{RMshape}}
RandomFields/man/QMath.Rd: \command{\link{RMmodel}}, \command{\link{RFfctn}},
RandomFields/man/QMath.Rd:	 \command{\link{RMshape}}	
RandomFields/man/QMath.Rd:z <- RFsimulate(RMexp(Aniso=Aniso), x, x)
RandomFields/man/QMath.Rd:z2 <- RFsimulate(RMexp() + -40 + exp(0.5 * R.p(new="isotropic")), x, x)
RandomFields/man/QMath.Rd:z1 <- RFsimulate(RMexp() + -40 + exp(0.5 * sqrt(R.p(1)^2 + R.p(2)^2)), x, x)
RandomFields/man/RMmodelsNonstatationary.Rd:\name{RMmodelsNonstationary}
RandomFields/man/RMmodelsNonstatationary.Rd:\alias{RMmodelsNonstationary}
RandomFields/man/RMmodelsNonstatationary.Rd:\alias{Nonstationary RMmodels}
RandomFields/man/RMmodelsNonstatationary.Rd:\alias{non-stationary RMmodels}
RandomFields/man/RMmodelsNonstatationary.Rd: \command{\link{RMnonstwm}} \tab one of Stein's non-stationary
RandomFields/man/RMmodelsNonstatationary.Rd: Whittle-Matern models
RandomFields/man/RMmodelsNonstatationary.Rd: \command{\link{RMprod}} \tab scalar product
RandomFields/man/RMmodelsNonstatationary.Rd: \code{\link[=RMS]{Aniso}} \tab for space transformation, see
RandomFields/man/RMmodelsNonstatationary.Rd: \code{scale}, cf. \command{\link{RMS}}, can be any non-negative
RandomFields/man/RMmodelsNonstatationary.Rd: \command{\link{RMgencauchy}} model.
RandomFields/man/RMmodelsNonstatationary.Rd:See \link{RMmodelsTrend}.
RandomFields/man/RMmodelsNonstatationary.Rd:\seealso{\command{\link{RFformula}}, \command{\link{RMmodels}},
RandomFields/man/RMmodelsNonstatationary.Rd:   \command{\link{RM}},
RandomFields/man/RMmodelsNonstatationary.Rd: \command{\link{RMmodelsAdvanced}}
RandomFields/man/RMgauss.Rd:\name{RMgauss}
RandomFields/man/RMgauss.Rd:\alias{RMgauss}
RandomFields/man/RMgauss.Rd:\title{Gaussian Covariance Model}
RandomFields/man/RMgauss.Rd: \command{\link{RMgauss}} is a stationary isotropic covariance model.
RandomFields/man/RMgauss.Rd:RMgauss(var, scale, Aniso, proj)
RandomFields/man/RMgauss.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMgauss.Rd: (cf. Stein, M. L. (1999), p. 29).
RandomFields/man/RMgauss.Rd:% See \command{\link{RMgneiting}} for an alternative model that does not
RandomFields/man/RMgauss.Rd: \command{\link{RMstable}}) for the choice \eqn{\alpha = 2}{alpha = 2}.
RandomFields/man/RMgauss.Rd: \command{\link{RMgauss}} returns an object of class
RandomFields/man/RMgauss.Rd: \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMgauss.Rd:  The use of \command{RMgauss} is questionable from both a theoretical
RandomFields/man/RMgauss.Rd:  Instead, \command{\link{RMgneiting}} should be used.
RandomFields/man/RMgauss.Rd: Gelfand, A. E., Diggle, P., Fuentes, M. and Guttorp,
RandomFields/man/RMgauss.Rd: Stein, M. L. (1999) \emph{Interpolation of Spatial Data.} New York: Springer-Verlag 
RandomFields/man/RMgauss.Rd: \command{\link{RMstable}} and \command{\link{RMmatern}} for generalizations;
RandomFields/man/RMgauss.Rd: \command{\link{RMmodel}},
RandomFields/man/RMgauss.Rd:model <- RMgauss(scale=0.4)
RandomFields/man/RMgauss.Rd:lines(RMgauss(), col="red")
RandomFields/man/RFvariogram.Rd:\title{Empirical (Cross-)Variogram, (Generalized) Madograms, Covariance functions}
RandomFields/man/RFvariogram.Rd:\item{model,params}{\argModel }
RandomFields/man/RFvariogram.Rd:  Gelfand, A. E., Diggle, P., Fuentes, M. and Guttorp,
RandomFields/man/RFvariogram.Rd:  Stein, M. L. (1999) \emph{Interpolation of Spatial Data.}
RandomFields/man/RFvariogram.Rd:\author{Sebastian Engelke; Jonas Auel; Johannes Martini; \martin}
RandomFields/man/RFvariogram.Rd: \command{\link{RMmodel}},
RandomFields/man/RFvariogram.Rd:model <- RMexp()
RandomFields/man/RFvariogram.Rd:model <- RMexp(Aniso=cbind(c(2,1), c(1,1)))
RandomFields/man/RFvariogram.Rd:model <- RMnsst(phi=RMexp(), psi=RMfbm(alpha=1), delta=2)
RandomFields/man/RFvariogram.Rd:model <- RMbiwm(nudiag=c(1, 2), nured=1, rhored=1, cdiag=c(1, 5), 
RandomFields/man/RFvariogram.Rd:model <- RMbiwm(A=matrix(c(1,1,1,2), nc=2),
RandomFields/man/RMnonstwm.Rd:\name{RMnonstwm}
RandomFields/man/RMnonstwm.Rd:\alias{RMnonstwm}
RandomFields/man/RMnonstwm.Rd:\title{Non-stationary Whittle-Matern Covariance Model}
RandomFields/man/RMnonstwm.Rd:  The non-stationary Whittle-Matern model
RandomFields/man/RMnonstwm.Rd: covariance of the \command{\link{RMwhittle}} model or the
RandomFields/man/RMnonstwm.Rd: \command{\link{RMmatern}} model.
RandomFields/man/RMnonstwm.Rd:  The non-stationary Whittle-Matern models are obtained by
RandomFields/man/RMnonstwm.Rd: \item Stein, M. (2005)
RandomFields/man/RMnonstwm.Rd: \command{\link{RMwhittle}},
RandomFields/man/RMnonstwm.Rd: \command{\link{RMmodel}},
RandomFields/man/RMnonstwm.Rd:model <- RMwhittle(nu=RMgauss())
RandomFields/man/RFdistr.Rd:  in the \command{\link{RMmodel}} definitions.
RandomFields/man/RFdistr.Rd:model <- RMgauss(scale=exp())
RandomFields/man/RFdistr.Rd:  readline(paste("Model no.", i, ": press return", sep=""))
RandomFields/man/RMintrinsic.Rd:\name{RMintrinsic}
RandomFields/man/RMintrinsic.Rd:\alias{RMintrinsic}
RandomFields/man/RMintrinsic.Rd:\title{Intrinsic Embedding Covariance Model}
RandomFields/man/RMintrinsic.Rd: \command{\link{RMintrinsic}} is a univariate stationary isotropic covariance
RandomFields/man/RMintrinsic.Rd:RMintrinsic(phi, diameter, rawR, var, scale, Aniso, proj)
RandomFields/man/RMintrinsic.Rd: \item{phi}{an \command{\link{RMmodel}}; has to be stationary and isotropic}
RandomFields/man/RMintrinsic.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMintrinsic.Rd: \command{\link{RMintrinsic}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMintrinsic.Rd: \item Gneiting, T., Sevecikova, H, Percival, D.B., Schlather M.,
RandomFields/man/RMintrinsic.Rd: \item Stein, M.L. (2002) Fast and exact simulation of fractional
RandomFields/man/RMintrinsic.Rd: \command{\link{RMmodel}},
RandomFields/man/RMintrinsic.Rd:model <- RMintrinsic(RMfbm(alpha=1), diameter=x.max)
RandomFields/man/RMdagum.Rd:\name{RMdagum}
RandomFields/man/RMdagum.Rd:\alias{RMdagum}
RandomFields/man/RMdagum.Rd:\title{Dagum Covariance Model Family}
RandomFields/man/RMdagum.Rd: \command{\link{RMdagum}} is a stationary isotropic covariance model.
RandomFields/man/RMdagum.Rd:RMdagum(beta, gamma, var, scale, Aniso, proj)
RandomFields/man/RMdagum.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMdagum.Rd: see Berg, C. and Mateau, J. and Porcu, E. (2008). This paper also
RandomFields/man/RMdagum.Rd: \command{\link{RMdagum}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMdagum.Rd: \item Berg, C. and Mateau, J. and Porcu, E. (2008)
RandomFields/man/RMdagum.Rd: \command{\link{RMmodel}},
RandomFields/man/RMdagum.Rd:model <- RMdagum(beta=0.5, gamma=0.5, scale=0.2)
RandomFields/man/sp2RF.Rd:z <- RFsimulate(RMexp(), x=x, y=y, n=n)
RandomFields/man/RFgui.Rd:\title{Graphical User Interface For Fitting Covariance Models And Variograms}
RandomFields/man/RFgui.Rd: else it returns the last chosen \command{\link{RMmodel}}.
RandomFields/man/RMmult.Rd:\name{RMmult}
RandomFields/man/RMmult.Rd:\alias{RMmult}
RandomFields/man/RMmult.Rd:\alias{RM_MULT}
RandomFields/man/RMmult.Rd:\title{Multiplication of Random Field Models}
RandomFields/man/RMmult.Rd: \command{\link{RMmult}} is a multivariate covariance model which depends on
RandomFields/man/RMmult.Rd: In general, realizations of the created \command{\link{RMmodel}} are pointwise
RandomFields/man/RMmult.Rd:RMmult(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, var, scale, Aniso, proj)
RandomFields/man/RMmult.Rd: \item{C0}{an \command{\link{RMmodel}}.}
RandomFields/man/RMmult.Rd: \item{C1,C2,C3,C4,C5,C6,C7,C8,C9}{optional; each an \command{\link{RMmodel}}.}
RandomFields/man/RMmult.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMmult.Rd: \command{\link{RMmodel}}s can also be multiplied via the
RandomFields/man/RMmult.Rd: The global arguments \code{scale,Aniso,proj} of \command{\link{RMmult}}
RandomFields/man/RMmult.Rd: \code{RMmult(Aniso=A1, RMexp(Aniso=A2), RMspheric(Aniso=A3))}
RandomFields/man/RMmult.Rd: \code{RMexp(Aniso=A2 \%*\% A1) * RMspheric(Aniso=A3 \%*\% A1)}
RandomFields/man/RMmult.Rd: the global argument \code{var} of \command{\link{RMmult}}
RandomFields/man/RMmult.Rd: is multiplied to the product covariance of \command{\link{RMmult}}.
RandomFields/man/RMmult.Rd: \command{\link{RMmult}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMmult.Rd: \command{\link{RMplus}},	
RandomFields/man/RMmult.Rd: \command{\link{RMmodel}},
RandomFields/man/RMmult.Rd: \command{\link{RMprod}},
RandomFields/man/RMmult.Rd:model <- RMgauss(proj=1) * RMexp(proj=2, scale=5)
RandomFields/man/RPhyperplane.Rd: \item{phi}{object of class \code{\link[=RMmodel-class]{RMmodel}};
RandomFields/man/RPhyperplane.Rd: Maximum number of allowed lines.
RandomFields/man/RPhyperplane.Rd: \code{\link[=RMmodel-class]{RMmodel}}. 
RandomFields/man/RPhyperplane.Rd: \emph{Geostatistical Simulation: Models and Algorithms.}
RandomFields/man/RPhyperplane.Rd:model <- RPhyperplane(RMexp(s=2), superpos=1)
RandomFields/man/plot-method.Rd:\title{Methods for function \code{plot} in package \pkg{RandomFields}}
RandomFields/man/plot-method.Rd:  (objects of class \code{\link[=RMmodel-class]{RMmodel}}),  
RandomFields/man/plot-method.Rd:  \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/plot-method.Rd:\section{Methods}{
RandomFields/man/plot-method.Rd: points of \code{y}. Requires \code{MARGIN.slices=NULL} and 
RandomFields/man/plot-method.Rd: points of \code{y}. Requires \code{MARGIN.slices=NULL} and 
RandomFields/man/plot-method.Rd:%% generated by using the functions promptClass() and promptMethods()
RandomFields/man/plot-method.Rd:%% % \S4method{GENERIC}{SIGNATURE_LIST}(ARGUMENT_LIST)
RandomFields/man/plot-method.Rd:RFplotSimulation(x, y, MARGIN=c(1,2), MARGIN.slices=NULL,
RandomFields/man/plot-method.Rd: n.slices = if (is.null(MARGIN.slices)) 1 else 10, nmax=6, 
RandomFields/man/plot-method.Rd: MARGIN.movie = NULL, file=NULL, speed = 0.3,
RandomFields/man/plot-method.Rd:     \command{\link[=RMmodel-class]{RMmodel}}; in the latter case, \code{x} can
RandomFields/man/plot-method.Rd:  \item{MARGIN}{vector of two; two integer values giving the coordinate
RandomFields/man/plot-method.Rd:  \item{MARGIN.slices}{integer value; if \eqn{[space-time-dimension>2]},
RandomFields/man/plot-method.Rd:    \code{MARGIN.slices} can specify a third dimension w.r.t. which a
RandomFields/man/plot-method.Rd: % \item{fixed.MARGIN}{only for \code{class(x)==CLASS_CLIST} and if
RandomFields/man/plot-method.Rd:  \item{MARGIN.movie}{integer. If given a sequence of figures is shown for this
RandomFields/man/plot-method.Rd:    In case \code{MARGIN.movie} and \code{file} is given an 'avi' movie
RandomFields/man/plot-method.Rd:%    \command{\link[=RMmodel-class]{RMmodel}}; only for
RandomFields/man/plot-method.Rd:\author{Alexander Malinowski, \martin}
RandomFields/man/plot-method.Rd:model <- RMshape(mean=0.5) + # mean
RandomFields/man/plot-method.Rd:         RMstable(alpha=1, var=4, scale=10) + # see help("RMstable")
RandomFields/man/plot-method.Rd:         RMnugget(var=1) # nugget
RandomFields/man/plot-method.Rd:main="My simulation", xlab="my_xlab")
RandomFields/man/plot-method.Rd:model <- RMmatern(nu=1.5, var=4, scale=2)
RandomFields/man/plot-method.Rd:plot(sim3D, MARGIN=c(2,3), MARGIN.slices=1, n.slices=4)
RandomFields/man/plot-method.Rd:model <- RMexp()
RandomFields/man/plot-method.Rd:model <- RMexp(Aniso = cbind(c(10,0), c(0,1)))
RandomFields/man/plot-method.Rd:model <- RMexp(Aniso = cbind(c(10,0), c(0,1)))
RandomFields/man/plot-method.Rd:fit <- RFfit(~RMexp(Aniso=cbind(c(NA, 0), c( 0, NA))), data=X, fit.nphi = 2,
RandomFields/man/plot-method.Rd:model <- RMwhittle(nu=1.2, scale=2)
RandomFields/man/plot-method.Rd:model <- RMdivfree(RMgauss(), scale=4)
RandomFields/man/plot-method.Rd:model <- RMdelay(RMstable(alpha=1.9, scale=2), s=c(0, 4)) +
RandomFields/man/plot-method.Rd:         RMdelay(RMstable(alpha=1.9, scale=2), s=c(4, 0))
RandomFields/man/RPmaxstableAdvanced.Rd:\name{Max-stable random fields, advanced }
RandomFields/man/RPmaxstableAdvanced.Rd:\title{Simulation examples of advanced Max-Stable Random Fields}
RandomFields/man/RPmaxstableAdvanced.Rd:model <- RMexp(var=1.62 / 2) 
RandomFields/man/RPmaxstableAdvanced.Rd:  freq <- rowMeans(below)
RandomFields/man/RPmaxstableAdvanced.Rd:  ecf <-  2-log(colMeans(both)) / log(meanfreq)
RandomFields/man/RPmaxstableAdvanced.Rd:  lines(x, m1 <- RFcov(RMbrownresnick(model), x), col="yellow")
RandomFields/man/RPmaxstableAdvanced.Rd:  lines(x, m2 <- RFcov(RMschlather(RMbr2eg(model)), x), col="red", lty=2) # OK
RandomFields/man/RPmaxstableAdvanced.Rd:  m3 <- RFcov(RMbernoulli(RMbr2bg(model), centred=FALSE), x)
RandomFields/man/RPmaxstableAdvanced.Rd:z <- RFsimulate(RPschlather(RMbr2eg(model)), y, y)
RandomFields/man/RPmaxstableAdvanced.Rd:simu <- RFsimulate(RPschlather(RMbr2eg(model)), x,  n=n)
RandomFields/man/RPmaxstableAdvanced.Rd:binary.model <- RPbernoulli(RMbr2bg(model))
RandomFields/man/RPmaxstableAdvanced.Rd:  simu <- RFsimulate(RPschlather(RMbr2eg(model)), x, spConform=FALSE, n=n,
RandomFields/man/RMmodelExt-class.Rd:\name{RMmodelFit-class}
RandomFields/man/RMmodelExt-class.Rd:\alias{RMmodelFit-class}
RandomFields/man/RMmodelExt-class.Rd:\alias{RM_modelFit-class}
RandomFields/man/RMmodelExt-class.Rd:\alias{[,RMmodelFit-method}
RandomFields/man/RMmodelExt-class.Rd:\alias{[,RMmodelFit,ANY,ANY-method}
RandomFields/man/RMmodelExt-class.Rd:\alias{[,RMmodelFit,ANY,ANY,ANY-method}
RandomFields/man/RMmodelExt-class.Rd:\alias{[<-,RMmodelFit-method}
RandomFields/man/RMmodelExt-class.Rd:\alias{[<-,RMmodelFit,ANY,ANY-method}
RandomFields/man/RMmodelExt-class.Rd:\alias{[<-,RMmodelFit,ANY,ANY,ANY-method}
RandomFields/man/RMmodelExt-class.Rd:\alias{show,RMmodelFit-method}
RandomFields/man/RMmodelExt-class.Rd:\alias{print,RMmodelFit-method}
RandomFields/man/RMmodelExt-class.Rd:\alias{anova,RMmodelFit-method}
RandomFields/man/RMmodelExt-class.Rd:\alias{summary,RMmodelFit-method}
RandomFields/man/RMmodelExt-class.Rd:\alias{print.RMmodelFit}
RandomFields/man/RMmodelExt-class.Rd:\alias{print.RM_modelFit}
RandomFields/man/RMmodelExt-class.Rd:\alias{anova.RM_modelFit}
RandomFields/man/RMmodelExt-class.Rd:\alias{summary.RM_modelFit}
RandomFields/man/RMmodelExt-class.Rd:\description{ Extension of class \code{\link[=RMmodel-class]{RMmodel}}
RandomFields/man/RMmodelExt-class.Rd:%anova.RM_modelFit(object, ...)
RandomFields/man/RMmodelExt-class.Rd:%print.RM_modelFit(x, ...)
RandomFields/man/RMmodelExt-class.Rd:%summary.RM_modelFit(object, ..., isna.param)
RandomFields/man/RMmodelExt-class.Rd:    \item{\code{model,formel}:}{See \code{\link[=RMmodel]{RMmodel}}.}
RandomFields/man/RMmodelExt-class.Rd:%    \item{\code{call}:}{See \code{\link[=RMmodel-class]{RMmodel}}.} 
RandomFields/man/RMmodelExt-class.Rd: %    \item{\code{name}:}{See \code{\link[=RMmodel]{RMmodel}}.}
RandomFields/man/RMmodelExt-class.Rd: %   \item{\code{par.model}:}{See \code{\link[=RMmodel]{RMmodel}}.}
RandomFields/man/RMmodelExt-class.Rd: %   \item{\code{par.general}:}{See \code{\link[=RMmodel]{RMmodel}}.}
RandomFields/man/RMmodelExt-class.Rd:\section{Methods}{
RandomFields/man/RMmodelExt-class.Rd:\author{Alexander Malinowski; \martin}
RandomFields/man/RMmodelExt-class.Rd:  \code{\link[=RMmodel-class]{RMmodel}},
RandomFields/man/RMmultiquad.Rd:\name{RMmultiquad}
RandomFields/man/RMmultiquad.Rd:\alias{RMmultiquad}
RandomFields/man/RMmultiquad.Rd:\title{The Multiquadric Family Covariance Model on the Sphere}
RandomFields/man/RMmultiquad.Rd:  \command{\link{RMmultiquad}} is an isotropic covariance model. The
RandomFields/man/RMmultiquad.Rd:RMmultiquad(delta, tau, var, scale, Aniso, proj)
RandomFields/man/RMmultiquad.Rd:    \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMmultiquad.Rd: For a more general form, see \command{\link{RMchoquet}}.
RandomFields/man/RMmultiquad.Rd: \command{\link{RMmultiquad}} returns an object of class \command{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMmultiquad.Rd: \command{\link{RMmodel}},
RandomFields/man/RMmultiquad.Rd: \command{\link{RMchoquet}},
RandomFields/man/RMmultiquad.Rd:model <- RMmultiquad(delta=0.5, tau=1)
RandomFields/man/RPschlather.Rd: \item{phi}{an \command{\link{RMmodel}}, see Details.}
RandomFields/man/RPschlather.Rd: \item{tcf}{an \command{\link{RMmodel}} specifying the
RandomFields/man/RPschlather.Rd: \command{\link{RMmodel}},
RandomFields/man/RPschlather.Rd:model <- RMgauss()
RandomFields/man/RPschlather.Rd:model <- RPgauss(RMgauss(var=2))
RandomFields/man/RPschlather.Rd:try(RFsimulate(model=RPschlather(RMgauss(var=2)), x=x))
RandomFields/man/RPschlather.Rd:model <- RMgauss()
RandomFields/man/RMrational.Rd:\name{RMrational}
RandomFields/man/RMrational.Rd:\alias{RMrational}
RandomFields/man/RMrational.Rd:RMrational(A, a) 
RandomFields/man/RMrational.Rd: \command{\link{RMrational}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}. 
RandomFields/man/RMrational.Rd: \command{\link{RMmodel}},
RandomFields/man/RMcurlfree.Rd:\name{RMcurlfree}
RandomFields/man/RMcurlfree.Rd:\alias{RMcurlfree}
RandomFields/man/RMcurlfree.Rd:\title{Curlfree Covariance Model}
RandomFields/man/RMcurlfree.Rd: \command{\link{RMcurlfree}}
RandomFields/man/RMcurlfree.Rd:RMcurlfree(phi, which, var, scale, Aniso, proj)
RandomFields/man/RMcurlfree.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMcurlfree.Rd: See also the models \command{\link{RMdivfree}} and \command{\link{RMvector}}.
RandomFields/man/RMcurlfree.Rd: \command{\link{RMcurlfree}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMcurlfree.Rd: \item Scheuerer, M. and Schlather, M. (2012)
RandomFields/man/RMcurlfree.Rd: Covariance Models for Divergence-Free and Curl-Free Random Vector Fields.
RandomFields/man/RMcurlfree.Rd: \emph{Stochastic Models} \bold{28:3}.
RandomFields/man/RMcurlfree.Rd: \command{\link{RMderiv}},
RandomFields/man/RMcurlfree.Rd: \command{\link{RMdivfree}},
RandomFields/man/RMcurlfree.Rd: \command{\link{RMvector}},
RandomFields/man/RMcurlfree.Rd: \command{\link{RMmodel}},
RandomFields/man/RMcurlfree.Rd:model <- RMcurlfree(RMgauss(), scale=4)
RandomFields/man/RMmodelsSpaceTime.Rd:\name{RMmodelsSpacetime}
RandomFields/man/RMmodelsSpaceTime.Rd:\alias{RMmodelsSpacetime}
RandomFields/man/RMmodelsSpaceTime.Rd:\alias{RMmodelsSpaceTime}
RandomFields/man/RMmodelsSpaceTime.Rd:\title{Space-time Covariance Models}
RandomFields/man/RMmodelsSpaceTime.Rd:  \command{\link[=RMplus]{+}},   \command{\link[=RMmult]{*}},
RandomFields/man/RMmodelsSpaceTime.Rd:  and \link[=RMmodels]{proj}, see also the example below
RandomFields/man/RMmodelsSpaceTime.Rd:  \command{\link{RMave}} \tab space-time moving average model
RandomFields/man/RMmodelsSpaceTime.Rd:  \command{\link{RMcoxisham}} \tab Cox-Isham model
RandomFields/man/RMmodelsSpaceTime.Rd:  \command{\link{RMcurlfree}} \tab curlfree (spatial) field (stationary
RandomFields/man/RMmodelsSpaceTime.Rd:  \command{\link{RMdivfree}} \tab divergence free (spatial) vector-valued
RandomFields/man/RMmodelsSpaceTime.Rd:  \command{\link{RMgennsst}} \tab generalization of Gneiting's
RandomFields/man/RMmodelsSpaceTime.Rd:  \command{\link{RMiaco}} \tab non-separable space-time model
RandomFields/man/RMmodelsSpaceTime.Rd:  \command{\link{RMmastein}} \tab Ma-Stein model
RandomFields/man/RMmodelsSpaceTime.Rd:  \command{\link{RMnsst}} \tab Gneiting's non-separable space-time model
RandomFields/man/RMmodelsSpaceTime.Rd:  \command{\link{RMstein}} \tab Stein's non-separable space-time model
RandomFields/man/RMmodelsSpaceTime.Rd:  \command{\link{RMstp}} \tab Single temporal process
RandomFields/man/RMmodelsSpaceTime.Rd:  \command{\link{RMtbm}} \tab Turning bands operator
RandomFields/man/RMmodelsSpaceTime.Rd:   \item Schlather, M. (2011) Construction of covariance functions and
RandomFields/man/RMmodelsSpaceTime.Rd:   unconditional simulation of random fields. In Porcu, E., Montero, J.M.
RandomFields/man/RMmodelsSpaceTime.Rd:   and Schlather, M., \emph{Space-Time Processes and Challenges Related
RandomFields/man/RMmodelsSpaceTime.Rd:  \link{RM},
RandomFields/man/RMmodelsSpaceTime.Rd:  \command{\link{RMmodels}},
RandomFields/man/RMmodelsSpaceTime.Rd:  \command{\link{RMmodelsAdvanced}}.
RandomFields/man/RMmodelsSpaceTime.Rd:\author{Alexander Malinowski; \martin}
RandomFields/man/RMmodelsSpaceTime.Rd:model <- RMexp(proj = "space") * RMgauss(proj = "time")
RandomFields/man/RMmodelsSpaceTime.Rd:model <- RMexp(proj = "space") + RMgauss(proj = "time")
RandomFields/man/RM.Rd:\name{RMmodels Overview}
RandomFields/man/RM.Rd:\alias{RM}
RandomFields/man/RM.Rd:\title{Overview over classes of \code{RMmodels}}
RandomFields/man/RM.Rd:  Various classes of models \code{RMxxx} are implemented in
RandomFields/man/RM.Rd:\section{Man pages}{
RandomFields/man/RM.Rd:  Beginners should start with \link{RMmodels}, then go
RandomFields/man/RM.Rd:  for \link{RMmodelsAdvanced} if more information is needed.
RandomFields/man/RM.Rd:   \link{RMmodels} \tab general introduction and a collection of simple models
RandomFields/man/RM.Rd:   \link{RMmodelsAdvanced} \tab includes more advanced stationary and
RandomFields/man/RM.Rd:    \link{RMmodelsMultivariate} \tab multivariate covariance models and 
RandomFields/man/RM.Rd:    \link{RMmodelsNonstationary} \tab non-stationary covariance models
RandomFields/man/RM.Rd:   \link{RMmodelsSpaceTime} \tab space-time covariance models
RandomFields/man/RM.Rd: \link[=RFcalc]{Mathematical functions} \tab simple mathematical
RandomFields/man/RM.Rd:   \link{RMmodelsAuxiliary} \tab
RandomFields/man/RM.Rd:%   \link{RMmodels} \tab
RandomFields/man/RM.Rd:RFgetModelNames(type="positive definite", domain="single variable",
RandomFields/man/RM.Rd:                isotropy="isotropic", operator=!FALSE) ## RMmodel.Rd
RandomFields/man/RMbubble.Rd:\name{RMbubble}
RandomFields/man/RMbubble.Rd:\alias{RMbubble}
RandomFields/man/RMbubble.Rd:RMbubble(phi, scaling, z, weight, minscale, barycentre,
RandomFields/man/RMbubble.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMbubble.Rd: \command{\link{RMbubble}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMbubble.Rd:    \item Bonat, W.H. , Ribeiro, P. Jr. and Schlather, M. (2019)
RandomFields/man/RMbubble.Rd:    Modelling non-stationarity in scale. In preparation.
RandomFields/man/RMbubble.Rd:  \command{\link{RMSadvanced}},
RandomFields/man/RMbubble.Rd:  \command{\link{RMblend}},
RandomFields/man/RMbubble.Rd:  \command{\link{RMscale}}
RandomFields/man/RMbubble.Rd:scale <- RMcovariate(data=as.double(d) * 2 + 0.5, raw=TRUE)
RandomFields/man/RMbubble.Rd:model1 <- RMbubble(RMexp(), scaling=scale)
RandomFields/man/RMbubble.Rd:model2 <- RMbubble(RMexp(), scaling=scale, z=c(0.5, 0.5))
RandomFields/man/RMbubble.Rd:model3 <- RMbubble(RMexp(), scaling=scale, barycentre=TRUE) # approx. of model2
RandomFields/man/RMbubble.Rd:## the models RMblend, RMscale and RMS (so, model2 above
RandomFields/man/RMbubble.Rd:biwm <- RMbiwm(nudiag=c(0.5, 0.5), nured=1, rhored=1, cdiag=c(1, 1), 
RandomFields/man/RMbubble.Rd:blend <- RMblend(multi=biwm, blend=RMcovariate(data = as.double(d), raw=TRUE))
RandomFields/man/RMbubble.Rd:Mscale <- RMscale(RMexp(), scaling = scale, penalty=RMidcoord() / 2)
RandomFields/man/RMbubble.Rd:plot(zscale <- RFsimulate(Mscale, x, x))
RandomFields/man/RMbubble.Rd:Cscale <- RFcovmatrix(Mscale, x, x)
RandomFields/man/RMbubble.Rd:Mscale2 <- RMscale(RMexp(), scaling = scale, penalty=RMidcoord() / 20000)
RandomFields/man/RMbubble.Rd:plot(zscale2 <- RFsimulate(Mscale2, x, x))
RandomFields/man/RMbubble.Rd:Cscale2 <- RFcovmatrix(Mscale2, x, x)
RandomFields/man/RMbubble.Rd:S <- RMexp(scale = scale)
RandomFields/man/RMbubble.Rd:dev.new(); hist(C1-Cscale2) ## both are equally good. Maybe C1 slightly better
RandomFields/man/RMshape.Rd:\name{RMshape}
RandomFields/man/RMshape.Rd:\alias{RMshape}
RandomFields/man/RMshape.Rd:\title{Shape Model}
RandomFields/man/RMshape.Rd: \command{\link{RMshape}} is a pure shape model with covariance 0.
RandomFields/man/RMshape.Rd:RMshape(mean) %, plane, polydeg, polycoeff, arbitraryfct, fctcoeff)
RandomFields/man/RMshape.Rd:  \item{mean}{numeric or \link{RMmodel}.
RandomFields/man/RMshape.Rd: Any function that is defined inside \command{RMshape} is considered as
RandomFields/man/RMshape.Rd: \command{\link{RMshape}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMshape.Rd: Modelling Spatial Uncertainty.} New York: John Wiley & Sons.
RandomFields/man/RMshape.Rd: \command{\link{RMmodel}},
RandomFields/man/RMshape.Rd: \command{\link{RMplus}}
RandomFields/man/RMshape.Rd:model1 <- RMexp(var=2, scale=1) + trend
RandomFields/man/RMshape.Rd:model2 <- RMexp(var=NA, scale=NA) + NA * sin(R.p(new="isotropic")) + NA
RandomFields/man/RMshape.Rd:\dontshow{if(RFoptions()$internal$examples_reduced){warning("reduced 'repet'"); model2 <- RMexp(var=NA) + NA * sin(R.p(new="isotropic")) + NA}}
RandomFields/man/RMshape.Rd:## 'RMshape'
RandomFields/man/RMshape.Rd:model3 <- RMexp(var=NA, scale=NA) + NA *
RandomFields/man/RMshape.Rd:          RMshape(sin(R.p(new="isotropic"))) + RMshape(NA)
RandomFields/man/RMshape.Rd:## IMPORTANT:  subtraction is not a way to combine definite models
RandomFields/man/RMshape.Rd:(model0 <- RMexp(var=0.4) + trend) ## exponential covariance with mean -1
RandomFields/man/RMshape.Rd:(model1 <- RMexp(var=0.4) + -1)    ## same as model0
RandomFields/man/RMshape.Rd:(model2 <- RMexp(var=0.4) + RMshape(-1)) ## same as model0
RandomFields/man/RMshape.Rd:(model3 <- RMexp(var=0.4) - 1) ## this is a purely deterministic model
RandomFields/man/RMshape.Rd:model <- ~ RMshape(mean=1, plane = c(1,-1)) + RMexp(var=0.04)
RandomFields/man/RMshape.Rd:model <- ~ RMshape(polydeg=1,polycoeff=c(1,1,-1)) + RMexp(var=0.4)
RandomFields/man/RMshape.Rd:# the covariance function is the sum of a bivariate Whittle-Matern model
RandomFields/man/RMshape.Rd:model <- RMshape(plane=matrix(c(1,2,3,4), ncol=2)) + 
RandomFields/man/RMshape.Rd:         RMparswm(nu=c(1,1)) + RMnugget(var=0.5)
RandomFields/man/RMshape.Rd:model.na <- RMshape(plane=matrix(c(1, 2, NA, NA), ncol=2)) + 
RandomFields/man/RMshape.Rd:            RMparswm(nu=c(1,1), var=NA) + RMnugget(var=NA)
RandomFields/man/RMshape.Rd:model <- ~ RMshape(arbitraryfct=function(x) sin(x),
RandomFields/man/RMshape.Rd: RMshape(arbitraryfct=function(y) cos(y),
RandomFields/man/RMshape.Rd: RMspheric(scale=3)
RandomFields/man/RMshape.Rd:model.est <- ~ RMshape(arbitraryfct=function(x) sin(x), fctcoeff=1) +
RandomFields/man/RMshape.Rd: RMshape(arbitraryfct=function(y) cos(y), fctcoeff=1) +
RandomFields/man/RMshape.Rd: RMspheric(scale=NA)
RandomFields/man/RMshape.Rd:model.est <- ~ RMshape(arbitraryfct=function(x) sin(x)) +
RandomFields/man/RMshape.Rd: RMshape(arbitraryfct=function(y) cos(y)) +
RandomFields/man/RMshape.Rd: RMspheric(scale=NA)
RandomFields/man/RMshape.Rd:model <- ~ RMshape(arbitraryfct=function(x) 2*x^2 - 3*y^2,
RandomFields/man/RMshape.Rd: fctcoeff=1) + RMwhittle(nu=1, scale=0.5)
RandomFields/man/RMshape.Rd:model <- ~ RMshape(polydeg=2, polycoeff=c(0,0,2,0,0,-3))
RandomFields/man/RMshape.Rd:model.est <- ~ RMshape(polydeg=2) + RMwhittle(nu=NA, scale=0.5)
RandomFields/man/RMstein.Rd:\name{RMstein}
RandomFields/man/RMstein.Rd:\alias{RMstein}
RandomFields/man/RMstein.Rd: \command{\link{RMstein}} is a univariate stationary covariance model
RandomFields/man/RMstein.Rd: \command{\link{RMwhittle}} model with
RandomFields/man/RMstein.Rd:RMstein(nu, zeta, var, scale, Aniso, proj)
RandomFields/man/RMstein.Rd: RMwhittle model}
RandomFields/man/RMstein.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMstein.Rd: \command{\link{RMstein}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMstein.Rd: \item Stein, M.L. (2005) Space-time covariance functions.
RandomFields/man/RMstein.Rd: \command{\link{RMmodel}},
RandomFields/man/RMstein.Rd:model <- RMstein(nu=1.5, zeta=0.9)
RandomFields/man/RRmcmc.Rd:\title{Random Sample From The Modulus Of A Function}
RandomFields/man/RRmcmc.Rd:    positive integer. Every \code{mcmc_n}th element of the MCMC chain
RandomFields/man/RRmcmc.Rd:    The MCMC update is done by adding a normal variable with
RandomFields/man/RRmcmc.Rd: \command{\link{RRmcmc}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RRmcmc.Rd:  \command{\link{RMmodel}},
RandomFields/man/RRmcmc.Rd:   \command{\link{RMuser}}.
RandomFields/man/RRmcmc.Rd:z <- RFrdistr(RRmcmc(RMexp(), sigma=1), n=10000)
RandomFields/man/papers.GSPSJ06.Rd: Gneiting, T., Sevcikova, H., Percival, D.B., Schlather, M., Jiang,
RandomFields/man/papers.GSPSJ06.Rd: % Schlather, M. (2001) Simulation of stationary and isotropic random
RandomFields/man/papers.GSPSJ06.Rd:  model <- RMcutoff(diameter=theta, a=1, RMstable(alpha=alpha))
RandomFields/man/papers.GSPSJ06.Rd:  r <- RFgetModelInfo(modelname="RMcutoff", level=3)$storage$R_theor
RandomFields/man/RMqexp.Rd:\name{RMqexp}
RandomFields/man/RMqexp.Rd:\alias{RMqexp}
RandomFields/man/RMqexp.Rd:RMqexp(alpha, var, scale, Aniso, proj)
RandomFields/man/RMqexp.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMqexp.Rd: \command{\link{RMqexp}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMqexp.Rd: \command{\link{RMmodel}}.
RandomFields/man/RMqexp.Rd:model <- RMqexp(alpha=0.95, scale=0.2)
RandomFields/man/RMball.Rd:\name{RMball}
RandomFields/man/RMball.Rd:\alias{RMball}
RandomFields/man/RMball.Rd:\title{RMball}
RandomFields/man/RMball.Rd:  \command{RMball} refers to the indicator function of a ball
RandomFields/man/RMball.Rd:RMball(var, scale, Aniso, proj)
RandomFields/man/RMball.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMball.Rd:  \command{\link{RMpolygon}},
RandomFields/man/RMball.Rd:  \command{\link{RMspheric}},
RandomFields/man/RMball.Rd: \command{\link{RMmodel}}.
RandomFields/man/RMball.Rd:model <- RMball(var=2,scale=1.5)
RandomFields/man/RMball.Rd:model <- RPcoins(shape=RMball())
RandomFields/man/RRdeterm.Rd: \command{\link{RRdeterm}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RRdeterm.Rd: \command{\link{RMmodel}},
RandomFields/man/RMsum.Rd:\name{RMsum}
RandomFields/man/RMsum.Rd:\alias{RMsum}
RandomFields/man/RMsum.Rd: \command{\link{RMsum}} is given by
RandomFields/man/RMsum.Rd:RMsum(phi, var, scale, Aniso, proj)
RandomFields/man/RMsum.Rd:  \item{phi}{any function of class \code{\link[=RMmodel-class]{RMmodel}}
RandomFields/man/RMsum.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMsum.Rd: \command{\link{RMsum}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMsum.Rd:  Do not mix up this model with  \command{\link{RMplus}}.
RandomFields/man/RMsum.Rd: \command{\link{RMmodel}},
RandomFields/man/RMsum.Rd: \command{\link{RMplus}},
RandomFields/man/RMsum.Rd: \command{\link{RMprod}}.
RandomFields/man/RMsum.Rd:RFfctn(RMsum(RMexp()), 1:10, grid=FALSE)
RandomFields/man/RMsum.Rd:RFfctn(RMsum(RMexp()), 1:10, 1:10, grid=FALSE)
RandomFields/man/RMsum.Rd:RFfctn(RMsum(RMexp()), as.matrix(1:10), as.matrix(1:10), grid=FALSE)
RandomFields/man/RMschur.Rd:\name{RMschur}
RandomFields/man/RMschur.Rd:\alias{RMschur}
RandomFields/man/RMschur.Rd: \deqn{C(x)= M * \phi(x)}
RandomFields/man/RMschur.Rd:RMschur(phi, M,  diag, rhored, var, scale, Aniso, proj)
RandomFields/man/RMschur.Rd: \item{phi}{covariance function of class \code{\link[=RMmodel-class]{RMmodel}}}
RandomFields/man/RMschur.Rd: \item{M}{constant \eqn{n \times n}{n x n} covariance matrix of the
RandomFields/man/RMschur.Rd: \item{diag,rhored}{alternative way of passing \code{M}:
RandomFields/man/RMschur.Rd:   containing the correlations of the lower triangle of the \code{M}.
RandomFields/man/RMschur.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMschur.Rd: \command{\link{RMschur}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMschur.Rd: \command{\link{RMmodel}},
RandomFields/man/RMschur.Rd: \command{\link{RMmatrix}}.
RandomFields/man/RMschur.Rd:model <- RMschur(M=matrix(c(2, 1, 1, 1), ncol=2), RMparswm(nudiag=c(0.5, 2)))
RandomFields/man/papers.S02.Rd:\title{Models for stationary max-stable random fields }
RandomFields/man/papers.S02.Rd: Here, the code of the paper on \sQuote{Models for stationary max-stable
RandomFields/man/papers.S02.Rd:    Schlather, M. (2002) Models for stationary max-stable
RandomFields/man/papers.S02.Rd:\dontrun{\dontshow{plot(RFsimulate(RPsmith(RMgauss(s=1.5)), x, x))   # < 1 sec
RandomFields/man/papers.S02.Rd:plot(RFsimulate(RPsmith(RMball(s=RRspheric(2, 3,
RandomFields/man/papers.S02.Rd:plot(RFsimulate(RPschlather(RMexp()), x, x))      #   1 sec
RandomFields/man/papers.S02.Rd:plot(RFsimulate(RPschlather(RMgauss()), x, x))    #  17 sec
RandomFields/man/Changings.Rd:       \item Some new \link{Multivariate RMmodels}
RandomFields/man/Changings.Rd:       value. Also dummy variables can be \command{\link{RMdeclare}}d.
RandomFields/man/Changings.Rd:  \link{MajorRevisions},
RandomFields/man/PrintModelList.Rd:\name{PrintModelList} 
RandomFields/man/PrintModelList.Rd:\alias{PrintModelList}
RandomFields/man/PrintModelList.Rd:\alias{GetModelList}
RandomFields/man/PrintModelList.Rd:\alias{GetModelNames}
RandomFields/man/PrintModelList.Rd:  \code{PrintModelList} prints the list of currently implemented models
RandomFields/man/PrintModelList.Rd:PrintModelList(operators=FALSE, internal=FALSE, newstyle=TRUE)
RandomFields/man/PrintModelList.Rd:  \item{internal}{logical. Flag whether internal models should also be considered. In case of \command{PrintModelList} and
RandomFields/man/PrintModelList.Rd:    definition of models, see \link{RMmodelsAdvanced}.
RandomFields/man/PrintModelList.Rd:  \code{PrintModelList} prints a table of the currently implemented covariance
RandomFields/man/PrintModelList.Rd:  \code{PrintModelList} returns \code{NULL}.
RandomFields/man/PrintModelList.Rd: See \link{RMmodel} for a description of the models and their use.
RandomFields/man/PrintModelList.Rd:  From version 3.0 on, the command \code{PrintModelList()}
RandomFields/man/PrintModelList.Rd:  \code{\link{RFgetModelNames}(internal=FALSE)}.
RandomFields/man/PrintModelList.Rd:  \command{\link{RFgetModelNames}}
RandomFields/man/PrintModelList.Rd:PrintModelList()
RandomFields/man/RFoptionsAdvanced.Rd:%% NOTE: THE BELOW EXAMPLE NEEDS seed = NA
RandomFields/man/RFoptionsAdvanced.Rd: ##                      EXAMPLE 1                          ##
RandomFields/man/RFoptionsAdvanced.Rd:model <- RMexp(var=1.1, Aniso=matrix(nc=2, c(2,0.1,1.5,1)))
RandomFields/man/RFoptionsAdvanced.Rd: ##                      EXAMPLE 2                          ##
RandomFields/man/RFoptionsAdvanced.Rd: ## configurations, i.e. grid, non-grid) using TBM          ##
RandomFields/man/RFoptionsAdvanced.Rd:model <- RPtbm(RMexp(scale=10))
RandomFields/man/RFoptionsAdvanced.Rd:tbm.points <- RFgetModelInfo(level=3)$loc$totpts
RandomFields/man/RMmatrix.Rd:\name{RMmatrix}
RandomFields/man/RMmatrix.Rd:\alias{RMmatrix}
RandomFields/man/RMmatrix.Rd:%\alias{diag,RMmodel,missing,missing,missing-method}
RandomFields/man/RMmatrix.Rd:\title{Matrix operator}
RandomFields/man/RMmatrix.Rd: \command{\link{RMmatrix}} is primarily a multivariate covariance model
RandomFields/man/RMmatrix.Rd: \deqn{ C(h) = M C_0(h) M^t}{ C(h) = M C_0(h) M^t}
RandomFields/man/RMmatrix.Rd:RMmatrix(C0, C1,  C2, C3, C4, C5, C6, C7, C8, C9, M, vdim,
RandomFields/man/RMmatrix.Rd:%\S4method{diag}{RMmodel,missing,missing,missing}(x,nrow,ncol,names)
RandomFields/man/RMmatrix.Rd:  \item{C0}{a k-variate covariance \command{\link{RMmodel}}
RandomFields/man/RMmatrix.Rd:  \item{M}{a k times k matrix, which is multiplied from left and right to
RandomFields/man/RMmatrix.Rd:    the given model; \eqn{M} may depend on the location, hence it is then a
RandomFields/man/RMmatrix.Rd:    \deqn{C(x, y) = M(x) \phi(x, y) M(y)^t}{ C(x, y) = M(x) phi(x, y) M(y)^t}}
RandomFields/man/RMmatrix.Rd:    \code{M} is not given. (In fact, if \code{M} is given, \code{vdim} must
RandomFields/man/RMmatrix.Rd:    equal the number of columns of \code{M})}
RandomFields/man/RMmatrix.Rd:    \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMmatrix.Rd:  % \item{x}{an \link{R.c} list of \link{RMmodel}s}
RandomFields/man/RMmatrix.Rd:    \item{Model used as definite function (covariance model)}{
RandomFields/man/RMmatrix.Rd:	\item{\code{M} given}{Then, exactly one covariance model must be
RandomFields/man/RMmatrix.Rd:	    \item{\code{C0} is multivarate}{If \code{M} is \eqn{k \times
RandomFields/man/RMmatrix.Rd:	\item{\code{M} not given}{a diagonal matrix is returned, with univariate
RandomFields/man/RMmatrix.Rd:    \item{Model used as shape function}{
RandomFields/man/RMmatrix.Rd:	\item{\code{M} given}{Then, exactly one shape function must be
RandomFields/man/RMmatrix.Rd:	  is the matrix multiplication \eqn{M C0}.
RandomFields/man/RMmatrix.Rd:	\item{\code{M} not given}{a vector is returned consisting of the
RandomFields/man/RMmatrix.Rd:      Furthermore, the matrices \eqn{M} might be functions of the
RandomFields/man/RMmatrix.Rd:      \deqn{ C(x, y) = M(x) C_0(x, y) M(y)^t}{ C(x, y) = M(x) C_0(x, y) M(y)^t}
RandomFields/man/RMmatrix.Rd:%    is identical to \code{RMmatrix(C0, C1, C2, C3, C4, C5, C6, C7, C8,
RandomFields/man/RMmatrix.Rd:    \item\command{RMmatrix} also allows variogram models and
RandomFields/man/RMmatrix.Rd:\value{\command{\link{RMmatrix}} returns an object of class
RandomFields/man/RMmatrix.Rd:  \code{\link[=RMmodel-class]{RMmodel}}.}
RandomFields/man/RMmatrix.Rd: \command{RMconstant} to define \eqn{M^\top M}
RandomFields/man/RMmatrix.Rd: \command{\link{RMmodel}},
RandomFields/man/RMmatrix.Rd:## first example: bivariate Linear Model of Coregionalisation
RandomFields/man/RMmatrix.Rd:model1 <- RMmatrix(M = c(0.9, 0.43), RMwhittle(nu = 0.3)) + 
RandomFields/man/RMmatrix.Rd:  RMmatrix(M = c(0.6, 0.8), RMwhittle(nu = 2))
RandomFields/man/RMmatrix.Rd:model2 <- RMmatrix(M = matrix(ncol=2, c(0.9, 0.43, 0.6, 0.8)),
RandomFields/man/RMmatrix.Rd:                  c(RMwhittle(nu = 0.3), RMwhittle(nu = 2)))
RandomFields/man/RMmatrix.Rd:model3 <- RMmatrix(M = matrix(ncol=2, c(0.9, 0.43, 0.6, 0.8)),
RandomFields/man/RMmatrix.Rd:                   RMwhittle(nu = 0.3), RMwhittle(nu = 2))
RandomFields/man/RMmatrix.Rd:x <- seq(0, 10, 0.1) % to do: naechste Zeile RMmatrix durch diag ersetzen
RandomFields/man/RMmatrix.Rd:modelB <- RMmatrix(c(RMfbm(alpha=0.5), RMfbm(alpha=1.5))) ## see the Note above
RandomFields/man/RMmatrix.Rd:modelC <- RMmatrix(RMexp(), M=c(RMfbm(alpha=0.5), RMfbm(alpha=1.5))) 
RandomFields/man/RPopitz.Rd:  \item{phi}{an \command{\link{RMmodel}};
RandomFields/man/RPopitz.Rd:    Davison, A.C., Padoan, S., Ribatet, M. (2012).
RandomFields/man/RPopitz.Rd: \command{\link{RMmodel}},
RandomFields/man/RPopitz.Rd:model <- RPopitz(RMgauss(), alpha=2)
RandomFields/man/RRspherical.Rd: \command{\link{RRspheric}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RRspherical.Rd:  \command{\link{RMmodel}},
RandomFields/man/RRspherical.Rd:  \command{\link{RMball}}.
RandomFields/man/RFoptionsFit.Rd:    bounds, the ML target function is evaluated on a grid
RandomFields/man/RFoptionsFit.Rd:    to get a new initial value for the ML estimation. 
RandomFields/man/RFoptionsFit.Rd: \item{\code{emp_alpha}}{integer within \code{RC_VARIOGRAM},
RandomFields/man/RFoptionsFit.Rd:   \code{RC_PSEUDO},  \code{RC_PSEUDOMADOGRAM},
RandomFields/man/RFoptionsFit.Rd:   \code{RC_MADOGRAM},
RandomFields/man/RFoptionsFit.Rd:    Default: \code{RC_VARIOGRAM}
RandomFields/man/RFoptionsFit.Rd:    Maximum number of locations (with depending values)
RandomFields/man/RFoptionsFit.Rd:    returned from the ML estimation
RandomFields/man/RFoptionsFit.Rd:    the MLE algorithm has dropped into a local minimum,
RandomFields/man/RFoptionsFit.Rd:    ML target function on a grid, cf. the beginning paragraphs
RandomFields/man/RFoptionsFit.Rd:    Minimal value of any estimated diagonal matrix element.    
RandomFields/man/RFoptionsFit.Rd:      for the MLE and returned.
RandomFields/man/RFoptionsFit.Rd:    value for the ML estimation 
RandomFields/man/RFoptionsFit.Rd:    \command{\link{RMmodel}}. (In contrast to \code{practicalrange}
RandomFields/man/RMkolmogorov.Rd:\name{RMkolmogorov}
RandomFields/man/RMkolmogorov.Rd:\alias{RMkolmogorov}
RandomFields/man/RMkolmogorov.Rd:\title{Identical Model}
RandomFields/man/RMkolmogorov.Rd: \command{RMkolmogorov} corresponds to a vector-valued random field with
RandomFields/man/RMkolmogorov.Rd: RMkolmogorov(var, scale, Aniso, proj)
RandomFields/man/RMkolmogorov.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMkolmogorov.Rd: \command{\link{RMkolmogorov}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMkolmogorov.Rd: \command{\link{RMmodel}}, \command{\link{RMcurlfree}},
RandomFields/man/RMkolmogorov.Rd: \command{\link{RMdivfree}},
RandomFields/man/RMkolmogorov.Rd: \command{\link{RMvector}}.
RandomFields/man/RMkolmogorov.Rd:model <- RMkolmogorov()
RandomFields/man/RMkolmogorov.Rd:plot(model, dim=3, MARGIN=1:2, fixed.MARGIN=1)
RandomFields/man/RMstrokorb.Rd:\alias{RMstrokorb}
RandomFields/man/RMstrokorb.Rd:\alias{RMm2r}
RandomFields/man/RMstrokorb.Rd:\alias{RMm3b}
RandomFields/man/RMstrokorb.Rd:\alias{RMmps}
RandomFields/man/RMstrokorb.Rd:RMm2r(phi)
RandomFields/man/RMstrokorb.Rd:RMm3b(phi)
RandomFields/man/RMstrokorb.Rd:RMmps(phi)
RandomFields/man/RMstrokorb.Rd:  \command{RMm2r} used with \command{\link{RPsmith}} defines
RandomFields/man/RMstrokorb.Rd:  \command{RMm3b} used with \command{\link{RPsmith}} defines
RandomFields/man/RMstrokorb.Rd:  \command{RMmps} used with \command{\link{RPsmith}} defines
RandomFields/man/RMstrokorb.Rd:   \code{\link{RMbrownresnick}(\link{RMfbm}(alpha=1))} and dimension 2.
RandomFields/man/RMstrokorb.Rd: object of class \code{\link[=RMmodel-class]{RMmodel}}
RandomFields/man/RMstrokorb.Rd:   Strokorb, K., Ballani, F. and Schlather, M. (2014)
RandomFields/man/RMstrokorb.Rd: \command{\link{RMmodel}}.
RandomFields/man/RMstrokorb.Rd:model <- RMbrownresnick(RMfbm(alpha=1.5, s=0.2))
RandomFields/man/RMstrokorb.Rd:plot(RMm2r(model))
RandomFields/man/RMstrokorb.Rd:z <- RFsimulate(RPsmith(RMm2r(model), xi=0), x)
RandomFields/man/RPmaxstable.Rd:\name{Max-stable random fields}
RandomFields/man/RPmaxstable.Rd:\alias{Maxstable}
RandomFields/man/RPmaxstable.Rd:\title{Simulation of Max-Stable Random Fields}
RandomFields/man/RPmaxstable.Rd:  Models
RandomFields/man/RPmaxstable.Rd: \command{\link{RPsmith}} \tab M3 processes \cr
RandomFields/man/RPmaxstable.Rd:Methods
RandomFields/man/RPmaxstable.Rd: using M3 representation\cr
RandomFields/man/RPmaxstable.Rd:  \item Kabluchko, Z., Schlather, M. & de Haan, L (2009)
RandomFields/man/RPmaxstable.Rd:  \item Schlather, M. (2002) Models for stationary max-stable
RandomFields/man/RPmaxstable.Rd:  \item Smith, R.L. (1990) Max-stable processes and spatial extremes
RandomFields/man/RPmaxstable.Rd:  Unpublished Manuscript.
RandomFields/man/RPmaxstable.Rd:model <- RMfbm(alpha=1.5)
RandomFields/man/RPmaxstable.Rd:model <- RMball()
RandomFields/man/RPmaxstable.Rd:model <- RMgauss()
RandomFields/man/RPmaxstable.Rd: \command{\link{RMmodel}},
RandomFields/man/RMgenfbm.Rd:\name{RMgenfbm}
RandomFields/man/RMgenfbm.Rd:\alias{RMgenfbm}
RandomFields/man/RMgenfbm.Rd:\title{Generalized Fractal Brownian Motion Variogram Model}
RandomFields/man/RMgenfbm.Rd:  \command{\link{RMgenfbm}} is an intrinsically stationary isotropic
RandomFields/man/RMgenfbm.Rd: See also \command{\link{RMfbm}}.
RandomFields/man/RMgenfbm.Rd:RMgenfbm(alpha, beta, var, scale, Aniso, proj)
RandomFields/man/RMgenfbm.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMgenfbm.Rd: Here, the variogram of \command{\link{RMfbm}} is modified by
RandomFields/man/RMgenfbm.Rd: further generalization, cf. \command{\link{RMbcw}}.
RandomFields/man/RMgenfbm.Rd: \command{\link{RMgenfbm}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMgenfbm.Rd: Schlather, M. (2010)
RandomFields/man/RMgenfbm.Rd: % \item Martin's Toledo-Chapter: Construction of covariance functions
RandomFields/man/RMgenfbm.Rd:  \command{\link{RMbcw}},
RandomFields/man/RMgenfbm.Rd: \command{\link{RMfbm}},
RandomFields/man/RMgenfbm.Rd: \command{\link{RMmodel}},
RandomFields/man/RMgenfbm.Rd: \command{\link{RMflatpower}},
RandomFields/man/RMgenfbm.Rd:model <- RMgenfbm(alpha=1, beta=0.5)
RandomFields/man/RFspatialGridDataFrame-class.Rd:\section{Methods}{
RandomFields/man/RFspatialGridDataFrame-class.Rd: \code{MARGIN}; to get different slices in a third direction, the
RandomFields/man/RFspatialGridDataFrame-class.Rd: argument \code{MARGIN.slices} can be used;
RandomFields/man/RFspatialGridDataFrame-class.Rd: Methods \command{summary},
RandomFields/man/RFspatialGridDataFrame-class.Rd:\author{Alexander Malinowski, \martin}
RandomFields/man/RFspatialGridDataFrame-class.Rd:f <- RFsimulate(model=RMexp(), x=x, n=n)
RandomFields/man/RFspatialGridDataFrame-class.Rd:f2 <- RFsimulate(model=RMwhittle(nu=1.2, scale=scale), x=x2, n=n,
RandomFields/man/RFspatialGridDataFrame-class.Rd:plot(f2, MARGIN=c(3,4), MARGIN.slices=1, n.slices=6, nmax=2)
RandomFields/man/RFspatialGridDataFrame-class.Rd:f.sp <- RFsimulate(model=RMexp(), x=x, n=n)
RandomFields/man/RFspatialGridDataFrame-class.Rd:f.old <- RFsimulate(model=RMexp(), x=x, n=n, spConform=FALSE)
RandomFields/man/RFspatialPointsDataFrame-class.Rd:\section{Methods}{
RandomFields/man/RFspatialPointsDataFrame-class.Rd: \code{MARGIN}; to get different slices in a third direction, the
RandomFields/man/RFspatialPointsDataFrame-class.Rd: argument \code{MARGIN.slices} can be used;
RandomFields/man/RFspatialPointsDataFrame-class.Rd: Methods \command{summary} and \command{dimensions}
RandomFields/man/RFspatialPointsDataFrame-class.Rd:\author{Alexander Malinowski, \martin}
RandomFields/man/RFspatialPointsDataFrame-class.Rd:f <- RFsimulate(model=RMexp(), x=x, n=3)
RandomFields/man/RFspatialPointsDataFrame-class.Rd:f2 <- RFsimulate(model=RMwhittle(nu=1.2, scale=10), x=cbind(x,x), n=4)
RandomFields/man/RFspatialPointsDataFrame-class.Rd:plot(f2, MARGIN=c(3,4), nmax=2)
RandomFields/man/RFspatialPointsDataFrame-class.Rd:f.sp <- RFsimulate(model=RMexp(), x=x, n=3)
RandomFields/man/RFspatialPointsDataFrame-class.Rd:f.old <- RFsimulate(model=RMexp(), x=x, n=3, spConform=FALSE)
RandomFields/man/RPchi2.Rd: \item{phi}{the \command{\link{RMmodel}}. If a model for the
RandomFields/man/RPchi2.Rd: The function returns an object of class \code{\link[=RMmodel]{RMmodel}}.
RandomFields/man/RPchi2.Rd:  \command{\link{Auxiliary RMmodels}},
RandomFields/man/RPchi2.Rd:model <- RPchi2(RMexp(), f=2)
RandomFields/man/RPsequential.Rd:\title{Methods relying on square roots of the covariance matrix}
RandomFields/man/RPsequential.Rd:  \item{phi}{object of class \code{\link[=RMmodel-class]{RMmodel}};
RandomFields/man/RPsequential.Rd: \command{\link{RPsequential}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RPsequential.Rd: Schlather, M. (1999) \emph{An introduction to positive definite
RandomFields/man/RPsequential.Rd: Technical report ST 99-10, Dept. of Maths and Statistics,
RandomFields/man/RPsequential.Rd:model <- RMgauss(var=10, s=10) + RMnugget(var=0.01)
RandomFields/man/RMtruncsupport.Rd:\name{RMtruncsupport}
RandomFields/man/RMtruncsupport.Rd:\alias{RMtruncsupport}
RandomFields/man/RMtruncsupport.Rd:  \command{\link{RMtruncsupport}} may be used to truncate the support of a shape function when
RandomFields/man/RMtruncsupport.Rd: Poisson fields or M3 processes are created.
RandomFields/man/RMtruncsupport.Rd:RMtruncsupport(phi, radius)
RandomFields/man/RMtruncsupport.Rd: \item{phi}{function of class \code{\link[=RMmodel-class]{RMmodel}}}
RandomFields/man/RMtruncsupport.Rd: \command{\link{RMtruncsupport}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMtruncsupport.Rd: \command{\link{RMmodel}},
RandomFields/man/RMtruncsupport.Rd: \command{\link{RMmatrix}},
RandomFields/man/RMtruncsupport.Rd:    \item Schlather, M. (2002) Models for stationary max-stable
RandomFields/man/RMtruncsupport.Rd:model <- RMgauss()
RandomFields/man/RMtruncsupport.Rd:model1 <- RMtruncsupport(model, radius=1)
RandomFields/man/RMtruncsupport.Rd:## For a real application of 'RMtruncsupport' see example 2 of 'RPpoisson'.
RandomFields/man/RMtruncsupport.Rd:model <- RPcoins(shape = RMtruncsupport(RMgauss(), radius=1.5), intensity=1)
RandomFields/man/RMfix.Rd:\name{RMfixcov}
RandomFields/man/RMfix.Rd:\alias{RMfixcov}
RandomFields/man/RMfix.Rd:\title{Fixed Covariance Matrix}
RandomFields/man/RMfix.Rd:  \command{\link{RMfixcov}} is a user-defined (spatially constant or
RandomFields/man/RMfix.Rd:RMfixcov(M, x, y=NULL, z=NULL, T=NULL, grid, var, proj, raw, givenM)%, norm)
RandomFields/man/RMfix.Rd: \item{M}{a numerical matrix defining the user-defined  covariance for a
RandomFields/man/RMfix.Rd:   \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMfix.Rd: \item{givenM}{numerical matrix.
RandomFields/man/RMfix.Rd:   corrleations defined by \command{RMfixcov} are zero between the given
RandomFields/man/RMfix.Rd: \command{\link{RMfixcov}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMfix.Rd: \item Ober, U., Ayroles, J.F., Stone, E.A., Richards, S., Zhu, D., Gibbs, R.A., Stricker, C., Gianola, D., Schlather, M., Mackay, T.F.C., Simianer, H. (2012): \emph{Using Whole Genome Sequence Data to Predict Quantitative Trait Phenotypes in Drosophila melanogaster}. PLoS Genet 8(5): e1002685.
RandomFields/man/RMfix.Rd: \command{\link{RMcovariate}},
RandomFields/man/RMfix.Rd: \command{\link{RMmodel}},
RandomFields/man/RMfix.Rd: \command{\link{RMuser}}.
RandomFields/man/RMfix.Rd:RFcovmatrix(RMfixcov(C), 1:n)
RandomFields/man/RMfix.Rd:RFcovmatrix(RMfixcov(C, 1:n), c(2, 2.1, 2.5, 3))
RandomFields/man/RMfix.Rd:model <- RMfixcov(C, 1:n, proj="space") * RMexp(s=40, proj="time")
RandomFields/man/RPcirculant.Rd: for further covariance models, e.g. the \command{\link{RMwhittle}} model.
RandomFields/man/RPcirculant.Rd: hypermodel, see \command{\link{RMcutoff}}.
RandomFields/man/RPcirculant.Rd: For details see \command{\link{RMcutoff}}.
RandomFields/man/RPcirculant.Rd: for further \emph{variogram} models, e.g. \command{\link{RMfbm}}.
RandomFields/man/RPcirculant.Rd: hypermodel, see \command{\link{RMintrinsic}}.
RandomFields/man/RPcirculant.Rd: For details see \command{\link{RMintrinsic}}.
RandomFields/man/RPcirculant.Rd: \item{maxGB}{Maximal memory used for the circulant matrix in units of
RandomFields/man/RPcirculant.Rd:   If this argument is set then \code{maxmem} is set to MAXINT.
RandomFields/man/RPcirculant.Rd:   methods (TBM) might be faster and might be preferred by the user.
RandomFields/man/RPcirculant.Rd:   Default: \code{MAXINT}.
RandomFields/man/RPcirculant.Rd: \item{diameter}{See \command{\link{RMcutoff}} or \command{\link{RMintrinsic}}.}
RandomFields/man/RPcirculant.Rd: \item{a}{See \command{\link{RMcutoff}}.}
RandomFields/man/RPcirculant.Rd: \item{rawR}{See \command{\link{RMintrinsic}}.}
RandomFields/man/RPcirculant.Rd: An object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RPcirculant.Rd: Circulant Embedding of the Covariance Matrix.
RandomFields/man/RPcirculant.Rd: \emph{SIAM J. Sci. Comput.} \bold{18}, 1088--1107.
RandomFields/man/RPcirculant.Rd: \item Gneiting, T., Sevecikova, H, Percival, D.B., Schlather M.,
RandomFields/man/RPcirculant.Rd: \item Stein, M.L. (2002) Fast and exact simulation of fractional
RandomFields/man/RPcirculant.Rd:model <- RMstable(s=1, alpha=1.8)
RandomFields/man/RPcirculant.Rd:model <- RMexp(var=10, s=2)
RandomFields/man/RPcirculant.Rd:model <- RMfbm(Aniso=diag(c(1,2)), alpha=1.5)
RandomFields/man/RMparswm.Rd:\name{RMparswm}
RandomFields/man/RMparswm.Rd:\alias{RMparswm}
RandomFields/man/RMparswm.Rd:\alias{RMparswmX}
RandomFields/man/RMparswm.Rd:\title{Parsimonious Multivariate Whittle Matern Model}
RandomFields/man/RMparswm.Rd: \command{\link{RMparswm}} is a multivariate stationary isotropic
RandomFields/man/RMparswm.Rd: \command{\link{RMwhittle}} model.
RandomFields/man/RMparswm.Rd: \command{RMparswmX} ist defined as
RandomFields/man/RMparswm.Rd:RMparswm(nudiag, var, scale, Aniso, proj)
RandomFields/man/RMparswm.Rd:RMparswmX(nudiag, rho, var, scale, Aniso, proj)
RandomFields/man/RMparswm.Rd:   \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMparswm.Rd: Note that the definition of \command{RMparswmX} is
RandomFields/man/RMparswm.Rd: \code{RMschur(M=rho, RMparswm(nudiag, var, scale, Aniso, proj))}. 
RandomFields/man/RMparswm.Rd: \command{\link{RMparswm}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMparswm.Rd: \item Gneiting, T., Kleiber, W., Schlather, M. (2010)
RandomFields/man/RMparswm.Rd: Matern covariance functions for multivariate random fields
RandomFields/man/RMparswm.Rd: \command{\link{RMbiwm}},
RandomFields/man/RMparswm.Rd: \command{\link{RMwhittle}},
RandomFields/man/RMparswm.Rd: \command{\link{RMmodel}},
RandomFields/man/RMparswm.Rd:model <- RMparswmX(nudiag=c(1.3, 0.7, 2), rho=rho)
RandomFields/man/RMbiwm.Rd:\name{RMbiwm}
RandomFields/man/RMbiwm.Rd:\alias{RMbiwm}
RandomFields/man/RMbiwm.Rd:\title{Full Bivariate Whittle Matern Model}
RandomFields/man/RMbiwm.Rd: \command{\link{RMbiwm}} is a bivariate stationary isotropic covariance model
RandomFields/man/RMbiwm.Rd: \command{\link{RMwhittle}} model.
RandomFields/man/RMbiwm.Rd:RMbiwm(nudiag, nured12, nu, s, cdiag, rhored, c, notinvnu, var,
RandomFields/man/RMbiwm.Rd: (\command{\link{RMwhittle}}) model applies.
RandomFields/man/RMbiwm.Rd: If logical then the formula for the \command{\link{RMmatern}} model
RandomFields/man/RMbiwm.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMbiwm.Rd: (cf. Gneiting, T., Kleiber, W., Schlather, M. (2010), Full 
RandomFields/man/RMbiwm.Rd: Bivariate Matern Model (Section 2.2)).
RandomFields/man/RMbiwm.Rd: % For an alternative model see also \command{\link{RMbiwm}}. 
RandomFields/man/RMbiwm.Rd: \command{\link{RMbiwm}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMbiwm.Rd: \item Gneiting, T., Kleiber, W., Schlather, M. (2010)
RandomFields/man/RMbiwm.Rd: Matern covariance functions for multivariate random fields
RandomFields/man/RMbiwm.Rd: \command{\link{RMparswm}},
RandomFields/man/RMbiwm.Rd: \command{\link{RMwhittle}},
RandomFields/man/RMbiwm.Rd: \command{\link{RMmodel}},
RandomFields/man/RMbiwm.Rd: \link{Multivariate RMmodels}.
RandomFields/man/RMbiwm.Rd:model <- RMbiwm(nudiag=c(0.3, 2), nured=1, rhored=1, cdiag=c(1, 1.5), 
RandomFields/man/RMqam.Rd:\name{RMqam}
RandomFields/man/RMqam.Rd:\alias{RMqam}
RandomFields/man/RMqam.Rd:\alias{RMqam}
RandomFields/man/RMqam.Rd: \command{\link{RMqam}} is a univariate stationary covariance model depending
RandomFields/man/RMqam.Rd:RMqam(phi, C1, C2, C3, C4, C5, C6, C7, C8, C9, theta, var, scale, Aniso, proj)
RandomFields/man/RMqam.Rd: \item{phi}{a valid covariance \command{\link{RMmodel}} that is a normal
RandomFields/man/RMqam.Rd:   \code{\link{RFgetModelNames}(monotone="normal mixture")}.
RandomFields/man/RMqam.Rd: stationary \command{\link{RMmodel}}s}
RandomFields/man/RMqam.Rd: \item{var,scale,Aniso,proj}{optional arguments; same meaning for any \command{\link{RMmodel}}. If not passed, the above covariance function remains unmodified.}
RandomFields/man/RMqam.Rd: e.g. \command{\link{RMstable}}, \command{\link{RMgauss}}, \command{\link{RMexponential}}.
RandomFields/man/RMqam.Rd: \command{\link{RMqam}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMqam.Rd: \item Porcu, E., Mateu, J. & Christakos, G. (2007) Quasi-arithmetic
RandomFields/man/RMqam.Rd: space-time data. Submitted to Journal of Multivariate Analysis.
RandomFields/man/RMqam.Rd: \command{\link{RMmqam}},
RandomFields/man/RMqam.Rd: \command{\link{RMmodel}},
RandomFields/man/RMqam.Rd:model <- RMqam(phi=RMgauss(), RMexp(), RMgauss(),
RandomFields/man/RFgetModel.Rd:\name{RFgetModel}
RandomFields/man/RFgetModel.Rd:\alias{RFgetModel}
RandomFields/man/RFgetModel.Rd:%\alias{GetModelInfo}
RandomFields/man/RFgetModel.Rd:%\alias{GetModel}
RandomFields/man/RFgetModel.Rd:RFgetModel(register, explicite.natscale, show.call=FALSE,
RandomFields/man/RFgetModel.Rd:   If \code{FALSE} then any \command{\link{RMnatsc}} is ignored.
RandomFields/man/RFgetModel.Rd:   If \code{TRUE} then any  \command{\link{RMnatsc}} is tried to be
RandomFields/man/RFgetModel.Rd:   combined with leading \command{\link{RMS}}, or returned as such.
RandomFields/man/RFgetModel.Rd:   \code{\link[=RFgetModelInfo]{which.submodels}}.
RandomFields/man/RFgetModel.Rd:  \command{\link{RFgetModel}} returns a model that can be re-used
RandomFields/man/RFgetModel.Rd:  \command{RFgetModelInfo} can return detailed information.
RandomFields/man/RFgetModel.Rd:\seealso{\command{\link{RFgetModelInfo}}, \command{\link{RFsimulate}}.
RandomFields/man/RFgetModel.Rd:model <- RMexp(scale=4, var=2) + RMnugget(var=3) + RMshape(mean=1)
RandomFields/man/RFgetModel.Rd:RFgetModel(show.call=FALSE)
RandomFields/man/RFgetModel.Rd:RFgetModel(show.call=TRUE)
RandomFields/man/MajorRevisions.Rd:\name{Major Revisions}
RandomFields/man/MajorRevisions.Rd:\alias{MajorRevisions}
RandomFields/man/MajorRevisions.Rd:    \item \command{RMconstant} is now called \command{\link{RMfixcov}}
RandomFields/man/MajorRevisions.Rd:\section{Major Revision: changings from Version 2 to Version 3 (Jan 2014)}{
RandomFields/man/MajorRevisions.Rd:      Covariance models start with \code{\link{RM}}, distribution families
RandomFields/man/MajorRevisions.Rd:      replacing the former \code{ShowModels}
RandomFields/man/MajorRevisions.Rd:     \item Modelling of \link[=maxstable]{maxstable
RandomFields/man/MajorRevisions.Rd:     \link[=RMmodelsAdvanced]{tail correlation functions};
RandomFields/man/MajorRevisions.Rd:   \item \bold{Models}
RandomFields/man/MajorRevisions.Rd:     \item \link[=RMmodelsAdvanced]{Multivariate and vector-valued random
RandomFields/man/MajorRevisions.Rd:     \item The \link[=RMuser]{user}
RandomFields/man/MajorRevisions.Rd:     \item The \link[=RMshape]{trend} allows for much more flexibility
RandomFields/man/MajorRevisions.Rd:model <- RMexp()
RandomFields/man/RMave.Rd:\name{RMave}
RandomFields/man/RMave.Rd:\alias{RMave}
RandomFields/man/RMave.Rd: \command{\link{RMave}} is a univariate stationary covariance model
RandomFields/man/RMave.Rd:RMave(phi, A, z, spacetime, var, scale, Aniso, proj)
RandomFields/man/RMave.Rd:   \command{\link{RMmodel}} whose \code{monotone} property equals
RandomFields/man/RMave.Rd:   \code{\link{RFgetModelNames}(monotone="normal mixture")}
RandomFields/man/RMave.Rd:   \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMave.Rd:\details{See Schlather, M. (2010), Example 13 with l=1.
RandomFields/man/RMave.Rd: \command{\link{RMave}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}
RandomFields/man/RMave.Rd: \item Schlather, M. (2010)
RandomFields/man/RMave.Rd: \code{\link{RMmodel}},
RandomFields/man/RMave.Rd: \code{\link{RMstp}}.
RandomFields/man/RMave.Rd:phi <- function(t){return(RFcov(RMwhittle(1), t))}
RandomFields/man/RMave.Rd:z1 <- RFcov( model=RMave(RMwhittle(1),A=A,z=z) , x=t(c(h,0)) )
RandomFields/man/RMave.Rd:z2 <- RFcov( model=RMave(RMwhittle(1),A=A,z=z,spacetime=FALSE) , x=t(h) )
RandomFields/man/RMhyperbolic.Rd:\name{RMhyperbolic}
RandomFields/man/RMhyperbolic.Rd:\alias{RMhyperbolic}
RandomFields/man/RMhyperbolic.Rd:\title{Generalized Hyperbolic Covariance Model}
RandomFields/man/RMhyperbolic.Rd: \command{\link{RMhyperbolic}} is a stationary isotropic covariance model
RandomFields/man/RMhyperbolic.Rd:RMhyperbolic(nu, lambda, delta, var, scale, Aniso, proj)
RandomFields/man/RMhyperbolic.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMhyperbolic.Rd: (see \command{\link{RMcauchy}}) with \eqn{\gamma =
RandomFields/man/RMhyperbolic.Rd: \command{\link{RMwhittle}} with smoothness parameter \eqn{\nu}{\nu}
RandomFields/man/RMhyperbolic.Rd: \command{\link{RMhyperbolic}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMhyperbolic.Rd: \command{\link{RMcauchy}},
RandomFields/man/RMhyperbolic.Rd: \command{\link{RMwhittle}},
RandomFields/man/RMhyperbolic.Rd: \command{\link{RMmodel}},
RandomFields/man/RMhyperbolic.Rd:model <- RMhyperbolic(nu=1, lambda=2, delta=0.2)
RandomFields/man/RMiaco.Rd:\name{RMiaco}
RandomFields/man/RMiaco.Rd:\alias{RMiaco}
RandomFields/man/RMiaco.Rd:RMiaco(nu, lambda, delta, var, scale, Aniso, proj)
RandomFields/man/RMiaco.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMiaco.Rd: \command{\link{RMiaco}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMiaco.Rd: \item de Cesare, L., Myers, D.E., and Posa, D. (2002)
RandomFields/man/RMiaco.Rd: \item de Iaco, S.. Myers, D.E., and Posa, D. (2002)
RandomFields/man/RMiaco.Rd: families. \emph{Math. Geol.} \bold{34}, 23-42.
RandomFields/man/RMiaco.Rd: \command{\link{RMmodel}}.
RandomFields/man/RMiaco.Rd:model <- RMiaco(nu=1, lambda=1.5, delta=0.5)
RandomFields/man/RMdivfree.Rd:\name{RMdivfree}
RandomFields/man/RMdivfree.Rd:\alias{RMdivfree}
RandomFields/man/RMdivfree.Rd:\title{Divfree Covariance Model}
RandomFields/man/RMdivfree.Rd: \command{\link{RMdivfree}}
RandomFields/man/RMdivfree.Rd:RMdivfree(phi, which, var, scale, Aniso, proj)
RandomFields/man/RMdivfree.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMdivfree.Rd: See also the models \command{\link{RMcurlfree}} and \command{\link{RMvector}}.
RandomFields/man/RMdivfree.Rd: \command{\link{RMdivfree}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMdivfree.Rd: \item Scheuerer, M. and Schlather, M. (2012)
RandomFields/man/RMdivfree.Rd: Covariance Models for Divergence-Free and Curl-Free Random Vector Fields.
RandomFields/man/RMdivfree.Rd: \emph{Stochastic Models} \bold{28:3}.
RandomFields/man/RMdivfree.Rd: \command{\link{RMcurlfree}},
RandomFields/man/RMdivfree.Rd: \command{\link{RMderiv}},
RandomFields/man/RMdivfree.Rd: \command{\link{RMvector}},
RandomFields/man/RMdivfree.Rd: \command{\link{RMmodel}},
RandomFields/man/RMdivfree.Rd:model <- RMdivfree(RMgauss(), scale=4)
RandomFields/man/RMdampedcos.Rd:\name{RMdampedcos}
RandomFields/man/RMdampedcos.Rd:\alias{RMdampedcos}
RandomFields/man/RMdampedcos.Rd: \command{\link{RMdampedcos}} is a stationary isotropic covariance model.
RandomFields/man/RMdampedcos.Rd:RMdampedcos(lambda, var, scale, Aniso, proj)
RandomFields/man/RMdampedcos.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMdampedcos.Rd:and corresponds to \command{\link{RMbessel}} for
RandomFields/man/RMdampedcos.Rd: \command{\link{RMdampedcos}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMdampedcos.Rd: \emph{Geostatistics. Modeling Spatial Uncertainty.}
RandomFields/man/RMdampedcos.Rd: \item Gelfand, A. E., Diggle, P., Fuentes, M. and Guttorp,
RandomFields/man/RMdampedcos.Rd: \command{\link{RMbessel}},
RandomFields/man/RMdampedcos.Rd: \command{\link{RMmodel}},
RandomFields/man/RMdampedcos.Rd:model <- RMdampedcos(lambda=0.3, scale=0.1)
RandomFields/man/papers.jss14.Rd:  Schlather, M., Malinowski, A., Menck, P.J., Oesting, M. and
RandomFields/man/papers.jss14.Rd:               ##  SECTION 4: UNCONDITIONAL SIMULATION  ##
RandomFields/man/papers.jss14.Rd:M1 <- c(0.9, 0.6)
RandomFields/man/papers.jss14.Rd:M2 <- c(sqrt(0.19), 0.8)
RandomFields/man/papers.jss14.Rd:model <- RMmatrix(M = M1, RMwhittle(nu = 0.3)) + 
RandomFields/man/papers.jss14.Rd:         RMmatrix(M = M2, RMwhittle(nu = 2))
RandomFields/man/papers.jss14.Rd:model <- RMdelay(RMstable(alpha = 1.9, scale = 2), s = c(4, 4))
RandomFields/man/papers.jss14.Rd:model <- RMdelay(RMstable(alpha = 1.9, scale = 2), s = c(0, 4)) + 
RandomFields/man/papers.jss14.Rd:         RMdelay(RMstable(alpha = 1.9, scale = 2), s = c(4, 0))
RandomFields/man/papers.jss14.Rd:## MARGIN.slices has the effect of choosing the third dimension
RandomFields/man/papers.jss14.Rd:model <- RMgencauchy(alpha = 1.5, beta = 3)
RandomFields/man/papers.jss14.Rd:plot(simu, MARGIN.slices = 3, n.slices = 2)
RandomFields/man/papers.jss14.Rd:## Fig. 5: Gneiting's bivariate Whittle-Matern model
RandomFields/man/papers.jss14.Rd:model <- RMbiwm(nudiag = c(1, 2), nured = 1, rhored = 1, cdiag = c(1, 5), 
RandomFields/man/papers.jss14.Rd:M1 <- c(0.9, 0.6)
RandomFields/man/papers.jss14.Rd:M2 <- c(sqrt(0.19), 0.8)
RandomFields/man/papers.jss14.Rd:A1 <- RMangle(angle = pi/4, diag = c(0.1, 0.5))
RandomFields/man/papers.jss14.Rd:A2 <- RMangle(angle = 0, diag = c(0.1, 0.5))
RandomFields/man/papers.jss14.Rd:model <- RMmatrix(M = M1, RMgengneiting(kappa = 0, mu = 2, Aniso = A1)) +
RandomFields/man/papers.jss14.Rd:         RMmatrix(M = M2, RMgengneiting(kappa = 3, mu = 2, Aniso = A2))
RandomFields/man/papers.jss14.Rd:model <- RMcurlfree(RMmatern(nu = 5), scale = 4)
RandomFields/man/papers.jss14.Rd:model <- RMkolmogorov()
RandomFields/man/papers.jss14.Rd:plot(model, dim = 3, xlim = c(-3, 3), MARGIN = 1 : 2, cex = 2.3,
RandomFields/man/papers.jss14.Rd:     fixed.MARGIN = 1.0, main = "", col = "brown")
RandomFields/man/papers.jss14.Rd:nug <- RMmatrix(M = matrix(nc = 2, c(NA, 0, 0, NA)), RMnugget())
RandomFields/man/papers.jss14.Rd:## parsimonious bivariate Matern model
RandomFields/man/papers.jss14.Rd:pars.model <- nug + RMbiwm(nudiag = c(NA, NA), scale = NA, cdiag = c(NA, NA),
RandomFields/man/papers.jss14.Rd:## whole bivariate Matern model
RandomFields/man/papers.jss14.Rd:whole.model <- nug + RMbiwm(nudiag = c(NA, NA), nured = NA, s = rep(NA, 3),
RandomFields/man/papers.jss14.Rd:a <- colMeans(weather[All , 3 : 4]) * pi / 180
RandomFields/man/RMmastein.Rd:\name{RMmastein}
RandomFields/man/RMmastein.Rd:\alias{RMmastein}
RandomFields/man/RMmastein.Rd:\title{Ma-Stein operator}
RandomFields/man/RMmastein.Rd: \command{\link{RMmastein}} is a univariate stationary covariance model
RandomFields/man/RMmastein.Rd:Here \eqn{\Gamma} is the Gamma function; \eqn{W} is the Whittle-Matern
RandomFields/man/RMmastein.Rd:model (RMwhittle).
RandomFields/man/RMmastein.Rd:RMmastein(phi, nu, delta, var, scale, Aniso, proj)
RandomFields/man/RMmastein.Rd: \item{phi}{an \command{\link{RMmodel}} on the real axis}
RandomFields/man/RMmastein.Rd: Whittle-Matern model (for \eqn{t=0})} 
RandomFields/man/RMmastein.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMmastein.Rd: the argument in the Whittle-Matern function.)
RandomFields/man/RMmastein.Rd: \command{\link{RMmastein}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMmastein.Rd: \item Ma, C. (2003)
RandomFields/man/RMmastein.Rd: \emph{Math. Geol.}, \bold{34}, 965-975.
RandomFields/man/RMmastein.Rd: \item Stein, M.L. (2005) Space-time covariance functions. \emph{JASA},
RandomFields/man/RMmastein.Rd: \command{\link{RMwhittle}},
RandomFields/man/RMmastein.Rd: \command{\link{RMmodel}},
RandomFields/man/RMmastein.Rd:model <- RMmastein(RMgauss(), nu=1, delta=10)
RandomFields/man/RMmastein.Rd:plot(RMexp(), model.mastein=model, dim=2)
RandomFields/man/RFsimulate.sophisticated.examples.Rd:  z <- RFsimulate(x=x, model=RPcoins(RMspheric()),
RandomFields/man/RFsimulate.sophisticated.examples.Rd:z <- RFsimulate(RPsmith(RMgauss()), x=x, n=10)
RandomFields/man/RFsimulate.sophisticated.examples.Rd:model <- RPsmith(RMmppplus(RMgauss(), RMexp(), p=c(0.3, 0.7)))
RandomFields/man/RFsimulate.sophisticated.examples.Rd:m <- list(RMmppplus(RPgauss(RMgauss())),
RandomFields/man/RFsimulate.sophisticated.examples.Rd:          RPgauss(RMgauss()),
RandomFields/man/RFsimulate.sophisticated.examples.Rd:          RMgauss())
RandomFields/man/RFsimulate.sophisticated.examples.Rd:model <- RMmppplus(RPgauss(RMgauss()), RPgauss(RMexp()),
RandomFields/man/RFsimulate.sophisticated.examples.Rd:model <- RMnsst(aniso=diag(c(3, 3, 0.02)), delta=2,
RandomFields/man/RFsimulate.sophisticated.examples.Rd:                phi=RMgauss(), psi=RMgenfbm(alpha=1, delta=0.5))
RandomFields/man/RFsimulate.sophisticated.examples.Rd:ut <- system.time(f <- RFsimulate(RPcirculant(RMexp())), x=x, y=y)
RandomFields/man/RFsimulate.sophisticated.examples.Rd:model1 <- RPcutoff(RMstable(alpha=1, scale=scale))
RandomFields/man/RFsimulate.sophisticated.examples.Rd:model2 <- RMcutoff(scale = scale, diam=cut.off.param$diam, a=cut.off.param$a, 
RandomFields/man/RFsimulate.sophisticated.examples.Rd:                   RMstable(alpha=1.0))
RandomFields/man/RFsimulate.sophisticated.examples.Rd:model <- RMexp(var=1.1, aniso=matrix(nc=2, c(2, 1, 0.5, 1)))
RandomFields/man/RMconstant.Rd:\name{RMconstant}
RandomFields/man/RMconstant.Rd:\alias{RMconstant}
RandomFields/man/RMconstant.Rd:\alias{RMconstant}
RandomFields/man/RMconstant.Rd:\title{Covariance Matrix Constant in Space}
RandomFields/man/RMconstant.Rd:  \command{\link{RMconstant}} defines a spatially constant covariance function.
RandomFields/man/RMconstant.Rd:RMconstant(M, var)
RandomFields/man/RMconstant.Rd: \item{M}{a numerical matrix defining the user-defined covariance for a
RandomFields/man/RMconstant.Rd: \command{\link{RMconstant}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMconstant.Rd: \command{\link{RMfixcov}},
RandomFields/man/RMconstant.Rd:\command{\link{RMmodel}}.
RandomFields/man/RMconstant.Rd:model <- RMconstant(diag(2),var=3)
RandomFields/man/RPbrownresnick.Rd:    \link{RMmodel} and \link{RMmodelsAdvanced}.
RandomFields/man/RPbrownresnick.Rd:    Brown, B.M. and Resnick, S.I. (1977).
RandomFields/man/RPbrownresnick.Rd:    \item Kabluchko, Z., Schlather, M. and de Haan, L (2009)
RandomFields/man/RPbrownresnick.Rd:    \item  Oesting, M., Kabluchko, Z. and Schlather M. (2012)
RandomFields/man/RPbrownresnick.Rd: \command{\link{RMmodel}},
RandomFields/man/RPbrownresnick.Rd:model <- ~ RPbrownresnick(RMfbm(alpha=A), xi=0)
RandomFields/man/RPbrownresnick.Rd:model <- RMfbm(proj=1, alpha=1, var=0.5) + RMfbm(proj=2, alpha=1, var=0.5) 
RandomFields/man/RMstable.Rd:\name{RMstable}
RandomFields/man/RMstable.Rd:\alias{RMstable}
RandomFields/man/RMstable.Rd:\alias{RMpoweredexp}
RandomFields/man/RMstable.Rd:\alias{RMpoweredexponential}
RandomFields/man/RMstable.Rd:\title{Stable Family / Powered Exponential Model}
RandomFields/man/RMstable.Rd: \command{\link{RMstable}} is a stationary isotropic covariance model
RandomFields/man/RMstable.Rd:RMstable(alpha, var, scale, Aniso, proj)
RandomFields/man/RMstable.Rd:RMpoweredexp(alpha, var, scale, Aniso, proj)
RandomFields/man/RMstable.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMstable.Rd: \command{\link{RMexp}}) for \eqn{\alpha = 1}{\alpha = 1} and the Gaussian
RandomFields/man/RMstable.Rd: model (see \command{\link{RMgauss}}) for \eqn{\alpha = 2}{\alpha = 2}.
RandomFields/man/RMstable.Rd: \command{\link{RMstable}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMstable.Rd:    \emph{Geostatistics. Modeling Spatial Uncertainty.}
RandomFields/man/RMstable.Rd:    \item Diggle, P. J., Tawn, J. A. and Moyeed, R. A. (1998) Model-based
RandomFields/man/RMstable.Rd:    \item Gelfand, A. E., Diggle, P., Fuentes, M. and Guttorp, P. (eds.)
RandomFields/man/RMstable.Rd:    \item Strokorb, K., Ballani, F., and  Schlather, M. (2014)
RandomFields/man/RMstable.Rd:  \command{\link{RMbistable}},
RandomFields/man/RMstable.Rd: \command{\link{RMexp}},
RandomFields/man/RMstable.Rd: \command{\link{RMgauss}},
RandomFields/man/RMstable.Rd: \command{\link{RMmodel}},
RandomFields/man/RMstable.Rd:model <- RMstable(alpha=1.9, scale=0.4)
RandomFields/man/RMlsfbm.Rd:\name{RMlsfbm}
RandomFields/man/RMlsfbm.Rd:\alias{RMlsfbm}
RandomFields/man/RMlsfbm.Rd:\title{Locally Positive Definite Function Given by the Fractal Brownian Motion}
RandomFields/man/RMlsfbm.Rd:  \command{\link{RMlsfbm}} is a positive definite function on the
RandomFields/man/RMlsfbm.Rd:RMlsfbm(alpha, const, var, scale, Aniso, proj)
RandomFields/man/RMlsfbm.Rd:   \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMlsfbm.Rd: \command{\link{RMlsfbm}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMlsfbm.Rd:   \item Martini, J., Schlather, M., Simianer, H. (In preparation.)
RandomFields/man/RMlsfbm.Rd: \command{\link{RMbcw}} generalizes \command{RMlsfbm} in case that \eqn{c}
RandomFields/man/RMlsfbm.Rd: \command{\link{RMfbm}},
RandomFields/man/RMlsfbm.Rd: \command{\link{RMmodel}},
RandomFields/man/RMlsfbm.Rd:model <- RMlsfbm(alpha=1, scale=10)
RandomFields/man/RMcircular.Rd:\name{RMcircular}
RandomFields/man/RMcircular.Rd:\alias{RMcircular}
RandomFields/man/RMcircular.Rd:\title{Circular Covariance Model}
RandomFields/man/RMcircular.Rd: \command{\link{RMcircular}} is a stationary isotropic covariance model
RandomFields/man/RMcircular.Rd:RMcircular(var, scale, Aniso, proj)
RandomFields/man/RMcircular.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMcircular.Rd: \command{\link{RMcircular}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMcircular.Rd: \emph{Geostatistics. Modeling Spatial Uncertainty.}
RandomFields/man/RMcircular.Rd: \command{\link{RMmodel}},
RandomFields/man/RMcircular.Rd:model <- RMcircular()
RandomFields/man/RR.Rd:  See \link{Bayesian Modelling} for a less technical introduction to
RandomFields/man/RR.Rd:  the \command{\link{RMball}} to simulate \command{\link{RMspheric}}, etc.
RandomFields/man/RR.Rd:  A further random element is \command{\link{RMsign}}, which is an
RandomFields/man/RR.Rd:  \code{RM} and not with \code{RR}.
RandomFields/man/RR.Rd:  \link{RC}, \link{RF}, \link{RM}, \link{RP}, \command{\link{Other models}},
RandomFields/man/RR.Rd: \code{\link[=RMmodelgenerator-class]{RMmodelgenerator}}, \link{R.}
RandomFields/man/RR.Rd:model <- RMgauss(scale=exp())
RandomFields/man/RR.Rd:model <- RMgauss(scale=exp(rate=unif()))
RandomFields/man/RR.Rd:model <- RMgauss(scale=exp(1))
RandomFields/man/RMintexp.Rd:\name{RMintexp}
RandomFields/man/RMintexp.Rd:\alias{RMintexp}
RandomFields/man/RMintexp.Rd: \command{\link{RMintexp}} is a univariate stationary covariance model
RandomFields/man/RMintexp.Rd:RMintexp(phi, var, scale, Aniso, proj)
RandomFields/man/RMintexp.Rd: \item{phi}{a variogram \command{\link{RMmodel}}}
RandomFields/man/RMintexp.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMintexp.Rd: \command{\link{RMintexp}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMintexp.Rd: \item Schlather, M. (2012)
RandomFields/man/RMintexp.Rd: \command{\link{RMmodel}},
RandomFields/man/RMintexp.Rd:model <- RMintexp(RMfbm(alpha=1.5, scale=0.2))
RandomFields/man/RPspectral.Rd: Gaussian random fields (Mantoglou and Wilson, 1982). 
RandomFields/man/RPspectral.Rd: \item{phi}{object of class \code{\link[=RMmodel-class]{RMmodel}};
RandomFields/man/RPspectral.Rd:   Sometimes, the spectral density must be sampled by MCMC.
RandomFields/man/RPspectral.Rd: \item{sigma}{real. Considered if the Metropolis
RandomFields/man/RPspectral.Rd: \code{\link[=RMmodel-class]{RMmodel}}. 
RandomFields/man/RPspectral.Rd: \emph{Geostatistical Simulation: Models and Algorithms.}
RandomFields/man/RPspectral.Rd: \item Mantoglou, A. and J. L. Wilson (1982),
RandomFields/man/RPspectral.Rd: \emph{The Turning Bands Method for simulation of random fields using
RandomFields/man/RPspectral.Rd:model <- RPspectral(RMmatern(nu=1))
RandomFields/man/soil.Rd: Master thesis, University of Bayreuth, Germany.
RandomFields/man/soil.Rd:\dontshow{if (!interactive()) gui.model <- RMexp()} %ok
RandomFields/man/soil.Rd:## fit by ML
RandomFields/man/soil.Rd:model <- moisture ~ 1 + RMwhittle(scale=NA, var=NA, nu=NA) + RMnugget(var=NA)
RandomFields/man/RMma.Rd:\name{RMma}
RandomFields/man/RMma.Rd:\alias{RMma}
RandomFields/man/RMma.Rd:\title{Ma operator}
RandomFields/man/RMma.Rd: \command{\link{RMma}} is a univariate stationary covariance model
RandomFields/man/RMma.Rd:RMma(phi, alpha, theta, var, scale, Aniso, proj)
RandomFields/man/RMma.Rd: \item{phi}{a stationary covariance \command{\link{RMmodel}}.}
RandomFields/man/RMma.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMma.Rd: \command{\link{RMma}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMma.Rd: \item Ma, C. (2003)
RandomFields/man/RMma.Rd: \emph{Math. Geol.}, \bold{34}, 965-975.
RandomFields/man/RMma.Rd: \command{\link{RMmodel}},
RandomFields/man/RMma.Rd:model <- RMma(RMgauss(), alpha=4, theta=0.5)
RandomFields/man/RMdeclare.Rd:\name{RMdeclare}
RandomFields/man/RMdeclare.Rd:\alias{RMdeclare}
RandomFields/man/RMdeclare.Rd:\alias{RM_DECLARE}
RandomFields/man/RMdeclare.Rd:RMdeclare(...)
RandomFields/man/RMdeclare.Rd:    \code{arg=arg}, e.g. \code{RMdeclare(u=u)}.
RandomFields/man/RMdeclare.Rd: \command{\link{RMdeclare}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}
RandomFields/man/RMdeclare.Rd:\author{Martin Schlather, \email{schlather@math.uni-mannheim.de}
RandomFields/man/RMdeclare.Rd: \command{\link{RMmodel}}.
RandomFields/man/RMdeclare.Rd:## The following two examples illustrate the use of RMdeclare and the
RandomFields/man/RMdeclare.Rd:model <- ~ RMexp(sc=sc1, var=var1) + RMgauss(var=var2, sc=sc2) + RMdeclare(u=u)
RandomFields/man/RMdeclare.Rd:## 'var's a unknown variable and an argument for RMwhittle
RandomFields/man/RMdeclare.Rd:model2 <- ~ RMexp(var=sc) + RMwhittle(var = g, nu=Nu) + RMnugget(var=nugg) +
RandomFields/man/RMdeclare.Rd:            RMexp(var=var, Aniso=A) + RMdeclare(CCC=CCC, DD=DD)
RandomFields/man/RMcauchytbm.Rd:\name{RMcauchytbm}
RandomFields/man/RMcauchytbm.Rd:\alias{RMcauchytbm}
RandomFields/man/RMcauchytbm.Rd:\title{Modifications of the Cauchy Family Covariance Model}
RandomFields/man/RMcauchytbm.Rd: \code{\link{RMcauchytbm}()} is a shortcut of
RandomFields/man/RMcauchytbm.Rd: \command{\link{RMtbm}(\link{RMgencauchy}())} and is 
RandomFields/man/RMcauchytbm.Rd:RMcauchytbm(alpha, beta, gamma, var, scale, Aniso, proj)
RandomFields/man/RMcauchytbm.Rd: \item{alpha,beta}{See \command{\link{RMgencauchy}}.}
RandomFields/man/RMcauchytbm.Rd: \item{gamma}{is the same as \code{fulldim} in \command{\link{RMtbm}}.}
RandomFields/man/RMcauchytbm.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMcauchytbm.Rd: \command{\link{RMcauchytbm}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMcauchytbm.Rd: \item Gneiting, T. and Schlather, M. (2004)
RandomFields/man/RMcauchytbm.Rd: \emph{SIAM review} \bold{46}, 269--282.
RandomFields/man/RMcauchytbm.Rd: \command{\link{RMcauchy}},
RandomFields/man/RMcauchytbm.Rd: \command{\link{RMgencauchy}},
RandomFields/man/RMcauchytbm.Rd: \command{\link{RMmodel}},
RandomFields/man/RMcauchytbm.Rd:model <- RMcauchytbm(alpha=1, beta=1, gamma=3)
RandomFields/man/RPpoisson.Rd: \item{shape}{the model, \command{\link{RMmodel}}, gives the shape
RandomFields/man/RPpoisson.Rd:model <- RMball()
RandomFields/man/RPpoisson.Rd:model <- RMtent(s=2)
RandomFields/man/RPpoisson.Rd:model <- RMspheric()
RandomFields/man/RPpoisson.Rd:model <- RMtruncsupport(radius=5, RMgauss())
RandomFields/man/RPpoisson.Rd:# example 2: Poisson field based on the double exponential density (RMexp)
RandomFields/man/RPpoisson.Rd:model <- RMtruncsupport(radius=1.5, 0.2 + 2 * RMexp(s=exp()))
RandomFields/man/RPpoisson.Rd:  \command{\link{RMmodel}},
RandomFields/man/macros/def.Rd:% M-x auto-fill-mode
RandomFields/man/macros/def.Rd:\newcommand{\argModel}{ object of class  \code{\link[=RMmodel-class]{RMmodel}}, \command{\link{RFformula}} or  \command{\link[stats]{formula}}; best is to consider the examples below, first. \cr The argument \code{params} is a list that specifies free parameters in a formula description, see \link{RMformula}.}
RandomFields/man/macros/def.Rd:\newcommand{\argErrmodel}{In case of (assumed) error-free measurements (which is mostly the case in geostatistics) the argument \code{err.model} is not given. In case of measurement errors we have usually \code{err.model=RMnugget(var=var)}, but any other \code{RMmodel} with mean zero is allowed.\cr \code{err.param} plays the same role as \code{params} for \code{model}.}
RandomFields/man/macros/def.Rd:\newcommand{\argFitmethods}{ Main methods to be used for estimating. If several methods are given, estimation will be performed with each method and the results reported.}
RandomFields/man/macros/def.Rd:\newcommand{\argOrigin}{character; one of \code{"original"}, \code{"MLE conform"}, \code{"all"}. This argument determines the parameters that are returned.}
RandomFields/man/macros/def.Rd:%\newcommand\NormDetails{If \code{raw=FALSE} the model extends to the space through a Voronoi tessellation, that is, any point in space gets the value of its nearest neighbour. In case the points given by \code{x}, \code{y}, \code{z} and \code{T} ly on a grid (\code{grid=TRUE}), always the Euclidean distance to the grid points is taken. Otherwise, the Euclidean distance is the default distance, but any other \code{norm} might be used instead. It is completely within the users responsability that \code{norm} is well defined. In particular, \code{RMcovariates} may not be included in the definition of the norm. There is no check by the package.\cr Default: Euclidean norm}
RandomFields/man/macros/def.Rd:\newcommand{\GEV}{The argument \code{xi} is always a number, i.e. \eqn{\xi} is constant in space. In contrast, \eqn{\mu} and \eqn{s} might be constant numerical values or (in future!) be given by an \code{\link{RMmodel}}, in particular by an \code{\link{RMshape}} model.  \cr For \eqn{xi=0}, the default values of \eqn{mu} and \eqn{s} are \eqn{0} and \eqn{1}, respectively. For \eqn{xi\not=0}, the default values of \eqn{mu} and \eqn{s} are \eqn{1} and \eqn{|\xi|}, respectively, so that it defaults to the standard Frechet case if \eqn{\xi > 0}.}
RandomFields/man/macros/allg_defn.Rd:\newcommand{\martin}{Martin Schlather, \email{schlather@math.uni-mannheim.de}, \url{http://ms.math.uni-mannheim.de}}
RandomFields/man/macros/allg_defn.Rd:\newcommand{\marco}{Marco Oesting, \email{marco.oesting@mathematik.uni-stuttgart.de}, \url{https://www.isa.uni-stuttgart.de/institut/team/Oesting/}}
RandomFields/man/macros/allg_defn.Rd:\newcommand{\KMM}{\author{\kirstin \marco, \martin}}
RandomFields/man/macros/lit.Rd:% M-x auto-fill-mode
RandomFields/man/macros/lit.Rd:\newcommand{\litIntro}{Schlather, M. (1999) \emph{An introduction to positive definite functions and to unconditional simulation of random fields.} Technical report ST 99-10, Dept. of Maths and Statistics, Lancaster University.}
RandomFields/man/macros/lit.Rd:\newcommand{\litBA02}{Burnham, K. P. and Anderson, D. R. (2002) \emph{Model selection and Multi-Model Inference: A Practical Information-Theoretic Approach.} 2nd edition. New York: Springer.}
RandomFields/man/macros/lit.Rd:\newcommand{\litChiles}{Chiles, J.-P. and Delfiner, P. (1999) \emph{Geostatistics. Modeling Spatial Uncertainty.} New York: Wiley.}
RandomFields/man/macros/lit.Rd:\newcommand{\litHC}{Ver Hoef, J.M. and Cressie, N.A.C. (1993) Multivariate Spatial Prediction. \emph{Mathematical Geology} \bold{25}(2), 219-240.}
RandomFields/man/macros/lit.Rd:\newcommand{\litWackernagel}{Wackernagel, H. (1998) \emph{Multivariate Geostatistics.} Berlin: Springer, 2nd edition. }
RandomFields/man/RMblend.Rd:\name{RMblend}
RandomFields/man/RMblend.Rd:\alias{RMblend}
RandomFields/man/RMblend.Rd:RMblend(multi, blend, thresholds, var, scale, Aniso, proj)
RandomFields/man/RMblend.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMblend.Rd: \command{\link{RMblend}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMblend.Rd:    \item Bonat, W.H. , Ribeiro, P. Jr. and Schlather, M. (2019)
RandomFields/man/RMblend.Rd:    Modelling non-stationarity in scale. In preparation.
RandomFields/man/RMblend.Rd:  \command{\link{RMSadvanced}},
RandomFields/man/RMblend.Rd:  \command{\link{RMbubble}},
RandomFields/man/RMblend.Rd:  \command{\link{RMscale}},
RandomFields/man/RMblend.Rd:biwm <- RMbiwm(nudiag=c(0.3, 1), nured=1, rhored=1, cdiag=c(1, 1), 
RandomFields/man/RMblend.Rd:model <- RMblend(multi=biwm, blend=RMcovariate(data = as.double(m), raw=TRUE))
RandomFields/man/RFboxcox.Rd:\title{Linear part of \command{\link{RMmodel}}}
RandomFields/man/RFboxcox.Rd: \command{\link{RMmodel}},
RandomFields/man/RFboxcox.Rd:    Springer Science & Business Media. Section 4.9.
RandomFields/man/RFboxcox.Rd:  model <- moisture ~ 1 + RMwhittle(scale=NA, var=NA, nu=NA) + RMnugget(var=NA)
RandomFields/man/RFboxcox.Rd:} else model <- moisture ~ 1 + RMnugget(var=NA)
RandomFields/man/weather.Rd: Meteorological dataset, which consists of differences between forecasts
RandomFields/man/weather.Rd:regional numerical weather prediction ensemble (UWME; Grimit and Mass
RandomFields/man/weather.Rd:2002; Eckel and Mass 2005); they were valid on December 18, 2003 at 4 pm
RandomFields/man/weather.Rd:The data were obtained from Cliff Mass and Jeff Baars from the University
RandomFields/man/weather.Rd:    Eckel, A. F. and Mass, C. F. (2005) Aspects of effective mesoscale,
RandomFields/man/weather.Rd:    Gneiting, T., Kleiber, W. and Schlather, M. (2010) Matern
RandomFields/man/weather.Rd:    Grimit, E. P. and Mass, C. F. (2002) Initial results of a
RandomFields/man/RMfractdiff.Rd:\name{RMfractdiff}
RandomFields/man/RMfractdiff.Rd:\alias{RMfractdiff}
RandomFields/man/RMfractdiff.Rd:\title{Fractionally Differenced Process Model}
RandomFields/man/RMfractdiff.Rd: \command{\link{RMfractdiff}} is a stationary isotropic covariance model.
RandomFields/man/RMfractdiff.Rd:RMfractdiff(alpha, var, scale, Aniso, proj)
RandomFields/man/RMfractdiff.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMfractdiff.Rd: \command{\link{RMfractdiff}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMfractdiff.Rd: \command{\link{RMmodel}},
RandomFields/man/RMfractdiff.Rd:model <- RMfractdiff(0.5, scale=0.2)
RandomFields/man/RFgetModelInfo.Rd:\name{RFgetModelInfo}
RandomFields/man/RFgetModelInfo.Rd:\alias{RFgetModelInfo}
RandomFields/man/RFgetModelInfo.Rd:\alias{RFgetModelInfo_register}
RandomFields/man/RFgetModelInfo.Rd:\alias{RFgetModelInfo_model}
RandomFields/man/RFgetModelInfo.Rd:%\alias{GetModelInfo}
RandomFields/man/RFgetModelInfo.Rd:%\alias{GetModel}
RandomFields/man/RFgetModelInfo.Rd:\title{Information on RMmodels}
RandomFields/man/RFgetModelInfo.Rd:  The function returns information about an \link{RMmodel},
RandomFields/man/RFgetModelInfo.Rd:RFgetModelInfo(...) 
RandomFields/man/RFgetModelInfo.Rd:RFgetModelInfo_register(register, level = 1, spConform =
RandomFields/man/RFgetModelInfo.Rd:RFgetModelInfo_model(model, params, dim = 1, Time = FALSE,
RandomFields/man/RFgetModelInfo.Rd:  \item{...}{\command{RFgetModelInfo} is an
RandomFields/man/RFgetModelInfo.Rd:  abbreviation for the other two functions \command{RFgetModelInfo_register} and
RandomFields/man/RFgetModelInfo.Rd:  \command{RFgetModelInfo_model}. So \code{\ldots} takes the arguments
RandomFields/man/RFgetModelInfo.Rd:  of these two functions. Additionally, \command{RFgetModelInfo_model}
RandomFields/man/RFgetModelInfo.Rd:  % \item{max.elements}{integer; since \command{\link{RFgetModelInfo}}
RandomFields/man/RFgetModelInfo.Rd:    return the information in a format that is C compatible.%eg for RMcovariate
RandomFields/man/RFgetModelInfo.Rd:  Most models have a leading internal model.
RandomFields/man/RFgetModelInfo.Rd:\item{model,params}{\argModel
RandomFields/man/RFgetModelInfo.Rd:  \command{RFgetModelInfo} branches either into
RandomFields/man/RFgetModelInfo.Rd:  \command{RFgetModelInfo_register} or \command{RFgetModelInfo_model},
RandomFields/man/RFgetModelInfo.Rd:  \command{RFgetModelInfo} has three standard usages:
RandomFields/man/RFgetModelInfo.Rd:    \item \code{RFgetModelInfo()} returns internal information on the
RandomFields/man/RFgetModelInfo.Rd:    \item \code{RFgetModelInfo(RFfunction)} returns internal information on the
RandomFields/man/RFgetModelInfo.Rd:    \item \code{RFgetModelInfo(RMmodel)} returns general information on
RandomFields/man/RFgetModelInfo.Rd:    \code{\link{RMmodel}}
RandomFields/man/RFgetModelInfo.Rd:  Whereas \command{RFgetModelInfo()} 
RandomFields/man/RFgetModelInfo.Rd:  \command{\link{RFgetModel}} returns a model that can be re-used
RandomFields/man/RFgetModelInfo.Rd:  If \code{RFgetModelInfo(model)} is called a list is returned with the
RandomFields/man/RFgetModelInfo.Rd:\seealso{command{\link{RFgetModel}}, \command{\link{RFsimulate}}
RandomFields/man/RFgetModelInfo.Rd:model <- RMexp(scale=4, var=2) + RMnugget(var=3) + RMshape(mean=1)
RandomFields/man/RFgetModelInfo.Rd:RFgetModelInfo()
RandomFields/man/RFgetModelInfo.Rd:model <-  RMwhittle(scale=NA, var=NA, nu=NA) + RMnugget(var=NA)
RandomFields/man/RFgetModelInfo.Rd:RFgetModelInfo(model)
RandomFields/man/RMmodelsAuxiliary.Rd:\alias{AuxiliaryModels}
RandomFields/man/RMmodelsAuxiliary.Rd:\alias{Auxiliary Models}
RandomFields/man/RMmodelsAuxiliary.Rd:\alias{Auxiliary RMmodels}
RandomFields/man/RMmodelsAuxiliary.Rd:\alias{RMmodelsAuxiliary}
RandomFields/man/RMmodelsAuxiliary.Rd:\title{Auxiliary and other Models}
RandomFields/man/RMmodelsAuxiliary.Rd:  \bold{Mathematical functions}
RandomFields/man/RMmodelsAuxiliary.Rd:    \command{\link{RMangle}} \tab defines an anisotropy matrix by angle
RandomFields/man/RMmodelsAuxiliary.Rd:    \command{\link{RMball}} \tab Indicator of a ball of radius
RandomFields/man/RMmodelsAuxiliary.Rd:    \command{\link{RMm2r}} \tab spectral function belonging to a
RandomFields/man/RMmodelsAuxiliary.Rd:    \command{\link{RMm3b}}  \tab spectral function belonging to a tail
RandomFields/man/RMmodelsAuxiliary.Rd:    \command{\link{RMmppplus}} \tab operator to define mixed moving
RandomFields/man/RMmodelsAuxiliary.Rd:    maxima (M3) processes
RandomFields/man/RMmodelsAuxiliary.Rd:    \command{\link{RMmps}} \tab spectral functions belonging to a tail
RandomFields/man/RMmodelsAuxiliary.Rd:    \command{\link{RMpolygon}} \tab Indicator of a typical Poisson
RandomFields/man/RMmodelsAuxiliary.Rd:    \command{\link{RMrational}} \tab shape function used in the Bernoulli
RandomFields/man/RMmodelsAuxiliary.Rd:    \command{\link{RMrotat}} \tab shape function used in the Bernoulli
RandomFields/man/RMmodelsAuxiliary.Rd:    \command{\link{RMsign}} \tab random sign
RandomFields/man/RMmodelsAuxiliary.Rd:    \command{\link{RMtruncsupport}} \tab truncates the support of a shape in
RandomFields/man/RMmodelsAuxiliary.Rd:    \command{\link{RMeaxxa}} \tab shape function used in the Bernoulli
RandomFields/man/RMmodelsAuxiliary.Rd:    \command{\link{RMetaxxa}} \tab shape function used in the Bernoulli
RandomFields/man/RMmodelsAuxiliary.Rd:    \command{\link{RMidmodel}} \tab model identity\cr
RandomFields/man/RMmodelsAuxiliary.Rd:    \command{\link{RMidcoord}} \tab identity but interpretation turns from a
RandomFields/man/RMmodelsAuxiliary.Rd:  \command{\link{RMtrafo}} \tab allows to model the identity within the
RandomFields/man/RMmodelsAuxiliary.Rd:   \command{\link{RMrotation}} \tab shape function used in the Bernoulli
RandomFields/man/RMmodelsAuxiliary.Rd:    \command{\link{RMuser}} \tab User defined covariance model
RandomFields/man/RMmodelsAuxiliary.Rd:%\section{Methods}{
RandomFields/man/RMmodelsAuxiliary.Rd:  \link{RM}}
RandomFields/man/RMmodelsAuxiliary.Rd:\author{Alexander Malinowski; \martin}
RandomFields/man/RMmodelsAuxiliary.Rd:RFgetModelNames()
RandomFields/man/RFplot.Rd:\title{Plotting Models, Simulations, Empirical Statistics}
RandomFields/man/RFplot.Rd:    \command{\link{RFplotModel}}.
RandomFields/man/RFplot.Rd:    if \code{\link{RMmodels}} are defined by means of an
RandomFields/man/RFplot.Rd:    \command{\link{RFplotModel}}}
RandomFields/man/RFplot.Rd:    \command{\link{RFplotModel}}
RandomFields/man/RFplot.Rd: \command{\link{RMmodel}},
RandomFields/man/RFplot.Rd:model <- ~RMexp(s=S)
RandomFields/man/RMprod.Rd:\name{RMprod}
RandomFields/man/RMprod.Rd:\alias{RMprod}
RandomFields/man/RMprod.Rd: \command{\link{RMprod}} is a non-stationary covariance model given by
RandomFields/man/RMprod.Rd:RMprod(phi, var, scale, Aniso, proj)
RandomFields/man/RMprod.Rd:  \item{phi}{any function of class \code{\link[=RMmodel-class]{RMmodel}}
RandomFields/man/RMprod.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMprod.Rd: \command{\link{RMprod}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMprod.Rd:  Do not mix up this model with  \command{\link{RMmult}}.
RandomFields/man/RMprod.Rd:  See also \command{RMS} for a simple, alternative method to set
RandomFields/man/RMprod.Rd:  \command{\link{RMidcoord}},
RandomFields/man/RMprod.Rd:  \command{\link{RMidmodel}},
RandomFields/man/RMprod.Rd:  \command{\link{RMsum}},
RandomFields/man/RMprod.Rd:  \command{\link{RMmodel}},
RandomFields/man/RMprod.Rd:  \command{\link{RMmult}}.
RandomFields/man/RMprod.Rd:RFcov(RMprod(RMidcoord()), as.matrix(1:10), as.matrix(1:10), grid=FALSE)
RandomFields/man/RMprod.Rd:RFcov(RMprod(RMexp()), as.matrix(1:10), as.matrix(1:10), grid=FALSE)
RandomFields/man/RMprod.Rd:model <- RMprod(RMexp(scale=10))
RandomFields/man/RMsign.Rd:\name{RMsign}
RandomFields/man/RMsign.Rd:\alias{RMsign}
RandomFields/man/RMsign.Rd:  \command{RMsign} defines a random sign. It can be used as part of the
RandomFields/man/RMsign.Rd:RMsign(phi, p)
RandomFields/man/RMsign.Rd: \item{phi}{shape function of class \code{\link[=RMmodel-class]{RMmodel}}}
RandomFields/man/RMsign.Rd:  \command{RMsign} changes the sign of the shape function \code{phi}
RandomFields/man/RMsign.Rd: \command{\link{RMsign}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMsign.Rd:  Random univariate or multivariate objects usually start with \code{RR}, not with \code{RM}.
RandomFields/man/RMsign.Rd:  \command{\link{RMmodel}},
RandomFields/man/RMsign.Rd:model <- RPpoisson(RMsign(RMtent(), p=0.8))
RandomFields/man/RMmodelsMultivariate.Rd:\name{RMmodelsMultivariate}
RandomFields/man/RMmodelsMultivariate.Rd:\alias{RMmodelsMultivariate}
RandomFields/man/RMmodelsMultivariate.Rd:\alias{Multivariate RMmodels}
RandomFields/man/RMmodelsMultivariate.Rd:\title{Multivariate models}
RandomFields/man/RMmodelsMultivariate.Rd: \command{\link{RMbicauchy}} \tab a bivariate Cauchy model\cr
RandomFields/man/RMmodelsMultivariate.Rd: \command{\link{RMbiwm}} \tab full bivariate Whittle-Matern model (stationary and isotropic)\cr
RandomFields/man/RMmodelsMultivariate.Rd: \command{\link{RMbigneiting}} \tab bivariate Gneiting model (stationary and isotropic)\cr
RandomFields/man/RMmodelsMultivariate.Rd: \command{\link{RMbistable}} \tab a bivariate stable model\cr
RandomFields/man/RMmodelsMultivariate.Rd:   \command{\link{RMmatrix}} \tab linear model of coregionalization\cr
RandomFields/man/RMmodelsMultivariate.Rd:   \command{\link{RMS}} \tab see \link{RMSadvanced}\cr
RandomFields/man/RMmodelsMultivariate.Rd:   \command{\link{RMfixcov}} \tab for any kind of of covariance matrix a
RandomFields/man/RMmodelsMultivariate.Rd:\command{\link{RMcurlfree}} \tab curlfree (spatial) vector-valued field (stationary and anisotropic)\cr
RandomFields/man/RMmodelsMultivariate.Rd:\command{\link{RMdivfree}} \tab divergence free (spatial) vector-valued
RandomFields/man/RMmodelsMultivariate.Rd:\command{\link{RMkolmogorov}} \tab Kolmogorov's model of turbulence\cr
RandomFields/man/RMmodelsMultivariate.Rd:\command{\link{RMvector}} \tab vector-valued field (combining \command{\link{RMcurlfree}} and \command{\link{RMdivfree}})
RandomFields/man/RMmodelsMultivariate.Rd:\bold{Multivariate covariance models}
RandomFields/man/RMmodelsMultivariate.Rd:\command{\link{RMdelay}} \tab  delay effect model
RandomFields/man/RMmodelsMultivariate.Rd:\command{\link{RMderiv}} \tab field and its gradient\cr
RandomFields/man/RMmodelsMultivariate.Rd:\command{\link{RMmatrix}} \tab linear model of coregionalization\cr
RandomFields/man/RMmodelsMultivariate.Rd:\command{\link{RMparswm}} \tab multivariate Whittle-Matern model (stationary and isotropic)\cr
RandomFields/man/RMmodelsMultivariate.Rd:\command{\link{RMcov}} \tab covariance structure given by a multivariate variogram\cr 
RandomFields/man/RMmodelsMultivariate.Rd:\command{\link{RMexponential}} \tab functional returning \eqn{e^C}{exp(C)}\cr
RandomFields/man/RMmodelsMultivariate.Rd:\command{\link{RMmatrix}} \tab linear model of coregionalization\cr
RandomFields/man/RMmodelsMultivariate.Rd:\command{\link{RMmqam}} \tab multivariate quasi-arithmetic mean (stationary)\cr
RandomFields/man/RMmodelsMultivariate.Rd:\command{\link{RMschur}} \tab element-wise product with a positive definite
RandomFields/man/RMmodelsMultivariate.Rd:\command{\link{RMtbm}} \tab turning bands operator\cr
RandomFields/man/RMmodelsMultivariate.Rd:  \command{\link{RMshape}} \tab for explicit trend modelling\cr
RandomFields/man/RMmodelsMultivariate.Rd: \emph{Geostatistics. Modeling Spatial Uncertainty.}
RandomFields/man/RMmodelsMultivariate.Rd: % \item Gneiting, T. and Schlather, M. (2004)
RandomFields/man/RMmodelsMultivariate.Rd: \item Schlather, M. (2011) Construction of covariance functions and
RandomFields/man/RMmodelsMultivariate.Rd: unconditional simulation of random fields. In Porcu, E., Montero, J.M.
RandomFields/man/RMmodelsMultivariate.Rd: and Schlather, M., \emph{Space-Time Processes and Challenges Related
RandomFields/man/RMmodelsMultivariate.Rd: % \item Schlather, M. (2002) Models for stationary max-stable
RandomFields/man/RMmodelsMultivariate.Rd:   Schlather, M., Malinowski, A., Menck, P.J., Oesting, M. and
RandomFields/man/RMmodelsMultivariate.Rd:  Wackernagel, H. (2003) \emph{Multivariate Geostatistics.} Berlin:
RandomFields/man/RMmodelsMultivariate.Rd:\seealso{\command{\link{RFformula}}, \command{\link{RMmodels}},
RandomFields/man/RMmodelsMultivariate.Rd:   \command{\link{RM}},
RandomFields/man/RMmodelsMultivariate.Rd: \command{\link{RMmodelsAdvanced}}
RandomFields/man/RMmodelsMultivariate.Rd:model <- RMparswmX(nudiag=c(0.5, 0.5), rho=rho)
RandomFields/man/GaussianFields.Rd:\title{Methods for Gaussian Random Fields}
RandomFields/man/GaussianFields.Rd: \tab \tab \tab  \tab see \pkg{\link[spam:SPAM]{spam}} \tab \eqn{O(z + v
RandomFields/man/GaussianFields.Rd: \eqn{s = }\code{\link[=RMmodels]{scale}}\cr
RandomFields/man/GaussianFields.Rd: * * \command{\link{RMplus}}\tab any \tab any \tab any \tab O(v n) \tab
RandomFields/man/GaussianFields.Rd: * * \command{\link{RMS}}\tab any \tab any \tab any  \tab O(1) \tab O(v n) \tab\cr
RandomFields/man/GaussianFields.Rd: * * \command{\link{RMmult}}\tab any \tab any \tab any  \tab O(v n) \tab
RandomFields/man/GaussianFields.Rd:  \tab \tab  \tab see \pkg{\link[spam:SPAM]{spam}}+ O(v^2nk) \tab \eqn{O(z + v
RandomFields/man/GaussianFields.Rd: \emph{Geostatistics. Modeling Spatial Uncertainty.}
RandomFields/man/GaussianFields.Rd: % \item Gneiting, T. and Schlather, M. (2004)
RandomFields/man/GaussianFields.Rd: \item Schlather, M. (1999) \emph{An introduction to positive definite
RandomFields/man/GaussianFields.Rd: Technical report ST 99-10, Dept. of Maths and Statistics,
RandomFields/man/GaussianFields.Rd: \item Schlather, M. (2010)
RandomFields/man/GaussianFields.Rd: \item Schlather, M. (2011) Construction of covariance functions and
RandomFields/man/GaussianFields.Rd: unconditional simulation of random fields. In Porcu, E., Montero, J.M.
RandomFields/man/GaussianFields.Rd: and Schlather, M., \emph{Space-Time Processes and Challenges Related
RandomFields/man/GaussianFields.Rd: % \item Schlather, M. (2002) Models for stationary max-stable
RandomFields/man/GaussianFields.Rd: \item Yaglom, A.M. (1987) \emph{Correlation Theory of Stationary and
RandomFields/man/GaussianFields.Rd: \item Wackernagel, H. (2003) \emph{Multivariate Geostatistics.} Berlin:
RandomFields/man/GaussianFields.Rd:  \command{\link{RMmodel}},
RandomFields/man/GaussianFields.Rd:  \command{\link{RFgetMethodNames}},
RandomFields/man/GaussianFields.Rd:z <- RFsimulate(RMspheric(), x)
RandomFields/man/GaussianFields.Rd:z <- RFsimulate(RMspheric(), x, max_variab=10000)
RandomFields/man/RMgennsst.Rd:\name{RMgennsst}
RandomFields/man/RMgennsst.Rd:\alias{RMgennsst}
RandomFields/man/RMgennsst.Rd: \command{\link{RMgennsst}} is a univariate stationary spaceisotropic
RandomFields/man/RMgennsst.Rd:RMgennsst(phi, psi, dim_u, var, scale, Aniso, proj)
RandomFields/man/RMgennsst.Rd: \item{phi}{is a normal mixture \command{\link{RMmodel}}, cf.\cr
RandomFields/man/RMgennsst.Rd:    \code{RFgetModelNames(monotone="normal mixture")}.
RandomFields/man/RMgennsst.Rd:   \command{\link{RMmodel}}.}
RandomFields/man/RMgennsst.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMgennsst.Rd: \command{\link{RMgennsst}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMgennsst.Rd: \item Schlather, M. (2010)
RandomFields/man/RMgennsst.Rd: \command{\link{RMnsst}},
RandomFields/man/RMgennsst.Rd: \command{\link{RMmodel}},
RandomFields/man/RMgennsst.Rd:% RMgennsst( RMwhittle(nu=4, s=3), RMconstant(diag(3)))
RandomFields/man/RMtbm.Rd:\name{RMtbm}
RandomFields/man/RMtbm.Rd:\alias{RMtbm}
RandomFields/man/RMtbm.Rd:\title{Turning Bands Method}
RandomFields/man/RMtbm.Rd: \command{\link{RMtbm}} is a univariate or multivaraiate stationary isotropic covariance
RandomFields/man/RMtbm.Rd:RMtbm(phi, fulldim, reduceddim, layers, var, scale, Aniso, proj)
RandomFields/man/RMtbm.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMtbm.Rd: \command{\link{RMtbm}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMtbm.Rd:  which for \code{n=1} reduces to the standard TBM operator
RandomFields/man/RMtbm.Rd:    \emph{J. Math. Anal. Appl}, \bold{236}, 86-99
RandomFields/man/RMtbm.Rd:    Matheron, G. (1973).
RandomFields/man/RMtbm.Rd:    Strokorb, K., Ballani, F., and  Schlather, M. (2014)
RandomFields/man/RMtbm.Rd:    \item Schlather, M. (2011) Construction of covariance functions and
RandomFields/man/RMtbm.Rd:    unconditional simulation of random fields. In Porcu, E., Montero, J.M.
RandomFields/man/RMtbm.Rd:    and Schlather, M., \emph{Space-Time Processes and Challenges Related
RandomFields/man/RMtbm.Rd:model <- RMspheric()
RandomFields/man/RMtbm.Rd:plot(model, model.on.the.line=RMtbm(RMspheric()), xlim=c(-1.5, 1.5))
RandomFields/man/RMoesting.Rd:\name{RMflatpower}
RandomFields/man/RMoesting.Rd:\alias{RMflatpower}
RandomFields/man/RMoesting.Rd:\title{Variogram Model Similar to Fractal Brownian Motion}
RandomFields/man/RMoesting.Rd: \command{\link{RMflatpower}} is an intrinsically stationary isotropic variogram
RandomFields/man/RMoesting.Rd:  For related models see \command{\link{RMgenfbm}}.
RandomFields/man/RMoesting.Rd:RMflatpower(alpha, var, scale, Aniso, proj)
RandomFields/man/RMoesting.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMoesting.Rd: \command{\link{RMflatpower}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMoesting.Rd: \item Oesting, M., Schlather, M., and Friederichs, P. (2014)
RandomFields/man/RMoesting.Rd: Conditional Modelling of Extreme Wind Gusts
RandomFields/man/RMoesting.Rd: \command{\link{RMgenfbm}},
RandomFields/man/RMoesting.Rd: \command{\link{RMmodel}},
RandomFields/man/RMoesting.Rd:model <- RMflatpower(alpha=0.5)
RandomFields/man/RMsinepower.Rd:\name{RMsinepower}
RandomFields/man/RMsinepower.Rd:\alias{RMsinepower}
RandomFields/man/RMsinepower.Rd:\title{The Sinepower Covariance Model on the Sphere}
RandomFields/man/RMsinepower.Rd:  \command{\link{RMsinepower}} is an isotropic covariance model. The
RandomFields/man/RMsinepower.Rd:RMsinepower(alpha, var, scale, Aniso, proj)
RandomFields/man/RMsinepower.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMsinepower.Rd: Gneiting, T. (2013), equation (17). For a more general form see \command{\link{RMchoquet}}.
RandomFields/man/RMsinepower.Rd: \command{\link{RMsinepower}} returns an object of class \command{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMsinepower.Rd: \command{\link{RMmodel}},
RandomFields/man/RMsinepower.Rd: \command{\link{RMchoquet}}
RandomFields/man/RMsinepower.Rd:model <- RMsinepower(alpha=1.7)
RandomFields/man/RMbistable.Rd:\name{RMbistable}
RandomFields/man/RMbistable.Rd:\alias{RMbistable}
RandomFields/man/RMbistable.Rd:\title{Bivariate stable Model}
RandomFields/man/RMbistable.Rd: \command{\link{RMbistable}} is a bivariate stationary isotropic covariance model
RandomFields/man/RMbistable.Rd:RMbistable(alpha, s, cdiag, rho, rhored, betared, alphadiag, var, scale, Aniso, proj)
RandomFields/man/RMbistable.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMbistable.Rd: \command{\link{RMbistable}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMbistable.Rd: \item Moreva, O., Schlather, M. (2016) Modelling and simulation of bivariate Gaussian random fields.
RandomFields/man/RMbistable.Rd: \command{\link{RMstable}},
RandomFields/man/RMbistable.Rd: \link{Multivariate RMmodels}.
RandomFields/man/RMgencauchy.Rd:\name{RMgencauchy}
RandomFields/man/RMgencauchy.Rd:\alias{RMgencauchy}
RandomFields/man/RMgencauchy.Rd:\title{Generalized Cauchy Family Covariance Model}
RandomFields/man/RMgencauchy.Rd: \command{\link{RMgencauchy}} is a stationary isotropic covariance model
RandomFields/man/RMgencauchy.Rd: See also \command{\link{RMcauchy}}.
RandomFields/man/RMgencauchy.Rd:RMgencauchy(alpha, beta, var, scale, Aniso, proj)
RandomFields/man/RMgencauchy.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMgencauchy.Rd: More precisely, this model admits simulating random fields where fractal dimension
RandomFields/man/RMgencauchy.Rd: can be chosen independently (compare also with \command{\link{RMlgd}}): Here, we have
RandomFields/man/RMgencauchy.Rd: Note that the Cauchy Family (see \command{\link{RMcauchy}}) is included
RandomFields/man/RMgencauchy.Rd: \command{\link{RMgencauchy}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMgencauchy.Rd:    % functions. \emph{J. Multivariate Anal.} \bold{83} 493--508.
RandomFields/man/RMgencauchy.Rd:    \item Gneiting, T. and Schlather, M. (2004)
RandomFields/man/RMgencauchy.Rd:    \emph{SIAM review} \bold{46}, 269--282.
RandomFields/man/RMgencauchy.Rd:    \item Strokorb, K., Ballani, F., and  Schlather, M. (2014)
RandomFields/man/RMgencauchy.Rd: \command{\link{RMcauchy}},
RandomFields/man/RMgencauchy.Rd: \command{\link{RMcauchytbm}},
RandomFields/man/RMgencauchy.Rd: \command{\link{RMmodel}},
RandomFields/man/RMgencauchy.Rd:model <- RMgencauchy(alpha=1.5, beta=1.5, scale=0.3)
RandomFields/man/RFoptions.Rd:\alias{RC_VARIOGRAM}
RandomFields/man/RFoptions.Rd:    printed if simulated by TBM or random coin method. The value zero
RandomFields/man/RFoptions.Rd:    additional steps in the MLE methods are
RandomFields/man/RFoptions.Rd:    for models without range. See \command{\link{RMmodel}} or type
RandomFields/man/RFoptions.Rd:    \code{\link{RFgetModelNames}(type="positive definite",
RandomFields/man/RFoptions.Rd:    %RFsimulate(RPschlather(RMmatern(nu=2), xi=1, mu=1, s=1), x, grid=F, n=5)@data
RandomFields/man/RFoptions.Rd:    %RFsimulate(RPschlather(RMmatern(nu=2.01), xi=1, mu=1, s=1), x,grid=F,n=5)@data
RandomFields/man/RFoptions.Rd:    %RFsimulate(RPschlather(RMmatern(nu=2), xi=1, mu=1, s=1), x, grid=F, n=5)@data
RandomFields/man/RFoptions.Rd:    %RFsimulate(RPschlather(RMmatern(nu=2.01), xi=1, mu=1, s=1), x, grid=F,n=5)@data
RandomFields/man/RFoptions.Rd:    Certain models (e.g. \command{\link{RMfixcov}} and
RandomFields/man/RFoptions.Rd:    \command{\link{RMcovariate}}) 
RandomFields/man/RFoptions.Rd:  \item{\code{deltaAM}}{ 
RandomFields/man/RFoptions.Rd:    with \code{optim_mixed=2}. In this case, \code{deltaAM} is the number 
RandomFields/man/RFoptions.Rd:    positive; width of the grid on which the shape functions in the M3
RandomFields/man/RFoptions.Rd:    in the M3 representation of BR processes, the component \eqn{E} from
RandomFields/man/RFoptions.Rd:  \item{\code{max_variab}}{Maximal size of the covariance matrix.
RandomFields/man/RFoptions.Rd:    In case of the use of MCMC it leaves out \eqn{n-1}
RandomFields/man/RFoptions.Rd:    member of the Markov chain bevor the \eqn{n} member
RandomFields/man/RFoptions.Rd:    Minimal number of realisations to determine a quantity of the
RandomFields/man/RFoptions.Rd:    distribution by MCMC. E.g. to determine the integral value \eqn{c}
RandomFields/man/RFoptions.Rd:    Maximum number of allowed lines.
RandomFields/man/RFoptions.Rd:  \item{\code{flathull}}{\code{NA, FALSE, TRUE}. Only used in M3
RandomFields/man/RFoptions.Rd:    by MCMC, if the shape functions are random.
RandomFields/man/RFoptions.Rd:    In case of random shape functions, an MCMC step is required.
RandomFields/man/RFoptions.Rd:    \code{mcmc_zhou}-1 equals the number of members of the MCMC chain
RandomFields/man/RFoptions.Rd:    In case of random shape functions, an MCMC step is required.
RandomFields/man/RFoptions.Rd:    \code{mcmc_zhou}-1 equals the number of members of the MCMC chain
RandomFields/man/RFoptions.Rd:    In certain cases (\link{Coins},\link{RMtruncsupport}),
RandomFields/man/RFoptions.Rd:    Used in the internal function \code{RMscatter} that calculates
RandomFields/man/RFoptions.Rd:    %    see \code{size} and \code{max} in \code{\link{RMscatter}}.
RandomFields/man/RFoptions.Rd:      and \eqn{h_i \in M = \{ (k s, \ldots, k s),\ldots, (m s, \ldots, m
RandomFields/man/RFoptions.Rd:Model for different purposes are or can be stored at
RandomFields/man/RFoptions.Rd:  \item{\code{max_chol}}{integer. Maximum number of rows of a matrix in
RandomFields/man/RFoptions.Rd:  \item{\code{max_svd}}{integer. Maximum number of rows of a matrix in
RandomFields/man/RFoptions.Rd:	  an upper triangular matrix L, but still L^t L = M holds true.}
RandomFields/man/RFoptions.Rd:  \item{\code{multicopies}}{Only used by \command{\link{RMmult}}.
RandomFields/man/RFoptions.Rd:    the turning bands for \code{TBM2} and \code{TBM3}.
RandomFields/man/RFoptions.Rd:    traditional TBM is not applicable.
RandomFields/man/RFoptions.Rd:    \code{points} gives the number of points simulated on the TBM
RandomFields/man/RFoptions.Rd:    \code{TBMx.linesimufactor} and \code{TBMx.linesimustep}.
RandomFields/man/RFoptions.Rd:%Most of the above arguments determine the basic settings of a
RandomFields/man/RFoptions.Rd:      Schlather, M. (1999) \emph{An introduction to positive definite
RandomFields/man/RFoptions.Rd:      Technical report ST 99-10, Dept. of Maths and Statistics,
RandomFields/man/RFoptions.Rd:      \item Schlather, M. (2011) Construction of covariance functions and
RandomFields/man/RFoptions.Rd:      unconditional simulation of random fields. In Porcu, E., Montero, J.M.
RandomFields/man/RFoptions.Rd:      and Schlather, M., \emph{Space-Time Processes and Challenges Related
RandomFields/man/RFoptions.Rd:      % \item Schlather, M. (2002) Models for stationary max-stable
RandomFields/man/RFoptions.Rd:      Oesting, M., Schlather, M. and Zhou, C. (2013) On the Normalized
RandomFields/man/RFoptions.Rd:      Spectral Representation of Max-Stable Processes on a compact set. 
RandomFields/man/RFoptions.Rd:      Ballani, F. and Schlather, M. (2015) In preparation.
RandomFields/man/RFoptions.Rd: and \command{\link{RFgetMethodNames}}.}
RandomFields/man/RFoptions.Rd:model <- RMgauss()
RandomFields/man/RFoptions.Rd:  print(RFgetModelInfo(RFsimulate,which="internal")) # $internal$name)
RandomFields/man/RFlinearpart.Rd:\title{Linear part of \command{\link{RMmodel}}}
RandomFields/man/RFlinearpart.Rd: \item{model,params}{\argModel}
RandomFields/man/RFlinearpart.Rd: \command{\link{RMmodel}},
RandomFields/man/RFlinearpart.Rd:model <- RMexp(var=2, scale=1) + trend
RandomFields/man/RFlinearpart.Rd:model <- RMexp(var=NA, scale=NA) + trend
RandomFields/man/RMangle.Rd:\name{RMangle}
RandomFields/man/RMangle.Rd:\alias{RMangle}
RandomFields/man/RMangle.Rd:  \command{RMangle} delivers an anisotropy matrix for the
RandomFields/man/RMangle.Rd:  argument \code{Aniso} in \command{\link{RMmodel}} in two dimensions.
RandomFields/man/RMangle.Rd:  \command{RMangle} requires one or two stretching values, passed by
RandomFields/man/RMangle.Rd:RMangle(angle, lat.angle, ratio, diag) 
RandomFields/man/RMangle.Rd: \command{\link{RMangle}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMangle.Rd: \command{\link{RMtrafo}}, \command{\link{RMmodel}}
RandomFields/man/RMangle.Rd:model <- RMexp(Aniso=RMangle(angle=pi/4, ratio=3))
RandomFields/man/RMangle.Rd:model <- RMexp(Aniso=RMangle(angle=pi/4, lat.angle=pi/8, diag=c(1,2,3)))
RandomFields/man/RMangle.Rd:plot(z, MARGIN.slices=3)
RandomFields/man/RMangle.Rd:model <- RMexp(Aniso=RMangle(angle=pi/4, diag=c(1/4, 1/12)))
RandomFields/man/RMangle.Rd:estmodel <- RMexp(Aniso=RMangle(angle=NA, diag=c(NA, NA)))
RandomFields/man/RMpolynome.Rd:\name{RMpolynome}
RandomFields/man/RMpolynome.Rd:\alias{RMpolynome}
RandomFields/man/RMpolynome.Rd:RMpolynome(degree, dim, value=NA, coordnames = c("x", "y", "z", "T"),
RandomFields/man/RMpolynome.Rd: \command{\link{RMpolynome}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMpolynome.Rd:  \command{\link{RMshape}},
RandomFields/man/RMpolynome.Rd:## For further examples see the help page of 'RFformula' and 'RMshape'
RandomFields/man/RMpolynome.Rd:RMpolynome(1, 1)
RandomFields/man/RMpolynome.Rd:RMpolynome(3, 3)
RandomFields/man/RMmodelsSphere.Rd:\alias{RMmodelsSphere}
RandomFields/man/RMmodelsSphere.Rd:     \command{\link{RMbcw}} \tab Model bridging stationary and
RandomFields/man/RMmodelsSphere.Rd:       \command{\link{RMcubic}} \tab cubic model\cr
RandomFields/man/RMmodelsSphere.Rd:   \command{\link{RMdagum}} \tab Dagum model with \eqn{\beta < \gamma}
RandomFields/man/RMmodelsSphere.Rd:    \command{\link{RMexp}} \tab exponential model \cr
RandomFields/man/RMmodelsSphere.Rd:    \command{\link{RMgencauchy}} \tab generalized Cauchy family with
RandomFields/man/RMmodelsSphere.Rd:    \command{\link{RMmatern}} \tab Whittle-Matern model with
RandomFields/man/RMmodelsSphere.Rd:    \command{\link{RMstable}} \tab symmetric stable family or powered
RandomFields/man/RMmodelsSphere.Rd:    \command{\link{RMwhittle}} \tab Whittle-Matern model, alternative
RandomFields/man/RMmodelsSphere.Rd:   \command{\link{RMconstant}} \tab spatially constant model \cr
RandomFields/man/RMmodelsSphere.Rd:   \command{\link{RMnugget}} \tab nugget effect model \cr
RandomFields/man/RMmodelsSphere.Rd:      \command{\link{RMaskey}} \tab Askey's model\cr
RandomFields/man/RMmodelsSphere.Rd:      \command{\link{RMcircular}} \tab circular model\cr
RandomFields/man/RMmodelsSphere.Rd:     \command{\link{RMgengneiting}} \tab Wendland-Gneiting model;
RandomFields/man/RMmodelsSphere.Rd:   \command{\link{RMgneiting}} \tab differentiable model with compact
RandomFields/man/RMmodelsSphere.Rd:    \command{\link{RMspheric}} \tab spherical model \cr
RandomFields/man/RMmodelsSphere.Rd:    \command{\link{RMmult}}, \code{*} \tab product of covariance models \cr
RandomFields/man/RMmodelsSphere.Rd:    \command{\link{RMplus}}, \code{+} \tab sum of covariance models
RandomFields/man/RMmodelsSphere.Rd: \bold{See \link{RMmodels} for cartesian models.}
RandomFields/man/RMmodelsSphere.Rd:  \command{\link{RMmodels}},
RandomFields/man/RMmodelsSphere.Rd:  \command{\link{RMtrafo}}.
RandomFields/man/RMmodelsSphere.Rd:RFgetModelNames(isotropy=c("spherical isotropic"))
RandomFields/man/RMmodelsSphere.Rd:model <- RMexp(var=1.6, scale=0.5) + RMnugget(var=0) #exponential + nugget
RandomFields/man/RMmodelsSphere.Rd:z <- RFsimulate(RMwhittle(s=30, nu=0.45), coord, grid=TRUE) # takes 1 min
RandomFields/man/RMmodelsSphere.Rd:z <- RFsimulate(RMwhittle(s=500, nu=0.5), coord, grid=TRUE,
RandomFields/man/RMmodelsSphere.Rd:z <- RFsimulate(RMwhittle(s=500, nu=0.5), coord, grid=TRUE,
RandomFields/man/RMmodelsSphere.Rd:model <- RMprod(sigma) * RMtrafo(RMexp(s=500, proj="space"), "cartesian") *
RandomFields/man/RMmodelsSphere.Rd:  RMspheric(proj="time") 
RandomFields/man/RMmodelsSphere.Rd:plot(z, MARGIN.slices=3)
RandomFields/man/RPnugget.Rd:\title{Method to simulate the Nugget effect}
RandomFields/man/RPnugget.Rd: Method to simulate the Nugget effect. (Only for advanced users)
RandomFields/man/RPnugget.Rd: \item{phi}{object of class \code{\link[=RMmodel-class]{RMmodel}};
RandomFields/man/RPnugget.Rd: model for \code{phi} is \command{\link{RMnugget}}.}
RandomFields/man/RPnugget.Rd:   Mostly, the value of \code{vdim} is set automatically.
RandomFields/man/RPnugget.Rd:      This method only allows \command{\link{RMnugget}} as a submodel.
RandomFields/man/RPnugget.Rd:      should be given in \command{\link{RMnugget}}. There, only the
RandomFields/man/RPnugget.Rd:      Measurement errors are mathematically not distinguishable from spatial
RandomFields/man/RPnugget.Rd:      In this case \code{RMnugget()} models the measurement error (which
RandomFields/man/RPnugget.Rd:      On the other hand \code{RMnugget(Ansio=something)} and
RandomFields/man/RPnugget.Rd:      \code{RMnugget(proj=something)} model the spatial nugget effect
RandomFields/man/RPnugget.Rd:      the \link{RMnugget} is involved in the covariance model.
RandomFields/man/RPnugget.Rd: \code{\link[=RMmodel-class]{RMmodel}}. 
RandomFields/man/RPnugget.Rd: Schlather, M. (1999) \emph{An introduction to positive definite
RandomFields/man/RPnugget.Rd: Technical report ST 99-10, Dept. of Maths and Statistics,
RandomFields/man/RPnugget.Rd:model <- RMnugget(var = 100)
RandomFields/man/RPnugget.Rd:model <- RMnugget(proj =1)  
RandomFields/man/RPnugget.Rd:model <- RMnugget(Aniso=matrix(1, nr=2, nc=2))
RandomFields/man/RPnugget.Rd:model <- RMnugget()
RandomFields/man/RPnugget.Rd:model <- RMnugget(Aniso=diag(2))
RandomFields/man/RPnugget.Rd:model <- RMnugget(Aniso=matrix(c(1, 0, 0, 0), nc=2))
RandomFields/man/RPnugget.Rd:model <- RMnugget(proj=1)
RandomFields/man/RMmodelsTailcorrelation.Rd:\alias{RMmodelsTailCorrelation}
RandomFields/man/RMmodelsTailcorrelation.Rd:    \command{\link{RMbcw}} \tab Model bridging stationary and
RandomFields/man/RMmodelsTailcorrelation.Rd:    \command{\link{RMdagum}} \tab Dagum model with \eqn{\beta < \gamma}
RandomFields/man/RMmodelsTailcorrelation.Rd:    \command{\link{RMexp}} \tab exponential model \cr
RandomFields/man/RMmodelsTailcorrelation.Rd:    \command{\link{RMgencauchy}} \tab generalized Cauchy family with
RandomFields/man/RMmodelsTailcorrelation.Rd:    \command{\link{RMmatern}} \tab Whittle-Matern model with
RandomFields/man/RMmodelsTailcorrelation.Rd:    \command{\link{RMstable}} \tab symmetric stable family or powered
RandomFields/man/RMmodelsTailcorrelation.Rd:    \command{\link{RMwhittle}} \tab Whittle-Matern model, alternative
RandomFields/man/RMmodelsTailcorrelation.Rd:    \command{\link{RMnugget}} \tab nugget effect model \cr
RandomFields/man/RMmodelsTailcorrelation.Rd:      \command{\link{RMaskey}} \tab Askey's model\cr
RandomFields/man/RMmodelsTailcorrelation.Rd:      \command{\link{RMcircular}} \tab circular model\cr
RandomFields/man/RMmodelsTailcorrelation.Rd:       \command{\link{RMconstant}}\tab identically constant \cr
RandomFields/man/RMmodelsTailcorrelation.Rd:      \command{\link{RMcubic}} \tab cubic model\cr
RandomFields/man/RMmodelsTailcorrelation.Rd:   \command{\link{RMgengneiting}} \tab Wendland-Gneiting model;
RandomFields/man/RMmodelsTailcorrelation.Rd:   \command{\link{RMgneiting}} \tab differentiable model with compact
RandomFields/man/RMmodelsTailcorrelation.Rd:    \command{\link{RMspheric}} \tab spherical model \cr
RandomFields/man/RMmodelsTailcorrelation.Rd:    \command{\link{RMmult}}, \code{*} \tab product of covariance models \cr
RandomFields/man/RMmodelsTailcorrelation.Rd:    \command{\link{RMplus}}, \code{+} \tab sum of covariance models or variograms\cr
RandomFields/man/RMmodelsTailcorrelation.Rd:    \command{\link{RMbernoulli}} \tab correlation of binary fields\cr
RandomFields/man/RMmodelsTailcorrelation.Rd:    \command{\link{RMbrownresnick}}\tab tcf of a \link{Brown-Resnick} process\cr
RandomFields/man/RMmodelsTailcorrelation.Rd:    \command{\link{RMschlather}}\tab  tcf of an extremal Gaussian
RandomFields/man/RMmodelsTailcorrelation.Rd:    process / \link[=RMschlather]{Schlather} process \cr 
RandomFields/man/RMmodelsTailcorrelation.Rd:    \command{\link{RMm2r}}\tab M2 process with monotone shape function\cr
RandomFields/man/RMmodelsTailcorrelation.Rd:    \command{\link{RMm3b}}\tab M3 process with balls of random radius\cr
RandomFields/man/RMmodelsTailcorrelation.Rd:    \command{\link{RMmps}}\tab M3 process with hyperplane polygons\cr
RandomFields/man/RMmodelsTailcorrelation.Rd: \bold{See \link{RMmodels} for cartesian models.}
RandomFields/man/RMmodelsTailcorrelation.Rd:    Strokorb, K.,  Ballani, F.,  and Schlather, M. (2015)
RandomFields/man/RMmodelsTailcorrelation.Rd:  \link{RM},
RandomFields/man/RMmodelsTailcorrelation.Rd:  \command{\link{RMmodels}},
RandomFields/man/RMmodelsTailcorrelation.Rd:  \command{\link{RMtrafo}}.
RandomFields/man/RMmodelsTailcorrelation.Rd:RFgetModelNames(type="tail")
RandomFields/man/RMmodelsTailcorrelation.Rd:model <- RMexp(var=1.6, scale=0.5) + RMnugget(var=0) #exponential + nugget
RandomFields/man/RMidmodel.Rd:\name{RMidmodel}
RandomFields/man/RMidmodel.Rd:\alias{RMidmodel}
RandomFields/man/RMidmodel.Rd:\title{Identical Model}
RandomFields/man/RMidmodel.Rd:  \command{RMidmodel} is the identical operator on models, i.e.
RandomFields/man/RMidmodel.Rd:  for objects of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMidmodel.Rd:RMidmodel(phi, vdim, var, scale, Aniso, proj)
RandomFields/man/RMidmodel.Rd: \item{phi}{covariance function of class \code{\link[=RMmodel-class]{RMmodel}}}
RandomFields/man/RMidmodel.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMidmodel.Rd: \command{\link{RMidmodel}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMidmodel.Rd:  \command{\link{RMmodel}}.
RandomFields/man/RMidmodel.Rd:  \command{RMidcoord},
RandomFields/man/RMidmodel.Rd:  \command{RMtrafo},
RandomFields/man/RMidmodel.Rd:  \command{RMprod}
RandomFields/man/RMidmodel.Rd:model <- RMexp()
RandomFields/man/RMidmodel.Rd:model2 <- RMidmodel(model)
RandomFields/man/RMepscauchy.Rd:\name{RMepscauchy}
RandomFields/man/RMepscauchy.Rd:\alias{RMepscauchy}
RandomFields/man/RMepscauchy.Rd:\title{Generalized Cauchy Family Covariance Model}
RandomFields/man/RMepscauchy.Rd: \command{\link{RMepscauchy}} is a stationary isotropic covariance model
RandomFields/man/RMepscauchy.Rd: See also \command{\link{RMcauchy}}.
RandomFields/man/RMepscauchy.Rd:RMepscauchy(alpha, beta, eps, var, scale, Aniso, proj)
RandomFields/man/RMepscauchy.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMepscauchy.Rd: More precisely, this model admits simulating random fields where fractal dimension
RandomFields/man/RMepscauchy.Rd: can be chosen independently (compare also \command{\link{RMlgd}}): Here, we have
RandomFields/man/RMepscauchy.Rd: Note that the Cauchy Family (see \command{\link{RMcauchy}}) is included
RandomFields/man/RMepscauchy.Rd: \command{\link{RMepscauchy}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMepscauchy.Rd: % functions. \emph{J. Multivariate Anal.} \bold{83} 493--508.
RandomFields/man/RMepscauchy.Rd: \item Gneiting, T. and Schlather, M. (2004)
RandomFields/man/RMepscauchy.Rd: \emph{SIAM review} \bold{46}, 269--282.
RandomFields/man/RMepscauchy.Rd: \command{\link{RMcauchy}},
RandomFields/man/RMepscauchy.Rd: \command{\link{RMcauchytbm}},
RandomFields/man/RMepscauchy.Rd: \command{\link{RMmodel}},
RandomFields/man/RMepscauchy.Rd:model <- RMepscauchy(alpha=1.5, beta=1.5, scale=0.3, eps=0.5)
RandomFields/man/RMmodelgenerator-class.Rd:\name{RMmodelgenerator-class}
RandomFields/man/RMmodelgenerator-class.Rd:\alias{RMmodelgenerator-class}
RandomFields/man/RMmodelgenerator-class.Rd:\alias{show,RMmodelgenerator-method}
RandomFields/man/RMmodelgenerator-class.Rd:\alias{[,RMmodelgenerator-method}
RandomFields/man/RMmodelgenerator-class.Rd:\alias{[,RMmodelgenerator,ANY,ANY-method}
RandomFields/man/RMmodelgenerator-class.Rd:\alias{[,RMmodelgenerator,ANY,ANY,ANY-method}
RandomFields/man/RMmodelgenerator-class.Rd:\alias{[<-,RMmodelgenerator,ANY,ANY-method}
RandomFields/man/RMmodelgenerator-class.Rd:\alias{[<-,RMmodelgenerator,ANY,ANY,ANY-method}
RandomFields/man/RMmodelgenerator-class.Rd:\alias{[<-,RMmodelgenerator-method}
RandomFields/man/RMmodelgenerator-class.Rd:\alias{print.RMmodelgenerator}
RandomFields/man/RMmodelgenerator-class.Rd:\title{Class \code{RMmodelgenerator} }
RandomFields/man/RMmodelgenerator-class.Rd:\description{ Class for all functions of this package with prefix \code{RM},
RandomFields/man/RMmodelgenerator-class.Rd:  \code{\link[=RMmodel-class]{RMmodel}}; direct extension of
RandomFields/man/RMmodelgenerator-class.Rd: \command{\link[=RMmodel-class]{RMmodel}} }
RandomFields/man/RMmodelgenerator-class.Rd: RMmodel-function, see Details} 
RandomFields/man/RMmodelgenerator-class.Rd:\section{Methods}{
RandomFields/man/RMmodelgenerator-class.Rd: \item{[}{\code{signature(x = CLASS_RM)}: enables accessing
RandomFields/man/RMmodelgenerator-class.Rd: \item{[<-}{\code{signature(x = CLASS_RM)}: enables replacing
RandomFields/man/RMmodelgenerator-class.Rd:     \item{\code{'shape function'}:}{functions used in, e.g., M3 processes (\link{RPsmith})}
RandomFields/man/RMmodelgenerator-class.Rd:     \item{\code{'trend'}:}{\link{RMshape} or a \link[=RFformula]{mixed model} }
RandomFields/man/RMmodelgenerator-class.Rd: e.g. \code{\link{RMS}}}
RandomFields/man/RMmodelgenerator-class.Rd:\author{Alexander Malinowski, \martin}
RandomFields/man/RMmodelgenerator-class.Rd:    generated by Euclid's hat, \emph{J.  Multivariate Anal.},
RandomFields/man/RMmodelgenerator-class.Rd: \code{\link[=RMmodel-class]{RMmodel}},
RandomFields/man/RMmodelgenerator-class.Rd: \code{\link{RFgetModelNames}}
RandomFields/man/RMmodelgenerator-class.Rd:RFgetModelNames()
RandomFields/man/papers.S10.Rd: Schlather, M. (2010)
RandomFields/man/papers.S10.Rd:model <- RMcoxisham(mu=c(1, 1), D=matrix(nr=2, c(1, 0.5, 0.5, 1)),
RandomFields/man/papers.S10.Rd:                    RMwhittle(nu=1))
RandomFields/man/papers.S10.Rd:plot(z, MARGIN.slices=3, col=col)
RandomFields/man/papers.S10.Rd:plot(z, MARGIN.movie=3) # add 'file="ci.avi"' to get it stored
RandomFields/man/papers.S10.Rd:model <- RMave(A = matrix(nc=2,c(0.5, 0, 0, 1)), z= c(2,0),
RandomFields/man/papers.S10.Rd:               RMwhittle(nu=1))
RandomFields/man/papers.S10.Rd:model <- RMstp(M=matrix(nc=3, rep(0, 9)),
RandomFields/man/papers.S10.Rd:               S=RMetaxxa(E=c(1, 1, 1), alpha = -2 * pi,
RandomFields/man/papers.S10.Rd:               Aniso = RMrotation(phi= -2 * pi),
RandomFields/man/papers.S10.Rd:               phi = RMwhittle(nu = 1) )
RandomFields/man/RMbigneiting.Rd:\name{RMbigneiting}
RandomFields/man/RMbigneiting.Rd:\alias{RMbigneiting}
RandomFields/man/RMbigneiting.Rd:\alias{RMbiwendland}
RandomFields/man/RMbigneiting.Rd:\title{Gneiting-Wendland Covariance Models}
RandomFields/man/RMbigneiting.Rd: \command{\link{RMbigneiting}} is a bivariate stationary isotropic covariance
RandomFields/man/RMbigneiting.Rd: \code{\link{RMgengneiting}}, i.e.,
RandomFields/man/RMbigneiting.Rd:RMbigneiting(kappa, mu, s, sred12, gamma, cdiag, rhored, c, var, scale, Aniso, proj)
RandomFields/man/RMbigneiting.Rd: \command{\link{RMmodel}}. If not passed, the above
RandomFields/man/RMbigneiting.Rd: In the function \command{\link{RMbigneiting}}, either \code{c} is
RandomFields/man/RMbigneiting.Rd: \command{\link{RMbigneiting}} returns an object of class \code{\link[=RMmodel-class]{RMmodel}}.
RandomFields/man/RMbigneiting.Rd:    \item Bevilacqua, M., Daley, D.J., Porcu, E., Schlather, M. (2012)
RandomFields/man/RMbigneiting.Rd:    \code{RMbigeneiting} is based on this original work.
RandomFields/man/RMbigneiting.Rd:    D.J. Daley, E. Porcu and M. Bevilacqua have published end of 
RandomFields/man/RMbigneiting.Rd:    without clarifying the genuine authorship of \code{RMbigneiting},
RandomFields/man/RMbigneiting.Rd:    which has included \code{RMbigneiting} since version 3.0.5 (05 Dec
RandomFields/man/RMbigneiting.Rd:    \emph{Q. J. Roy. Meteor. Soc} Part A \bold{125}, 2449-2464.
RandomFields/man/RMbigneiting.Rd:    {Cambridge Monogr. Appl. Comput. Math.}
RandomFields/man/RMbigneiting.Rd: \command{\link{RMaskey}},
RandomFields/man/RMbigneiting.Rd: \command{\link{RMbiwm}},
RandomFields/man/RMbigneiting.Rd: \command{\link{RMgengneiting}},
RandomFields/man/RMbigneiting.Rd: \command{\link{RMgneiting}},
RandomFields/man/RMbigneiting.Rd: \command{\link{RMmodel}},
RandomFields/man/RMbigneiting.Rd:model <- RMbigneiting(kappa=2, mu=0.5, gamma=c(0, 3, 6), rhored=1)
RandomFields/man/papers.Rd:\title{Papers involving \pkg{RandomFields} and co-authored by M. Schlather}
RandomFields/man/papers.Rd: Here, an overview is given over the papers co-authored by M. Schlather
RandomFields/man/papers.Rd: Gneiting, T., Kleiber, W. and Schlather, M. (2010) Matern
RandomFields/man/papers.Rd: Gneiting, T., Sevcikova, H., Percival, D.B., Schlather, M., Jiang,
RandomFields/man/papers.Rd: Scheuerer, M. and Schlather, M. (2012) Covariance Models for Random
RandomFields/man/papers.Rd: Vector Fields. \emph{Stochastic Models}, \bold{82}, 433-451.
RandomFields/man/papers.Rd: Schlather, M. (2002) Models for stationary max-stable
RandomFields/man/papers.Rd: Schlather, M. (2010)
RandomFields/man/papers.Rd:   Schlather, M., Malinowski, A., Menck, P.J., Oesting, M. and
RandomFields/man/papers.Rd: Strokorb, K., Ballani, F. and Schlather, M. (2014)
RandomFields/man/papers.Rd: % Schlather, M. (2001) Simulation of stationary and isotropic random
RandomFields/configure.ac:CXX=`"${R_HOME}/bin/R" CMD config CXX`
RandomFields/configure.ac:AC_MSG_CHECKING([which SIMD flags can be recognized])
RandomFields/configure.ac:     AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]])], [ FX="$FX $AUTOCPPFLAGS" ], [ ])
RandomFields/configure.ac:  AC_MSG_RESULT([$AUTOCPPFLAGS])
RandomFields/configure.ac:  AC_MSG_RESULT([none])
RandomFields/configure.ac:RANDOMFIELDS_CXXFLAGS="$CXX_FLAGS $AUTOCPPFLAGS"
RandomFields/configure.ac:RANDOMFIELDS_LIBFLAGS="$LIB_FLAGS"
RandomFields/configure.ac:AC_SUBST(RANDOMFIELDS_CXXFLAGS)
RandomFields/configure.ac:AC_SUBST(RANDOMFIELDS_LIBFLAGS)
RandomFields/configure.ac:AC_CONFIG_FILES([src/Makevars])
RandomFields/configure:# Guess values for system-dependent variables and create Makefiles.
RandomFields/configure:## M4sh Initialization. ##
RandomFields/configure:DUALCASE=1; export DUALCASE # for MKS sh
RandomFields/configure:  NULLCMD=:
RandomFields/configure:# We did not find ourselves, most probably we were run as `sh COMMAND'
RandomFields/configure:for as_var in BASH_ENV ENV MAIL MAILPATH
RandomFields/configure:  NULLCMD=:
RandomFields/configure:## M4sh Shell Functions. ##
RandomFields/configure:as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
RandomFields/configure:  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)
RandomFields/configure:    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
RandomFields/configure:MFLAGS=
RandomFields/configure:MAKEFLAGS=
RandomFields/configure:PACKAGE_NAME='RandomFields'
RandomFields/configure:PACKAGE_TARNAME='randomfields'
RandomFields/configure:RANDOMFIELDS_LIBFLAGS
RandomFields/configure:RANDOMFIELDS_CXXFLAGS
RandomFields/configure:PACKAGE_TARNAME
RandomFields/configure:PACKAGE_NAME
RandomFields/configure:docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
RandomFields/configure:    # FIXME: should be removed in autoconf 3.0.
RandomFields/configure:# FIXME: To remove some day.
RandomFields/configure:# FIXME: To remove some day.
RandomFields/configure:# mess up M-x gdb in Emacs.
RandomFields/configure:for instance \`--prefix=\$HOME'.
RandomFields/configure:cat <<_ASUNAME
RandomFields/configure:_ASUNAME
RandomFields/configure:# Make two passes to allow for proper duplicate-argument suppression.
RandomFields/configure:#define PACKAGE_NAME "$PACKAGE_NAME"
RandomFields/configure:#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
RandomFields/configure:## Main body of script. ##
RandomFields/configure:CXX=`"${R_HOME}/bin/R" CMD config CXX`
RandomFields/configure:ac_clean_files="$ac_clean_files a.out a.out.dSYM a.exe b.out"
RandomFields/configure:    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
RandomFields/configure:# in a Makefile.  We should not override ac_cv_exeext if it was cached,
RandomFields/configure:    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj )
RandomFields/configure:rm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out
RandomFields/configure:    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
RandomFields/configure:    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM ) ;;
RandomFields/configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: checking which SIMD flags can be recognized" >&5
RandomFields/configure:$as_echo_n "checking which SIMD flags can be recognized... " >&6; }
RandomFields/configure:RANDOMFIELDS_CXXFLAGS="$CXX_FLAGS $AUTOCPPFLAGS"
RandomFields/configure:RANDOMFIELDS_LIBFLAGS="$LIB_FLAGS"
RandomFields/configure:ac_config_files="$ac_config_files src/Makevars"
RandomFields/configure:# Protect against shell expansion while executing Makefile rules.
RandomFields/configure:# Protect against Makefile macro expansion.
RandomFields/configure:## M4sh Initialization. ##
RandomFields/configure:DUALCASE=1; export DUALCASE # for MKS sh
RandomFields/configure:  NULLCMD=:
RandomFields/configure:# We did not find ourselves, most probably we were run as `sh COMMAND'
RandomFields/configure:for as_var in BASH_ENV ENV MAIL MAILPATH
RandomFields/configure:as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
RandomFields/configure:    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
RandomFields/configure:## Main body of $CONFIG_STATUS script. ##
RandomFields/configure:  CONFIG_COMMANDS = $CONFIG_COMMANDS
RandomFields/configure:      --file=FILE[:TEMPLATE]
RandomFields/configure:    "src/Makevars") CONFIG_FILES="$CONFIG_FILES src/Makevars" ;;
RandomFields/configure:# Have a temporary directory for convenience.  Make it in the build tree
RandomFields/configure:  tmp=./conf$$-$RANDOM
RandomFields/configure:# FIXME: This hack should be removed a few years after 2.60.
RandomFields/configure:# FIXME: do we really want to maintain this feature?
RandomFields/R/RFfit.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/RFfit.R:## Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/R/RFfit.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/RFfit.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/RFfit.R:##   source("~/R/RF/RandomFields/R/MLES.R")
RandomFields/R/RFfit.R:##   im prinzipt CMbuild, aber ruechwaers mit 1/newscale und eingefuegt
RandomFields/R/RFfit.R:#Beim paper lesen im Zug nach Muenchen heute morgen ist mir eine Referenz zu einem R Paket "mlegp: Maximum likelihood estimates of Gaussian processes" aufgefallen. Ist Dir aber sicher schon bekannt! 
RandomFields/R/RFfit.R:## fuer random effects -> BA/MA
RandomFields/R/RFfit.R:## REML fehlt
RandomFields/R/RFfit.R:## Erweiterungen: Emilio's Bi-MLE, Covarianz-Matrix-INversion per fft oder
RandomFields/R/RFfit.R:## !!! Mixed Model Equations !!! ##
RandomFields/R/RFfit.R:setMethod("[", signature = CLASS_FITLIST, def=accessByNameOrNumber)
RandomFields/R/RFfit.R:#effects_RMmodelFit <- function(...) stop("'effects' can only be used with the original and sp_conform output of 'R Ffit'.")
RandomFields/R/RFfit.R:#setMethod(f="effects", signature='R Ffit',
RandomFields/R/RFfit.R:#setMethod(f="effects", signature='RMmodelFit',
RandomFields/R/RFfit.R:#          definition=function(object, newdata=NULL) effects_RMmodelFit())#
RandomFields/R/RFfit.R:#effects.RM_mod elFit <- function(object, ...) effects_RMmodelFit()
RandomFields/R/RFfit.R:#effects.RF_ fit <- function(object, method="ml") effects_RMmodelFit()
RandomFields/R/RFfit.R:summary.RMmodelFit <- function(object, ..., isna.param) {
RandomFields/R/RFfit.R:  class(l) <- "summary.RMmodelFit"
RandomFields/R/RFfit.R:setMethod(f="summary", signature=CLASS_SINGLEFIT, summary.RMmodelFit)#
RandomFields/R/RFfit.R:print.summary.RMmodelFit <- function(x, ...) {
RandomFields/R/RFfit.R:print.RMmodelFit <- function(x, ...)
RandomFields/R/RFfit.R:  print.summary.RMmodelFit(summary.RMmodelFit(x, ...))#
RandomFields/R/RFfit.R:setMethod(f="show", signature=CLASS_SINGLEFIT,
RandomFields/R/RFfit.R:          definition=function(object) print.RMmodelFit(object))#
RandomFields/R/RFfit.R:  if (missing(method) || length(method) == 0) method <- METHOD_PREFLIST
RandomFields/R/RFfit.R:  s <- summary.RMmodelFit(if (IsS4) object[m] else object[[m]])
RandomFields/R/RFfit.R:  print.summary.RMmodelFit(summary.RFfit(x, ..., method=method, full=full))
RandomFields/R/RFfit.R:setMethod(f="show", signature=CLASS_FITLIST,
RandomFields/R/RFfit.R:setMethod(f="plot", signature(x=CLASS_FITLIST, y="missing"),
RandomFields/R/RFfit.R:setMethod(f="plot", signature(x=CLASS_SINGLEFIT, y="missing"),
RandomFields/R/RFfit.R:          function(x, y, ...) RFplotModel(x, ...))
RandomFields/R/RFfit.R:setMethod(f="persp", signature(x=CLASS_FITLIST),
RandomFields/R/RFfit.R:                || (is(x, CLASS_EMPIR) && is.list(x@centers))
RandomFields/R/RFfit.R:  parscale <- optim.control$parscale ## could be given by RMmodel!!
RandomFields/R/RFfit.R:                                     as.integer(MODEL_MLE),
RandomFields/R/Likelihoodratio.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/Likelihoodratio.R:## Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/R/Likelihoodratio.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/Likelihoodratio.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/Likelihoodratio.R:    ## MC ratio test
RandomFields/R/Likelihoodratio.R:     cat("\nMonte Carlo likelihood ratio test",
RandomFields/R/Likelihoodratio.R:         "\nnull model:", rfConvertRMmodel2string(x$model.list$nullmodel), 
RandomFields/R/Likelihoodratio.R:         "\nalt. model:", rfConvertRMmodel2string(x$model.list$alternative),
RandomFields/R/Likelihoodratio.R:            list(RM_MATRIX, M=diag(true.vdim)[, tot.v.proj[[k]], drop=FALSE],
RandomFields/R/Likelihoodratio.R:    if (printlevel >= PL_IMPORTANT)
RandomFields/R/Likelihoodratio.R:  if (!isSubmodel && printlevel >= PL_IMPORTANT)
RandomFields/R/Likelihoodratio.R:    if (printlevel>=PL_SUBIMPORTANT)
RandomFields/R/Likelihoodratio.R:    if (printlevel > PL_SUBIMPORTANT)
RandomFields/R/zzz.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/zzz.R:## Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/R/zzz.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/zzz.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/zzz.R:# sudo tar xvf ~/TMP/bwidget-1.9.5.tar 
RandomFields/R/zzz.R: # packageStartupMessage("This is RandomFields Version: 4.0.0.4") # ")
RandomFields/R/zzz.R:  packageStartupMessage("Note that a new package 'RandomFieldsLight' is upcoming,\nwhich offers a simplified access to modelling random fields.")
RandomFields/R/zzz.R:  packageStartupMessage(.Call("attachRandomFields"))
RandomFields/R/zzz.R:#  3) if C(maxh)/C(0) > 0.05  -> TBM else CE
RandomFields/R/Crossvalidation.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/Crossvalidation.R:## Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/R/Crossvalidation.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/Crossvalidation.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/Crossvalidation.R:  if (printlevel < PL_IMPORTANT) pch <- ""
RandomFields/R/Crossvalidation.R:  if (method %in%LSQMETHODS){
RandomFields/R/Crossvalidation.R:  } else if (method %in% MLMETHODS) {
RandomFields/R/Crossvalidation.R:    sub.methods <- LSQMETHODS
RandomFields/R/Crossvalidation.R:      if (printlevel >= PL_IMPORTANT && pch!="") cat(pch)
RandomFields/R/Crossvalidation.R:        if (printlevel <= PL_IMPORTANT && pch!="") cat("\n")
RandomFields/R/Crossvalidation.R:      if (printlevel <= PL_IMPORTANT && pch!="") cat("\n")
RandomFields/R/fitbr.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/fitbr.R:## Copyright (C) 2015 -- 2017  Martin Schlather
RandomFields/R/fitbr.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/fitbr.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/getNset.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/getNset.R:## Copyright (C) 2015 -- 2017  Martin Schlather
RandomFields/R/getNset.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/getNset.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/getNset.R:GetCurrentNrOfModels <- function() {
RandomFields/R/getNset.R:  .C(C_GetCurrentNrOfModels, nr=as.integer(1))$nr
RandomFields/R/getNset.R:## BEIM AUFRUF: entweder mit COPY = FALSE oder nachfolgend mit !hasArg("COPY")
RandomFields/R/getNset.R:                              SAVEOPTIONS=NULL, FORMER = FALSE, RETURN = TRUE){
RandomFields/R/getNset.R:  if (FORMER)
RandomFields/R/getNset.R:    if (FORMER) list(former, new) else new
RandomFields/R/getNset.R:  } else if (FORMER) former
RandomFields/R/getNset.R:             "RFcovariance" = MODEL_COV,
RandomFields/R/getNset.R:             "RFcovmatrix" = MODEL_COVMATRIX,
RandomFields/R/getNset.R:             "RFfctn" = MODEL_FCTN,
RandomFields/R/getNset.R:             "RFpseudovariogram" =  MODEL_PSEUDO,
RandomFields/R/getNset.R:             "RFvariogram" = MODEL_VARIOGRAM,
RandomFields/R/getNset.R:             "RFdistr" = MODEL_DISTR,
RandomFields/R/getNset.R:             "RFddistr" = MODEL_DISTR,
RandomFields/R/getNset.R:             "RFpdistr" = MODEL_DISTR,
RandomFields/R/getNset.R:             "RFqdistr" = MODEL_DISTR,
RandomFields/R/getNset.R:             "RFrdistr" = MODEL_DISTR,
RandomFields/R/getNset.R:             "RFcrossvalidate" =  MODEL_MLE,
RandomFields/R/getNset.R:             "RFfit" =  MODEL_MLE,
RandomFields/R/getNset.R:             "RFgui" =  MODEL_GUI,
RandomFields/R/getNset.R:             "RFlinearpart" = MODEL_USER,
RandomFields/R/getNset.R:             "RFratiotest" =  MODEL_MLE,
RandomFields/R/getNset.R:print_RFgetModelInfo <- function(x, max.level=99, short=TRUE,
RandomFields/R/getNset.R:                TYPEOF_PARAM_NAMES[types + 1], "\n"),
RandomFields/R/getNset.R:print.RFgetModelInfo <- function(x, ...) {
RandomFields/R/getNset.R:  print_RFgetModelInfo(x, ...) 
RandomFields/R/getNset.R:RFgetModelInfo <- function(...) {
RandomFields/R/getNset.R:  if (length(x) > 0 && is(x[[1]], CLASS_CLIST)) RFgetModelInfo_model(...)
RandomFields/R/getNset.R:  else RFgetModelInfo_register(...)
RandomFields/R/getNset.R:RFgetModelInfo_model <- function(model, params, dim = 1, Time = FALSE,
RandomFields/R/getNset.R:  Reg <- MODEL_AUX
RandomFields/R/getNset.R:  intern <- Try(.Call(C_SetAndGetModelFacts, Reg,
RandomFields/R/getNset.R:                           PrepareModel2(model, params=params,
RandomFields/R/getNset.R:  class(intern) <- "RFgetModelInfo"
RandomFields/R/getNset.R:RFgetModelInfo_register <- function(register, level=1, 
RandomFields/R/getNset.R:  ##  Print(which.submodels, as.list(RFgetModelInfo)$which.submodels[-1])  
RandomFields/R/getNset.R:                    as.list(RFgetModelInfo_register)$which.submodels[-1]) - 1)
RandomFields/R/getNset.R:    origin <- pmatch(origin, SORT_ORIGIN_NAMES) - 1
RandomFields/R/getNset.R:    if (!is.numeric(origin) || origin < 0 || origin >=length(SORT_ORIGIN_NAMES))
RandomFields/R/getNset.R:  cov <- .Call(C_GetModelInfo, as.integer(register), as.integer(level),
RandomFields/R/getNset.R:  class(cov) <- "RFgetModelInfo"
RandomFields/R/getNset.R:RFgetModel <- function(register, explicite.natscale, show.call=FALSE,
RandomFields/R/getNset.R:  modus <- (if (missing(explicite.natscale)) GETMODEL_AS_SAVED else
RandomFields/R/getNset.R:            if (explicite.natscale)  GETMODEL_DEL_NATSC else
RandomFields/R/getNset.R:            GETMODEL_SOLVE_NATSC)
RandomFields/R/getNset.R:    origin <- pmatch(origin, SORT_ORIGIN_NAMES) - 1
RandomFields/R/getNset.R:    if (!is.numeric(origin) || origin < 0 || origin >=length(SORT_ORIGIN_NAMES))
RandomFields/R/getNset.R:  m <- GetModel(register=register, modus=modus, which.submodels = which,
RandomFields/R/getNset.R:GetModel <- function(register, modus=GETMODEL_DEL_NATSC,
RandomFields/R/getNset.R:                     C_conform = TRUE, # coordinates of RMcovariate in R
RandomFields/R/getNset.R:                     ## STANDARD, ALLPARAMETERS, NOPARAMETERS,
RandomFields/R/getNset.R:                     ## INTERNALPARAMETER, INCLUDENOTRETURN,
RandomFields/R/getNset.R:  ##  AS_SAVED : Modell wie gespeichert
RandomFields/R/getNset.R:  ##  DEL_NATSC : Modell unter Annahme PracticalRange>0 (natsc werden geloescht)
RandomFields/R/getNset.R:  ##  DEL_MLE : nur natscale_MLE werden geloescht
RandomFields/R/getNset.R:  ##  SOLVE_MLE : nur natscale_MLE  zusammengezogen (natsc werden
RandomFields/R/getNset.R:  ##              if > 1 than also "+" is forced to be "RMplus"
RandomFields/R/getNset.R:            as.list(GetModel)$which.submodels[-1]) - 1
RandomFields/R/getNset.R:  return(.Call(C_GetModel, as.integer(register), as.integer(modus),
RandomFields/R/getNset.R:GetModelRegister <- function(name) { ## obsolete
RandomFields/R/getNset.R:  .C(C_GetModelRegister, name, integer(1))[[2]]
RandomFields/R/getNset.R:RFgetModelNames <- function(type = RC_TYPE_NAMES, domain = RC_DOMAIN_NAMES,
RandomFields/R/getNset.R:                            isotropy = RC_ISO_NAMES, operator = c(TRUE, FALSE),
RandomFields/R/getNset.R:                            monotone = RC_MONOTONE_NAMES,
RandomFields/R/getNset.R:    return(PrintModelList(operators=operator, internal = internal,
RandomFields/R/getNset.R:    return( .Call(C_GetAllModelNames, as.logical(newnames)) )
RandomFields/R/getNset.R:##  Print(type, TYPE_NAMES)
RandomFields/R/getNset.R:  if (hasArg(type)) type <- TYPE_NAMES[pmatch(type, TYPE_NAMES)]
RandomFields/R/getNset.R:  if (hasArg(domain)) domain <- DOMAIN_NAMES[pmatch(domain, DOMAIN_NAMES)]
RandomFields/R/getNset.R:  if (hasArg(isotropy)) isotropy <- ISO_NAMES[pmatch(isotropy, ISO_NAMES)]
RandomFields/R/getNset.R:  if (hasArg(monotone)) monotone <- MONOTONE_NAMES[pmatch(monotone, MONOTONE_NAMES)]
RandomFields/R/getNset.R:  if (any(is.na(pmatch(type, TYPE_NAMES))))
RandomFields/R/getNset.R:  if (any(is.na(pmatch(domain, DOMAIN_NAMES))))
RandomFields/R/getNset.R:  if (any(is.na(pmatch(isotropy, ISO_NAMES))))
RandomFields/R/getNset.R:  if (any(is.na(pmatch(monotone, MONOTONE_NAMES))))
RandomFields/R/getNset.R:	any(type %in% TYPE_NAMES[c(TcfType, PosDefType, VariogramType) + 1]) &&
RandomFields/R/getNset.R:	domain %in% DOMAIN_NAMES[1 + c(XONLY, KERNEL)])
RandomFields/R/getNset.R:      domain <- c(domain, DOMAIN_NAMES[c(PREVMODEL_D, SUBMODEL_D, PARAMDEP_D) + 1])
RandomFields/R/getNset.R:      idx <- which(type ==  TYPE_NAMES[1 + c(TcfType, PosDefType, VariogramType,
RandomFields/R/getNset.R:                                             GaussMethodType, 
RandomFields/R/getNset.R:                                             BrMethodType, SmithType,
RandomFields/R/getNset.R:	type <- TYPE_NAMES[1 + list(c(TcfType, ManifoldType),
RandomFields/R/getNset.R:				    c(TcfType, PosDefType, ManifoldType),
RandomFields/R/getNset.R:                                      ManifoldType),
RandomFields/R/getNset.R:				      ManifoldType),
RandomFields/R/getNset.R:				    c(GaussMethodType, BrMethodType, SmithType,
RandomFields/R/getNset.R:				    c(BrMethodType, SmithType, SchlatherType)
RandomFields/R/getNset.R:      list(do.call("RFgetModelNames", args))
RandomFields/R/getNset.R:    mon <- MONOTONE_NAMES[(MON_UNSET-1) : -1]
RandomFields/R/getNset.R:    for (i in MONOTONE:NORMAL_MIXTURE)
RandomFields/R/getNset.R:    if (mon[BERNSTEIN] %in% monotone) monotone <- c(monotone, mon[MONOTONE])
RandomFields/R/getNset.R:  all <- list2RMmodel_Names
RandomFields/R/getNset.R:    idx[i] <- is.function(fun) && is(fun, CLASS_RM) 
RandomFields/R/getNset.R:RFgetMethodNames <- function() {
RandomFields/R/getNset.R:  RFgetModelNames(type=TYPE_NAMES[c(GaussMethodType, BrMethodType) + 1])
RandomFields/R/getNset.R:RFformula <- function(f) return(parseModel(f, Env=.GlobalEnv,
RandomFields/R/getNset.R:  .Call(C_GetProcessType, MODEL_INTERN, list("RFdummy", model))
RandomFields/R/datasets.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/datasets.R:## Copyright (C) 2017 -- 2017 Martin Schlather
RandomFields/R/datasets.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/datasets.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/RFgui.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/RFgui.R:## Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/R/RFgui.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/RFgui.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/RFgui.R:      res <- list2RMmodel(GetModel(RFvariogram))
RandomFields/R/RFgui.R:  guiReg <- MODEL_GUI
RandomFields/R/RFgui.R:  OnModelSelected <- function(...)
RandomFields/R/RFgui.R:    if(exists("baseModel", envir=ENVIR)) {
RandomFields/R/RFgui.R:      baseParam <- get("baseModel", envir=ENVIR)$k
RandomFields/R/RFgui.R:        assign(paste("remember",selModelNum,sep=""), baseParam, envir=ENVIR)
RandomFields/R/RFgui.R:    # nun zum neuen Model
RandomFields/R/RFgui.R:    selModelNum <- .C(C_GetModelNr, as.character(modelChoice), nr=integer(1))$nr
RandomFields/R/RFgui.R:    selModelCountPar <- .C(C_GetNrParameters, selModelNum, k=integer(1) )$k
RandomFields/R/RFgui.R:    newmodel <- list(modelChoice, k=rep(NA, times=selModelCountPar))
RandomFields/R/RFgui.R:    minmax <- Try(.Call(C_SetAndGetModelFacts, guiReg,
RandomFields/R/RFgui.R:    selModelCountPar <- nrow(minmax)
RandomFields/R/RFgui.R:    assign("selModelNum",selModelNum, envir=ENVIR)
RandomFields/R/RFgui.R:    if (exists("baseModel", where=ENVIR)) remove("baseModel", envir=ENVIR)
RandomFields/R/RFgui.R:    if (selModelCountPar == 0) {
RandomFields/R/RFgui.R:      assign("baseModel", list(modelChoice), ENVIR)
RandomFields/R/RFgui.R:    baseParam <- rep(NA, times=selModelCountPar)
RandomFields/R/RFgui.R:    if(exists(paste("remember", selModelNum, sep=""), envir=ENVIR)) 
RandomFields/R/RFgui.R:      baseParam <- get(paste("remember", selModelNum, sep=""), envir=ENVIR)
RandomFields/R/RFgui.R:    ## selModelCountPar > 0 hier !!
RandomFields/R/RFgui.R:    for (i in 1:selModelCountPar) { ## nrow(minmax) ist kleinr als
RandomFields/R/RFgui.R:      ## selModelCountPar, wenn internal parameter dabei sind
RandomFields/R/RFgui.R:      else if (minmax[i, MINMAX_TYPE] == INTEGERPARAM) minmax[i, MINMAX_PMAX]
RandomFields/R/RFgui.R:      else if (minmax[i, MINMAX_PMIN] >=0)
RandomFields/R/RFgui.R:	0.25 * sum(sqrt(minmax[i, c(MINMAX_PMIN, MINMAX_PMAX)]))^2 + 0.1
RandomFields/R/RFgui.R:      else 0.5 * (minmax[i, MINMAX_PMIN] + minmax[i, MINMAX_PMAX])
RandomFields/R/RFgui.R:      resolution <- (if (minmax[i, MINMAX_TYPE]==INTEGERPARAM) -1
RandomFields/R/RFgui.R:		     else (minmax[i, MINMAX_PMAX] - minmax[i, MINMAX_PMIN]) /
RandomFields/R/RFgui.R:                         from= minmax[i, MINMAX_PMIN], 
RandomFields/R/RFgui.R:                         to = minmax[i, MINMAX_PMAX],
RandomFields/R/RFgui.R:    baseModel <- list(modelChoice, k=baseParam)
RandomFields/R/RFgui.R:    assign("baseModel", baseModel, ENVIR)
RandomFields/R/RFgui.R:    baseModel <- get("baseModel", envir=ENVIR)
RandomFields/R/RFgui.R:    if(length(baseModel$k) > 0)
RandomFields/R/RFgui.R:      for (i in 1:length(baseModel$k)) {
RandomFields/R/RFgui.R:  GetGuiModel <- function() {
RandomFields/R/RFgui.R:    baseParam <- baseModel$k
RandomFields/R/RFgui.R:    if(length(baseModel$k) > 0)
RandomFields/R/RFgui.R:      for (i in 1:length(baseModel$k)) { 
RandomFields/R/RFgui.R:    baseModel$k <- baseParam
RandomFields/R/RFgui.R:      newmodel <- list(SYMBOL_PLUS,
RandomFields/R/RFgui.R:                    list(DOLLAR[1], var=variance, scale=scale, baseModel),
RandomFields/R/RFgui.R:                    list(DOLLAR[1], var=nugget, list(RM_NUGGET[1])))
RandomFields/R/RFgui.R:      newmodel <- list(SYMBOL_PLUS,
RandomFields/R/RFgui.R:                    list(DOLLAR[1], var=variance, aniso=aniso, baseModel),
RandomFields/R/RFgui.R:                    list(DOLLAR[1], var=nugget, list(RM_NUGGET[1])))
RandomFields/R/RFgui.R:    if(!exists("baseModel",envir=ENVIR)) {
RandomFields/R/RFgui.R:    #baseModel <- get("baseModel",envir=ENVIR)
RandomFields/R/RFgui.R:    newmodel <- GetGuiModel()
RandomFields/R/RFgui.R:      tranMatrix <- persp(x=xcov, y=ycov, z=cv,
RandomFields/R/RFgui.R:        points(trans3d(xcov[1], ycov[1], cv00, pmat = tranMatrix), pch =16)
RandomFields/R/RFgui.R:   #   Print(GetGuiModel())
RandomFields/R/RFgui.R:    setRFoptions(storing=c(FALSE, MODEL_GUI))
RandomFields/R/RFgui.R:    tkGridConf(labModelSelect, column=col.sl, row=row.sl)
RandomFields/R/RFgui.R:    if(exists("baseModel", envir=ENVIR)) {
RandomFields/R/RFgui.R:      baseModel <- get("baseModel",envir=ENVIR)
RandomFields/R/RFgui.R:      baseParam <- baseModel$k
RandomFields/R/RFgui.R:      if(length(baseModel$k) > 0)
RandomFields/R/RFgui.R:        for (i in 1:length(baseModel$k)) { 
RandomFields/R/RFgui.R:  if (exists("baseModel", where=ENVIR)) remove("baseModel", envir=ENVIR)
RandomFields/R/RFgui.R:    nuggetMin <- 0
RandomFields/R/RFgui.R:    nuggetMax <- 10
RandomFields/R/RFgui.R:    nuggetMin <- 0 ## nugget/10
RandomFields/R/RFgui.R:    nuggetMax <- max(ev@empirical[idx1])
RandomFields/R/RFgui.R:  varianceMin <- Round(log(0.01))
RandomFields/R/RFgui.R:  varianceMax <- log(max(1e-10, nuggetMax))
RandomFields/R/RFgui.R:  scaleMin <- Round(log(0.1*scale))  
RandomFields/R/RFgui.R:  scaleMax <- Round(log(10*scale))   
RandomFields/R/RFgui.R:  radiusMax <- 2
RandomFields/R/RFgui.R:  tcltk::tkwm.protocol(tt, "WM_DELETE_WINDOW", OnReturn)
RandomFields/R/RFgui.R:  labModelSelect <- tkLabel(tt,text="Model Selection")
RandomFields/R/RFgui.R:  textModell <- tkVar("Please select a model...")
RandomFields/R/RFgui.R:  comboBox <- tkCombobox(tt,textvariable=textModell, state="readonly",
RandomFields/R/RFgui.R:  tkBind(comboBox, "<<ComboboxSelected>>", OnModelSelected)
RandomFields/R/RFgui.R:  slScaleA <- tkScale(tt, command = Plot, from=scaleMin, to=scaleMax,
RandomFields/R/RFgui.R:                      resolution=-radiusMax/numberSteps, orient="horizontal",
RandomFields/R/RFgui.R:  slScaleB <- tkScale(tt, command = Plot, from=scaleMin, to=scaleMax,
RandomFields/R/RFgui.R:                      resolution=-radiusMax/numberSteps, orient="horizontal",
RandomFields/R/RFgui.R:  slScale <- tkScale(tt, command = Plot, from=scaleMin, to=scaleMax,
RandomFields/R/RFgui.R:                            resolution=-(scaleMax-scaleMin)/numberSteps,
RandomFields/R/RFgui.R:  slVariance <- tkScale(tt, command = Plot, from=varianceMin,
RandomFields/R/RFgui.R:                               to=varianceMax,
RandomFields/R/RFgui.R:                               resolution=(varianceMin-varianceMax)/numberSteps,
RandomFields/R/RFgui.R:  slNugget <- tkScale(tt, command = Plot, from=nuggetMin, to=nuggetMax,
RandomFields/R/RFgui.R:                             resolution=-(nuggetMax-nuggetMin)/numberSteps,
RandomFields/R/Methods-RFsp.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/Methods-RFsp.R:## Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/R/Methods-RFsp.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/Methods-RFsp.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/Methods-RFsp.R:setMethod("RFspDataFrame2dataArray", signature=c("RFspatialGridDataFrame"),
RandomFields/R/Methods-RFsp.R:setMethod("RFspDataFrame2dataArray", signature=c("RFgridDataFrame"),
RandomFields/R/Methods-RFsp.R:setMethod("GridTopology2gridVectors",
RandomFields/R/Methods-RFsp.R:setMethod("GridTopology2gridVectors",
RandomFields/R/Methods-RFsp.R:setMethod(f = "coordinates", signature="RFpointsDataFrame",
RandomFields/R/Methods-RFsp.R:setMethod(f = "coordinates", signature="RFgridDataFrame",
RandomFields/R/Methods-RFsp.R:setMethod(f = "variance", signature="RFspatialGridDataFrame",
RandomFields/R/Methods-RFsp.R:setMethod(f = "variance", signature="RFspatialPointsDataFrame",
RandomFields/R/Methods-RFsp.R:setMethod(f = "variance", signature="RFgridDataFrame", 
RandomFields/R/Methods-RFsp.R:setMethod(f = "variance", signature="RFpointsDataFrame",
RandomFields/R/Methods-RFsp.R:setMethod(f="show", signature="RFpointsDataFrame",
RandomFields/R/Methods-RFsp.R:setMethod(f="show", signature="RFgridDataFrame", 
RandomFields/R/Methods-RFsp.R:setMethod(f="show", signature="RFspatialPointsDataFrame", 
RandomFields/R/Methods-RFsp.R:setMethod(f="show", signature="RFspatialGridDataFrame", 
RandomFields/R/Methods-RFsp.R:##setMethod(f="isGridded", signature="RFsp", 
RandomFields/R/Methods-RFsp.R:#setMethod(f="isGridded", "RFgridDataFrame", function(obj) TRUE)
RandomFields/R/Methods-RFsp.R:#setMethod(f="isGridded", "RFpointsDataFrame", function(obj) FALSE)
RandomFields/R/Methods-RFsp.R:#setMethod(f="isGridded", "RFspatialGridDataFrame", function(obj) TRUE)
RandomFields/R/Methods-RFsp.R:#setMethod(f="isGridded", "RFspatialPointsDataFrame", function(obj) FALSE)
RandomFields/R/Methods-RFsp.R:setMethod(f="dimensions", signature="RFspatialGridDataFrame", 
RandomFields/R/Methods-RFsp.R:	  function(obj) (getMethod("dimensions", "Spatial")@.Data)(obj) )
RandomFields/R/Methods-RFsp.R:setMethod(f="dimensions", signature="RFspatialPointsDataFrame", 
RandomFields/R/Methods-RFsp.R:	  function(obj) (getMethod("dimensions", "Spatial")@.Data)(obj) )
RandomFields/R/Methods-RFsp.R:setMethod(f="dimensions", signature="RFgridDataFrame", 
RandomFields/R/Methods-RFsp.R:setMethod(f="dimensions", signature="RFpointsDataFrame", 
RandomFields/R/Methods-RFsp.R:setMethod("[", signature=c("RFgridDataFrame"), def=brack)
RandomFields/R/Methods-RFsp.R:setMethod("[", signature=c("RFpointsDataFrame"), def=brack)
RandomFields/R/Methods-RFsp.R:setMethod("[", signature=c("RFspatialGridDataFrame"), def=brack)
RandomFields/R/Methods-RFsp.R:setMethod("[", signature=c("RFspatialPointsDataFrame"), def=brack)
RandomFields/R/Methods-RFsp.R:setMethod("[<-", signature=c("RFgridDataFrame", "ANY", "ANY"),
RandomFields/R/Methods-RFsp.R:setMethod("[<-", signature=c("RFpointsDataFrame", "ANY", "ANY"),
RandomFields/R/Methods-RFsp.R:setMethod("[<-", signature=c("RFspatialGridDataFrame", "ANY", "ANY"),
RandomFields/R/Methods-RFsp.R:setMethod("[<-", signature=c("RFspatialPointsDataFrame", "ANY", "ANY"),
RandomFields/R/Methods-RFsp.R:#setMethod("[<-", signature=c("RFgridDataFrame"), brackpfeil)
RandomFields/R/Methods-RFsp.R:#setMethod("[<-", signature=c("RFpointsDataFrame"), brackpfeil)
RandomFields/R/Methods-RFsp.R:#setMethod("[<-", signature=c("RFspatialGridDataFrame"), brackpfeil)
RandomFields/R/Methods-RFsp.R:#setMethod("[<-", signature=c("RFspatialPointsDataFrame"), brackpfeil)
RandomFields/R/RFempvario-Methods-plots.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/RFempvario-Methods-plots.R:## Copyright (C) 2012 -- 2014 Alexander Malinowski & Martin Schlather
RandomFields/R/RFempvario-Methods-plots.R:##               2015 -- 2017 Martin Schlather
RandomFields/R/RFempvario-Methods-plots.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/RFempvario-Methods-plots.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/RFempvario-Methods-plots.R:## Methods for classes 'RFempVario' and CLASS_FITLIST  #######################
RandomFields/R/RFempvario-Methods-plots.R:  cat("Object of class '", CLASS_EMPIR, "'\n", sep="")
RandomFields/R/RFempvario-Methods-plots.R:setMethod(f="show", signature=CLASS_EMPIR,
RandomFields/R/RFempvario-Methods-plots.R:setAs(CLASS_EMPIR, "list",
RandomFields/R/RFempvario-Methods-plots.R:setAs(CLASS_FITLIST, CLASS_EMPIR, def=function(from) from@ev)
RandomFields/R/RFempvario-Methods-plots.R:    if (!is(x, CLASS_EMPIR))
RandomFields/R/RFempvario-Methods-plots.R:      stop("method only for objects of class '", CLASS_EMPIR, "' or '",
RandomFields/R/RFempvario-Methods-plots.R:             else if (alpha == as.integer(alpha)) FCTN_TYPE_NAMES[alpha + 3]
RandomFields/R/RFempvario-Methods-plots.R:             paste(FCTN_TYPE_NAMES[alpha + 3], "plot")
RandomFields/R/RFempvario-Methods-plots.R:                             is(x, CLASS_CLIST) || ## model as RMmodel
RandomFields/R/RFempvario-Methods-plots.R:    ## stille Zeitkomponent moeglich, die aber das Modell braucht
RandomFields/R/RFempvario-Methods-plots.R:setMethod(f="plot", signature(x=CLASS_EMPIR, y="missing"),
RandomFields/R/RMmodels.R:## This file has been created automatically by 'rfGenerateModels'.
RandomFields/R/RMmodels.R:RMplus <- function(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, trend, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMplus', 
RandomFields/R/RMmodels.R:RMplus <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMplus,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:RMmult <- function(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMmult', 
RandomFields/R/RMmodels.R:RMmult <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMmult,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:RMS  <- function(phi, var, scale, Aniso, proj, anisoT) {
RandomFields/R/RMmodels.R:	par.model[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMS', 
RandomFields/R/RMmodels.R:RMS <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMS,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:RMave <- function(phi, A, z, spacetime, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMave', 
RandomFields/R/RMmodels.R:RMave <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMave,
RandomFields/R/RMmodels.R:RMbcw <- function(alpha, beta, const, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMbcw', 
RandomFields/R/RMmodels.R:RMbcw <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMbcw,
RandomFields/R/RMmodels.R:RMlsfbm <- function(alpha, const, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMlsfbm', 
RandomFields/R/RMmodels.R:RMlsfbm <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMlsfbm,
RandomFields/R/RMmodels.R:RMbessel <- function(nu, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMbessel', 
RandomFields/R/RMmodels.R:RMbessel <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMbessel,
RandomFields/R/RMmodels.R:RMbigneiting <- function(kappa, mu, s, sred12, gamma, cdiag, rhored, c, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMbigneiting', 
RandomFields/R/RMmodels.R:RMbigneiting <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMbigneiting,
RandomFields/R/RMmodels.R:	maxdim = PARAM_DEP,
RandomFields/R/RMmodels.R:RMbernoulli <- function(phi, threshold, correlation, centred, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMbernoulli', 
RandomFields/R/RMmodels.R:RMbernoulli <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMbernoulli,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:RMbiwm <- function(nudiag, nured12, nu, s, cdiag, rhored, c, notinvnu, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMbiwm', 
RandomFields/R/RMmodels.R:RMbiwm <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMbiwm,
RandomFields/R/RMmodels.R:RMbistable <- function(alpha, s, cdiag, rho, rhored, betared, alphadiag, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMbistable', 
RandomFields/R/RMmodels.R:RMbistable <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMbistable,
RandomFields/R/RMmodels.R:RMblend <- function(multi, blend, thresholds, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMblend', 
RandomFields/R/RMmodels.R:RMblend <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMblend,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:RMbrownresnick <- function(phi, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMbrownresnick', 
RandomFields/R/RMmodels.R:RMbrownresnick <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMbrownresnick,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:RMbr2bg <- function(phi, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMbr2bg', 
RandomFields/R/RMmodels.R:RMbr2bg <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMbr2bg,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:RMbr2eg <- function(phi, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMbr2eg', 
RandomFields/R/RMmodels.R:RMbr2eg <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMbr2eg,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:RMbubble <- function(phi, scaling, z, weight, minscale, barycentre, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMbubble', 
RandomFields/R/RMmodels.R:RMbubble <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMbubble,
RandomFields/R/RMmodels.R:RMcauchy <- function(gamma, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMcauchy', 
RandomFields/R/RMmodels.R:RMcauchy <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMcauchy,
RandomFields/R/RMmodels.R:RMcauchyUnif1 <- function(eps, b, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMcauchyUnif1', 
RandomFields/R/RMmodels.R:RMcauchyUnif1 <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMcauchyUnif1,
RandomFields/R/RMmodels.R:RMcauchyUnif2 <- function(eps, b, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMcauchyUnif2', 
RandomFields/R/RMmodels.R:RMcauchyUnif2 <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMcauchyUnif2,
RandomFields/R/RMmodels.R:RMcauchyUnif3 <- function(eps, b, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMcauchyUnif3', 
RandomFields/R/RMmodels.R:RMcauchyUnif3 <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMcauchyUnif3,
RandomFields/R/RMmodels.R:RMlatentCauchy1 <- function(a, b, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMlatentCauchy1', 
RandomFields/R/RMmodels.R:RMlatentCauchy1 <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMlatentCauchy1,
RandomFields/R/RMmodels.R:RMlatentCauchy2 <- function(a, b, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMlatentCauchy2', 
RandomFields/R/RMmodels.R:RMlatentCauchy2 <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMlatentCauchy2,
RandomFields/R/RMmodels.R:RMlatentCauchy3 <- function(a, b, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMlatentCauchy3', 
RandomFields/R/RMmodels.R:RMlatentCauchy3 <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMlatentCauchy3,
RandomFields/R/RMmodels.R:RMlatentCauchy4 <- function(a, b, gamma, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMlatentCauchy4', 
RandomFields/R/RMmodels.R:RMlatentCauchy4 <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMlatentCauchy4,
RandomFields/R/RMmodels.R:RMcircular <- function(var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMcircular', 
RandomFields/R/RMmodels.R:RMcircular <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMcircular,
RandomFields/R/RMmodels.R:RMconstant <- function(M, var) {
RandomFields/R/RMmodels.R:  if (hasArg('M') && !is.null(subst <- substitute(M))) 
RandomFields/R/RMmodels.R:	par.model[['M']] <- CheckArg(M, subst, TRUE)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMconstant', 
RandomFields/R/RMmodels.R:RMconstant <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMconstant,
RandomFields/R/RMmodels.R:	vdim = PARAM_DEP
RandomFields/R/RMmodels.R:iRMfixcov <- function(M, x, raw, givenM, var, proj) {
RandomFields/R/RMmodels.R:  if (hasArg('M') && !is.null(subst <- substitute(M))) 
RandomFields/R/RMmodels.R:	par.model[['M']] <- CheckArg(M, subst, TRUE)
RandomFields/R/RMmodels.R:  if (hasArg('givenM') && !is.null(subst <- substitute(givenM))) 
RandomFields/R/RMmodels.R:	par.model[['givenM']] <- CheckArg(givenM, subst, TRUE)
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMfixcov', 
RandomFields/R/RMmodels.R:iRMfixcov <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = iRMfixcov,
RandomFields/R/RMmodels.R:	vdim = PARAM_DEP
RandomFields/R/RMmodels.R:RMcoxisham <- function(phi, mu, D, beta, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMcoxisham', 
RandomFields/R/RMmodels.R:RMcoxisham <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMcoxisham,
RandomFields/R/RMmodels.R:RMcubic <- function(var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMcubic', 
RandomFields/R/RMmodels.R:RMcubic <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMcubic,
RandomFields/R/RMmodels.R:RMcurlfree <- function(phi, which, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMcurlfree', 
RandomFields/R/RMmodels.R:RMcurlfree <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMcurlfree,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:	vdim = PARAM_DEP
RandomFields/R/RMmodels.R:RMcutoff <- function(phi, diameter, a, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMcutoff', 
RandomFields/R/RMmodels.R:RMcutoff <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMcutoff,
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:RMdagum <- function(beta, gamma, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMdagum', 
RandomFields/R/RMmodels.R:RMdagum <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMdagum,
RandomFields/R/RMmodels.R:RMdampedcos <- function(lambda, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMdampedcos', 
RandomFields/R/RMmodels.R:RMdampedcos <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMdampedcos,
RandomFields/R/RMmodels.R:	maxdim = PARAM_DEP,
RandomFields/R/RMmodels.R:RMderiv <- function(phi, which, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMderiv', 
RandomFields/R/RMmodels.R:RMderiv <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMderiv,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:	vdim = PARAM_DEP
RandomFields/R/RMmodels.R:RMdewijsian <- function(alpha, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMdewijsian', 
RandomFields/R/RMmodels.R:RMdewijsian <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMdewijsian,
RandomFields/R/RMmodels.R:RMdivfree <- function(phi, which, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMdivfree', 
RandomFields/R/RMmodels.R:RMdivfree <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMdivfree,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:	vdim = PARAM_DEP
RandomFields/R/RMmodels.R:RMepscauchy <- function(alpha, beta, eps, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMepscauchy', 
RandomFields/R/RMmodels.R:RMepscauchy <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMepscauchy,
RandomFields/R/RMmodels.R:RMexp <- function(var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMexp', 
RandomFields/R/RMmodels.R:RMexp <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMexp,
RandomFields/R/RMmodels.R:RMexponential <- function(phi, n, standardised, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMexponential', 
RandomFields/R/RMmodels.R:RMexponential <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMexponential,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:RMschlather <- function(phi, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMschlather', 
RandomFields/R/RMmodels.R:RMschlather <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMschlather,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:RMfractdiff <- function(alpha, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMfractdiff', 
RandomFields/R/RMmodels.R:RMfractdiff <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMfractdiff,
RandomFields/R/RMmodels.R:RMflatpower <- function(alpha, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMflatpower', 
RandomFields/R/RMmodels.R:RMflatpower <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMflatpower,
RandomFields/R/RMmodels.R:RMfbm <- function(alpha, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMfbm', 
RandomFields/R/RMmodels.R:RMfbm <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMfbm,
RandomFields/R/RMmodels.R:RMfractgauss <- function(alpha, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMfractgauss', 
RandomFields/R/RMmodels.R:RMfractgauss <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMfractgauss,
RandomFields/R/RMmodels.R:RMgauss <- function(var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMgauss', 
RandomFields/R/RMmodels.R:RMgauss <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMgauss,
RandomFields/R/RMmodels.R:RMgaussgauss <- function(nu, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMgaussgauss', 
RandomFields/R/RMmodels.R:RMgaussgauss <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMgaussgauss,
RandomFields/R/RMmodels.R:RMgaussGammalike <- function(m, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMgaussGammalike', 
RandomFields/R/RMmodels.R:RMgaussGammalike <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMgaussGammalike,
RandomFields/R/RMmodels.R:RMgenfbm <- function(alpha, beta, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMgenfbm', 
RandomFields/R/RMmodels.R:RMgenfbm <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMgenfbm,
RandomFields/R/RMmodels.R:RMgencauchy <- function(alpha, beta, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMgencauchy', 
RandomFields/R/RMmodels.R:RMgencauchy <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMgencauchy,
RandomFields/R/RMmodels.R:RMbicauchy <- function(alpha, beta, s, rho, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMbicauchy', 
RandomFields/R/RMmodels.R:RMbicauchy <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMbicauchy,
RandomFields/R/RMmodels.R:RMgengneiting <- function(kappa, mu, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMgengneiting', 
RandomFields/R/RMmodels.R:RMgengneiting <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMgengneiting,
RandomFields/R/RMmodels.R:RMgneiting <- function(orig, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMgneiting', 
RandomFields/R/RMmodels.R:RMgneiting <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMgneiting,
RandomFields/R/RMmodels.R:	maxdim = PARAM_DEP,
RandomFields/R/RMmodels.R:RMgennsst <- function(phi, psi, dim_u, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMgennsst', 
RandomFields/R/RMmodels.R:RMgennsst <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMgennsst,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:RMhyperbolic <- function(nu, lambda, delta, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMhyperbolic', 
RandomFields/R/RMmodels.R:RMhyperbolic <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMhyperbolic,
RandomFields/R/RMmodels.R:RMiaco <- function(nu, lambda, delta, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMiaco', 
RandomFields/R/RMmodels.R:RMiaco <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMiaco,
RandomFields/R/RMmodels.R:RMidmodel <- function(phi, vdim, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMidmodel', 
RandomFields/R/RMmodels.R:RMidmodel <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMidmodel,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:RMkolmogorov <- function(var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMkolmogorov', 
RandomFields/R/RMmodels.R:RMkolmogorov <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMkolmogorov,
RandomFields/R/RMmodels.R:RMlgd <- function(alpha, beta, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMlgd', 
RandomFields/R/RMmodels.R:RMlgd <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMlgd,
RandomFields/R/RMmodels.R:	maxdim = PARAM_DEP,
RandomFields/R/RMmodels.R:RMmastein <- function(phi, nu, delta, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMmastein', 
RandomFields/R/RMmodels.R:RMmastein <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMmastein,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:RMma <- function(phi, alpha, theta, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMma', 
RandomFields/R/RMmodels.R:RMma <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMma,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:RMintexp <- function(phi, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMintexp', 
RandomFields/R/RMmodels.R:RMintexp <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMintexp,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:RMmatrix <- function(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, M, vdim, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:  if (hasArg('M') && !is.null(subst <- substitute(M))) 
RandomFields/R/RMmodels.R:	par.model[['M']] <- CheckArg(M, subst, TRUE)
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMmatrix', 
RandomFields/R/RMmodels.R:RMmatrix <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMmatrix,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:	vdim = PARAM_DEP
RandomFields/R/RMmodels.R:RMmatern <- function(nu, notinvnu, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMmatern', 
RandomFields/R/RMmodels.R:RMmatern <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMmatern,
RandomFields/R/RMmodels.R:RMmqam <- function(phi, C1, C2, C3, C4, C5, C6, C7, C8, C9, theta, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMmqam', 
RandomFields/R/RMmodels.R:RMmqam <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMmqam,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:	vdim = PARAM_DEP
RandomFields/R/RMmodels.R:RMmultiquad <- function(delta, tau, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMmultiquad', 
RandomFields/R/RMmodels.R:RMmultiquad <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMmultiquad,
RandomFields/R/RMmodels.R:RMnatsc <- function(phi, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMnatsc', 
RandomFields/R/RMmodels.R:RMnatsc <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMnatsc,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:RMnsst <- function(phi, psi, delta, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMnsst', 
RandomFields/R/RMmodels.R:RMnsst <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMnsst,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:RMnugget <- function(tol, vdim, var, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMnugget', 
RandomFields/R/RMmodels.R:RMnugget <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMnugget,
RandomFields/R/RMmodels.R:	vdim = PREVMODEL_DEP
RandomFields/R/RMmodels.R:RMparswm <- function(nudiag, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMparswm', 
RandomFields/R/RMmodels.R:RMparswm <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMparswm,
RandomFields/R/RMmodels.R:	vdim = PARAM_DEP
RandomFields/R/RMmodels.R:RMpenta <- function(var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMpenta', 
RandomFields/R/RMmodels.R:RMpenta <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMpenta,
RandomFields/R/RMmodels.R:RMaskey <- function(alpha, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMaskey', 
RandomFields/R/RMmodels.R:RMaskey <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMaskey,
RandomFields/R/RMmodels.R:RMpower <- function(phi, alpha, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMpower', 
RandomFields/R/RMmodels.R:RMpower <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMpower,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:RMprod <- function(phi, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMprod', 
RandomFields/R/RMmodels.R:RMprod <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMprod,
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:RMqam <- function(phi, C1, C2, C3, C4, C5, C6, C7, C8, C9, theta, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMqam', 
RandomFields/R/RMmodels.R:RMqam <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMqam,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:RMqexp <- function(alpha, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMqexp', 
RandomFields/R/RMmodels.R:RMqexp <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMqexp,
RandomFields/R/RMmodels.R:RMscale <- function(phi, scaling, penalty, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMscale', 
RandomFields/R/RMmodels.R:RMscale <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMscale,
RandomFields/R/RMmodels.R:RMschur <- function(phi, M, diag, rhored, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:  if (hasArg('M') && !is.null(subst <- substitute(M))) 
RandomFields/R/RMmodels.R:	par.model[['M']] <- CheckArg(M, subst, TRUE)
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMschur', 
RandomFields/R/RMmodels.R:RMschur <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMschur,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:RMdelay <- function(phi, s, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMdelay', 
RandomFields/R/RMmodels.R:RMdelay <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMdelay,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:	vdim = PARAM_DEP
RandomFields/R/RMmodels.R:RMsinepower <- function(alpha, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMsinepower', 
RandomFields/R/RMmodels.R:RMsinepower <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMsinepower,
RandomFields/R/RMmodels.R:RMspheric <- function(var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMspheric', 
RandomFields/R/RMmodels.R:RMspheric <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMspheric,
RandomFields/R/RMmodels.R:RMstable <- function(alpha, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMstable', 
RandomFields/R/RMmodels.R:RMstable <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMstable,
RandomFields/R/RMmodels.R:RMintrinsic <- function(phi, diameter, rawR, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMintrinsic', 
RandomFields/R/RMmodels.R:RMintrinsic <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMintrinsic,
RandomFields/R/RMmodels.R:RMstein <- function(nu, zeta, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMstein', 
RandomFields/R/RMmodels.R:RMstein <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMstein,
RandomFields/R/RMmodels.R:RMstp <- function(xi, phi, S, z, M, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:  if (hasArg('M') && !is.null(subst <- substitute(M))) 
RandomFields/R/RMmodels.R:	par.model[['M']] <- CheckArg(M, subst, TRUE)
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMstp', 
RandomFields/R/RMmodels.R:RMstp <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMstp,
RandomFields/R/RMmodels.R:RMtbm <- function(phi, fulldim, reduceddim, layers, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMtbm', 
RandomFields/R/RMmodels.R:RMtbm <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMtbm,
RandomFields/R/RMmodels.R:	maxdim = PARAM_DEP,
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:RMsum <- function(phi, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMsum', 
RandomFields/R/RMmodels.R:RMsum <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMsum,
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:iRMcov <- function(gamma, x, a, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMcov', 
RandomFields/R/RMmodels.R:iRMcov <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = iRMcov,
RandomFields/R/RMmodels.R:RMvector <- function(phi, a, Dspace, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMvector', 
RandomFields/R/RMmodels.R:RMvector <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMvector,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:	vdim = PARAM_DEP
RandomFields/R/RMmodels.R:RMwave <- function(var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMwave', 
RandomFields/R/RMmodels.R:RMwave <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMwave,
RandomFields/R/RMmodels.R:RMwhittle <- function(nu, notinvnu, var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMwhittle', 
RandomFields/R/RMmodels.R:RMwhittle <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMwhittle,
RandomFields/R/RMmodels.R:RMshape <- function(mean) {
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMshape', 
RandomFields/R/RMmodels.R:RMshape <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMshape,
RandomFields/R/RMmodels.R:	vdim = PARAM_DEP
RandomFields/R/RMmodels.R:RMangle <- function(angle, lat.angle, ratio, diag) {
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMangle', 
RandomFields/R/RMmodels.R:RMangle <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMangle,
RandomFields/R/RMmodels.R:	vdim = PARAM_DEP
RandomFields/R/RMmodels.R:RMball <- function(var, scale, Aniso, proj) {
RandomFields/R/RMmodels.R:	par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMball', 
RandomFields/R/RMmodels.R:RMball <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMball,
RandomFields/R/RMmodels.R:iRMcovariate <- function(data, x, raw, extra_data, addNA, factor, name, var) {
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMcovariate', 
RandomFields/R/RMmodels.R:iRMcovariate <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = iRMcovariate,
RandomFields/R/RMmodels.R:	vdim = PARAM_DEP
RandomFields/R/RMmodels.R:RMeaxxa <- function(E, A) {
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMeaxxa', 
RandomFields/R/RMmodels.R:RMeaxxa <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMeaxxa,
RandomFields/R/RMmodels.R:	vdim = PARAM_DEP
RandomFields/R/RMmodels.R:RMetaxxa <- function(E, A, alpha) {
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMetaxxa', 
RandomFields/R/RMmodels.R:RMetaxxa <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMetaxxa,
RandomFields/R/RMmodels.R:RMidcoord <- function() {
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMidcoord', 
RandomFields/R/RMmodels.R:RMidcoord <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMidcoord,
RandomFields/R/RMmodels.R:	vdim = PARAM_DEP
RandomFields/R/RMmodels.R:RMtrafo <- function(phi, new) {
RandomFields/R/RMmodels.R:	par.model[['new']] <- CheckChar(new, subst, ISO_NAMES, TRUE)
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMtrafo', 
RandomFields/R/RMmodels.R:RMtrafo <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMtrafo,
RandomFields/R/RMmodels.R:	vdim = PARAM_DEP
RandomFields/R/RMmodels.R:RMpolygon <- function(lambda) {
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMpolygon', 
RandomFields/R/RMmodels.R:RMpolygon <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMpolygon,
RandomFields/R/RMmodels.R:RMrational <- function(A, a) {
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMrational', 
RandomFields/R/RMmodels.R:RMrational <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMrational,
RandomFields/R/RMmodels.R:RMrotat <- function(speed, phi) {
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMrotat', 
RandomFields/R/RMmodels.R:RMrotat <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMrotat,
RandomFields/R/RMmodels.R:RMrotation <- function(phi) {
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMrotation', 
RandomFields/R/RMmodels.R:RMrotation <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMrotation,
RandomFields/R/RMmodels.R:	vdim = PARAM_DEP
RandomFields/R/RMmodels.R:RMsign <- function(phi, p) {
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMsign', 
RandomFields/R/RMmodels.R:RMsign <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMsign,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:RMm2r <- function(phi) {
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMm2r', 
RandomFields/R/RMmodels.R:RMm2r <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMm2r,
RandomFields/R/RMmodels.R:RMm3b <- function(phi) {
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMm3b', 
RandomFields/R/RMmodels.R:RMm3b <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMm3b,
RandomFields/R/RMmodels.R:RMmps <- function(phi) {
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMmps', 
RandomFields/R/RMmodels.R:RMmps <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMmps,
RandomFields/R/RMmodels.R:RMtruncsupport <- function(phi, radius) {
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMtruncsupport', 
RandomFields/R/RMmodels.R:RMtruncsupport <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMtruncsupport,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:RRdeterm <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:RRgauss <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	vdim = PARAM_DEP
RandomFields/R/RMmodels.R:RRloc <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:RRmcmc <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	vdim = PARAM_DEP
RandomFields/R/RMmodels.R:RRrectangular <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	vdim = PARAM_DEP
RandomFields/R/RMmodels.R:RRspheric <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:RRunif <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	vdim = PARAM_DEP
RandomFields/R/RMmodels.R:RMmppplus <- function(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, p) {
RandomFields/R/RMmodels.R:  model <- methods::new(CLASS_CLIST, name = 'RMmppplus', 
RandomFields/R/RMmodels.R:RMmppplus <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	.Data = RMmppplus,
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:iRFsimulate <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:iRFcovariance <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:iRFcovmatrix <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:iRFloglikelihood <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:iRFpseudovariogra <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:iRFpseudomadogram <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:iRFmadogram <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:iRFvariogram <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:RPtrend <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:RPaverage <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:RPcoins <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:RPcirculant <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:RPcutoff <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:RPintrinsic <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:RPdirect <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:RPhyperplane <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:RPnugget <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	vdim = PREVMODEL_DEP
RandomFields/R/RMmodels.R:RPsequential <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:RPspectral <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:RPspecific <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:RPtbm <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodels.R:	vdim = PARAM_DEP
RandomFields/R/RMmodels.R:RPloggaussnormed <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:RPbrorig <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:RPbrmixed <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:RPbrshifted <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:RPbrownresnick <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:RPbernoulli <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:RPgauss <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:RPpoisson <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:RPschlather <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:RPopitz <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:RPsmith <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:RPchi2 <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:RPt <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['y']] <- CheckMaths(y, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['factor']] <- CheckMaths(factor, subst, TRUE)
RandomFields/R/RMmodels.R:R.minus <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, FALSE)
RandomFields/R/RMmodels.R:	par.model[['y']] <- CheckMaths(y, subst, FALSE)
RandomFields/R/RMmodels.R:	par.model[['factor']] <- CheckMaths(factor, subst, FALSE)
RandomFields/R/RMmodels.R:R.plus <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, FALSE)
RandomFields/R/RMmodels.R:	par.model[['y']] <- CheckMaths(y, subst, FALSE)
RandomFields/R/RMmodels.R:	par.model[['factor']] <- CheckMaths(factor, subst, FALSE)
RandomFields/R/RMmodels.R:R.div <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, FALSE)
RandomFields/R/RMmodels.R:	par.model[['y']] <- CheckMaths(y, subst, FALSE)
RandomFields/R/RMmodels.R:	par.model[['factor']] <- CheckMaths(factor, subst, FALSE)
RandomFields/R/RMmodels.R:R.mult <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:R.const <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodels.R:	par.model[['new']] <- CheckChar(new, subst, ISO_NAMES, FALSE)
RandomFields/R/RMmodels.R:	par.model[['factor']] <- CheckMaths(factor, subst, FALSE)
RandomFields/R/RMmodels.R:iR.p <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	par.model[['a']] <- CheckMaths(a, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['b']] <- CheckMaths(b, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['c']] <- CheckMaths(c, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['d']] <- CheckMaths(d, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['e']] <- CheckMaths(e, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['f']] <- CheckMaths(f, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['g']] <- CheckMaths(g, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['h']] <- CheckMaths(h, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['i']] <- CheckMaths(i, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['j']] <- CheckMaths(j, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['l']] <- CheckMaths(l, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['m']] <- CheckMaths(m, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['n']] <- CheckMaths(n, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['o']] <- CheckMaths(o, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['p']] <- CheckMaths(p, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['q']] <- CheckMaths(q, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['ncol']] <- CheckMaths(ncol, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['factor']] <- CheckMaths(factor, subst, TRUE)
RandomFields/R/RMmodels.R:iR.c <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	vdim = PARAM_DEP
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['is']] <- CheckChar(is, subst, EQ_NAMES, TRUE)
RandomFields/R/RMmodels.R:	par.model[['y']] <- CheckMaths(y, subst, TRUE)
RandomFields/R/RMmodels.R:R.is <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:R.asin <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:R.atan <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['y']] <- CheckMaths(y, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:R.atan2 <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:R.cos <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:R.sin <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:R.tan <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:R.asinh <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:R.atanh <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:R.cosh <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:R.sinh <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:R.tanh <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:R.log <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:R.expm1 <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:R.log1p <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:R.exp2 <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:R.log2 <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['y']] <- CheckMaths(y, subst, TRUE)
RandomFields/R/RMmodels.R:R.hypot <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:R.cbrt <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:R.ceil <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:R.floor <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['y']] <- CheckMaths(y, subst, TRUE)
RandomFields/R/RMmodels.R:R.fmod <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:R.round <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:R.trunc <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:R.erfc <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:R.lgamma <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['y']] <- CheckMaths(y, subst, TRUE)
RandomFields/R/RMmodels.R:R.remainder <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['y']] <- CheckMaths(y, subst, TRUE)
RandomFields/R/RMmodels.R:R.fdim <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['y']] <- CheckMaths(y, subst, TRUE)
RandomFields/R/RMmodels.R:R.fmax <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, TRUE)
RandomFields/R/RMmodels.R:	par.model[['y']] <- CheckMaths(y, subst, TRUE)
RandomFields/R/RMmodels.R:R.fmin <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, FALSE)
RandomFields/R/RMmodels.R:R.gamma <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, FALSE)
RandomFields/R/RMmodels.R:R.ggamma <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, FALSE)
RandomFields/R/RMmodels.R:R.exp <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, FALSE)
RandomFields/R/RMmodels.R:R.erf <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, FALSE)
RandomFields/R/RMmodels.R:R.fabs <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, FALSE)
RandomFields/R/RMmodels.R:R.acos <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, FALSE)
RandomFields/R/RMmodels.R:R.acosh <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, FALSE)
RandomFields/R/RMmodels.R:	par.model[['y']] <- CheckMaths(y, subst, FALSE)
RandomFields/R/RMmodels.R:R.pow <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/RMmodels.R:	par.model[['x']] <- CheckMaths(x, subst, FALSE)
RandomFields/R/RMmodels.R:R.sqrt <- new(CLASS_RM, 
RandomFields/R/RMmodels.R:	maxdim = PREVMODEL_DEP,
RandomFields/R/bigdata.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/bigdata.R:## Copyright (C) 2017 -- 2017 Martin Schlather
RandomFields/R/bigdata.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/bigdata.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/bigdata.R:  model.nr <- MODEL_AUX
RandomFields/R/bigdata.R:  minimum <- as.integer(split_vec[NEIGHB_MIN+1])# min. nmbr of pts in neighbhood
RandomFields/R/bigdata.R:  maximum <- as.integer(split_vec[NEIGHB_MAX+1])## max nmbr of points when still
RandomFields/R/bigdata.R:      natsc <- .C(C_MultiDimRange, as.integer(model.nr),
RandomFields/R/bigdata.R:  if (is.na(method <- pmatch(method, RC_LIKELIHOOD_NAMES)))
RandomFields/R/bigdata.R:  method <- RC_LIKELIHOOD_NAMES[method] # kein + 1 notwendig
RandomFields/R/bigdata.R:    if (RFopt$basic$printlevel>=PL_IMPORTANT)
RandomFields/R/Hints.R:## aber nicht RFopt, so dass es zu Mehrfachaufrufen kommen kann
RandomFields/R/Hints.R:      "mle" = "The MLE is extracted from a list of results. Use argument 'method' in any function of the package 'RandomFieldsLight' to extract different results, see ?RFfit for possible values of 'method'. Set RFoptions(helpinfo=FALSE) to avoid this message.",
RandomFields/R/Hints.R:      "normal_mode"=paste0("The modus_operandi='", MODE_NAMES[normal + 1],
RandomFields/R/Hints.R:                           "' is save, but slow. If you like the MLE running\n",
RandomFields/R/Hints.R:                           "choose modus='", MODE_NAMES[easygoing + 1],
RandomFields/R/Hints.R:                           "' or\neven modus='", MODE_NAMES[sloppy + 1], "'."),
RandomFields/R/Hints.R:                  "Note further that angles in R.cos, R.sin, R.tan, RMangle",
RandomFields/R/Hints.R:    ## opt = 0: keine Meldung
RandomFields/R/Hints.R:    ## opt = 2: Meldung, aber ohne "[This message ...]"
RandomFields/R/Hints.R:    ## opt = 3: Meldung mit "[This message]"
RandomFields/R/Hints.R:    if (basic$printlevel >= PL_IMPORTANT &&
RandomFields/R/rf.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/rf.R:## Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/R/rf.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/rf.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/rf.R:  Reg <- MODEL_USER  
RandomFields/R/rf.R:    pm <- PrepareModel2(if (hasArg("trend")) list(...)$trend else model,
RandomFields/R/rf.R:  if (model[[1]] == SYMBOL_PLUS) {
RandomFields/R/rf.R:    return(c(SYMBOL_PLUS,
RandomFields/R/rf.R:    if (!missing(factor)) model <- list(SYMBOL_MULT, model, factor)
RandomFields/R/rf.R:    if (!missing(factor)) model <- list(SYMBOL_MULT, model, factor)
RandomFields/R/rf.R:  } else if (model[[1]] == SYMBOL_MULT) {
RandomFields/R/rf.R:        return(list(SYMBOL_MULT, model, if (!missing(factor)) list(factor)))
RandomFields/R/rf.R:      model[[1]] <- SYMBOL_PLUS
RandomFields/R/rf.R:    if (model[[1]] == SYMBOL_MULT)
RandomFields/R/rf.R:      model <- c(SYMBOL_MULT, list(bind), model[-1])
RandomFields/R/rf.R:    else model <- list(SYMBOL_MULT, bind, model)
RandomFields/R/rf.R:  if (model[[1]] == SYMBOL_PLUS) return(max(sapply(model[-1], GetDimension)))
RandomFields/R/rf.R:  if (model[[1]] == SYMBOL_MULT) 
RandomFields/R/rf.R:  if (model[[1]] == SYMBOL_PLUS) {
RandomFields/R/rf.R:    return(c(SYMBOL_PLUS, lapply(model[-1], SetDimension, L=L)))
RandomFields/R/rf.R:  } else if (model[[1]] == SYMBOL_MULT) {
RandomFields/R/rf.R:    return(list(SYMBOL_MULT, model, if (!missing(factor)) list(factor)))
RandomFields/R/rf.R:	m <- list(SYMBOL_MULT, list(R_CONST, m)) 
RandomFields/R/rf.R:  model[[1]] <- SYMBOL_PLUS
RandomFields/R/rf.R:  if (model[[1]] == SYMBOL_PLUS) {
RandomFields/R/rf.R:  } else if (model[[1]] == SYMBOL_MULT) {
RandomFields/R/rf.R:  likeli <- .Call(C_EvaluateModel, double(0), integer(0), Reg)
RandomFields/R/rf.R:  ## here, in contrast to Covariance, nonstatCovMatrix needs only x
RandomFields/R/rf.R:  model<- list("Distr", PrepareModel2(model, params=params, xdim = 1, ## dummy 
RandomFields/R/rf.R:         reg = MODEL_DISTR, RFopt=RFopt)
RandomFields/R/rf.R:  res <-  .Call(C_EvaluateModel, double(0), integer(0),
RandomFields/R/rf.R:                as.integer(MODEL_DISTR))
RandomFields/R/rf.R:                  fctncall=c("Covariance", "CovMatrix", "Fctn",
RandomFields/R/rf.R:                             FCTN_TYPE_NAMES), reg=MODEL_USER) {
RandomFields/R/rf.R:  ## here, in contrast to Covariance, nonstatCovMatrix needs only x
RandomFields/R/rf.R:  if (fctncall != "CovMatrix" && !missing(distances) && !is.null(distances)) {
RandomFields/R/rf.R:    PrepareModel2(model, params=params, x=x, ...)$model
RandomFields/R/rf.R:  res <- .Call(C_EvaluateModel, double(0), integer(0), as.integer(reg))
RandomFields/R/rf.R:         distances=distances, dim=dim, params=params, ..., fctncall="CovMatrix",
RandomFields/R/rf.R:         reg=MODEL_COVMATRIX)
RandomFields/R/rf.R:      reg <- MODEL_COV
RandomFields/R/rf.R:    } else if (alpha == VARIOGRAM) {
RandomFields/R/rf.R:      reg <- MODEL_VARIOGRAM
RandomFields/R/rf.R:              else list("Madogram", alpha = -alpha)
RandomFields/R/rf.R:      reg <- MODEL_PSEUDO
RandomFields/R/rf.R:    MARGIN <- if (!is.null(L$MARGIN)) L$MARGIN
RandomFields/R/rf.R:    fixed.MARGIN <- if (!is.null(L$fixed.MARGIN)) L$fixed.MARGIN
RandomFields/R/rf.R:    L$plotmethod <- L$fixed.MARGIN <- L$MARGIN <- NULL
RandomFields/R/rf.R:                                  MARGIN = MARGIN,
RandomFields/R/rf.R:                                  fixed.MARGIN=fixed.MARGIN,
RandomFields/R/rf.R:         alpha = VARIOGRAM)
RandomFields/R/rf.R:                reg=MODEL_FCTN )
RandomFields/R/rf.R:         fctncall="Fctn",reg=MODEL_CALC)
RandomFields/R/rf.R:  info <- RFgetModelInfo_register(reg, level=3)
RandomFields/R/rf.R:  result <- .Call(C_EvaluateModel, as.double(0), as.integer(n),
RandomFields/R/rf.R:    nm <- names(model[METHOD_PREFLIST])
RandomFields/R/rf.R:                                   general.spConform = FALSE, FORMER=TRUE)
RandomFields/R/rf.R:                                   expected_number_simu=n, ..., FORMER=TRUE)
RandomFields/R/rf.R:  pM2 <- PrepareModel2(model, params=params, x = if (missing(x)) NULL else x,
RandomFields/R/rf.R:   model <- pM2$model
RandomFields/R/rf.R:    info <- RFgetModelInfo_register(reg, level=3)
RandomFields/R/rf.R:				  coordnames = pM2$data.names[pM2$is.x])
RandomFields/R/rf.R:    attributes(res)$varnames <- pM2$data.names[pM2$is.var]
RandomFields/R/rf.R:    cat("Empirical Variogram:\n"); print(args(RFplotModel))## ok
RandomFields/R/rf.R:    cat("\nModels:\n(Note that x can be a list of models; or further models can be given\nas additional arguments whose names starting with 'model')\n");
RandomFields/R/rf.R:    print(args(RFplotModel)) ## ok
RandomFields/R/rf.R:  } else if (is(x, CLASS_FITLIST) || is(x, CLASS_EMPIR)) {
RandomFields/R/rf.R:#  else if (is(x, CLASS_PLOT)) RFplotModel(x, ...)
RandomFields/R/rf.R:  else RFplotModel(x=x, ...)
RandomFields/R/aaa_globals.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/aaa_globals.R:## Copyright (C) 2017 - 2018 Martin Schlather
RandomFields/R/aaa_globals.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/aaa_globals.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/aaa_globals.R:SYMBOL_L_PAR <- "("
RandomFields/R/aaa_globals.R:SYMBOL_R_PAR <- ")"
RandomFields/R/aaa_globals.R:SYMBOL_PLUS <- '+'
RandomFields/R/aaa_globals.R:SYMBOL_MULT <- '*'
RandomFields/R/aaa_globals.R:DOLLAR <- c("$", "RMS")
RandomFields/R/aaa_globals.R:RM_PLUS <- c("RMplus", SYMBOL_PLUS)
RandomFields/R/aaa_globals.R:RM_MULT <- c("RMmult", SYMBOL_MULT)
RandomFields/R/aaa_globals.R:#RM_MIXED <- c( "RMmixed", "mixed") 
RandomFields/R/aaa_globals.R:##RM_INTERNALMIXED <- "internalRMmixed"
RandomFields/R/aaa_globals.R:RM_TREND <- c("RMshape", "trend")
RandomFields/R/aaa_globals.R:RM_DISTR <- c('RRdistr', 'Distr')
RandomFields/R/aaa_globals.R:RM_USER <- c('RMuser', 'U')
RandomFields/R/aaa_globals.R:RM_NUGGET <- c("RMnugget", "nugget")
RandomFields/R/aaa_globals.R:RM_COVARIATE <- "RMcovariate"
RandomFields/R/aaa_globals.R:RM_DECLARE <- "RMdeclare"
RandomFields/R/aaa_globals.R:RM_MATRIX <- "RMmatrix"
RandomFields/R/aaa_globals.R:CLASS_CLIST <- 'RMmodel'
RandomFields/R/aaa_globals.R:CLASS_RM <- 'RMmodelgenerator'
RandomFields/R/aaa_globals.R:CLASS_SINGLEFIT <- 'RMmodelFit'
RandomFields/R/aaa_globals.R:CLASS_EMPIR <- "RFempVariog"
RandomFields/R/aaa_globals.R:  if (is.character(type)) type <- pmatch(type, TYPE_NAMES, duplicates.ok=TRUE)-1
RandomFields/R/aaa_globals.R:  type==TcfType | type == PosDefType | type == ManifoldType
RandomFields/R/aaa_globals.R:  if (is.character(type)) type <- pmatch(type, TYPE_NAMES, duplicates.ok=TRUE)-1
RandomFields/R/aaa_globals.R:LSQMETHODS <- c("plain", "self", "sqrt.nr", "sd.inv",
RandomFields/R/aaa_globals.R:MLMETHODS <- c("ml") # "reml", "rml1"),
RandomFields/R/aaa_globals.R:PRIMMETHODS <- c("users.guess", "autostart")
RandomFields/R/aaa_globals.R:CROSSMETHODS <- NULL
RandomFields/R/aaa_globals.R:METHOD_PREFLIST <- c(MLMETHODS, LSQMETHODS, PRIMMETHODS)
RandomFields/R/aaa_globals.R:PL_IMPORTANT 	<- as.integer(1)
RandomFields/R/aaa_globals.R:PL_SUBIMPORTANT 	<- as.integer(2)
RandomFields/R/aaa_globals.R:RC_MAXSTABLE_NAMES <- c(BR_NAME, OPITZ_NAME, EG_NAME, SMITH_NAME)
RandomFields/R/basic.fctns.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/basic.fctns.R:## Copyright (C) 2015 -- 2017  Martin Schlather
RandomFields/R/basic.fctns.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/basic.fctns.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/basic.fctns.R:## NAME		extract VarNames
RandomFields/R/basic.fctns.R:## REQUIRE	$model is a formula or a RMmodel
RandomFields/R/basic.fctns.R:## DATE		26.08.2011; 2014 Martin Schlather modified
RandomFields/R/basic.fctns.R:    M <- PrepareModel2(model=model, params=params,
RandomFields/R/basic.fctns.R:    for (i in components) assign(i, c(M[[i]]))# resolve in case of matrix
RandomFields/R/basic.fctns.R:    if (M$repet > 0) repet <- M$repet
RandomFields/R/basic.fctns.R:    if (M$vdim > 0) {
RandomFields/R/basic.fctns.R:      if (vdim > 0 && vdim != M$vdim)
RandomFields/R/basic.fctns.R:             "' does not match the detected value: vdim=", M$vdim)
RandomFields/R/basic.fctns.R:      if (length(M[[i]]) > 0) {
RandomFields/R/basic.fctns.R:               paste(M[[i]], collapse="', '"), "'.")
RandomFields/R/basic.fctns.R:                   S(M[[i]]),  ": '",
RandomFields/R/basic.fctns.R:                   paste(M$data.names[M[[i]]], collapse="', '"), "'.")
RandomFields/R/basic.fctns.R:    M <- list()
RandomFields/R/basic.fctns.R:    } else if (PL >= PL_SUBIMPORTANT)
RandomFields/R/basic.fctns.R:  ######### NOTPROGRAM ###############
RandomFields/R/basic.fctns.R:          if (xdim < length(is.x) && PL >= PL_SUBIMPORTANT)
RandomFields/R/basic.fctns.R:      if (PL >= PL_SUBIMPORTANT)
RandomFields/R/basic.fctns.R:                                        #  Print("basic.fctn.R", M)
RandomFields/R/basic.fctns.R:  #            data.info=data.info, model=M)
RandomFields/R/basic.fctns.R:              data.info=data.info, model=M))
RandomFields/R/basic.fctns.R:    coordnames <- paste(COORD_NAMES_GENERAL[1], 1:tsdim, sep="")
RandomFields/R/basic.fctns.R:    if (has.time.comp) coordnames[tsdim] <- COORD_NAMES_GENERAL[2]
RandomFields/R/D.H.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/D.H.R:## Copyright (C) 2015 -- 2017  Martin Schlather
RandomFields/R/D.H.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/D.H.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/D.H.R:    if (averaging) y <- rowMeans(matrix(y, nrow=length(x)))
RandomFields/R/D.H.R:  if (printlevel>PL_SUBIMPORTANT ) {
RandomFields/R/D.H.R:    Ml.box.sequ <- l.box.count <- box <-
RandomFields/R/D.H.R:      Ml.range.sequ <- l.range.count <- rnge <-
RandomFields/R/D.H.R:          if (printlevel>=PL_IMPORTANT) cat("locations on a grid.\n")
RandomFields/R/D.H.R:          if (printlevel>PL_IMPORTANT) cat("locations not on a grid.\n")
RandomFields/R/D.H.R:      Ml.range.sequ <- -log(range.sequ + box.length.correction)
RandomFields/R/D.H.R:      Ml.box.sequ <- -log(box.sequ + box.length.correction)
RandomFields/R/D.H.R:      if (printlevel>=PL_IMPORTANT) {
RandomFields/R/D.H.R:      box <- regression(Ml.box.sequ, l.box.count,
RandomFields/R/D.H.R:      rnge <- regression(Ml.range.sequ, l.range.count, variable="D",
RandomFields/R/D.H.R:      if (length(l.lambda)>fft.max.regr && printlevel>=PL_IMPORTANT)
RandomFields/R/D.H.R:  if (printlevel>=PL_SUBIMPORTANT) {
RandomFields/R/D.H.R:    #DIM <- 1ev
RandomFields/R/D.H.R:    #Print(2 * (DIM + 1 - c(D.vario=vario$val, D.box=box$val, D.range=rnge$val)))
RandomFields/R/D.H.R:    #Print(2 * (DIM + 1 - c(D.vario=vario$val.u, D.box=box$val.u,
RandomFields/R/D.H.R:#              box = list(x=Ml.box.sequ, y=l.box.count, regr=box$regr,
RandomFields/R/D.H.R:#              range=list(x=Ml.range.sequ, y=l.range.count, regr=rnge$regr,
RandomFields/R/helmholz.R:xRMderivative <- function(phi, partial, var, scale, Aniso, proj) {
RandomFields/R/helmholz.R:  model <- new(CLASS_CLIST,  name = 'RMderivative', 
RandomFields/R/helmholz.R:xRMderivative <- new(CLASS_RM,
RandomFields/R/helmholz.R:	.Data = xRMderivative,
RandomFields/R/helmholz.R:xRMhelmholtz <- function(phi, component, var, scale, Aniso, proj) {
RandomFields/R/helmholz.R:  model <- new(CLASS_CLIST, name = 'RMhelmholtz', 
RandomFields/R/helmholz.R:xRMhelmholtz <- new(CLASS_RM,
RandomFields/R/helmholz.R:	.Data = xRMhelmholtz,
RandomFields/R/helmholz.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/helmholz.R:	vdim = PARAM_DEP
RandomFields/R/kriging.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/kriging.R:## Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/R/kriging.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/kriging.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/kriging.R:  ##  if (!ignore.trend) .Call(C_EvaluateModel, double(0), as.integer(1), Reg)
RandomFields/R/kriging.R:ModelAbbreviations <- function(model){
RandomFields/R/kriging.R:ModelParts <- function(model, effects, complete) { ## model immer schon aufbrtt
RandomFields/R/kriging.R:  ## model <- P repareModel2(model) 13.7.19
RandomFields/R/kriging.R:  model <- if ((model[[1]] %in% SYMBOL_PLUS)) model[-1] else list(model)
RandomFields/R/kriging.R:    else err <- c(SYMBOL_PLUS, err)
RandomFields/R/kriging.R:      if (length(m) == 1) m <- m[[1]] else m <- c(SYMBOL_PLUS, m)
RandomFields/R/kriging.R:  parts <- ModelParts(model, effect=GetModelInfos(Z)$effect, complete=TRUE)
RandomFields/R/kriging.R:    if (add) conditioning <- list(SYMBOL_PLUS, model, conditioning)
RandomFields/R/kriging.R:    names <- ModelAbbreviations(err.model)
RandomFields/R/kriging.R:    model <- list(ModelParts(model, effects=GetModelEffects(all$Z),
RandomFields/R/kriging.R:        paste(COORD_NAMES_GENERAL[1], 1:all$Z$spatialdim, sep=""),
RandomFields/R/kriging.R:        if (all$Z$has.time.comp) COORD_NAMES_GENERAL[2] else NULL)
RandomFields/R/kriging.R:  ## Nachteil: grosse Matrix muss fuer den Schaetzer des linearen Term
RandomFields/R/kriging.R:        RFopt$basic$printlevel>=PL_IMPORTANT)
RandomFields/R/kriging.R:             ## EvaluateModel/gauss_predict schafft nur 1 Datenssatz zu
RandomFields/R/kriging.R:             ## verarbeiten, insbesondere da EvaluateModel nur
RandomFields/R/kriging.R:             .Call(C_EvaluateModel, as.double(0), p, reg)
RandomFields/R/kriging.R:             .Call(C_EvaluateModel,
RandomFields/R/kriging.R:#    c("Simple Kriging", "Ordinary Kriging", "Kriging the Mean",
RandomFields/R/kriging.R:    which(RFopt$general$duplicated_loc == DUPLICATEDLOC_NAMES) - 1
RandomFields/R/kriging.R:                   DUPLICATEDLOC_NAMES[duplicated_loc + 1])
RandomFields/R/kriging.R:                DUPLICATEDLOC_NAMES[duplicated_loc.old + 1])
RandomFields/R/aaa_auto.R: MAXUNITS 	<- as.integer(4)
RandomFields/R/aaa_auto.R: MAXCHAR 	<- as.integer(18)
RandomFields/R/aaa_auto.R: MAXCHAR_RF 	<- as.integer(MAXCHAR)
RandomFields/R/aaa_auto.R: METHODMAXCHAR 	<- as.integer(MAXCHAR)
RandomFields/R/aaa_auto.R: MAXPARAM 	<- as.integer(20)
RandomFields/R/aaa_auto.R: MAXSUB 	<- as.integer(10)
RandomFields/R/aaa_auto.R: MAXCEDIM 	<- as.integer(13)
RandomFields/R/aaa_auto.R: MAXTBMSPDIM 	<- as.integer(4)
RandomFields/R/aaa_auto.R: MAXMPPDIM 	<- as.integer(4)
RandomFields/R/aaa_auto.R: MAXBOXCOXVDIM 	<- as.integer(10)
RandomFields/R/aaa_auto.R: MAXHYPERDIM 	<- as.integer(4)
RandomFields/R/aaa_auto.R: MAXVARIODIM 	<- as.integer(20)
RandomFields/R/aaa_auto.R: MAXACCEPTED 	<- as.double(1e300)
RandomFields/R/aaa_auto.R: MAXVARIANTS 	<- as.integer(6)
RandomFields/R/aaa_auto.R: MAXSYSTEMS 	<- as.integer(1)
RandomFields/R/aaa_auto.R: MAXDATANAMES 	<- as.integer(5)
RandomFields/R/aaa_auto.R: MAXMPPVDIM 	<- as.integer(9)
RandomFields/R/aaa_auto.R: MAXCOORDNAMES 	<- as.integer(4)
RandomFields/R/aaa_auto.R: PARAM_DEP 	<- as.integer(-1)
RandomFields/R/aaa_auto.R: PREVMODEL_DEP 	<- as.integer(-2)
RandomFields/R/aaa_auto.R: SUBMODEL_DEP 	<- as.integer(-3)
RandomFields/R/aaa_auto.R: MISMATCH 	<- as.integer(-4)
RandomFields/R/aaa_auto.R: PREVMODEL_D 	<- as.integer(2)
RandomFields/R/aaa_auto.R: SUBMODEL_D 	<- as.integer(3)
RandomFields/R/aaa_auto.R: PARAMDEP_D 	<- as.integer(5)
RandomFields/R/aaa_auto.R: KEEPCOPY_DOM 	<- as.integer(6)
RandomFields/R/aaa_auto.R: DOMAIN_MISMATCH 	<- as.integer(7)
RandomFields/R/aaa_auto.R: FIRST_DOMAIN 	<- as.integer(XONLY)
RandomFields/R/aaa_auto.R: LAST_DOMAINUSER 	<- as.integer(KERNEL)
RandomFields/R/aaa_auto.R: LAST_DOMAIN 	<- as.integer(DOMAIN_MISMATCH)
RandomFields/R/aaa_auto.R: SYMMETRIC 	<- as.integer(3)
RandomFields/R/aaa_auto.R:RC_GNOMONIC_PROJ <- GNOMONIC_PROJ 	<- as.integer(5)
RandomFields/R/aaa_auto.R: SPHERICAL_SYMMETRIC 	<- as.integer(8)
RandomFields/R/aaa_auto.R: EARTH_SYMMETRIC 	<- as.integer(11)
RandomFields/R/aaa_auto.R: PREVMODEL_I 	<- as.integer(15)
RandomFields/R/aaa_auto.R: SUBMODEL_I 	<- as.integer(16)
RandomFields/R/aaa_auto.R: PARAMDEP_I 	<- as.integer(18)
RandomFields/R/aaa_auto.R: ISO_MISMATCH 	<- as.integer(20)
RandomFields/R/aaa_auto.R: LAST_REDUCEDXDIM_CART 	<- as.integer(DOUBLEISOTROPIC)
RandomFields/R/aaa_auto.R: FIRST_PROJECTION 	<- as.integer(GNOMONIC_PROJ)
RandomFields/R/aaa_auto.R: LAST_ISO 	<- as.integer(ISO_MISMATCH)
RandomFields/R/aaa_auto.R: MON_UNSET 	<- as.integer(UNSET)
RandomFields/R/aaa_auto.R: MON_MISMATCH 	<- as.integer(MISMATCH)
RandomFields/R/aaa_auto.R: MON_SUB_DEP 	<- as.integer(SUBMODEL_DEP)
RandomFields/R/aaa_auto.R: MON_PREV_DEP 	<- as.integer(PREVMODEL_DEP)
RandomFields/R/aaa_auto.R: MON_PARAMETER 	<- as.integer(PARAM_DEP)
RandomFields/R/aaa_auto.R: NOT_MONOTONE 	<- as.integer(0)
RandomFields/R/aaa_auto.R: MONOTONE 	<- as.integer(1)
RandomFields/R/aaa_auto.R: GNEITING_MON 	<- as.integer(2)
RandomFields/R/aaa_auto.R: NORMAL_MIXTURE 	<- as.integer(3)
RandomFields/R/aaa_auto.R: COMPLETELY_MON 	<- as.integer(4)
RandomFields/R/aaa_auto.R: MONOTONE_TOTAL 	<- as.integer((BERNSTEIN-MON_UNSET+1))
RandomFields/R/aaa_auto.R: MAXFIELDS 	<- as.integer(10)
RandomFields/R/aaa_auto.R: MODEL_USER 	<- as.integer((MAXFIELDS+0))
RandomFields/R/aaa_auto.R: MODEL_COV 	<- as.integer((MAXFIELDS+1))
RandomFields/R/aaa_auto.R: MODEL_COVMATRIX 	<- as.integer((MAXFIELDS+2))
RandomFields/R/aaa_auto.R: MODEL_VARIOGRAM 	<- as.integer((MAXFIELDS+3))
RandomFields/R/aaa_auto.R: MODEL_PSEUDO 	<- as.integer((MAXFIELDS+4))
RandomFields/R/aaa_auto.R: MODEL_FCTN 	<- as.integer((MAXFIELDS+5))
RandomFields/R/aaa_auto.R: MODEL_DISTR 	<- as.integer((MAXFIELDS+6))
RandomFields/R/aaa_auto.R: MODEL_CALC 	<- as.integer((MAXFIELDS+7))
RandomFields/R/aaa_auto.R: LAST_MODEL_USER 	<- as.integer((MAXFIELDS+9))
RandomFields/R/aaa_auto.R: FIRST_INTERNAL 	<- as.integer((LAST_MODEL_USER+1))
RandomFields/R/aaa_auto.R: MODEL_AUX 	<- as.integer((FIRST_INTERNAL+0))
RandomFields/R/aaa_auto.R: MODEL_INTERN 	<- as.integer((FIRST_INTERNAL+1))
RandomFields/R/aaa_auto.R: MODEL_SPLIT 	<- as.integer((FIRST_INTERNAL+2))
RandomFields/R/aaa_auto.R: MODEL_GUI 	<- as.integer((FIRST_INTERNAL+3))
RandomFields/R/aaa_auto.R: MODEL_MLE 	<- as.integer((FIRST_INTERNAL+4))
RandomFields/R/aaa_auto.R: MODEL_MLESPLIT 	<- as.integer((FIRST_INTERNAL+5))
RandomFields/R/aaa_auto.R: MODEL_LSQ 	<- as.integer((FIRST_INTERNAL+6))
RandomFields/R/aaa_auto.R: MODEL_BOUNDS 	<- as.integer((FIRST_INTERNAL+7))
RandomFields/R/aaa_auto.R: MODEL_PREDICT 	<- as.integer((FIRST_INTERNAL+8))
RandomFields/R/aaa_auto.R: MODEL_ERR 	<- as.integer((FIRST_INTERNAL+10))
RandomFields/R/aaa_auto.R: MODEL_MAX 	<- as.integer(MODEL_ERR)
RandomFields/R/aaa_auto.R: ManifoldType 	<- as.integer(8)
RandomFields/R/aaa_auto.R: GaussMethodType 	<- as.integer(10)
RandomFields/R/aaa_auto.R: BrMethodType 	<- as.integer(12)
RandomFields/R/aaa_auto.R: MathDefType 	<- as.integer(19)
RandomFields/R/aaa_auto.R: MixedInputType 	<- as.integer(25)
RandomFields/R/aaa_auto.R: nVAR2COV_METHODS 	<- as.integer(4)
RandomFields/R/aaa_auto.R: VARPARAM 	<- as.integer(0)
RandomFields/R/aaa_auto.R: SIGNEDVARPARAM 	<- as.integer(1)
RandomFields/R/aaa_auto.R: SDPARAM 	<- as.integer(2)
RandomFields/R/aaa_auto.R: SIGNEDSDPARAM 	<- as.integer(3)
RandomFields/R/aaa_auto.R: SCALEPARAM 	<- as.integer(4)
RandomFields/R/aaa_auto.R: DIAGPARAM 	<- as.integer(5)
RandomFields/R/aaa_auto.R: ANISOPARAM 	<- as.integer(6)
RandomFields/R/aaa_auto.R: INTEGERPARAM 	<- as.integer(7)
RandomFields/R/aaa_auto.R: ANYPARAM 	<- as.integer(8)
RandomFields/R/aaa_auto.R: TRENDPARAM 	<- as.integer(9)
RandomFields/R/aaa_auto.R: CRITICALPARAM 	<- as.integer(11)
RandomFields/R/aaa_auto.R: DONOTVERIFYPARAM 	<- as.integer(12)
RandomFields/R/aaa_auto.R: FORBIDDENPARAM 	<- as.integer(14)
RandomFields/R/aaa_auto.R: UNKNOWNPARAM 	<- as.integer(15)
RandomFields/R/aaa_auto.R: VARONLYMLE 	<- as.integer(16)
RandomFields/R/aaa_auto.R: CRITONLYMLE 	<- as.integer(17)
RandomFields/R/aaa_auto.R: ONLYMLE 	<- as.integer(18)
RandomFields/R/aaa_auto.R: IGNOREPARAM 	<- as.integer(19)
RandomFields/R/aaa_auto.R: INTERNALPARAMETERS 	<- as.integer(22)
RandomFields/R/aaa_auto.R: ALLPARAMETERS 	<- as.integer(23)
RandomFields/R/aaa_auto.R: NOPARAMETERS 	<- as.integer(24)
RandomFields/R/aaa_auto.R: LASTRETURNED 	<- as.integer(FORBIDDENPARAM)
RandomFields/R/aaa_auto.R: FIRSTONLYMLE 	<- as.integer(VARONLYMLE)
RandomFields/R/aaa_auto.R: LASTONLYMLE 	<- as.integer(ONLYMLE)
RandomFields/R/aaa_auto.R: LASTUSERSORTOF 	<- as.integer(FORBIDDENPARAM)
RandomFields/R/aaa_auto.R: LASTSORTOF 	<- as.integer(NOPARAMETERS)
RandomFields/R/aaa_auto.R: TBM 	<- as.integer(3)
RandomFields/R/aaa_auto.R: SpectralTBM 	<- as.integer(4)
RandomFields/R/aaa_auto.R: INTERNAL_PARAM 	<- "internal"
RandomFields/R/aaa_auto.R: GETMODEL_AS_SAVED 	<- as.integer(0)
RandomFields/R/aaa_auto.R: GETMODEL_DEL_NATSC 	<- as.integer(1)
RandomFields/R/aaa_auto.R: GETMODEL_SOLVE_NATSC 	<- as.integer(2)
RandomFields/R/aaa_auto.R: GETMODEL_DEL_MLE 	<- as.integer(3)
RandomFields/R/aaa_auto.R: GETMODEL_SOLVE_MLE 	<- as.integer(4)
RandomFields/R/aaa_auto.R: MIXED_X_NAME 	<- "X"
RandomFields/R/aaa_auto.R: MIXED_BETA_NAME 	<- "beta"
RandomFields/R/aaa_auto.R: COVARIATE_C_NAME 	<- "data"
RandomFields/R/aaa_auto.R: COVARIATE_X_NAME 	<- "x"
RandomFields/R/aaa_auto.R: COVARIATE_RAW_NAME 	<- "raw"
RandomFields/R/aaa_auto.R: COVARIATE_EXTRA_DATA_NAME 	<- "extra_data"
RandomFields/R/aaa_auto.R: COVARIATE_ADDNA_NAME 	<- "addNA"
RandomFields/R/aaa_auto.R: COVARIATE_NAME_NAME 	<- "name"
RandomFields/R/aaa_auto.R: COVARIATE_DATA_NAME 	<- "data"
RandomFields/R/aaa_auto.R: CONST_A_NAME 	<- "x"
RandomFields/R/aaa_auto.R: MINMAX_PMIN 	<- as.integer(1)
RandomFields/R/aaa_auto.R: MINMAX_PMAX 	<- as.integer(2)
RandomFields/R/aaa_auto.R: MINMAX_TYPE 	<- as.integer(3)
RandomFields/R/aaa_auto.R: MINMAX_NAN 	<- as.integer(4)
RandomFields/R/aaa_auto.R: MINMAX_MIN 	<- as.integer(5)
RandomFields/R/aaa_auto.R: MINMAX_MAX 	<- as.integer(6)
RandomFields/R/aaa_auto.R: MINMAX_OMIN 	<- as.integer(7)
RandomFields/R/aaa_auto.R: MINMAX_OMAX 	<- as.integer(8)
RandomFields/R/aaa_auto.R: MINMAX_ROWS 	<- as.integer(9)
RandomFields/R/aaa_auto.R: MINMAX_COLS 	<- as.integer(10)
RandomFields/R/aaa_auto.R: MINMAX_BAYES 	<- as.integer(11)
RandomFields/R/aaa_auto.R: MINMAX_COORD 	<- as.integer(12)
RandomFields/R/aaa_auto.R: MINMAX_ENTRIES 	<- as.integer(MINMAX_COORD)
RandomFields/R/aaa_auto.R: XLIST_SPATIALDIM 	<- as.integer(3)
RandomFields/R/aaa_auto.R: XLIST_TIME 	<- as.integer(4)
RandomFields/R/aaa_auto.R: XLIST_RELEVANT_ELMTS 	<- as.integer((XLIST_GRIDY+1))
RandomFields/R/aaa_auto.R: PROJ_TIME 	<- as.integer(-2)
RandomFields/R/aaa_auto.R: VAR2COV_EXTREMAL 	<- as.integer(-1)
RandomFields/R/aaa_auto.R: VAR2COV_METHODS 	<- as.integer(3)
RandomFields/R/aaa_auto.R:RC_VARIOGRAM <- VARIOGRAM 	<- as.integer(-2)
RandomFields/R/aaa_auto.R:RC_MADOGRAM <- MADOGRAM 	<- as.integer(-1)
RandomFields/R/aaa_auto.R:RC_PSEUDOMADOGRAM <- PSEUDOMADOGRAM 	<- as.integer(1)
RandomFields/R/aaa_auto.R: ALPHAPSEUDOMADOGRAM 	<- as.integer(3)
RandomFields/R/aaa_auto.R: POISSON_SCATTER_OPTIM 	<- as.integer(0)
RandomFields/R/aaa_auto.R: nEQ_NAMES 	<- as.integer(6)
RandomFields/R/aaa_auto.R: NEIGHB_MIN 	<- as.integer(0)
RandomFields/R/aaa_auto.R: NEIGHB_MED 	<- as.integer(NEIGHB_SPLIT)
RandomFields/R/aaa_auto.R: NEIGHB_MAX 	<- as.integer(2)
RandomFields/R/aaa_auto.R: BR_NAME 	<- "brownresnick"
RandomFields/R/aaa_auto.R: EG_NAME 	<- "schlather"
RandomFields/R/aaa_auto.R: OPITZ_NAME 	<- "opitz"
RandomFields/R/aaa_auto.R: SMITH_NAME 	<- "smith"
RandomFields/R/aaa_auto.R: MAX_NA 	<- as.integer(100)
RandomFields/R/aaa_auto.R:RC_DOMAIN_NAMES <- DOMAIN_NAMES <-
RandomFields/R/aaa_auto.R:RC_OPTIMISER_NAMES <- OPTIMISER_NAMES <-
RandomFields/R/aaa_auto.R:RC_NLOPTR_NAMES <- NLOPTR_NAMES <-
RandomFields/R/aaa_auto.R:c( "NLOPT_GN_DIRECT","NLOPT_GN_DIRECT_L","NLOPT_GN_DIRECT_L_RAND","NLOPT_GN_DIRECT_NOSCAL","NLOPT_GN_DIRECT_L_NOSCAL","NLOPT_GN_DIRECT_L_RAND_NOSCAL","NLOPT_GN_ORIG_DIRECT","NLOPT_GN_ORIG_DIRECT_L","NLOPT_LN_PRAXIS","NLOPT_GN_CRS2_LM","NLOPT_LN_COBYLA","NLOPT_LN_NELDERMEAD","NLOPT_LN_SBPLX","NLOPT_LN_BOBYQA","NLOPT_GN_ISRES" )
RandomFields/R/aaa_auto.R:RC_LIKELIHOOD_NAMES <- LIKELIHOOD_NAMES <-
RandomFields/R/aaa_auto.R:RC_DUPLICATEDLOC_NAMES <- DUPLICATEDLOC_NAMES <-
RandomFields/R/aaa_auto.R:RC_ISO_NAMES <- ISO_NAMES <-
RandomFields/R/aaa_auto.R:RC_TYPE_NAMES <- TYPE_NAMES <-
RandomFields/R/aaa_auto.R: NEGATIVE_NAMES <-
RandomFields/R/aaa_auto.R:c( "PARAM_DEP","PREVMODEL_DEP","SUBMODEL_DEP","MISMATCH","UNSET" )
RandomFields/R/aaa_auto.R:RC_MONOTONE_NAMES <- MONOTONE_NAMES <-
RandomFields/R/aaa_auto.R: SORT_ORIGIN_NAMES <-
RandomFields/R/aaa_auto.R:c( "original model","MLE conform","all" )
RandomFields/R/aaa_auto.R: MODE_NAMES <-
RandomFields/R/aaa_auto.R: OUTPUTMODE_NAMES <-
RandomFields/R/aaa_auto.R: ANGLE_NAMES <-
RandomFields/R/aaa_auto.R: REPORTCOORD_NAMES <-
RandomFields/R/aaa_auto.R: UNITS_NAMES <-
RandomFields/R/aaa_auto.R: COORD_SYS_NAMES <-
RandomFields/R/aaa_auto.R: COORD_NAMES_GENERAL <-
RandomFields/R/aaa_auto.R: CARTESIAN_SYS_NAMES <-
RandomFields/R/aaa_auto.R: TYPEOF_PARAM_NAMES <-
RandomFields/R/aaa_auto.R:c( "variance","covariance","sd","signed sd","scale","diagonal","aniso","integer","unspecified","trend","nugget","critical to estimate","never verified","internally ignored","forbidden to be estimated","unkown","variance (used internally)","critical to estimate (used internally)","only used by MLE","neither used by MLE nor returned","standard","include never returned","internal","all","none" )
RandomFields/R/aaa_auto.R: EQ_NAMES <-
RandomFields/R/aaa_auto.R: NAMES_OF_NAMES <-
RandomFields/R/aaa_auto.R:c( "EQ_NAMES","ISO_NAMES","DOMAIN_NAMES","TYPE_NAMES","MONOTONE_NAMES","MODE_NAMES","OUTPUTMODE_NAMES","REPORTCOORD_NAMES","UNITS_NAMES","COORD_SYS_NAMES","CARTESIAN_SYS_NAMES","TYPEOF_PARAM_NAMES" )
RandomFields/R/aaa_auto.R: PROJECTION_NAMES <-
RandomFields/R/aaa_auto.R: RMCOV_X <-
RandomFields/R/aaa_auto.R: FCTN_TYPE_NAMES <-
RandomFields/R/aaa_auto.R:c( "Variogram","Madogram","Covariance","Pseudomadogram","Pseudovariogram" )
RandomFields/R/aaa_auto.R:RC_METHOD_NAMES <- METHOD_NAMES <-
RandomFields/R/aaa_auto.R: POISSON_SCATTER_NAMES <-
RandomFields/R/aaa_auto.R:list2RMmodel_Names <- c('iR_P', 'iR.c', 'iR.p', 'iRFcovariance', 'iRFcovmatrix', 'iRFloglikelihood', 'iRFmadogram', 'iRFpseudomadogram', 'iRFpseudovariogra', 'iRFsimulate', 'iRFvariogram', 'iRMcov', 'iRMcovariate', 'iRMfixcov', 'R.acos', 'R.acosh', 'R.asin', 'R.asinh', 'R.atan', 'R.atan2', 'R.atanh', 'R.c', 'R.cbrt', 'R.ceil', 'R.const', 'R.cos', 'R.cosh', 'R.div', 'R.erf', 'R.erfc', 'R.exp', 'R.exp2', 'R.expm1', 'R.fabs', 'R.fdim', 'R.floor', 'R.fmax', 'R.fmin', 'R.fmod', 'R.gamma', 'R.ggamma', 'R.hypot', 'R.is', 'R.lat', 'R.lgamma', 'R.log', 'R.log1p', 'R.log2', 'R.lon', 'R.minus', 'R.mult', 'R.p', 'R.plus', 'R.pow', 'R.remainder', 'R.round', 'R.sin', 'R.sinh', 'R.sqrt', 'R.tan', 'R.tanh', 'R.trunc', 'RFboxcox', 'RFcalc', 'RFcov', 'RFcovariance', 'RFcovmatrix', 'RFcrossvalidate', 'RFddistr', 'RFdistr', 'RFearth2cartesian', 'RFearth2dist', 'RFempiricalcovariance', 'RFempiricalmadogram', 'RFempiricalvariogram', 'RFfctn', 'RFfit', 'RFformula', 'RFfractaldim', 'RFgetMethodNames', 'RFgetModel', 'RFgetModelInfo', 'RFgetModelInfo_model', 'RFgetModelInfo_register', 'RFgetModelNames', 'RFgridDataFrame', 'RFgui', 'RFhessian', 'RFhurst', 'RFinterpolate', 'RFlikelihood', 'RFlinearpart', 'RFmadogram', 'RFoldstyle', 'RFpar', 'RFparameters', 'RFpdistr', 'RFplot', 'RFplotEmpVariogram', 'RFplotEmpVariogramX', 'RFplotModel', 'RFplotSimulation', 'RFplotSimulation1D', 'RFpointsDataFrame', 'RFpseudomadogram', 'RFpseudovariogram', 'RFqdistr', 'RFratiotest', 'RFrdistr', 'RFsimulate', 'RFspatialGridDataFrame', 'RFspatialPointsDataFrame', 'RFspDataFrame2conventional', 'RFspDataFrame2dataArray', 'RFvariogram', 'RM_COVARIATE', 'RM_DECLARE', 'RM_DISTR', 'RM_MATRIX', 'RM_MULT', 'RM_NUGGET', 'RM_PLUS', 'RM_TREND', 'RM_USER', 'RMangle', 'RMaskey', 'RMave', 'RMball', 'RMbcw', 'RMbernoulli', 'RMbessel', 'RMbicauchy', 'RMbigneiting', 'RMbistable', 'RMbiwm', 'RMblend', 'RMbr2bg', 'RMbr2eg', 'RMbrownresnick', 'RMbubble', 'RMcardinalsine', 'RMcauchy', 'RMcauchytbm', 'RMcauchyUnif1', 'RMcauchyUnif2', 'RMcauchyUnif3', 'RMchoquet', 'RMcircular', 'RMconstant', 'RMcov', 'RMCOV_X', 'RMcovariate', 'RMcoxisham', 'RMcubic', 'RMcurlfree', 'RMcutoff', 'RMdagum', 'RMdampedcos', 'RMdeclare', 'RMdelay', 'RMderiv', 'RMdewijsian', 'RMdivfree', 'RMeaxxa', 'RMepscauchy', 'RMetaxxa', 'RMexp', 'RMexponential', 'RMfbm', 'RMfixcov', 'RMflatpower', 'RMfractdiff', 'RMfractgauss', 'RMgauss', 'RMgaussGammalike', 'RMgaussgauss', 'RMgencauchy', 'RMgenfbm', 'RMgengneiting', 'RMgennsst', 'RMgneiting', 'RMgneitingdiff', 'RMhandcock', 'RMhyperbolic', 'RMiaco', 'RMid', 'RMidcoord', 'RMidmodel', 'RMintexp', 'RMintrinsic', 'RMkolmogorov', 'RMlatentCauchy1', 'RMlatentCauchy2', 'RMlatentCauchy3', 'RMlatentCauchy4', 'RMlgd', 'RMlsfbm', 'RMm2r', 'RMm3b', 'RMma', 'RMmastein', 'RMmatern', 'RMmatrix', 'RMmodelplus', 'RMmppplus', 'RMmps', 'RMmqam', 'RMmult', 'RMmultiquad', 'RMnatsc', 'RMnsst', 'RMnugget', 'RMparswm', 'RMparswmX', 'RMpenta', 'RMplus', 'RMpolygon', 'RMpolynome', 'RMpower', 'RMpoweredexp', 'RMprod', 'RMqam', 'RMqexp', 'RMrational', 'RMrotat', 'RMrotation', 'RMS', 'RMscale', 'RMschlather', 'RMschur', 'RMsign', 'RMsinepower', 'RMspheric', 'RMstable', 'RMstein', 'RMstp', 'RMsum', 'RMtbm', 'RMtent', 'RMtrafo', 'RMshape', 'RMshapeplus', 'RMtruncsupport', 'RMuser', 'RMvector', 'RMwave', 'RMwendland', 'RMwhittle', 'RPaverage', 'RPbernoulli', 'RPbrmixed', 'RPbrorig', 'RPbrownresnick', 'RPbrshifted', 'RPchi2', 'RPcirculant', 'RPcoins', 'RPcutoff', 'RPdirect', 'RPgauss', 'RPhyperplane', 'RPintrinsic', 'RPloggaussnormed', 'RPnugget', 'RPopitz', 'RPpoisson', 'RPschlather', 'RPsequential', 'RPsmith', 'RPspecific', 'RPspectral', 'RPt', 'RPtbm', 'RPtrend', 'RRdeterm', 'RRdistr', 'RRgauss', 'RRloc', 'RRmcmc', 'RRrectangular', 'RRspheric', 'RRunif')
RandomFields/R/aaa_auto.R:list2RMmodel_oldNames <- c('#', '>', '>', '+', '*', '$', '$power', 'ave', 'shape.ave', 'bcw', 'locstatfbm', 'bessel', 'bigneiting', 'bernoulli', 'biWM', 'bistable', 'blend', 'brownresnick', 'br2bg', 'br2eg', 'bubble', 'cauchy', 'cauchyUnif1', 'cauchyUnif2', 'cauchyUnif3', 'latentCauchy1', 'latentCauchy2', 'latentCauchy3', 'latentCauchy4', 'circular', 'CDeWijsian', 'constant', 'fixcov', 'coxisham', 'cubic', 'curlfree', 'cutoff', 'dagum', 'dampedcosine', 'deriv', 'DeWijsian', 'divfree', 'epsC', 'exponential', 'Exp', 'extremalgauss', 'FD', 'flatpower', 'fractalB', 'fractgauss', 'gauss', 'gaussgauss', 'gaussGammalike', 'genB', 'gencauchy', 'bicauchy', 'gengneiting', 'gengneit_intern', 'gneiting', 'gennsst', 'gennsst_intern', 'hyperbolic', 'iacocesare', 'identity', 'kolmogorov', 'lgd1', 'mastein', 'ma1', 'ma2', 'M', 'matern', 'mqam', 'multiquad', 'natsc', 'nsst', 'nugget', 'parsWM', 'penta', 'power', 'Pow', 'prod', 'qam', 'qexponential', 'scale', 'schur', 'shift', 'sinepower', 'spherical', 'stable', 'Stein', 'steinst1', 'stp', 'shape.stp', 'tbm', 'sum', 'U', 'cov', 'vector', 'wave', 'whittle', 'missing', 'null', 'trend', 'select', 'angle', 'ball', 'covariate', 'declare', 'EAxxA', 'EtAxxA', 'idcoord', 'trafo', 'mult_inverse', 'polygon', 'rational', 'rotat', 'Rotat', 'scatter', 'sign', 'setparam', 'm2r', 'm3b', 'r3binner', 'mps', 'truncsupport', 'arcsqrt', 'determ', 'distr', 'normal', 'setDistr', 'loc', 'mcmc', 'rectangular', 'spheric', 'unif', 'MCMC_PGS', 'zhou', 'ballani', 'standardShape', '++', 'statShape', 'Simulate', 'Covariance', 'CovMatrix', 'Dummy', 'get', 'Fctn', 'Distr', 'loglikelihood', 'linearpart', 'predict', 'Pseudovariogram', 'Pseudomadogram', 'Madogram', 'Variogram', '$proc', 'plusproc', 'prodproc', 'trafoproc', 'mppplusproc', 'multproc', 'matrixproc', 'covproc', 'trend', 'average', 'coins', 'averageIntern', 'circulant', 'cutoff', 'cutoffIntern', 'intrinsic', 'intrinsIntern', 'direct', 'hyperplane', 'hyperIntern', 'nugget', 'nuggetIntern', 'sequential', 'spectral', 'spectralIntern', 'specific', 'tbm', 'tbmIntern', 'loggaussnormed', 'brorig', 'brorigIntern', 'brmixed', 'brmixedIntern', 'brshifted', 'brshiftIntern', 'brownresnick', 'binaryprocess', 'gauss.process', 'poisson', 'extremalgauss', 'extremalt', 'smith', 'chi2', 't', 'minus', 'plus', 'div', 'mult', 'const', 'p', 'c', 'is', '.asin', '.atan', '.atan2', '.cos', '.sin', '.tan', '.asinh', '.atanh', '.cosh', '.sinh', '.tanh', '.log', '.expm1', '.log1p', '.exp2', '.log2', '.hypot', '.cbrt', '.ceil', '.floor', '.fmod', '.round', '.trunc', '.erfc', '.lgamma', '.remainder', '.fdim', '.fmax', '.fmin', '.gamma', '.ggamma', '.exp', '.erf', '.fabs', '.acos', '.acosh', '.pow', '.sqrt')
RandomFields/R/aaa_auto.R:rfgui1_Names <- c('RMaskey', 'RMbcw', 'RMbessel', 'RMcauchy', 'RMcauchytbm', 'RMcircular', 'RMcubic', 'RMdampedcos', 'RMepscauchy', 'RMexp', 'RMfractdiff', 'RMfractgauss', 'RMgauss', 'RMgencauchy', 'RMgengneiting', 'RMgneitingdiff', 'RMhyperbolic', 'RMlgd', 'RMparswm', 'RMpenta', 'RMqexp', 'RMspheric', 'RMstable', 'RMwave', 'RMwhittle')
RandomFields/R/aaa_auto.R:rfgui2_Names <- c('RMaskey', 'RMbcw', 'RMbessel', 'RMcauchy', 'RMcircular', 'RMcubic', 'RMdampedcos', 'RMepscauchy', 'RMexp', 'RMgauss', 'RMgencauchy', 'RMgengneiting', 'RMhyperbolic', 'RMlgd', 'RMparswm', 'RMpenta', 'RMqexp', 'RMspheric', 'RMstable', 'RMwave', 'RMwhittle')
RandomFields/R/RMmodelsSpecial.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/RMmodelsSpecial.R:## Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/R/RMmodelsSpecial.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/RMmodelsSpecial.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/RMmodelsSpecial.R:    model <- new(CLASS_CLIST, name = RM_DISTR[1],
RandomFields/R/RMmodelsSpecial.R:              do.call(RM_DISTR[1], list(subs[[i]]))
RandomFields/R/RMmodelsSpecial.R:  model <- new(CLASS_CLIST, name = RM_DISTR[1], submodels = submodels, 
RandomFields/R/RMmodelsSpecial.R:RRdistr <- new(CLASS_RM,
RandomFields/R/RMmodelsSpecial.R:               type = TYPE_NAMES[RandomType + 1],
RandomFields/R/RMmodelsSpecial.R:               domain = DOMAIN_NAMES[DOMAIN_MISMATCH + 1],
RandomFields/R/RMmodelsSpecial.R:               isotropy = ISO_NAMES[ISO_MISMATCH + 1],
RandomFields/R/RMmodelsSpecial.R:               monotone =  MONOTONE_NAMES[NOT_MONOTONE + 1 - MON_UNSET],
RandomFields/R/RMmodelsSpecial.R:RMuser <- function(type, domain, isotropy, vdim, beta,
RandomFields/R/RMmodelsSpecial.R:	if (!hasArg(type)) type <- TYPE_NAMES[ShapeType + 1]
RandomFields/R/RMmodelsSpecial.R:          par.model[['type']] <- pmatch(type, TYPE_NAMES) - 1
RandomFields/R/RMmodelsSpecial.R:                  TYPE_NAMES[1+par.model[['type']]],
RandomFields/R/RMmodelsSpecial.R:                  "'). (If you are not sure whether your function is positive/negative definite, please contact ", AUTHOR, ")\nUsing predefined functions leads to (much!) shorter computing times (up to a factor 100).\nSee ?RM for an overview over the implemented models. Further,\nsome simulation methods do not work at all for user defined functions.")
RandomFields/R/RMmodelsSpecial.R:          message("Please make sure that the defined function is not available in 'RandomFields'.\nUsing predefined functions leads to (much!) shorter computing times (up to a factor 100).\nSee ?RMmodelsTrend  for an overview over the implemented models. Further,\nsome simulation methods do not work at all for user defined functions.");
RandomFields/R/RMmodelsSpecial.R:                   par.model[['domain']] <- pmatch(domain, DOMAIN_NAMES) - 1
RandomFields/R/RMmodelsSpecial.R:                   par.model[['isotropy']] <- pmatch(isotropy, ISO_NAMES) - 1
RandomFields/R/RMmodelsSpecial.R:	model <- new(CLASS_CLIST, name = RM_USER[1], 
RandomFields/R/RMmodelsSpecial.R:RMuser <- new(CLASS_RM,
RandomFields/R/RMmodelsSpecial.R:              .Data = RMuser,
RandomFields/R/RMmodelsSpecial.R:              type = TYPE_NAMES[PosDefType + 1],
RandomFields/R/RMmodelsSpecial.R:              domain = DOMAIN_NAMES[PREVMODEL_D + 1],
RandomFields/R/RMmodelsSpecial.R:              isotropy = ISO_NAMES[PREVMODEL_I + 1],
RandomFields/R/RMmodelsSpecial.R:              monotone =  MONOTONE_NAMES[NOT_MONOTONE + 1 - MON_UNSET], # [MON_PARAMETER]
RandomFields/R/RMmodelsSpecial.R:RMdeclare <- function(...) {
RandomFields/R/RMmodelsSpecial.R:         " not follow the requirements of 'RMdeclare'.")
RandomFields/R/RMmodelsSpecial.R:               name = model.name, ## == RMdeclare
RandomFields/R/RMmodelsSpecial.R:RMdeclare <- new(CLASS_RM,
RandomFields/R/RMmodelsSpecial.R:               .Data = RMdeclare,
RandomFields/R/RMmodelsSpecial.R:               type = TYPE_NAMES[TrendType + 1],
RandomFields/R/RMmodelsSpecial.R:               domain = DOMAIN_NAMES[XONLY+ 1],
RandomFields/R/RMmodelsSpecial.R:               isotropy = ISO_NAMES[PREVMODEL_I + 1],
RandomFields/R/RMmodelsSpecial.R:               monotone =  MONOTONE_NAMES[NOT_MONOTONE + 1],
RandomFields/R/RMmodelsSpecial.R:RMcovariate <- function(formula=NULL, data, x, y=NULL, z=NULL, T=NULL, grid,
RandomFields/R/RMmodelsSpecial.R:  Call <- iRMcovariate
RandomFields/R/RMmodelsSpecial.R:RMcovariate <- copyProp(RMcovariate, iRMcovariate)
RandomFields/R/RMmodelsSpecial.R:RMfixcov <- function(M, x, y=NULL, z=NULL, T=NULL, grid, var, proj, raw#, norm
RandomFields/R/RMmodelsSpecial.R:  Call <- iRMfixcov
RandomFields/R/RMmodelsSpecial.R:         M=M, raw=raw, var=var, proj=proj)
RandomFields/R/RMmodelsSpecial.R:         M=M, x=new, raw=raw, var=var, proj=proj)
RandomFields/R/RMmodelsSpecial.R:RMfixcov <- copyProp(RMfixcov, iRMfixcov)
RandomFields/R/RMmodelsSpecial.R:RMcov <- function(gamma, x, y=NULL, z=NULL, T=NULL, grid, a,
RandomFields/R/RMmodelsSpecial.R:  Call <- iRMcov
RandomFields/R/RMmodelsSpecial.R:    x <- pmatch(x, RMCOV_X)
RandomFields/R/RMmodelsSpecial.R:RMcov <- copyProp(RMcov, iRMcov)
RandomFields/R/RMmodelsSpecial.R:RMpolynome <- function(degree, dim, value=NA,
RandomFields/R/RMmodelsSpecial.R:  if (length(z) > 100) stop("maximum is ", MAXSUB, "^2 terms")
RandomFields/R/RMmodelsSpecial.R:  idx <- as.integer(length(z) / MAXSUB) * MAXSUB  
RandomFields/R/RMmodelsSpecial.R:    dim(zz) <- c(MAXSUB, length(zz) / MAXSUB)
RandomFields/R/RMmodelsSpecial.R:    zz <- apply(zz, 2, function(x) paste("RMplus(", paste(x, collapse=", "), ")" ))
RandomFields/R/RMmodelsSpecial.R:       paste("RMplus(", paste(z[(idx+1) : length(z)], collapse=", "), ")" )
RandomFields/R/RMmodelsSpecial.R:    zz <- paste("RMplus(", paste(zz, collapse=", "), ")")
RandomFields/R/RMmodelsSpecial.R:RMpolynome <- copyProp(RMpolynome, iR.c)
RandomFields/R/RMmodelsSpecial.R:RMpolynome <- copyProp(RMpolynome, iR.c)
RandomFields/R/RMmodelsSpecial.R:xRMranef <- function(formula=NULL, data, x, y=NULL, z=NULL, T=NULL, grid,
RandomFields/R/RMmodelsSpecial.R:   formula <- RMcovariate(formula=formula, data=data, x=x, y=y, z=z, T=T,
RandomFields/R/RMmodelsSpecial.R:      stop("'formula' is not a 'RMmodel' as expected")
RandomFields/R/RMmodelsSpecial.R:       stop("If 'formula' is an 'RMmodel' then only 'var', 'scale', 'Aniso', and 'proj' might be given") 
RandomFields/R/RMmodelsSpecial.R:      message("Note that if 'var' is not given in 'RMranef', 'var' is set to 'NA' i.e., the variance is estimated'.")
RandomFields/R/RMmodelsSpecial.R:  #RMraneffct(formula, var, scale, Aniso, proj)
RandomFields/R/RMmodelsSpecial.R:XXXRMprod <- function(phi, var, scale, Aniso, proj) {
RandomFields/R/RMmodelsSpecial.R:  #RMraneffct(phi, var, scale, Aniso, proj)
RandomFields/R/RMmodelsSpecial.R:RMshapeplus <- function(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9,
RandomFields/R/RMmodelsSpecial.R:    par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodelsSpecial.R:                        name = 'RMplus',  ## !!
RandomFields/R/RMmodelsSpecial.R:RMshapeplus <- new(CLASS_RM, 
RandomFields/R/RMmodelsSpecial.R:	.Data = RMshapeplus,
RandomFields/R/RMmodelsSpecial.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodelsSpecial.R:	vdim = SUBMODEL_DEP
RandomFields/R/RMmodelsSpecial.R:RMmodelplus <- function(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9,
RandomFields/R/RMmodelsSpecial.R:    par.general[['proj']] <- CheckMixed(proj, subst, PROJECTION_NAMES)
RandomFields/R/RMmodelsSpecial.R:                        name = 'RMplus',  ## !!
RandomFields/R/RMmodelsSpecial.R:RMmodelplus <- new(CLASS_RM, 
RandomFields/R/RMmodelsSpecial.R:	.Data = RMmodelplus,
RandomFields/R/RMmodelsSpecial.R:	maxdim = SUBMODEL_DEP,
RandomFields/R/RMmodelsSpecial.R:	vdim = SUBMODEL_DEP
RandomFields/R/generatemodels.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/generatemodels.R:## Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/R/generatemodels.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/generatemodels.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/generatemodels.R:## meta-function that generates functions like RMplus, RMwhittle, which
RandomFields/R/generatemodels.R:## of class 'RMmodels'
RandomFields/R/generatemodels.R:      x[i] <- paste(x[i], "CheckMixed(proj, subst, PROJECTION_NAMES)", sep="")
RandomFields/R/generatemodels.R:   else if (length(Const) > 0 && Const[i] == MixedInputType) 
RandomFields/R/generatemodels.R:       x[i] <- paste(x[i], "CheckMixed(", names[i], ", subst, ",
RandomFields/R/generatemodels.R:                    NAMES_OF_NAMES[Const[i] - NN1 + 1], ", ",
RandomFields/R/generatemodels.R:       x[i] <- paste(x[i], "CheckMaths(", names[i], ", subst, ",
RandomFields/R/generatemodels.R:E <- function(n) if (n >= 0) n else NEGATIVE_NAMES[-n] # nicht + 1
RandomFields/R/generatemodels.R:rfGenerateModels <- function(package="RandomFields", assigning,
RandomFields/R/generatemodels.R:                             RMmodels.file = paste(RFpath,
RandomFields/R/generatemodels.R:						   "R/RMmodels.R",
RandomFields/R/generatemodels.R:  for (i in 1:length(NEGATIVE_NAMES)) 
RandomFields/R/generatemodels.R:    if (i != -get(NEGATIVE_NAMES[i]))  # nicht + 1
RandomFields/R/generatemodels.R:       stop("NEGATIVE_NAMES do not match values")
RandomFields/R/generatemodels.R:  if (assigning && file.exists(RMmodels.file))
RandomFields/R/generatemodels.R:    file.remove(RMmodels.file)
RandomFields/R/generatemodels.R:   write(file = RMmodels.file, append = TRUE,
RandomFields/R/generatemodels.R:        "\n## This file has been created automatically by 'rfGenerateModels'.\n\n")
RandomFields/R/generatemodels.R:  empty <- paste(rep(" ", MAXCHAR_RF), collapse="")
RandomFields/R/generatemodels.R:  empty2 <- paste(rep(" ", MAXCHAR_RF), collapse="")
RandomFields/R/generatemodels.R:  nr <- GetCurrentNrOfModels()
RandomFields/R/generatemodels.R:  vn <- nr * MAXVARIANTS
RandomFields/R/generatemodels.R:          paramtype = integer(vn * MAXPARAM),
RandomFields/R/generatemodels.R:  dim(A$paramtype) <- c(MAXPARAM, vn)
RandomFields/R/generatemodels.R:	cat(i, "internal", .C(C_GetModelName,as.integer(A$nr[i]),
RandomFields/R/generatemodels.R:    if (domains == PREVMODEL_D) domains <- c(XONLY, KERNEL)
RandomFields/R/generatemodels.R:    ret <- .C(C_GetModelName,as.integer(A$nr[i]),
RandomFields/R/generatemodels.R:           nick ==  .C(C_GetModelName,as.integer(A$nr[i + step]),
RandomFields/R/generatemodels.R:    internal <- which(paramnames == INTERNAL_PARAM)
RandomFields/R/generatemodels.R:               nick %in% c("RMball", "RMsum", "RMconstant",
RandomFields/R/generatemodels.R:                           "RMfixcov", "RMcovariate")
RandomFields/R/generatemodels.R:               || nick == RM_PLUS[1] || nick[1] == RM_MULT[1]) &&
RandomFields/R/generatemodels.R:      !(nick %in% c("RMtrafo",  "RMsine")) && !ismath
RandomFields/R/generatemodels.R:      if (nick %in% c("RMidcoord")) NULL
RandomFields/R/generatemodels.R:      else if (nick %in% c("RMfixcov")) c("var", "proj")
RandomFields/R/generatemodels.R:      else if (nick %in%  c("RMconstant", "RMcovariate")) "var"
RandomFields/R/generatemodels.R:      else if (nick == "RMnugget") c("var", "Aniso", "proj")
RandomFields/R/generatemodels.R:        paste(DOMAIN_NAMES[domains+1], collapse="; "), "\t",
RandomFields/R/generatemodels.R:             # create RMmodel object
RandomFields/R/generatemodels.R:    # assign class CLASS_RM (CLASS_RM) and attributes like stationarity
RandomFields/R/generatemodels.R:      paste(internal.nick, " <- new(CLASS_RM, \n\t",
RandomFields/R/generatemodels.R:         "type = ", "c('", paste(TYPE_NAMES[type+1], collapse="', '"), "'),",
RandomFields/R/generatemodels.R:         "isotropy = ", "c('", paste(ISO_NAMES[iso+1], collapse="', '"), "'),",
RandomFields/R/generatemodels.R:         "domain = ", "c('", paste(DOMAIN_NAMES[domains+1], collapse="', '"),   "'),", "\n\t",
RandomFields/R/generatemodels.R:         "monotone = ",    "'", MONOTONE_NAMES[A$monotone[i] + 1 - MON_UNSET],
RandomFields/R/generatemodels.R:    if (internal.nick == "RMwhittle") {
RandomFields/R/generatemodels.R:      #sink(file = RMmodels.file, append = TRUE, type='output')
RandomFields/R/generatemodels.R:      write(file = RMmodels.file, append = TRUE, text)
RandomFields/R/generatemodels.R:      #unlink(RMmodels.file)
RandomFields/R/generatemodels.R:                 abs(y) <= .Machine$integer.max
RandomFields/R/generatemodels.R:##      cat(Integer, "", y,"", .Machine$integer.max, "",abs(y) <= .Machine$integer.max)
RandomFields/R/generatemodels.R:    genuine <- all[substr(all, 1, 2) %in% c("iR", "RM", "R.", "RP" ,"RF", "RR")]
RandomFields/R/generatemodels.R:    define_char("list2RMmodel_Names", genuine) ##, RM_TREND
RandomFields/R/generatemodels.R:    define_char("list2RMmodel_oldNames",
RandomFields/R/generatemodels.R:		Try(RFgetModelNames(newnames=FALSE))) # , RM_INTERNALMIXED
RandomFields/R/generatemodels.R:    names1 <- c("RMwhittle",
RandomFields/R/generatemodels.R:                RFgetModelNames(type=TYPE_NAMES[c(TcfType, PosDefType) + 1],
RandomFields/R/generatemodels.R:                                isotropy=ISO_NAMES[ISOTROPIC + 1],
RandomFields/R/generatemodels.R:      c("RMnugget", # macht kaum sinn
RandomFields/R/generatemodels.R:        "RMwendland","RMcardinalsine","RMpoweredexp", # aliase
RandomFields/R/generatemodels.R:        "RMparswmX", "RMtent", # convenience models
RandomFields/R/generatemodels.R:        "RMconstant", ## macht aerger
RandomFields/R/generatemodels.R:        "RMlsfbm", ## nur fuer |x| < 1 definiert
RandomFields/R/generatemodels.R:        "RMdagum", ## internal parameter
RandomFields/R/generatemodels.R:        "RMgneiting" ## integer parameter
RandomFields/R/generatemodels.R:    names2 <- c("RMwhittle",
RandomFields/R/generatemodels.R:                 RFgetModelNames(type=TYPE_NAMES[c(TcfType, PosDefType) + 1],
RandomFields/R/generatemodels.R:                                isotropy=ISO_NAMES[ISOTROPIC + 1],
RandomFields/R/generatemodels.R:rfGenerateMaths <- function(package = "RandomFields",
RandomFields/R/generatemodels.R:                            Cfile = "QMath", Rfile = "RQmodels",
RandomFields/R/generatemodels.R:	  c("// This file has been created automatically by 'rfGenerateMaths'",
RandomFields/R/generatemodels.R:          "# This file has been created automatically by 'rfGenerateMaths'")
RandomFields/R/generatemodels.R:		  paste("void Math", name,
RandomFields/R/generatemodels.R:			"\nMATH_DEFAULT\n", sep=""))
RandomFields/R/generatemodels.R:              'IncludeModel(".', name, '", MathDefType, 0, 0, ', args,
RandomFields/R/generatemodels.R:			    'PREVMODEL_I,checkMath,rangeMath, PREF_TREND,\n\t',
RandomFields/R/generatemodels.R:			    'false, SCALAR, PREVMODEL_DEP, false, false); \n',
RandomFields/R/generatemodels.R:	      'addCov(Math', name, ', NULL, NULL);\n',
RandomFields/R/generatemodels.R:	      'AddVariant(TrendType, PREVMODEL_I);\n', sep="")
RandomFields/R/generatemodels.R:		      paste(sep="", "setMethod(\"", Rname,
RandomFields/R/generatemodels.R:    write(file = cfile, append=TRUE, "void includeStandardMath() {")
RandomFields/R/generatemodels.R:} ## NO QMath.* generated anymore
RandomFields/R/RMmodelsConvenience.R:# accessing 'RMmodel' and RMmodelgenerator via '['-operator
RandomFields/R/RMmodelsConvenience.R:# e.g. RMwhittle["domain"]
RandomFields/R/RMmodelsConvenience.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/RMmodelsConvenience.R:## Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/R/RMmodelsConvenience.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/RMmodelsConvenience.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/RMmodelsConvenience.R:RMcauchytbm <- function(alpha, beta, gamma, var, scale, Aniso, proj) {
RandomFields/R/RMmodelsConvenience.R:  return(RMtbm(fulldim=gamma,
RandomFields/R/RMmodelsConvenience.R:               RMgencauchy(alpha, beta, var, scale, Aniso, proj)))
RandomFields/R/RMmodelsConvenience.R:RMcauchytbm <- new(CLASS_RM, 
RandomFields/R/RMmodelsConvenience.R:	.Data = RMcauchytbm,
RandomFields/R/RMmodelsConvenience.R:RMgneitingdiff <- function(nu, taper.scale, scale, var, Aniso, proj){
RandomFields/R/RMmodelsConvenience.R:  return(RMmult(RMgengneiting(kappa=3, mu=1.5, scale=taper.scale) *
RandomFields/R/RMmodelsConvenience.R:                RMwhittle(nu=nu, scale=scale),
RandomFields/R/RMmodelsConvenience.R:RMgneitingdiff <- new(CLASS_RM, 
RandomFields/R/RMmodelsConvenience.R:	.Data = RMgneitingdiff,
RandomFields/R/RMmodelsConvenience.R:RMparswmX <- function(nudiag, rho, var, scale, Aniso, proj) {
RandomFields/R/RMmodelsConvenience.R:  return(RMschur(M=rho, RMparswm(nudiag, var, scale, Aniso, proj)))
RandomFields/R/RMmodelsConvenience.R:RMparswmX <- copyProp(RMparswmX, RMparswm)
RandomFields/R/RMmodelsConvenience.R:RMtent <- function(var, scale, Aniso, proj) {
RandomFields/R/RMmodelsConvenience.R:  return(RMaskey(alpha=1.0, var, scale, Aniso, proj))
RandomFields/R/RMmodelsConvenience.R:RMgneitingdiff <- new(CLASS_RM, 
RandomFields/R/RMmodelsConvenience.R:	.Data = RMgneitingdiff,
RandomFields/R/RMmodelsConvenience.R:RMhandcock <- function(nu, notinvnu, var, scale, Aniso, proj){
RandomFields/R/RMmodelsConvenience.R:  RMS(scale = 1/sqrt(2), RMmatern(nu, notinvnu, var, scale, Aniso, proj))
RandomFields/R/RMmodelsConvenience.R:RMhandcock <- copyProp(RMhandcock, RMmatern)
RandomFields/R/RMmodelsConvenience.R:RMpoweredexp <- RMstable
RandomFields/R/RMmodelsConvenience.R:RMcardinalsine <- RMwave
RandomFields/R/RMmodelsConvenience.R:RMwendland <- RMgengneiting
RandomFields/R/RMmodelsConvenience.R:RMchoquet <- function(b) stop("not implemented yet")
RandomFields/R/Class.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/Class.R:## Copyright (C) 2012 -- 2015 Alexander Malinowski & Martin Schlather
RandomFields/R/Class.R:## Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/R/Class.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/Class.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/Class.R:         representation(# name='RMexp'
RandomFields/R/Class.R:                        # submodels=NULL, submodels=list(RMmodel1, RMmodel2)
RandomFields/R/Class.R:isModel <- function(model) return(is.list(model) && is.character(model[[1]]) )
RandomFields/R/Class.R:##isRMmodel <- function(x) isS4(x) && is(x, CLASS_CLIST)
RandomFields/R/Class.R:## definition of class CLASS_RM ################################
RandomFields/R/Class.R:setClass(CLASS_RM, contains ="function",
RandomFields/R/Class.R:## definition of class 'RMmodelFit'
RandomFields/R/Class.R:setClass(CLASS_EMPIR, 
RandomFields/R/Class.R:                        ev=CLASS_EMPIR,
RandomFields/R/Class.R:                        users.guess = CLASS_SINGLEFIT, # Martin: 2.4.: eingefuegt
RandomFields/R/fitmaxstable.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/fitmaxstable.R:## Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/R/fitmaxstable.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/fitmaxstable.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/unify.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/unify.R:## Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/R/unify.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/unify.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/unify.R:  if (is.character(system)) system <- pmatch(system, ISO_NAMES) - 1
RandomFields/R/unify.R:            c(CARTESIAN_COORD, GNOMONIC_PROJ, ORTHOGRAPHIC_PROJ))
RandomFields/R/unify.R:                RMtrafo(new=system), coords, grid=grid,
RandomFields/R/unify.R: if (is.character(system)) system <- pmatch(system, ISO_NAMES) - 1
RandomFields/R/unify.R:            c(CARTESIAN_COORD, GNOMONIC_PROJ, ORTHOGRAPHIC_PROJ))
RandomFields/R/unify.R:              RMtrafo(new=system), coords, grid=grid,
RandomFields/R/unify.R:  duplicated <- which(RFopt$general$duplicated_loc == DUPLICATEDLOC_NAMES) - 1
RandomFields/R/unify.R:        if (PL>=PL_IMPORTANT && new$spatialdim > 1)
RandomFields/R/unify.R:   change.of.units <- coord_system == COORD_SYS_NAMES[coord_auto + 1] &&
RandomFields/R/unify.R:        if (newunits[1] == "") newunits[1] <-  UNITS_NAMES[units_km + 1]
RandomFields/R/unify.R:        coord_system <- COORD_SYS_NAMES[earth + 1]
RandomFields/R/unify.R:        setRFoptions(coords.coord_system =  COORD_SYS_NAMES[cartesian + 1])
RandomFields/R/unify.R:        if (PL >= PL_SUBIMPORTANT && RFopt$messages$warn_oldstyle) {
RandomFields/R/unify.R:        if (PL>PL_IMPORTANT) 
RandomFields/R/unify.R:    new_is_cartesian <- new_coord_system %in% CARTESIAN_SYS_NAMES
RandomFields/R/unify.R:                  else if (opt$zenit[!idx] == 1) colMeans(x[, 1:2])
RandomFields/R/unify.R:                  else if (opt$zenit[!idx] == Inf) colMeans(apply(x[, 1:2], 2,
RandomFields/R/unify.R:                     "gnomonic" = GNOMONIC_PROJ,
RandomFields/R/unify.R:                  RMtrafo(new=code), x, grid=grid, 
RandomFields/R/unify.R:                    RMtrafo(new=code), y, grid=grid, 
RandomFields/R/unify.R:  .Call(C_setlocalRFutils, NULL, min(PL, PL_IMPORTANT)) # fuer UnifyXT-Aufrufe
RandomFields/R/unify.R:  duplicated <- which(RFopt$general$duplicated_loc == DUPLICATEDLOC_NAMES) - 1
RandomFields/R/unify.R:#  Print(duplicated , RFopt$general$duplicated_loc, DUPLICATEDLOC_NAMES)
RandomFields/R/unify.R:     info <- data.columns(data, ## auch PM2
RandomFields/R/unify.R:                          model=model,  ## auch PM2
RandomFields/R/unify.R:                          xdim=xdim, ## auch PM2
RandomFields/R/unify.R:                          x = neu, ## auch PM2
RandomFields/R/unify.R:                           params=params, ## nur PM2
RandomFields/R/unify.R:                           add.na=add.na, ## nur PM2
RandomFields/R/unify.R:                             ...) ## nur PM2
RandomFields/R/unify.R:               PrepareModel2(model=model, params=params, xdim=xdim, x=neu,
RandomFields/R/unify.R:               PrepareModel2(further.models[[m]], params=params,
RandomFields/R/unify.R:    ##            keine x-Koord fuer Modell bekannt waren.
RandomFields/R/unify.R:  if (PL > PL_SUBIMPORTANT ||
RandomFields/R/unify.R:      (PL >= PL_IMPORTANT && info$data.info != "safe")) {
RandomFields/R/unify.R:    DataNames = info$M$data.coordnames ## info$M might be NULL already;
RandomFields/R/convert.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/convert.R:### Diese Datei wandelt RMmodel in eine Liste um
RandomFields/R/convert.R:## Copyright (C) 2015 -- 2016 Alexander Malinowski, Martin Schlather,
RandomFields/R/convert.R:##               2017 -- 2019 Martin Schlather
RandomFields/R/convert.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/convert.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/convert.R:    ## !! folllowing assignment also needed in PrepareModel !!
RandomFields/R/convert.R:    CM <- as.character(model)
RandomFields/R/convert.R:    if (length(CM) == 3) { ## data.varnames given by left hand side of formula
RandomFields/R/convert.R:      leftSide <- parse(text=CM[2])
RandomFields/R/convert.R:        used.varnames <- if (rawError(used.varnames)) NULL else CM[2]
RandomFields/R/convert.R:AddTransform <- function(M, model, params, orig.params, Names, nNA,
RandomFields/R/convert.R:                         xdim,  MODEL_AUX, add.na, Env, EnvDummies) {
RandomFields/R/convert.R:  values <- as.double(100001 * MAXACCEPTED * (1:MAX_NA))
RandomFields/R/convert.R:  M300 <- parseModel(model=model, Env=Env, EnvDummies = EnvDummies,
RandomFields/R/convert.R:    .Call(C_GetNAPositions, MODEL_AUX, list("Dummy", M300), M$C_coords,
RandomFields/R/convert.R:  CtoR <- .Call(C_GetNAPositions, MODEL_AUX, NULL, M$C_coords,
RandomFields/R/convert.R:    Check.CtoR(CtoR, MODEL_AUX, values)
RandomFields/R/convert.R:    ##    Print(M300, NAs.in.model, tot.NAs.in.model, cumNA, values, CtoR, RtoC, genuine.symbols, S2P, S2Pxx, S2C0, S2C, im.S2C)
RandomFields/R/convert.R:      stop("incorrect 'params'. Probably not all newly introduced variables have been defined in 'RMdeclare'.")
RandomFields/R/convert.R:#    Print("NACH MOCK", ls(envir = Env))
RandomFields/R/convert.R:    CmidN2RmidN <- .Call(C_GetNAPositions, MODEL_AUX, NULL, M$C_coords,
RandomFields/R/convert.R:      stop("number of parameters declared to be estimated differs from the number of non-linear parameters to be estimated. In other words, for any declaration of the form 'xy = NA' in 'params' needs exactly one counter part within in the (RM)model defintion of the form 'arg = xy'")
RandomFields/R/convert.R:  M$transform <- list(isNA=isNA, fctn=fctn, params.fctn=params.fctn)
RandomFields/R/convert.R:  return(M)
RandomFields/R/convert.R:  d <- strsplit(rightSide, "RMdeclare")[[1]]
RandomFields/R/convert.R:###         of RMdeclare (and not anything that has the user defined inbetween)
RandomFields/R/convert.R:      stop(paste0("In 'RMdeclare', in the declaration of ",
RandomFields/R/convert.R:    stop("We call an expression in 'params' that includes NAs on the right hand side of a definition. (In particular, a definition is not given by a formula.) The name of each definition must appear exactly once in the RMmodel definition as a \"value\" of an argument. This is not the case for ",
RandomFields/R/convert.R:                   "in 'RMdeclare'.\n")
RandomFields/R/convert.R:           else paste0("* add 'RMdeclare(", paste0(nn[f==0], collapse =","),
RandomFields/R/convert.R:                    " from 'RMdeclare'.\n")
RandomFields/R/convert.R:Check.CtoR <- function(indices, MODEL_AUX, values) {
RandomFields/R/convert.R:      model <- if (p$name %in% c(RM_PLUS, RM_MULT)) NULL else p$name
RandomFields/R/convert.R:    link <- GetParam(RFgetModelInfo(MODEL_AUX), NULL)
RandomFields/R/convert.R:PrepareModel2 <- function(model, ...,
RandomFields/R/convert.R:                          ## formulate RM_COVARIATE model and to prepare the
RandomFields/R/convert.R:                          ## transform; if not given, RMcovariate will fail,
RandomFields/R/convert.R:                          ## in general (for call from RFgetModelInfo_model, OK)
RandomFields/R/convert.R:                          ## add.na == TRUE: only RMcovaiate gets additional NA 
RandomFields/R/convert.R:  ## before parseModel is evaluated since columns might be added
RandomFields/R/convert.R:    if (is(model, CLASS_RM))
RandomFields/R/convert.R:      trend <- paste("RMshapeplus(add.na=", add.na, ", ~",
RandomFields/R/convert.R:               else RMshapeplus(trend, add.na=add.na)
RandomFields/R/convert.R:        model <- paste(v,"~RMplus(RMmodelplus(trend=FALSE, ",
RandomFields/R/convert.R:          model <- eval(parse(text=paste(model,"RMshapeplus(add.na=",
RandomFields/R/convert.R:        model  <- eval(parse(text=paste(Tv, "~RMplus(..model.., ", trend, ")")))
RandomFields/R/convert.R:        model  <- eval(parse(text=paste(Tv, "~RMplus(", trend, ",..model..)")))
RandomFields/R/convert.R:      else model <- RMplus(model, 
RandomFields/R/convert.R:                           RMshapeplus(trend, add.na=add.na),
RandomFields/R/convert.R:                           RMmodelplus(trend = FALSE, model))
RandomFields/R/convert.R:    return(PrepareModel2(model, params=params, 
RandomFields/R/convert.R:      FurtherModels <- "In bounds, initial values and parscales, "
RandomFields/R/convert.R:            stop(FurtherModels,
RandomFields/R/convert.R:        stop(FurtherModels, "additional variables may not be defined.\n  Here ",
RandomFields/R/convert.R:      CM <- as.character(model)
RandomFields/R/convert.R:      Check.declare(CM[length(CM)], Names, nNA, symbols)
RandomFields/R/convert.R:        ## so the data must be jointly passed to RMcovariate
RandomFields/R/convert.R:        ## RMcovariate must be able to distinguish.
RandomFields/R/convert.R:  assign("I", envir=Env, new(CLASS_RM, # 1 x isRM model aufgerufen
RandomFields/R/convert.R:                maxdim = SUBMODEL_DEP,
RandomFields/R/convert.R:                vdim = SUBMODEL_DEP
RandomFields/R/convert.R:  M <- parseModel(model=model, Env=Env, EnvDummies = EnvDummies, add.na=add.na,
RandomFields/R/convert.R:  class(M$model) <- CLASS_CLIST
RandomFields/R/convert.R:  M$is.x <- is.x
RandomFields/R/convert.R:  M$is.factor <- which(DataNames$factor)
RandomFields/R/convert.R:  M$is.var <- DataNames$is.var
RandomFields/R/convert.R:  M$data.trafo <- DataNames$data.trafo
RandomFields/R/convert.R:  M$data.names <- data.names
RandomFields/R/convert.R:  idx <- unclear.names %in% M$unclear
RandomFields/R/convert.R:  M$is.unclear <- c(is.unclear[idx], is.undetectable)
RandomFields/R/convert.R:  M$is.covariate <- union(which(data.names %in% is.covariate),
RandomFields/R/convert.R:  M$vdim <- DataNames$vdim
RandomFields/R/convert.R:  M$repet <- DataNames$repet
RandomFields/R/convert.R:#  Print(M)
RandomFields/R/convert.R:  if (xdim != 0 && length(M$is.x) != 0 && length(M$is.x) != xdim) {
RandomFields/R/convert.R:  M$C_coords <- if (length(x) > 0) trafo.to.C_UnifyXT(x)
RandomFields/R/convert.R:                else if (length(M$is.x) > 0) {
RandomFields/R/convert.R:                  C_UnifyXT(lapply(data, function(d) d[, M$is.x, drop = FALSE]),
RandomFields/R/convert.R:  ##  Print(x, M$C_coords)
RandomFields/R/convert.R:    M <- AddTransform(M=M, model=model, 
RandomFields/R/convert.R:                      MODEL_AUX=MODEL_AUX,
RandomFields/R/convert.R:  } else if (DataNames$vdim != 0) M$vdim <- DataNames$vdim
RandomFields/R/convert.R:    if (length(M$C_coords) > 0) {
RandomFields/R/convert.R:            MODEL_AUX, list("Dummy", M$model),
RandomFields/R/convert.R:            M$C_coords, as.double(NA), as.double(NA),
RandomFields/R/convert.R:    M$vdim <- model.vdim
RandomFields/R/convert.R:  if (any(M$add.na)) Help("addNA")
RandomFields/R/convert.R:  M
RandomFields/R/convert.R:  if (m[[1]]==RM_COVARIATE || m[[1]]==R_CONST) return(m[[COVARIATE_NAME_NAME]])
RandomFields/R/convert.R:parseModel <- function(model, Env, EnvDummies, add.na=NULL, 
RandomFields/R/convert.R:  if (!is(model, "formula")) stop("Malformed model expression -- maybe you have used a wrong or obsolete definition, or just used an incorrect option name or incorrect ordering of the arguments. See ?RMmodel for the model definition. Check manual for further information (RMmodel, RFsimulate)")
RandomFields/R/convert.R:    if (char == SYMBOL_PLUS && parToggle == 0) {
RandomFields/R/convert.R:      if (char == SYMBOL_L_PAR) parToggle <- parToggle+ 1
RandomFields/R/convert.R:      if (char == SYMBOL_R_PAR) parToggle <- parToggle- 1
RandomFields/R/convert.R:  isGenuineCovModel <- sapply(summands, FUN=function(s) { # pos def
RandomFields/R/convert.R:  isFormalCovModel <- sapply(summands, FUN=function(s) { # parts using data or
RandomFields/R/convert.R:  trendfct <- paste0(RM_TREND[1], "(")
RandomFields/R/convert.R:  isRMTrend <- sapply(summands, FUN=function(s)
RandomFields/R/convert.R:  add.na <- add.na * (!isGenuineCovModel | add.na < 0) * !isRMTrend
RandomFields/R/convert.R:  listModel <- vector("list", length(summands) + 1)
RandomFields/R/convert.R:      if (length(lev) > MAXSUB^2 + 1)
RandomFields/R/convert.R:        stop("max number of factors limited to ", MAXSUB^2)
RandomFields/R/convert.R:      L <- list(RM_PLUS[1])
RandomFields/R/convert.R:        last <- min(length(lev), i + MAXSUB -1)
RandomFields/R/convert.R:        plusList <- list(RM_PLUS[1])        
RandomFields/R/convert.R:          model <- list(RM_COVARIATE)
RandomFields/R/convert.R:          model[[COVARIATE_NAME_NAME]] <- paste0(S, i)
RandomFields/R/convert.R:          model[[COVARIATE_C_NAME]] <- as.numeric(C == lev[i]) ## 'data'
RandomFields/R/convert.R:          model[[COVARIATE_ADDNA_NAME]] <- add.na[k] > 1
RandomFields/R/convert.R:          model[[COVARIATE_RAW_NAME]] <- TRUE 
RandomFields/R/convert.R:      listModel[[k+1]] = if (length(lev) == 2) model
RandomFields/R/convert.R:                         else if (length(lev) <= MAXSUB + 1) plusList
RandomFields/R/convert.R:      if (isFormalCovModel[k]) { 
RandomFields/R/convert.R:          tL <- if ((model[[1]] %in% RM_MULT)) model[-1] else list(model) 
RandomFields/R/convert.R:            const[[CONST_A_NAME]] <- NA
RandomFields/R/convert.R:            const[[COVARIATE_NAME_NAME]] <- S
RandomFields/R/convert.R:            model <- c(SYMBOL_MULT, tL, list(const))
RandomFields/R/convert.R:            model <- list(RM_COVARIATE)         
RandomFields/R/convert.R:            model[[COVARIATE_C_NAME]] <-
RandomFields/R/convert.R:            model[[COVARIATE_ADDNA_NAME]] <- add.na[k] > 1
RandomFields/R/convert.R:            model[[COVARIATE_EXTRA_DATA_NAME]] <- extra
RandomFields/R/convert.R:            model[[COVARIATE_RAW_NAME]] <- TRUE 
RandomFields/R/convert.R:              model[[COVARIATE_NAME_NAME]] <- paste(S, L)
RandomFields/R/convert.R:              listModel[[m]] <- model
RandomFields/R/convert.R:          model[[CONST_A_NAME]] <-
RandomFields/R/convert.R:        model[[COVARIATE_NAME_NAME]] <- S
RandomFields/R/convert.R:      listModel[[m]] <- model
RandomFields/R/convert.R:  if (length(summands) == 1) listModel <- listModel[[2]]
RandomFields/R/convert.R:  else listModel[[1]] <- SYMBOL_PLUS
RandomFields/R/convert.R:  return(list(model=listModel, add.na=add.na, unclear=unclear))
RandomFields/R/convert.R:  ## in particular the models in RMmodels.R and the definition in
RandomFields/R/convert.R:  ## RMmodelsBasics.R
RandomFields/R/convert.R:  if (name == RM_PLUS[1]) name <- SYMBOL_PLUS
RandomFields/R/convert.R:  else if (name == RM_MULT[1]) name  <- SYMBOL_MULT
RandomFields/R/convert.R:  else if (name == RM_COVARIATE) 
RandomFields/R/convert.R:    unclear <- setdiff(unclear, P[[COVARIATE_NAME_NAME]])
RandomFields/R/convert.R:             parseModel(P[[i]], Env=Env, EnvDummies=EnvDummies,
RandomFields/R/convert.R:  while (substring(string, 1, 1) == SYMBOL_L_PAR &&
RandomFields/R/convert.R:         substring(string, n) == SYMBOL_R_PAR) {
RandomFields/R/convert.R:##   library(RandomFields); c(RMexp()); c(RMexp(), RMexp())
RandomFields/R/internal_use.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/internal_use.R:## Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/R/internal_use.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/internal_use.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/internal_use.R:## und wohl eher zum internen Gebrauch, wenn auch im NAMESPACE stehend;
RandomFields/R/internal_use.R:PrintModelList <-function (operators=FALSE, internal=FALSE,
RandomFields/R/internal_use.R:    .C(C_PrintModelList, as.integer(internal), as.integer(operators),
RandomFields/R/internal_use.R:showManpages <- function(path="/home/schlather/svn/RandomFields/RandomFields/man") {
RandomFields/R/internal_use.R:# showManpages()
RandomFields/R/internal_use.R:#     p <- c("DSpat", "GeoGenetix", "LS2Wstat", "ProbForecastGOP", "scpm", "UncerIn2", "	AHMbook", "CompRandFld", "constrainedKriging", "geoR", "georob", "geozoning", "lgcp", "NLMR", "raptr", "spagmix", "spatsurv", "windfarmGA", "fractaldim", "geostatsp", "IsoriX", "prioritizr", "rpanel", "SAMCpack", "SpaDES", "SpaDES.core", "SpaDES.tools", "spatstat")
RandomFields/R/internal_use.R:    n <- length(dev.list()) - 2 ## otherwise R CMD check complains
RandomFields/R/internal_use.R:  if (maintainers.machine()) paste0(" [Maintainer info: ", paste0(...), "] ")
RandomFields/R/fitgauss.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/fitgauss.R:## Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/R/fitgauss.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/fitgauss.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/fitgauss.R:##   source("~/R/RF/RandomFields/R/MLES.R")
RandomFields/R/fitgauss.R:##   im prinzipt CMbuild, aber ruechwaers mit 1/newscale und eingefuegt
RandomFields/R/fitgauss.R:#Beim paper lesen im Zug nach Muenchen heute morgen ist mir eine Referenz zu einem R Paket "mlegp: Maximum likelihood estimates of Gaussian processes" aufgefallen. Ist Dir aber sicher schon bekannt! 
RandomFields/R/fitgauss.R:## fuer random effects -> BA/MA
RandomFields/R/fitgauss.R:## REML fehlt
RandomFields/R/fitgauss.R:## Erweiterungen: Emilio's Bi-MLE, Covarianz-Matrix-INversion per fft oder
RandomFields/R/fitgauss.R:  if (model[[1]] == RM_DECLARE) return("")
RandomFields/R/fitgauss.R:      sub <- if (isModel(model[[i]])) model2string(model[[i]]) else model[[i]]
RandomFields/R/fitgauss.R:list2RMmodelFit <- function(x, RFsp.info=NULL, T) {
RandomFields/R/fitgauss.R:  x$model <- list2RMmodel(x$model)
RandomFields/R/fitgauss.R:addRMmatrix <- function(model, m) {
RandomFields/R/fitgauss.R:  if (model[[1]] %in% RM_PLUS)
RandomFields/R/fitgauss.R:      else if (x[[1]] %in% RM_PLUS) { addRMmatrix(x, m) }
RandomFields/R/fitgauss.R:      else if (x[[1]] %in% RM_MULT) {
RandomFields/R/fitgauss.R:        return( list(RM_MATRIX, M=m, x))        ## to do
RandomFields/R/fitgauss.R:          x[[idx[1]]] <- list(RM_MATRIX, M=m, x[[idx[1]]])                
RandomFields/R/fitgauss.R:        else list(RM_MATRIX, M=m, x)
RandomFields/R/fitgauss.R:      } else list(RM_MATRIX, M=m, x)
RandomFields/R/fitgauss.R:  else return(list(RM_MATRIX, M=m, model))
RandomFields/R/fitgauss.R:ModelSplitXT <- function(splitReg, info.cov, trafo, variab,
RandomFields/R/fitgauss.R:            stop("Model too complex to split it. Please set split=FALSE")
RandomFields/R/fitgauss.R:    ## dass auf x_1 projezierte Modell nicht mehr identifizierbar ist.
RandomFields/R/fitgauss.R:ModelSplit <- function(splitReg, info.cov, trafo, variab,
RandomFields/R/fitgauss.R: # if (xor(is.dist, statiso)) stop("mismatch in ModelSplit.", CONTACT)
RandomFields/R/fitgauss.R:    modelsplit <- ModelSplitXT(splitReg=splitReg, info.cov=info.cov,
RandomFields/R/fitgauss.R:        ModelSplitXT(splitReg=splitReg, info.cov=info.cov, trafo=trafo, variab=variab,
RandomFields/R/fitgauss.R:        ModelSplitXT(splitReg=splitReg, info.cov=info.cov, trafo=trafo,
RandomFields/R/fitgauss.R:        ModelSplitXT(splitReg=splitReg, info.cov=info.cov, trafo=trafo, variab=variab,
RandomFields/R/fitgauss.R:  M <- if (length(mle.methods) >= 1) mle.methods[length(mle.methods)]
RandomFields/R/fitgauss.R:        fix.zero <- (minmax[sp$fix, MINMAX_PMIN] <= 0) &
RandomFields/R/fitgauss.R:          (minmax[sp$fix, MINMAX_PMAX] >=0)
RandomFields/R/fitgauss.R:        fix.one <- (minmax[sp$fix, MINMAX_PMIN] <= 1) &
RandomFields/R/fitgauss.R:          (minmax[sp$fix, MINMAX_PMAX] >= 1)
RandomFields/R/fitgauss.R:      old.model <- GetModel(register=splitReg, modus=GETMODEL_DEL_MLE ,
RandomFields/R/fitgauss.R:      new.model <- GetModel(register=splitReg, modus=GETMODEL_DEL_MLE,
RandomFields/R/fitgauss.R:        lower.model <- GetModel(register=splitReg, modus=GETMODEL_DEL_MLE,
RandomFields/R/fitgauss.R:        upper.model <- GetModel(register=splitReg, modus=GETMODEL_DEL_MLE,
RandomFields/R/fitgauss.R:        new.model   <- addRMmatrix(new.model, m)
RandomFields/R/fitgauss.R:        lower.model <- addRMmatrix(lower.model, m)
RandomFields/R/fitgauss.R:        upper.model <- addRMmatrix(upper.model, m)
RandomFields/R/fitgauss.R:        old.model   <- addRMmatrix(old.model, m)
RandomFields/R/fitgauss.R:                m <- colMeans(xyz.ignored)
RandomFields/R/fitgauss.R:                               table[[M]][(np + 1) : (2 * np)])
RandomFields/R/fitgauss.R:                               table[[M]][(2 * np + 1) : (3 * np)])
RandomFields/R/fitgauss.R:    guess[sp$p.proj] <- res$table[[M]][1:length(sp$p.proj)]    
RandomFields/R/fitgauss.R:                        mle.methods=MLMETHODS,
RandomFields/R/fitgauss.R:                        lsq.methods= LSQMETHODS,
RandomFields/R/fitgauss.R:  MLE_CONFORM <- if (is.null(transform)) mle_conform else original_model
RandomFields/R/fitgauss.R:  if (RFopt$general$modus_operandi == MODE_NAMES[normal+1]) Help("normal_mode")
RandomFields/R/fitgauss.R:  if (printlevel < PL_IMPORTANT) pch <- ""
RandomFields/R/fitgauss.R:                     FCTN_TYPE_NAMES[3 + emp_alpha]
RandomFields/R/fitgauss.R:  LiliReg <- MODEL_MLE ## for calculating likelihood; either it is
RandomFields/R/fitgauss.R:  COVreg <- MODEL_LSQ  ## for calculating variogram and getting back models
RandomFields/R/fitgauss.R:  splitReg <- MODEL_SPLIT ## for splitting,
RandomFields/R/fitgauss.R:  OPTIMIZER <- function(optimiser, max=TRUE) {
RandomFields/R/fitgauss.R:  OPTIM <- OPTIMIZER(optimiser)
RandomFields/R/fitgauss.R:  SUBOPTIM <- OPTIMIZER(fit$sub_optimiser, max=FALSE)
RandomFields/R/fitgauss.R:    aux.reg <- MODEL_AUX
RandomFields/R/fitgauss.R:    models <- list(NAmodel, ReplaceC(#P repareModel2( ## 13.7.19 geaendert
RandomFields/R/fitgauss.R:      info[[m]] <- .Call(C_SetAndGetModelLikelihood, aux.reg,
RandomFields/R/fitgauss.R:      neu[[m]] <- GetModel(register=aux.reg, modus=GETMODEL_DEL_MLE,
RandomFields/R/fitgauss.R:    minmax <- minmax[, -MINMAX_NAN, drop=FALSE]
RandomFields/R/fitgauss.R:    minmax$type <- TYPEOF_PARAM_NAMES[minmax$type + 1]
RandomFields/R/fitgauss.R:      function(variab, control=NULL, MLELB, MLEUB, ...) {
RandomFields/R/fitgauss.R:        variabnew <- pmax(MLELB + ndeps, pmin(MLEUB - ndeps, variab))
RandomFields/R/fitgauss.R:        idx <- variabnew < MLELB | variabnew > MLEUB ## can happen if MLEUB-MLELB \approx 0
RandomFields/R/fitgauss.R:        oH <- rawTry(optimHess(par=variabnew, fn=MLtarget, control=control))
RandomFields/R/fitgauss.R:  show <- function(nr, M, OPT, PARAM)
RandomFields/R/fitgauss.R:    cat("\n ", M, ", ", switch(nr, "start", "grid ", "re-do"), ": value=",
RandomFields/R/fitgauss.R:        format(OPT, dig=6), ", param=", format(PARAM, dig=2), sep="")
RandomFields/R/fitgauss.R:    model.values <- .Call(C_MomentsIntern, COVreg, emp_alpha)
RandomFields/R/fitgauss.R:  WarningMessage <- function (variab, LB, UB, txt) {
RandomFields/R/fitgauss.R:  WarningMessage <- function (variab, LB, UB, txt) {
RandomFields/R/fitgauss.R:  LSQsettings <- function(M) {    
RandomFields/R/fitgauss.R:    assign("LSQ.SELF.WEIGHING", M=="self", envir=ENVIR)
RandomFields/R/fitgauss.R:      assign("LSQ.WEIGHTS", weights[[M]], envir=ENVIR)
RandomFields/R/fitgauss.R:    if (printlevel>PL_FCTN_DETAILS) Print("LS", LSMIN, format(variab, dig=20))#
RandomFields/R/fitgauss.R:    ##    Print("begin", LSMIN, format(variab, dig=20))
RandomFields/R/fitgauss.R:        WarningMessage(variab, LSQLB, LSQUB, "LSQ")      
RandomFields/R/fitgauss.R:      save <- list(LSMIN, LSPARAM, LSVARIAB)
RandomFields/R/fitgauss.R:      assign("LSMIN", +Inf, envir=ENVIR)
RandomFields/R/fitgauss.R:        assign("LSMIN", save[[1]], envir=ENVIR)
RandomFields/R/fitgauss.R:        assign("LSPARAM", save[[2]], envir=ENVIR)
RandomFields/R/fitgauss.R:      } else assign("LSMIN", res, envir=ENVIR)
RandomFields/R/fitgauss.R:    model.values <- .Call(C_MomentsIntern, COVreg, emp_alpha)
RandomFields/R/fitgauss.R:      if (printlevel>=PL_IMPORTANT) {
RandomFields/R/fitgauss.R:                                        #        Print(M, idx, bgw, g2w, LSQ.BINNEDSQUARE, bgw^2/g2w)
RandomFields/R/fitgauss.R:    ##    Print("Ende", LSMIN, format(variab, dig=20), res)
RandomFields/R/fitgauss.R:    if (res<=LSMIN) {
RandomFields/R/fitgauss.R:      assign("LSMIN", res, envir=ENVIR)
RandomFields/R/fitgauss.R:      assign("LSPARAM", param, envir=ENVIR)
RandomFields/R/fitgauss.R:      if (printlevel>=PL_FCTN_DETAILS) Print(param, LSMIN)  #
RandomFields/R/fitgauss.R:      if (abs(trace) >= 2 || res == LSMIN) {
RandomFields/R/fitgauss.R:        if (trace < 0) Print(M, res, variab, param) #
RandomFields/R/fitgauss.R:        else Trace(param=param, name=M, trace=trace, opt = res==LSMIN)
RandomFields/R/fitgauss.R:  MLtarget <- function(variab) {
RandomFields/R/fitgauss.R:      if (any((variab < MLELB) | (variab > MLEUB))) {
RandomFields/R/fitgauss.R:          WarningMessage(variab, MLELB, MLEUB, "MLE")   
RandomFields/R/fitgauss.R:        variab <- pmax(MLELB, pmin(MLEUB, variab)) 
RandomFields/R/fitgauss.R:        save <- list(MLEMAX, MLECOVAR, MLEPARAM, MLEVARIAB)
RandomFields/R/fitgauss.R:        assign("MLEMAX", -Inf, envir=ENVIR)
RandomFields/R/fitgauss.R:        res <- MLtarget(variab)
RandomFields/R/fitgauss.R:          assign("MLEMAX", save[[1]], envir=ENVIR)
RandomFields/R/fitgauss.R:          assign("MLECOVAR", save[[2]], envir=ENVIR)      
RandomFields/R/fitgauss.R:          assign("MLEPARAM", save[[3]], envir=ENVIR)
RandomFields/R/fitgauss.R:          assign("MLEVARIAB", save[[4]], envir=ENVIR)        
RandomFields/R/fitgauss.R:        } else assign("MLEMAX", res, envir=ENVIR)
RandomFields/R/fitgauss.R:      cat("\n\nAufruf von MLtarget\n===================\n")
RandomFields/R/fitgauss.R:      Print(variab, param, MLELB, MLEUB) ##
RandomFields/R/fitgauss.R:                                        #Print(RFgetModelInfo(register=LiliReg, level=4, which.submodels="call+user"))#
RandomFields/R/fitgauss.R:    ans <- TRY(.Call(C_EvaluateModel, double(0), integer(0), LiliReg))
RandomFields/R/fitgauss.R:      assign("ML_failures", ML_failures + 1)
RandomFields/R/fitgauss.R:      if (printlevel > PL_IMPORTANT) ("model evalation has failed")
RandomFields/R/fitgauss.R:      if (MLEMAX == -Inf) assign("MLECOVAR", NA, envir=ENVIR)
RandomFields/R/fitgauss.R:    ##    Print(ans, MLEMAX, variab, param, MLELB, MLEUB);
RandomFields/R/fitgauss.R:    ##  stopifnot(all(is.finite(MLEUB)))
RandomFields/R/fitgauss.R:    if (res >= MLEMAX) {## >= und nicht > da -Inf, -Inf auftreten kann
RandomFields/R/fitgauss.R:      assign("MLEMAX", res, envir=ENVIR)
RandomFields/R/fitgauss.R:      assign("MLECOVAR", ans[-1], envir=ENVIR)      
RandomFields/R/fitgauss.R:      assign("MLEPARAM", param, envir=ENVIR)
RandomFields/R/fitgauss.R:      assign("MLEVARIAB", variab, envir=ENVIR)
RandomFields/R/fitgauss.R:      if (printlevel>=PL_FCTN_DETAILS) Print(ans, MLEMAX)  #
RandomFields/R/fitgauss.R:      if (abs(trace) >= 2 || res == MLEMAX) {
RandomFields/R/fitgauss.R:        if (trace < 0) Print(M, res, variab, param, MLECOVAR) #
RandomFields/R/fitgauss.R:        else Trace(param=param, name=M, trace=trace, opt = res==MLEMAX)
RandomFields/R/fitgauss.R:    max <- MLEMAX
RandomFields/R/fitgauss.R:    covar <- MLECOVAR
RandomFields/R/fitgauss.R:    param <- MLEPARAM
RandomFields/R/fitgauss.R:    variab <- MLEVARIAB
RandomFields/R/fitgauss.R:    assign("MLEMAX", -Inf, envir=ENVIR)
RandomFields/R/fitgauss.R:    MLtarget(Variab)
RandomFields/R/fitgauss.R:    result <- MLECOVAR
RandomFields/R/fitgauss.R:    assign("MLEMAX", max, envir=ENVIR)
RandomFields/R/fitgauss.R:    assign("MLECOVAR", covar, envir=ENVIR)
RandomFields/R/fitgauss.R:    assign("MLEPARAM", param, envir=ENVIR)
RandomFields/R/fitgauss.R:    assign("MLEVARIAB", variab, envir=ENVIR)
RandomFields/R/fitgauss.R:      if (printlevel >= PL_IMPORTANT && get.var.message) {
RandomFields/R/fitgauss.R:    DO.REML <- DO.REML1 <- RML.A <- RML.data <-
RandomFields/R/fitgauss.R:      REML.CORRECTION <- DO.RML1 <- 
RandomFields/R/fitgauss.R:        ML.RESIDUALS <- MLEMAX <- MLEINF <- MLECOVAR <- MLEPARAM <- 
RandomFields/R/fitgauss.R:          CROSS.DIST <- CROSS.KRIGE <- CROSS.VAR <- CROSSMODEL <-
RandomFields/R/fitgauss.R:  ML_failures <- 0
RandomFields/R/fitgauss.R:  if (vdim > 1 && emp_alpha < 0 && emp_alpha != VARIOGRAM)
RandomFields/R/fitgauss.R:  info.cov <- .Call(C_SetAndGetModelLikelihood, LiliReg,
RandomFields/R/fitgauss.R:                    C_coords, noConcerns, MLE_CONFORM) ## LiliReg wieder verwendet !!!
RandomFields/R/fitgauss.R:    if (any(minmax[, MINMAX_NAN]==1)) ## nan, not na
RandomFields/R/fitgauss.R:    if (!recall) message("\nNote: if 'transform' or 'params' is given and off-diagonal elements of an anisotropy matrix are estimated, then 'RMS' should be given explicitely and 'anisoT' instead of 'Aniso' should be used within 'RMS'.")
RandomFields/R/fitgauss.R:    if (printlevel > PL_IMPORTANT) print(minmax[!NaNs, ]) #
RandomFields/R/fitgauss.R:        GetModel(register=LiliReg, modus=GETMODEL_DEL_MLE,
RandomFields/R/fitgauss.R:            " (maybe by '", RM_DECLARE, "').\n", 
RandomFields/R/fitgauss.R:    if (any(minmax[!trafoidx, MINMAX_NAN] != 1) ||
RandomFields/R/fitgauss.R:        any(minmax[trafoidx, MINMAX_NAN] != 0))
RandomFields/R/fitgauss.R:  if (printlevel >= PL_SUBIMPORTANT + recall) print(minmax) #
RandomFields/R/fitgauss.R:  ptype <- minmax[, MINMAX_TYPE]
RandomFields/R/fitgauss.R:  diag.idx <- which(ptype == DIAGPARAM)
RandomFields/R/fitgauss.R:  if (length(diag.idx)>0) minmax[diag.idx[1], MINMAX_PMIN] <- fit$min_diag
RandomFields/R/fitgauss.R:  SU <- SetUsers(lower, minmax[, MINMAX_PMIN], "lower")
RandomFields/R/fitgauss.R:  SU <- SetUsers(upper, minmax[, MINMAX_PMAX], "upper")
RandomFields/R/fitgauss.R:  ## DIESER TEIL MUSS IMMER HINTER SetUsers STEHEN
RandomFields/R/fitgauss.R:                                        # Or the dummy variables have not been defined by '", RM_DECLARE, "'.")
RandomFields/R/fitgauss.R:  SDVAR.IDX <- ptype == SDPARAM | ptype == VARPARAM | ptype == NUGGETVAR
RandomFields/R/fitgauss.R:  SIGN.VAR.IDX <- ptype == SIGNEDVARPARAM
RandomFields/R/fitgauss.R:  SIGN.SD.IDX <- ptype == SIGNEDSDPARAM
RandomFields/R/fitgauss.R:      sdvar[ , i] <- (minmax[, MINMAX_COLS] == i |
RandomFields/R/fitgauss.R:                      minmax[, MINMAX_ROWS] == i) & SDVAR.IDX
RandomFields/R/fitgauss.R:      ##                     minmax[, MINMAX_ROWS] == i) & ANY.SDVAR
RandomFields/R/fitgauss.R:      ##Print(i, MINMAX_COLS, MINMAX_ROWS, minmax[, MINMAX_COLS],  minmax[, MINMAX_ROWS] == i, SDVAR.IDX)
RandomFields/R/fitgauss.R:  SCALE.IDX <- ptype == SCALEPARAM  ## large capitals 
RandomFields/R/fitgauss.R:  var.idx <- which(ptype == VARPARAM)
RandomFields/R/fitgauss.R:  sd.idx <- which(ptype == SDPARAM)
RandomFields/R/fitgauss.R:    if (printlevel >= PL_IMPORTANT && !recall) {
RandomFields/R/fitgauss.R:  ##                   except for fctncall==CovarianceMatrix
RandomFields/R/fitgauss.R:  if (vdim>1 && printlevel>=PL_IMPORTANT && !recall)
RandomFields/R/fitgauss.R:  if (any(idx <- ptype == DIAGPARAM)) {
RandomFields/R/fitgauss.R:  if (any(idx <- ptype == ANISOPARAM)) {
RandomFields/R/fitgauss.R:      warning("The algorithms RandomFields transpose the matrix Aniso to aniso -- this may cause problems when applying transform to the anisotropy parameters. To be safe, use only the parameter anisoT in RMfit.")
RandomFields/R/fitgauss.R:    .Call(C_SetAndGetModelLikelihood, splitReg, list("Covariance", Z$model), 
RandomFields/R/fitgauss.R:          C_coords, neverGlobalXT, MLE_CONFORM)
RandomFields/R/fitgauss.R:      ## error appears e.g. when RMfixcov is used with raw=TRUE.
RandomFields/R/fitgauss.R:      split <- TRY(ModelSplit(splitReg=splitReg, info.cov=info.cov,trafo=trafo,
RandomFields/R/fitgauss.R:# 	Print("spitting. call start", C_Set AndGetModelLikelihood, splitReg, list("Covariance", Z$model),  C_coords)
RandomFields/R/fitgauss.R:        .Call(C_SetAndGetModelLikelihood, splitReg,
RandomFields/R/fitgauss.R:              C_coords, noConcerns, MLE_CONFORM) ## not in the previous version
RandomFields/R/fitgauss.R:                            lsq.methods = LSQMETHODS,
RandomFields/R/fitgauss.R:                            origin = MLE_CONFORM,
RandomFields/R/fitgauss.R:  bounds <- minmax[, c(MINMAX_MIN, MINMAX_MAX), drop=FALSE]
RandomFields/R/fitgauss.R:  bayes <- as.logical(minmax[, MINMAX_BAYES])
RandomFields/R/fitgauss.R:    lower[bayes] <- pmax(lower[bayes], minmax[bayes, MINMAX_PMIN])
RandomFields/R/fitgauss.R:    upper[bayes] <- pmin(upper[bayes], minmax[bayes, MINMAX_PMAX])    
RandomFields/R/fitgauss.R:    bounds[bayes, 1] <- pmax(bounds[bayes, 1], minmax[bayes, MINMAX_PMIN])
RandomFields/R/fitgauss.R:    bounds[bayes, 2] <- pmin(bounds[bayes, 2], minmax[bayes, MINMAX_PMAX])
RandomFields/R/fitgauss.R:  if (length(MLMETHODS) != 1 || MLMETHODS != "ml")
RandomFields/R/fitgauss.R:  allmethods <- c(PRIMMETHODS, LSQMETHODS, MLMETHODS, CROSSMETHODS)
RandomFields/R/fitgauss.R:  cm <- cumsum(c(0, length(PRIMMETHODS), length(LSQMETHODS),
RandomFields/R/fitgauss.R:                     length(MLMETHODS), length(CROSSMETHODS)))
RandomFields/R/fitgauss.R:                     rep(1, length(allmethods) - length(PRIMMETHODS)),#method
RandomFields/R/fitgauss.R:                             allmethods[-1:-length(PRIMMETHODS)],
RandomFields/R/fitgauss.R:      allmethods[-1:-length(PRIMMETHODS)],
RandomFields/R/fitgauss.R:###############    PRIMITIVE METHODS   ###########
RandomFields/R/fitgauss.R:  MLELB <- LSQLB <- lower
RandomFields/R/fitgauss.R:  MLEUB <- LSQUB <- upper
RandomFields/R/fitgauss.R:  M <- "autostart"
RandomFields/R/fitgauss.R:  primMethods <- M
RandomFields/R/fitgauss.R:  default.param <- param.table[[M]][IDX("variab")] <- autostart
RandomFields/R/fitgauss.R:  param.table[[M]][IDX("param")] <- trafo(autostart) 
RandomFields/R/fitgauss.R:  MLEVARIAB <- autostart
RandomFields/R/fitgauss.R:  param.table[[M]][IDX("glbl.var")] <- get.var.covariat(autostart)
RandomFields/R/fitgauss.R:    M <- "users.guess"
RandomFields/R/fitgauss.R:    primMethods <- c(primMethods, M)
RandomFields/R/fitgauss.R:      else if (general$modus_operandi ==  MODE_NAMES[careless + 1]) {
RandomFields/R/fitgauss.R:        MLELB <- LSQLB <- lower
RandomFields/R/fitgauss.R:        MLEUB <- LSQUB <- upper
RandomFields/R/fitgauss.R:      param.table[[M]][IDX("variab")] <- users.guess
RandomFields/R/fitgauss.R:      param.table[[M]][IDX("param")] <- trafo(users.guess)
RandomFields/R/fitgauss.R:      MLEVARIAB <- users.guess
RandomFields/R/fitgauss.R:      param.table[[M]][IDX("glbl.var")] <- get.var.covariat(users.guess)
RandomFields/R/fitgauss.R:  lsqMethods <- NULL
RandomFields/R/fitgauss.R:          if (is.matrix(evsd)) evsd <- rowMeans(evsd, na.rm=TRUE)
RandomFields/R/fitgauss.R:    stopifnot(ncol(weights)==length(LSQMETHODS))
RandomFields/R/fitgauss.R:    ## find a good initial value for MLE using weighted least squares
RandomFields/R/fitgauss.R:    ## yield the same result as MLE
RandomFields/R/fitgauss.R:    lsqMethods <- LSQMETHODS[pmatch(lsq.methods, LSQMETHODS)]
RandomFields/R/fitgauss.R:    .Call(C_SetAndGetModelLikelihood, COVreg, list(emp_alphaName, Z$model),
RandomFields/R/fitgauss.R:          C_coords, neverGlobalXT, MLE_CONFORM)
RandomFields/R/fitgauss.R:    #Print(RFgetModelInfo(COVreg))
RandomFields/R/fitgauss.R:    LSMIN <- Inf
RandomFields/R/fitgauss.R:    if (length(lsqMethods) > 0 &&
RandomFields/R/fitgauss.R:        any(is.na(lsqMethods))) stop("not all lsq.methods could be matched")
RandomFields/R/fitgauss.R:          ## last one could be still pretty large. Make a rectangle out of it
RandomFields/R/fitgauss.R:    for (M in lsqMethods) {
RandomFields/R/fitgauss.R:     if (printlevel>=PL_STRUCTURE) cat("\n", M) else cat(pch)
RandomFields/R/fitgauss.R:      param.table[[M]][IDX("variab")] <- default.param
RandomFields/R/fitgauss.R:      LSQsettings(M)
RandomFields/R/fitgauss.R:      LSMIN <- Inf ## must be before next "if (n.variab==0)"
RandomFields/R/fitgauss.R:      LSPARAM <- LSVARIAB <- NA 
RandomFields/R/fitgauss.R:      param.table[[M]][IDX("lower")] <- LSQLB
RandomFields/R/fitgauss.R:      param.table[[M]][IDX("upper")] <- LSQUB
RandomFields/R/fitgauss.R:              param.table[tblidx[[M]][1], i] <- value
RandomFields/R/fitgauss.R:                param.table[tblidx[[M]][1], i] <- NaN
RandomFields/R/fitgauss.R:        stopifnot(min==LSMIN) ## check
RandomFields/R/fitgauss.R:        if (any(min.variab != LSVARIAB) && printlevel > PL_SUBIMPORTANT) {
RandomFields/R/fitgauss.R:        fnscale <- if (length(fit.fnscale) == 0 || is.na(fit.fnscale[M]))
RandomFields/R/fitgauss.R:          min else fit.fnscale[M]
RandomFields/R/fitgauss.R:        ##        Print(M, LSVARIAB, lower, upper, autostart, info.cov, parscale, lsq.optim.control,optimiser);
RandomFields/R/fitgauss.R:        SUBOPTIM(LSVARIAB, LStarget, lower = LSQLB, upper = LSQUB,
RandomFields/R/fitgauss.R:      ## side effect: minimum so far is in LSMIN and LSPARAM
RandomFields/R/fitgauss.R:      if (is.finite(LSMIN)) {
RandomFields/R/fitgauss.R:        param.table[[M]][tblidx[[M]][1]] <- LSMIN
RandomFields/R/fitgauss.R:        param.table[[M]][IDX("variab")] <- LSVARIAB
RandomFields/R/fitgauss.R:        param.table[[M]][IDX("param")] <- LSPARAM
RandomFields/R/fitgauss.R:        param.table[[M]] <- if (n.variab==0) NA else NaN
RandomFields/R/fitgauss.R:      param.table[[M]][IDX("glbl.var")] <- get.var.covariat(LSVARIAB)
RandomFields/R/fitgauss.R:    } # for M   
RandomFields/R/fitgauss.R:  if (length(LSQMETHODS) > 0) {
RandomFields/R/fitgauss.R:    ps <- matrix(NA, nrow=n.variab, ncol=length(LSQMETHODS))
RandomFields/R/fitgauss.R:    for (iM in 1:length(LSQMETHODS)) {
RandomFields/R/fitgauss.R:      M <- LSQMETHODS[iM]
RandomFields/R/fitgauss.R:      if (!is.na(param.table[[M]][tblidx[[M]][1]])) {
RandomFields/R/fitgauss.R:        ps[ , iM] <- abs(param.table[[M]][IDX("variab")])
RandomFields/R/fitgauss.R:### optional parameter grid for MLE and CROSS  ###
RandomFields/R/fitgauss.R:###################   MLE    #####################
RandomFields/R/fitgauss.R:  if (printlevel>=PL_STRUCTURE) cat("\nMLE XXX...")
RandomFields/R/fitgauss.R:  mleMethods <- (if (length(mle.methods)==0) NULL else
RandomFields/R/fitgauss.R:                 MLMETHODS[pmatch(mle.methods, MLMETHODS)])
RandomFields/R/fitgauss.R:##    Print(mleMethods)
RandomFields/R/fitgauss.R:  if ("reml" %in% mleMethods && n.covariat == 0)
RandomFields/R/fitgauss.R:    mleMethods <- c("ml")# to do, "reml", "rml")
RandomFields/R/fitgauss.R:  ## value for MLE (heuristic statement). Therefore a small
RandomFields/R/fitgauss.R:  ## For MLE elimination we should include the true value of the scale;
RandomFields/R/fitgauss.R:  ## to be suitable for MLE elimination
RandomFields/R/fitgauss.R:  if (any(MLELB > MLEUB))
RandomFields/R/fitgauss.R:  for (M in mleMethods) {
RandomFields/R/fitgauss.R:    if (printlevel>=PL_STRUCTURE) cat("\n", M) else cat(pch)
RandomFields/R/fitgauss.R:    param.table[[M]][IDX("variab")] <- default.param    
RandomFields/R/fitgauss.R:    if (M!="ml" ##&& !anyFixedEffect
RandomFields/R/fitgauss.R:      param.table[[M]] <- param.table[["ml"]]
RandomFields/R/fitgauss.R:      ## ML-value is now REML value:
RandomFields/R/fitgauss.R:      param.table[[M]][tblidx[[M]][1]] <- param.table[[M]][tblidx[["ml"]][1]]
RandomFields/R/fitgauss.R:    MLEMAX <- -Inf ## must be before next "if (nMLEINDEX==0)"
RandomFields/R/fitgauss.R:    MLEVARIAB <- NULL ## nachfolgende for-schleife setzt MLEVARIAB
RandomFields/R/fitgauss.R:     MLEPARAM <- NA
RandomFields/R/fitgauss.R:    if (n.variab == 0) MLtarget(NULL)
RandomFields/R/fitgauss.R:      param.table[[M]][IDX("lower")] <- MLELB
RandomFields/R/fitgauss.R:      param.table[[M]][IDX("upper")] <- MLEUB
RandomFields/R/fitgauss.R:        ## should mle be included when M=reml?
RandomFields/R/fitgauss.R:          value <- MLtarget(variab) ## !
RandomFields/R/fitgauss.R:            param.table[tblidx[[M]][1], i] <- value
RandomFields/R/fitgauss.R:            param.table[tblidx[[M]][1], i] <- NaN
RandomFields/R/fitgauss.R:        if (length(fit.fnscale)==0 || is.na(fit.fnscale[M]))
RandomFields/R/fitgauss.R:          -max(abs(max), 0.1) else fit.fnscale[M]
RandomFields/R/fitgauss.R:#      Print(parscale, MLEVARIAB, info.cov, methodprevto$mle, globalvariance)
RandomFields/R/fitgauss.R:      if (length(parscale) > 0 && length(parscale) != length(MLEVARIAB))
RandomFields/R/fitgauss.R:        stop(#"length of 'parscale' (", length(parscale), ") differs from the length of the variables (", length(MLEVARIAB), "). ",
RandomFields/R/fitgauss.R:            if (length(MLEVARIAB) != 0) stop(CONTACT)
RandomFields/R/fitgauss.R:      MLEINF <- FALSE
RandomFields/R/fitgauss.R:        OPTIM(MLEVARIAB, MLtarget, lower = MLELB, upper=MLEUB,
RandomFields/R/fitgauss.R:        if (ML_failures > 20 && printlevel >= PL_IMPORTANT)
RandomFields/R/fitgauss.R:         if (MLEINF) {
RandomFields/R/fitgauss.R:            Print("MLEINF", MLEVARIAB, MLEMAX) else cat("#") #
RandomFields/R/fitgauss.R:          OPTIM(MLEVARIAB, MLtarget, lower = MLELB, upper=MLEUB,
RandomFields/R/fitgauss.R:            Print("MLEINF new", MLEVARIAB, MLEMAX) #
RandomFields/R/fitgauss.R:          pmax(fit$minbounddistance, fit$minboundreldist * abs(MLEVARIAB))
RandomFields/R/fitgauss.R:          (abs(MLEVARIAB - MLELB) <
RandomFields/R/fitgauss.R:                fit$minboundreldist * abs(MLELB) ## relative difference
RandomFields/R/fitgauss.R:        (abs(MLEVARIAB - MLEUB) <
RandomFields/R/fitgauss.R:         pmax(mindist, fit$minboundreldist * abs(MLEUB)))
RandomFields/R/fitgauss.R:    } # length(MLELB) > 0
RandomFields/R/fitgauss.R:      Print("mle first round", MLEVARIAB, MLEPARAM, MLEMAX) #
RandomFields/R/fitgauss.R:    if (!is.finite(MLEMAX)) {
RandomFields/R/fitgauss.R:      if (printlevel>=PL_IMPORTANT) message(M, ": MLtarget I failed.")
RandomFields/R/fitgauss.R:      param.table[[M]] <- MLEPARAM <- NaN
RandomFields/R/fitgauss.R:      variab <- MLELB ## to call for onborderline
RandomFields/R/fitgauss.R:      param.table[[M]][tblidx[[M]][1]] <- MLEMAX
RandomFields/R/fitgauss.R:      param.table[[M]][IDX("variab")] <- MLEVARIAB
RandomFields/R/fitgauss.R:      stopifnot(all(MLEVARIAB >= MLELB & MLEVARIAB <= MLEUB))
RandomFields/R/fitgauss.R:      param.table[[M]][IDX("param")] <- MLEPARAM
RandomFields/R/fitgauss.R:      param.table[[M]][IDX("glbl.var")] <- get.var.covariat(MLEVARIAB)     
RandomFields/R/fitgauss.R:      ml.residuals <- ML.RESIDUALS
RandomFields/R/fitgauss.R:        ## if the MLE result is close to the border, it usually means that
RandomFields/R/fitgauss.R:        ## calculate the MLE values on a grid and start the optimization with
RandomFields/R/fitgauss.R:          MLEgridmin <- gridmin
RandomFields/R/fitgauss.R:          MLEgridmax <- gridmax
RandomFields/R/fitgauss.R:          if (any(is.na(MLEgridmin)) || any(is.na(MLEgridmax))) {
RandomFields/R/fitgauss.R:            if (printlevel >= PL_SUBIMPORTANT) {
RandomFields/R/fitgauss.R:              Print(cbind(MLELB, variab, MLEUB, onborderline), #
RandomFields/R/fitgauss.R:                    MLEgridmin, MLEgridmax)
RandomFields/R/fitgauss.R:            warning(paste(M, "converged to a boundary value -- ",
RandomFields/R/fitgauss.R:              show(1, M, MLEMAX, MLEVARIAB) else cat(detailpch)
RandomFields/R/fitgauss.R:            MLEgridlength <-
RandomFields/R/fitgauss.R:            step <- (MLEgridmax - MLEgridmin) / (MLEgridlength-2) # grid starts
RandomFields/R/fitgauss.R:            MLEgridmin <- pmax(MLEgridmin - runif(length(MLEgridmin)) * step/2,
RandomFields/R/fitgauss.R:                               MLELB)   # the extremes of LS
RandomFields/R/fitgauss.R:            MLEgridmax <- pmin(MLEgridmax + runif(length(MLEgridmax)) * step/2,
RandomFields/R/fitgauss.R:                               MLEUB)
RandomFields/R/fitgauss.R:            step <- (MLEgridmax - MLEgridmin) / (MLEgridlength-1)
RandomFields/R/fitgauss.R:                MLEgridmin[i] + step[i] * 0:(MLEgridlength-1)
RandomFields/R/fitgauss.R:            ## MLEMAX <- -Inf
RandomFields/R/fitgauss.R:            apply(startingvalues, 1, ## side effect: MLEVARIAB
RandomFields/R/fitgauss.R:##                    TRY(MLtarget(x))
RandomFields/R/fitgauss.R:##                    stopifnot( MLEMAX == MLtarget(MLEVARIAB))
RandomFields/R/fitgauss.R:                    ##  if (MLEINF) stop("stop")
RandomFields/R/fitgauss.R:                    TRY(MLtarget(x))
RandomFields/R/fitgauss.R:              Print("mle grid search", MLEVARIAB, MLEPARAM, MLEMAX) #
RandomFields/R/fitgauss.R:            ## side effect:Maximum is in MLEMAX!
RandomFields/R/fitgauss.R:            ##                             and optimal parameter is in MLEVARIAB
RandomFields/R/fitgauss.R:              show(2, M, MLEMAX, MLEVARIAB)
RandomFields/R/fitgauss.R:            OPTIM(MLEVARIAB, MLtarget, lower = MLELB, upper = MLEUB,
RandomFields/R/fitgauss.R:            if (!is.finite(MLEMAX) &&(printlevel>=PL_IMPORTANT))
RandomFields/R/fitgauss.R:              message("MLtarget II failed.\n")
RandomFields/R/fitgauss.R:            if (printlevel>=PL_FCTN_SUBDETAILS) show(3, M, MLEMAX, MLEVARIAB)
RandomFields/R/fitgauss.R:              Print("mle second round", MLEVARIAB, MLEPARAM, MLEMAX) #
RandomFields/R/fitgauss.R:            if (is.finite(MLEMAX) && MLEMAX >=param.table[[M]][tblidx[[M]][1]]){
RandomFields/R/fitgauss.R:              param.table[[M]][tblidx[[M]][1]] <- MLEMAX
RandomFields/R/fitgauss.R:              param.table[[M]][IDX("variab")] <- MLEVARIAB
RandomFields/R/fitgauss.R:              stopifnot(all(MLEVARIAB >= MLELB & MLEVARIAB <= MLEUB))
RandomFields/R/fitgauss.R:              param.table[[M]][IDX("param")] <- MLEPARAM
RandomFields/R/fitgauss.R:              param.table[[M]][IDX("glbl.var")] <- get.var.covariat(MLEVARIAB)
RandomFields/R/fitgauss.R:              ml.residuals <- ML.RESIDUALS
RandomFields/R/fitgauss.R:          } # (is.na(MLEgridmin[1]))
RandomFields/R/fitgauss.R:          critical <- ptype == CRITICALPARAM;
RandomFields/R/fitgauss.R:          if (ncrit^sum(critical) > 100 && printlevel>=PL_IMPORTANT)
RandomFields/R/fitgauss.R:                newparam <- seq(if (SDVAR.IDX[i]) 0 else MLELB[i], MLEUB[i],
RandomFields/R/fitgauss.R:                lowlist[[i]] <- MLELB[i]
RandomFields/R/fitgauss.R:                upplist[[i]] <- MLEUB[i]
RandomFields/R/fitgauss.R:            orig.MLEVARIAB <- MLEVARIAB
RandomFields/R/fitgauss.R:                  new.lower <- GetModel(register=LiliReg,modus=GETMODEL_DEL_MLE,
RandomFields/R/fitgauss.R:					origin = MLE_CONFORM)
RandomFields/R/fitgauss.R:                  new.upper <- GetModel(register=LiliReg,modus=GETMODEL_DEL_MLE,
RandomFields/R/fitgauss.R:					origin = MLE_CONFORM)
RandomFields/R/fitgauss.R:                guess <- res$table[[M]][IDX("param")]
RandomFields/R/fitgauss.R:                likelihood <- res$table[[M]][tblidx[[M]][1]]
RandomFields/R/fitgauss.R:                  if (likelihood > param.table[[M]][tblidx[[M]][1]]) {
RandomFields/R/fitgauss.R:                          likelihood -  param.table[[M]][tblidx[[M]][1]], "\n") 
RandomFields/R/fitgauss.R:                    param.table[[M]][tblidx[[M]][1]] <- MLEMAX <- likelihood
RandomFields/R/fitgauss.R:                      param.table[[M]][IDX(j)] <- res$table[[M]][IDX(j)]
RandomFields/R/fitgauss.R:                ##value.ratio <- abs(log (abs(likelihood) / abs(MLEMAX)))
RandomFields/R/fitgauss.R:                ##outside <- (scale_ratio > fit$scale_ratio)  & MLEVARIAB != 0
RandomFields/R/fitgauss.R:                start <- which(names.tbl %in% LSQMETHODS)              
RandomFields/R/fitgauss.R:                guess <- GetModel(register=LiliReg, modus=GETMODEL_DEL_MLE,
RandomFields/R/fitgauss.R:				  origin = MLE_CONFORM)
RandomFields/R/fitgauss.R:      if (printlevel>=PL_STRUCTURE) cat("\nend MLE critical part ...\n")
RandomFields/R/fitgauss.R:        new.parscale <- abs(revariab <- param.table[[M]][IDX("variab")])
RandomFields/R/fitgauss.R:        fnscale <- -max(0.1, abs(MLEMAX <- param.table[[M]][tblidx[[M]][1]]))
RandomFields/R/fitgauss.R:          MLELB[SDVAR.IDX] <- pmax(MLELB[SDVAR.IDX]/100,
RandomFields/R/fitgauss.R:        OPTIM(revariab, MLtarget, lower = MLELB, upper=MLEUB, control=mle.optim.control)
RandomFields/R/fitgauss.R:        if (MLEMAX >= param.table[[M]][tblidx[[M]][1]]) {   
RandomFields/R/fitgauss.R:          if (printlevel > PL_SUBIMPORTANT)
RandomFields/R/fitgauss.R:                  param.table[[M]][IDX("param")],
RandomFields/R/fitgauss.R:                  MLEMAX, MLEVARIAB,  MLEPARAM, MLELB, MLEUB)
RandomFields/R/fitgauss.R:          param.table[[M]][tblidx[[M]][1]] <- MLEMAX
RandomFields/R/fitgauss.R:          param.table[[M]][IDX("variab")] <- MLEVARIAB         
RandomFields/R/fitgauss.R:          param.table[[M]][IDX("param")] <- MLEPARAM
RandomFields/R/fitgauss.R:          param.table[[M]][IDX("glbl.var")] <- get.var.covariat(MLEVARIAB)
RandomFields/R/fitgauss.R:    } # is.finite(MLEMAX)     
RandomFields/R/fitgauss.R:  } ## M(le)
RandomFields/R/fitgauss.R:  lower <- GetModel(register=LiliReg, modus=GETMODEL_SOLVE_MLE,
RandomFields/R/fitgauss.R:                    C_conform = FALSE, origin = MLE_CONFORM)
RandomFields/R/fitgauss.R:  upper <- GetModel(register=LiliReg, modus=GETMODEL_SOLVE_MLE,
RandomFields/R/fitgauss.R:		    C_conform = FALSE, origin = MLE_CONFORM)
RandomFields/R/fitgauss.R:  allMethods <- c(primMethods, lsqMethods, mleMethods)
RandomFields/R/fitgauss.R:    Meth_i <- allmethods[i]
RandomFields/R/fitgauss.R:    if (!(Meth_i %in% allMethods)) next
RandomFields/R/fitgauss.R:    if (is.na(param.table[[Meth_i]][1])## && !is.nan(param.table[1,i]) ?? unklar
RandomFields/R/fitgauss.R:    v <- param.table[[Meth_i]][IDX("variab")] 
RandomFields/R/fitgauss.R:    for (M in LSQMETHODS) {
RandomFields/R/fitgauss.R:      if (M %in% lsqMethods) {          
RandomFields/R/fitgauss.R:        LSQsettings(M)
RandomFields/R/fitgauss.R:        param.table[[Meth_i]][tblidx[[M]][1]] <- LStarget(v)
RandomFields/R/fitgauss.R:    for (M in MLMETHODS) {
RandomFields/R/fitgauss.R:      cur <- param.table[[Meth_i]][tblidx[[M]][1]]
RandomFields/R/fitgauss.R:      if (is.na(cur[1]) && !is.nan(cur[1]) && M %in% mleMethods) {
RandomFields/R/fitgauss.R:        param.table[[Meth_i]][tblidx[[M]][1]] <- MLtarget(v)
RandomFields/R/fitgauss.R:      if (Meth_i== M) {
RandomFields/R/fitgauss.R:        H <- NA#INVDIAGHESS(param.table[[M]][IDX("variab")], MLELB=MLELB,
RandomFields/R/fitgauss.R:             #         MLEUB=MLEUB, control=mle.optim.control)
RandomFields/R/fitgauss.R:        param.table[[M]][IDX("sdvariab")] <- NA#H$sd
RandomFields/R/fitgauss.R:        Hessians[[Meth_i]] <- NA#H$hessian
RandomFields/R/fitgauss.R:        invH[[Meth_i]] <- NA#invH
RandomFields/R/fitgauss.R:    for (M in CROSSMETHODS) {
RandomFields/R/fitgauss.R:      cur <- param.table[[Meth_i]][tblidx[[M]][1]]
RandomFields/R/fitgauss.R:      if (is.na(cur) && !is.nan(cur) && M %in% NULL) { # crossMethods) {
RandomFields/R/fitgauss.R:          ##  crosssettings(M) ## uncomment
RandomFields/R/fitgauss.R:          variab <- c(variab, param.table[[Meth_i]][idxCovar])
RandomFields/R/fitgauss.R:        param.table[[Meth_i]][tblidx[[M]][1]] <- stop("") # crosstarget(variab)
RandomFields/R/fitgauss.R:      param <- as.double(param.table[[Meth_i]][idxpar]  + 0.0) ## + 0.0 MUSS STEHEN
RandomFields/R/fitgauss.R:      .C(C_expliciteDollarMLE, LiliReg, param)
RandomFields/R/fitgauss.R:      param.table[[Meth_i]][idxpar]  <- param
RandomFields/R/fitgauss.R:    .C(C_PutValuesAtNA, LiliReg, as.double(param.table[[Meth_i]][idxpar] ))
RandomFields/R/fitgauss.R:##    Print(RFgetModelInfo(LiliReg))
RandomFields/R/fitgauss.R:                           as.double(param.table[[Meth_i]][glblvar.idx]))
RandomFields/R/fitgauss.R:    modelres <- GetModel(register = LiliReg, modus = GETMODEL_SOLVE_MLE,
RandomFields/R/fitgauss.R:    ##   AIC etc for MLE
RandomFields/R/fitgauss.R:    M <- allmethods[i]
RandomFields/R/fitgauss.R: #   if (M == "ml")  {
RandomFields/R/fitgauss.R:    if ("ml" %in% mleMethods) {
RandomFields/R/fitgauss.R:      likelihood <- param.table[[Meth_i]][tblidx[["ml"]][1]]
RandomFields/R/fitgauss.R:      lilihood <- TRY(.Call(C_EvaluateModel, double(0), integer(0), LiliReg))
RandomFields/R/fitgauss.R:               ". Maybe the model definition is incorrect or the parameters ",
RandomFields/R/fitgauss.R:      param.table[[Meth_i]][tblidx[["AIC"]][1]] <- AIC
RandomFields/R/fitgauss.R:      param.table[[Meth_i]][tblidx[["AICc"]][1]] <- AICc
RandomFields/R/fitgauss.R:      param.table[[Meth_i]][tblidx[["BIC"]][1]] <- BIC
RandomFields/R/fitgauss.R:      c.table <- rbind(param.table[[Meth_i]][IDX("covariat")], NA)
RandomFields/R/fitgauss.R:    v.table <- rbind(param.table[[Meth_i]][IDX("variab"), drop=FALSE],
RandomFields/R/fitgauss.R:                     param.table[[Meth_i]][IDX("sdvariab"), drop=FALSE],
RandomFields/R/fitgauss.R:                     param.table[[Meth_i]][IDX("lower"), drop=FALSE],
RandomFields/R/fitgauss.R:                     param.table[[Meth_i]][IDX("upper"), drop=FALSE])
RandomFields/R/fitgauss.R:    p.table <- if (n.variab > 0) rbind(param.table[[Meth_i]][IDX("param")], NA)
RandomFields/R/fitgauss.R:    res[[M]] <-
RandomFields/R/fitgauss.R:             if (globalvariance) param.table[[Meth_i]][IDX("glbl.var")][1],
RandomFields/R/fitgauss.R:    ##Print(res[[M]])
RandomFields/R/fitgauss.R:    class(res[[M]]) <- CLASS_SINGLEFIT
RandomFields/R/fitgauss.R:  ## Hess-Matrix for the parameters (for the variables see above)
RandomFields/R/fitgauss.R:  ## prepare MLtarget for getting 'param' directly
RandomFields/R/fitgauss.R:      for (i in OneTo(length(mleMethods))) {
RandomFields/R/fitgauss.R:        M <- mleMethods[i]
RandomFields/R/fitgauss.R:        res[[M]]$param[2, 1:n.param] <- param.table[[M]][IDX("sdparam")] <-
RandomFields/R/fitgauss.R:           param.table[[M]][IDX("sdvariab")]
RandomFields/R/fitgauss.R:        res[[M]]$hessian <- Hessians[[M]]
RandomFields/R/fitgauss.R:      for (i in OneTo(length(mleMethods))) {
RandomFields/R/fitgauss.R:        M <- mleMethods[i]
RandomFields/R/fitgauss.R:        variab <- param.table[[M]][IDX("variab")] ## before orig.trafo
RandomFields/R/fitgauss.R:        param <- param.table[[M]][IDX("param")] ##  after orig.trafo
RandomFields/R/fitgauss.R:        eps <- pmin(pmax(variab - MLELB, MLEUB - variab), eps.max)        
RandomFields/R/fitgauss.R:        eps <- diag(nrow=n.variab, eps * (2 * (variab <= MLEUB - eps) - 1))
RandomFields/R/fitgauss.R:        res[[M]]$hessian <- t(pseudoinv) %*% Hessians[[M]] %*% pseudoinv
RandomFields/R/fitgauss.R:        ## Print(res[[M]]$hessian)
RandomFields/R/fitgauss.R:        if (length(invH[[M]]) == 0) res[[M]]$param[2, 1:n.param] <- NA
RandomFields/R/fitgauss.R:          res[[M]]$param[2, 1:n.param] <-
RandomFields/R/fitgauss.R:            sqrt(-diag(dtrafo %*% invH[[M]] %*% t(dtrafo)))
RandomFields/R/fitgauss.R:    L <- trafo(MLELB)
RandomFields/R/fitgauss.R:    U <- trafo(MLEUB)
RandomFields/R/fitgauss.R:    for (i in OneTo(length(mleMethods))) {
RandomFields/R/fitgauss.R:      M <- mleMethods[i]
RandomFields/R/fitgauss.R:      param <- param.table[[M]][IDX("param")] ##  after orig.trafo
RandomFields/R/fitgauss.R:      MLELB <- pmin(L, U, param, na.rm=TRUE)
RandomFields/R/fitgauss.R:      MLEUB <- pmax(L, U, param, na.rm=TRUE)
RandomFields/R/fitgauss.R:      cur <- param.table[[M]][tblidx[["ml"]][1]]
RandomFields/R/fitgauss.R:        mle <- MLtarget(param)
RandomFields/R/fitgauss.R:        if ( (difference > 1e-10 && printlevel > PL_IMPORTANT) ||
RandomFields/R/fitgauss.R:             (difference > 1e-4 && printlevel >= PL_IMPORTANT) )
RandomFields/R/fitgauss.R:  if (printlevel >= PL_IMPORTANT && BEYOND > 100)
RandomFields/R/fitgauss.R:  for (i in 1:length(res)) { ## laeuft ueber Methoden, nicht ueber data.sets!
RandomFields/R/fitgauss.R:    res2[[i]] <- list2RMmodelFit(res[[i]], RFsp.info=Z$RFsp.info,
RandomFields/R/fitgauss.R:  if (length(L$ev) > 0) L$ev <- do.call("new", c(list(CLASS_EMPIR), L$ev))
RandomFields/R/fitgauss.R:  L$lowerbounds <- list2RMmodel(L$lower)
RandomFields/R/fitgauss.R:  L$upperbounds <- list2RMmodel(L$upper)
RandomFields/R/RMmodels-Methods-plots.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/RMmodels-Methods-plots.R:## Copyright (C) 2015 -- 2017 Alexander Malinowski & Martin Schlather
RandomFields/R/RMmodels-Methods-plots.R:## Copyright (C) 2017 -- 2017 Martin Schlather
RandomFields/R/RMmodels-Methods-plots.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/RMmodels-Methods-plots.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/RMmodels-Methods-plots.R:## accessing CLASS_CLIST and RMmodelgenerator via '['-operator
RandomFields/R/RMmodels-Methods-plots.R:# e.g. RMwhittle["domain"]
RandomFields/R/RMmodels-Methods-plots.R:setMethod(f="[", signature = CLASS_CLIST, def = accessSlotsByName)
RandomFields/R/RMmodels-Methods-plots.R:setMethod(f="[", signature = CLASS_SINGLEFIT, def = accessSlotsByName)
RandomFields/R/RMmodels-Methods-plots.R:setMethod(f="[", signature = CLASS_RM, def = accessSlotsByName)
RandomFields/R/RMmodels-Methods-plots.R:setReplaceMethod(f="[", signature = CLASS_CLIST, accessReplaceSlotsByName)
RandomFields/R/RMmodels-Methods-plots.R:setReplaceMethod(f="[", signature = CLASS_SINGLEFIT, accessReplaceSlotsByName)
RandomFields/R/RMmodels-Methods-plots.R:setReplaceMethod(f="[", signature = CLASS_RM,accessReplaceSlotsByName)
RandomFields/R/RMmodels-Methods-plots.R:## summing up RMmodels
RandomFields/R/RMmodels-Methods-plots.R:setMethod('c', signature=c(CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:## funktioniert im speziellen Modus nicht, allgemein schon
RandomFields/R/RMmodels-Methods-plots.R:#setMethod('diag', signature=c(CLASS_CLIST, 'missing', 'missing', 'missing'),
RandomFields/R/RMmodels-Methods-plots.R:#            RMmatrix(x)
RandomFields/R/RMmodels-Methods-plots.R:  ## RMmodels only
RandomFields/R/RMmodels-Methods-plots.R:  if (e1@name==sign && (len.e1 <- length(e1@submodels)) < MAXSUB) {             
RandomFields/R/RMmodels-Methods-plots.R:      stop("characters cannot be combined with 'RMmodels'")
RandomFields/R/RMmodels-Methods-plots.R:                                        #  do.call(SYMBOL_P, list(e1))
RandomFields/R/RMmodels-Methods-plots.R:       stop("characters cannot be combined with 'RMmodels'")
RandomFields/R/RMmodels-Methods-plots.R:                                        #  do.call(SYMBOL_P, list(e2))
RandomFields/R/RMmodels-Methods-plots.R:  if (sign == RM_MULT[1]) {
RandomFields/R/RMmodels-Methods-plots.R:warn.resolve.txt <- "A large vector consists fully of NAs -- the model is probably not correct.\nNote that it is always better to define the covariance model in the first\nsummands and then the trend. Also better use explicitely 'R.c', 'RMcovariate'\nand 'R.const' if the model is more complicated"
RandomFields/R/RMmodels-Methods-plots.R:  if (e1@name==sign && (len.e1 <- length(e1@submodels)) < MAXSUB) {
RandomFields/R/RMmodels-Methods-plots.R:       stop("characters cannot be combined with 'RMmodels'")
RandomFields/R/RMmodels-Methods-plots.R:                                        #do.call(SYMBOL_P, list(e1))
RandomFields/R/RMmodels-Methods-plots.R:    } else if (sign == RM_PLUS[1]) {
RandomFields/R/RMmodels-Methods-plots.R:      tmpList <- list(RM_COVARIATE)
RandomFields/R/RMmodels-Methods-plots.R:      tmpList[[COVARIATE_C_NAME]] <- e2
RandomFields/R/RMmodels-Methods-plots.R:      tmpList[[COVARIATE_X_NAME]] <- NULL
RandomFields/R/RMmodels-Methods-plots.R:      tmpList[[COVARIATE_ADDNA_NAME]] <- TRUE
RandomFields/R/RMmodels-Methods-plots.R:      do.call(RM_COVARIATE, tmpList)
RandomFields/R/RMmodels-Methods-plots.R:##    e[[COVARIATE_ADDNA_NAME]] <- TRUE
RandomFields/R/RMmodels-Methods-plots.R:##    d[[len.e1 + 1]] <- do.call(RM_COVARIATE, e)
RandomFields/R/RMmodels-Methods-plots.R:#    e[[COVARIATE_ADDNA_NAME]] <- TRUE   
RandomFields/R/RMmodels-Methods-plots.R:#    d[[1]] <- do.call(RM_COVARIATE, e)
RandomFields/R/RMmodels-Methods-plots.R:    } else if (sign == RM_PLUS[1]) {
RandomFields/R/RMmodels-Methods-plots.R:      tmpList <- list(RM_COVARIATE)
RandomFields/R/RMmodels-Methods-plots.R:      tmpList[[COVARIATE_C_NAME]] <- e1
RandomFields/R/RMmodels-Methods-plots.R:      tmpList[[COVARIATE_X_NAME]] <- NULL
RandomFields/R/RMmodels-Methods-plots.R:      tmpList[[COVARIATE_ADDNA_NAME]] <- TRUE
RandomFields/R/RMmodels-Methods-plots.R:      do.call(RM_COVARIATE, tmpList)
RandomFields/R/RMmodels-Methods-plots.R:			 stop("characters cannot be combined with 'RMmodels'")
RandomFields/R/RMmodels-Methods-plots.R:		       ##do.call(SYMBOL_P, list(e2))
RandomFields/R/RMmodels-Methods-plots.R:## summing up RMmodels
RandomFields/R/RMmodels-Methods-plots.R:setMethod('+', signature=c(CLASS_CLIST, CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:          function(e1, e2) resolve(e1, e2, RM_PLUS[1]))
RandomFields/R/RMmodels-Methods-plots.R:setMethod('+', signature=c(CLASS_CLIST, 'numeric'), 
RandomFields/R/RMmodels-Methods-plots.R:          function(e1, e2) resolveRight(e1, e2, RM_PLUS[1]))
RandomFields/R/RMmodels-Methods-plots.R:setMethod('+', signature=c(CLASS_CLIST, 'logical'),
RandomFields/R/RMmodels-Methods-plots.R:          function(e1, e2) resolveRight(e1, e2, RM_PLUS[1]))
RandomFields/R/RMmodels-Methods-plots.R:setMethod('+', signature=c(CLASS_CLIST, 'factor'),
RandomFields/R/RMmodels-Methods-plots.R:          function(e1, e2) resolveRight(e1, e2, RM_PLUS[1]))
RandomFields/R/RMmodels-Methods-plots.R:setMethod('+', signature=c(CLASS_CLIST, 'list'),
RandomFields/R/RMmodels-Methods-plots.R:          function(e1, e2) resolveRight(e1, e2, RM_PLUS[1]))
RandomFields/R/RMmodels-Methods-plots.R:setMethod('+', signature=c('numeric', CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:          function(e1, e2) resolveLeft(e1, e2, RM_PLUS[1]))
RandomFields/R/RMmodels-Methods-plots.R:setMethod('+', signature=c('logical', CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:          function(e1, e2) resolveLeft(e1, e2, RM_PLUS[1]))
RandomFields/R/RMmodels-Methods-plots.R:setMethod('+', signature=c('data.frame', CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:          function(e1, e2) resolveLeft(e1, e2, RM_PLUS[1]))
RandomFields/R/RMmodels-Methods-plots.R:setMethod('+', signature=c('factor', CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:          function(e1, e2) resolveLeft(e1, e2, RM_PLUS[1]))
RandomFields/R/RMmodels-Methods-plots.R:setMethod('+', signature=c(CLASS_CLIST, 'character'),
RandomFields/R/RMmodels-Methods-plots.R:          function(e1, e2) resolve(e1, e2, RM_PLUS[1]))
RandomFields/R/RMmodels-Methods-plots.R:setMethod('+', signature=c('character', CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:          function(e1, e2) resolve(e1, e2, RM_PLUS[1]))
RandomFields/R/RMmodels-Methods-plots.R:## multiplying RMmodels
RandomFields/R/RMmodels-Methods-plots.R:setMethod('*', signature=c(CLASS_CLIST, CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:         function(e1, e2) resolve(e1, e2, RM_MULT[1]))
RandomFields/R/RMmodels-Methods-plots.R:setMethod('*', signature=c('numeric', CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:         function(e1, e2) resolveLeft(e1, e2, RM_MULT[1]))
RandomFields/R/RMmodels-Methods-plots.R:setMethod('*', signature=c('logical', CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:         function(e1, e2) resolveLeft(e1, e2, RM_MULT[1]))
RandomFields/R/RMmodels-Methods-plots.R:setMethod('*', signature=c(CLASS_CLIST, 'logical'),
RandomFields/R/RMmodels-Methods-plots.R:          function(e1, e2) resolveRight(e1, e2, RM_MULT[1]))
RandomFields/R/RMmodels-Methods-plots.R:setMethod('*', signature=c(CLASS_CLIST, 'numeric'),
RandomFields/R/RMmodels-Methods-plots.R:          function(e1, e2) resolveRight(e1, e2, RM_MULT[1]))
RandomFields/R/RMmodels-Methods-plots.R:setMethod('*', signature=c(CLASS_CLIST, 'character'),
RandomFields/R/RMmodels-Methods-plots.R:         function(e1, e2) resolve(e1, e2, RM_MULT[1]))
RandomFields/R/RMmodels-Methods-plots.R:setMethod('*', signature=c('character', CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:         function(e1, e2) resolve(e1, e2, RM_MULT[1]))
RandomFields/R/RMmodels-Methods-plots.R:     stop("characters cannot be combined with 'RMmodels'")
RandomFields/R/RMmodels-Methods-plots.R:                                        #do.call(SYMBOL_P, list(e1))
RandomFields/R/RMmodels-Methods-plots.R:      stop("characters cannot be combined with 'RMmodels'")
RandomFields/R/RMmodels-Methods-plots.R:                                        #do.call(SYMBOL_P, list(e2))
RandomFields/R/RMmodels-Methods-plots.R:##    e[[COVARIATE_ADDNA_NAME]] <- TRUE   
RandomFields/R/RMmodels-Methods-plots.R:##    d[[1]] <-  do.call(RM_COVARIATE, e)
RandomFields/R/RMmodels-Methods-plots.R:			stop("characters cannot be combined with 'RMmodels'")
RandomFields/R/RMmodels-Methods-plots.R:                                        #do.call(SYMBOL_P, list(e2))
RandomFields/R/RMmodels-Methods-plots.R:     stop("characters cannot be combined with 'RMmodels'")
RandomFields/R/RMmodels-Methods-plots.R:                                        #do.call(SYMBOL_P, list(e1))
RandomFields/R/RMmodels-Methods-plots.R:  ## e[[COVARIATE_ADDNA_NAME]] <- TRUE   
RandomFields/R/RMmodels-Methods-plots.R:  ## d[[len.e1 + 1]] <- do.call(RM_COVARIATE, e)
RandomFields/R/RMmodels-Methods-plots.R:## substracting RMmodels
RandomFields/R/RMmodels-Methods-plots.R:setMethod('-', signature=c(CLASS_CLIST, CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:setMethod('-', signature=c('numeric', CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:setMethod('-', signature=c('logical', CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:setMethod('-', signature=c(CLASS_CLIST, 'numeric'),
RandomFields/R/RMmodels-Methods-plots.R:setMethod('-', signature=c(CLASS_CLIST, 'logical'),
RandomFields/R/RMmodels-Methods-plots.R:setMethod('-', signature=c(CLASS_CLIST, 'character'),
RandomFields/R/RMmodels-Methods-plots.R:setMethod('-', signature=c('character', CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:## dividing up RMmodels
RandomFields/R/RMmodels-Methods-plots.R:setMethod('/', signature=c(CLASS_CLIST, CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:setMethod('/', signature=c('numeric', CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:setMethod('/', signature=c('logical', CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:setMethod('/', signature=c(CLASS_CLIST, 'numeric'),
RandomFields/R/RMmodels-Methods-plots.R:setMethod('/', signature=c(CLASS_CLIST, 'logical'),
RandomFields/R/RMmodels-Methods-plots.R:setMethod('/', signature=c(CLASS_CLIST, 'character'),
RandomFields/R/RMmodels-Methods-plots.R:setMethod('/', signature=c('character', CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:## powering up RMmodels
RandomFields/R/RMmodels-Methods-plots.R:setMethod('^', signature=c(CLASS_CLIST, CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:setMethod('^', signature=c('numeric', CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:setMethod('^', signature=c('logical', CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:setMethod('^', signature=c(CLASS_CLIST, 'numeric'),
RandomFields/R/RMmodels-Methods-plots.R:setMethod('^', signature=c(CLASS_CLIST, 'logical'),
RandomFields/R/RMmodels-Methods-plots.R:setMethod('^', signature=c(CLASS_CLIST, 'character'),
RandomFields/R/RMmodels-Methods-plots.R:setMethod('^', signature=c('character', CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:## str.RMmodel is basically copied from str.default, but where
RandomFields/R/RMmodels-Methods-plots.R:## for which the value is 'RMdefault', i.e. for which there is no
RandomFields/R/RMmodels-Methods-plots.R:str.RMmodel <-
RandomFields/R/RMmodels-Methods-plots.R:  if (isS4(object)) object <- as.list.RMmodel(object)
RandomFields/R/RMmodels-Methods-plots.R:      is.RMdefault <-
RandomFields/R/RMmodels-Methods-plots.R:      obj$par.general[is.RMdefault] <- NULL
RandomFields/R/RMmodels-Methods-plots.R:      if (all(is.RMdefault)) obj$par.general <- list()
RandomFields/R/RMmodels-Methods-plots.R:as.list.RMmodel <- function(x, ...) {
RandomFields/R/RMmodels-Methods-plots.R:    ans[names(x@submodels)] <- lapply(x@submodels, as.list.RMmodel)
RandomFields/R/RMmodels-Methods-plots.R:             function(p) if (is(p, CLASS_CLIST)) as.list.RMmodel(p) else p)
RandomFields/R/RMmodels-Methods-plots.R:             function(p) if (is(p, CLASS_CLIST)) as.list.RMmodel(p) else p)
RandomFields/R/RMmodels-Methods-plots.R:summary.RMmodel <- function(object, max.level=5, ...) {
RandomFields/R/RMmodels-Methods-plots.R:    model <- try(PrepareModel2(object, ..., xdim=1)$model, silent=TRUE) # OK
RandomFields/R/RMmodels-Methods-plots.R:      return(as.list.RMmodel(object))
RandomFields/R/RMmodels-Methods-plots.R:  class(object) <- "summary.RMmodel"
RandomFields/R/RMmodels-Methods-plots.R:print.summary.RMmodel <- function(x, max.level=5, ...) {
RandomFields/R/RMmodels-Methods-plots.R:print.RMmodel <- function(x, max.level=5,...) {
RandomFields/R/RMmodels-Methods-plots.R:  print.summary.RMmodel(summary.RMmodel(x, max.level=max.level, ...),
RandomFields/R/RMmodels-Methods-plots.R:setMethod(f="show", signature=CLASS_CLIST,
RandomFields/R/RMmodels-Methods-plots.R:          definition=function(object) print.RMmodel(object))#
RandomFields/R/RMmodels-Methods-plots.R:print.RMmodelgenerator <- function(x, ...) {
RandomFields/R/RMmodels-Methods-plots.R:  cat("*** object of Class '", CLASS_RM, "' ***\n", sep="")
RandomFields/R/RMmodels-Methods-plots.R:      else if (x@vdim == PARAM_DEP) "parameter dependent"
RandomFields/R/RMmodels-Methods-plots.R:      else if (x@vdim == PREVMODEL_DEP) "depends on calling model"
RandomFields/R/RMmodels-Methods-plots.R:      else if (x@vdim == SUBMODEL_DEP) "submodel dependent"
RandomFields/R/RMmodels-Methods-plots.R:      else if (x@maxdim == PARAM_DEP) "parameter dependent"
RandomFields/R/RMmodels-Methods-plots.R:      else if (x@maxdim == PREVMODEL_DEP) "depends on calling model"
RandomFields/R/RMmodels-Methods-plots.R:      else if (x@maxdim == SUBMODEL_DEP) "submodel dependent"
RandomFields/R/RMmodels-Methods-plots.R:setMethod("show", signature=CLASS_RM,
RandomFields/R/RMmodels-Methods-plots.R:	  definition=function(object) print.RMmodelgenerator(object))
RandomFields/R/RMmodels-Methods-plots.R:ConvertRMlist2string <- function(model) {
RandomFields/R/RMmodels-Methods-plots.R:    is.list(x) && (x[[1]] %in% DOLLAR || x[[1]] %in% list2RMmodel_Names))
RandomFields/R/RMmodels-Methods-plots.R:  sub <- if (any(subi)) sapply(model[subi], ConvertRMlist2string) else NULL
RandomFields/R/RMmodels-Methods-plots.R:      !(model[subi][[1]] %in% c(RM_PLUS, RM_MULT, DOLLAR))) {
RandomFields/R/RMmodels-Methods-plots.R:  } else if (model[[1]] %in% RM_PLUS && !any(pari))
RandomFields/R/RMmodels-Methods-plots.R:  else if (model[[1]] %in% RM_MULT && !any(pari)) {
RandomFields/R/RMmodels-Methods-plots.R:    idx <- 1 + sapply(model[subi], function(x) x[[1]] %in% RM_PLUS)
RandomFields/R/RMmodels-Methods-plots.R:#   else if (model[[1]] %in% RM_DISTR) FEHLT!
RandomFields/R/RMmodels-Methods-plots.R:rfConvertRMmodel2string <- function(model){
RandomFields/R/RMmodels-Methods-plots.R:  if (is.list(model)) return(ConvertRMlist2string(model))
RandomFields/R/RMmodels-Methods-plots.R:    string.vector <- lapply(par[idx.random], FUN=rfConvertRMmodel2string)
RandomFields/R/RMmodels-Methods-plots.R:    string.vector <- lapply(model@submodels, FUN=rfConvertRMmodel2string)
RandomFields/R/RMmodels-Methods-plots.R:## empvario is(x, CLASS_FITLIST) || is(x, CLASS_EMPIR)
RandomFields/R/RMmodels-Methods-plots.R:                            MARGIN, fixed.MARGIN, ...,
RandomFields/R/RMmodels-Methods-plots.R:  plotMethods <- c("plot.xy", "image", "matplot", "contour", "persp", "none")
RandomFields/R/RMmodels-Methods-plots.R:    pm <- pmatch(plotmethod, plotMethods)
RandomFields/R/RMmodels-Methods-plots.R:      if (is.na(pm)) stop("possible values for 'plotMethods' are ",
RandomFields/R/RMmodels-Methods-plots.R:                          paste(plotMethods, collapse=", "),
RandomFields/R/RMmodels-Methods-plots.R:      plotmethod <- plotMethods[pm]  
RandomFields/R/RMmodels-Methods-plots.R:    if (missing(MARGIN) || missing(fixed.MARGIN))
RandomFields/R/RMmodels-Methods-plots.R:      stop("'MARGIN' and 'fixed.MARGIN' must be given if dim >=3")
RandomFields/R/RMmodels-Methods-plots.R:  if ((!missing(MARGIN) && length(MARGIN) > 0) ||
RandomFields/R/RMmodels-Methods-plots.R:      (!missing(fixed.MARGIN) && length(fixed.MARGIN) > 0)) {
RandomFields/R/RMmodels-Methods-plots.R:      stop("'MARGIN' and 'fixed.MARGIN' should only be given for dim>=3")
RandomFields/R/RMmodels-Methods-plots.R:    if (missing(MARGIN) || length(MARGIN) == 0 ||
RandomFields/R/RMmodels-Methods-plots.R:        missing(fixed.MARGIN) || length(fixed.MARGIN) == 0)
RandomFields/R/RMmodels-Methods-plots.R:      stop("both 'MARGIN' and 'fixed.margin' must be given")
RandomFields/R/RMmodels-Methods-plots.R:    stopifnot(is.numeric(MARGIN) && length(MARGIN) == 2)
RandomFields/R/RMmodels-Methods-plots.R:    stopifnot(is.numeric(fixed.MARGIN) && (length(fixed.MARGIN) == dim - 2))
RandomFields/R/RMmodels-Methods-plots.R:        fctnTypes <- FCTN_TYPE_NAMES[fctn.type + 3]
RandomFields/R/RMmodels-Methods-plots.R:    m <- list("", PrepareModel2(m0, xdim=dim, params=params)$model)
RandomFields/R/RMmodels-Methods-plots.R:      mnames[i] <- rfConvertRMmodel2string(m[[2]])
RandomFields/R/RMmodels-Methods-plots.R:      msplit <- strsplit(mnames[i], "RM")[[1]]
RandomFields/R/RMmodels-Methods-plots.R:                              reg=MODEL_AUX, RFopt=RFopt, NAOK=FALSE))
RandomFields/R/RMmodels-Methods-plots.R:        ## !! result of MODEL_AUX may not be used for model evaluation !!
RandomFields/R/RMmodels-Methods-plots.R:        ## since RMcovariate is wrongly evaluated !!
RandomFields/R/RMmodels-Methods-plots.R:      coords[,MARGIN] <- as.matrix(m1)
RandomFields/R/RMmodels-Methods-plots.R:      coords[,-MARGIN] <- rep(fixed.MARGIN, each=nrow(m1))      
RandomFields/R/RMmodels-Methods-plots.R:            MARGIN=if(!missing(MARGIN)) MARGIN,
RandomFields/R/RMmodels-Methods-plots.R:            fixed.MARGIN=if(!missing(fixed.MARGIN))fixed.MARGIN,
RandomFields/R/RMmodels-Methods-plots.R:RFplotModel <- function(x, y, dim=1,
RandomFields/R/RMmodels-Methods-plots.R:                        MARGIN, fixed.MARGIN, ...,
RandomFields/R/RMmodels-Methods-plots.R:                            MARGIN = MARGIN, fixed.MARGIN = fixed.MARGIN,
RandomFields/R/RMmodels-Methods-plots.R:                     if (alpha == PSEUDOMADOGRAM) {
RandomFields/R/RMmodels-Methods-plots.R:                       if (vdim == 1) "Madogram" else "Pseudomadogram"
RandomFields/R/RMmodels-Methods-plots.R:                                   if (vdim == 1) "Madrogram"
RandomFields/R/RMmodels-Methods-plots.R:                   "Madogram" = "Madogram",
RandomFields/R/RMmodels-Methods-plots.R:                    paste((1:dim)[-MARGIN], collapse=", "), 
RandomFields/R/RMmodels-Methods-plots.R:                    paste(format(fixed.MARGIN, digits=4), collapse=", "))
RandomFields/R/RMmodels-Methods-plots.R:points.RMmodel <- function(x, ..., type="p")  
RandomFields/R/RMmodels-Methods-plots.R:  RFplotModel(x, ..., type=type,  plotmethod="plot.xy")
RandomFields/R/RMmodels-Methods-plots.R:lines.RMmodel <- function(x, ..., type="l")
RandomFields/R/RMmodels-Methods-plots.R:  RFplotModel(x, ..., type=type,  plotmethod="plot.xy")
RandomFields/R/RMmodels-Methods-plots.R:# @NAME		list2RMmodel
RandomFields/R/RMmodels-Methods-plots.R:# @AUTHOR	A Malinowski <malinows@math.uni-goettingen.de>
RandomFields/R/RMmodels-Methods-plots.R:list2RMmodel <- function(x) { 
RandomFields/R/RMmodels-Methods-plots.R:  if (name == RM_DECLARE) return(NULL)
RandomFields/R/RMmodels-Methods-plots.R:  if (name %in% DOLLAR) return(list2RMmodel(c(x[[len]], x[-c(1, len)])))
RandomFields/R/RMmodels-Methods-plots.R:#  if (name == RM_DISTR[1]){
RandomFields/R/RMmodels-Methods-plots.R:#    m <- do.call(RM_DISTR[1], args=list())
RandomFields/R/RMmodels-Methods-plots.R:  if (name==SYMBOL_PLUS) name <- RM_PLUS[1] else
RandomFields/R/RMmodels-Methods-plots.R:  if (name==SYMBOL_MULT) name <- RM_MULT[1] else
RandomFields/R/RMmodels-Methods-plots.R:  if (!(name %in% list2RMmodel_Names)) {
RandomFields/R/RMmodels-Methods-plots.R:    if (!(name %in% list2RMmodel_oldNames))
RandomFields/R/RMmodels-Methods-plots.R:    x <- lapply(x, FUN=list2RMmodel)
RandomFields/R/RMmodels-Methods-plots.R:plot.RFplot <- RFplotModel
RandomFields/R/RMmodels-Methods-plots.R:setMethod(f="plot", signature(x=CLASS_CLIST, y="missing"),
RandomFields/R/RMmodels-Methods-plots.R:          function(x, y, ...) RFplotModel(x, ...))
RandomFields/R/RMmodels-Methods-plots.R:#setMethod(f="plot", signature(x=CLASS_PLOT, y="missing"),
RandomFields/R/RMmodels-Methods-plots.R:#          function(x, ...) RFplotModel(x, ...))
RandomFields/R/RMmodels-Methods-plots.R:setMethod(f="lines", signature(x=CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:          RFplotModel(x, ..., type=type, plotmethod="plot.xy"))
RandomFields/R/RMmodels-Methods-plots.R:setMethod(f="points", signature(x=CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:          RFplotModel(x, ..., type=type, plotmethod="plot.xy"))
RandomFields/R/RMmodels-Methods-plots.R:setMethod(f="persp", signature(x=CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:          RFplotModel(x,...,dim=dim,zlab=zlab,plotmethod="persp"))
RandomFields/R/RMmodels-Methods-plots.R:setMethod(f="image", signature(x=CLASS_CLIST),
RandomFields/R/RMmodels-Methods-plots.R:          function(x, ..., dim=2) RFplotModel(x,...,dim=dim,plotmethod="image"))
RandomFields/R/RQmodels.R:# This file has been created automatically by 'rfGenerateMaths'
RandomFields/R/RQmodels.R:setMethod("asin", signature = CLASS_CLIST, definition=function(x) R.asin(x))
RandomFields/R/RQmodels.R:setMethod("atan", signature = CLASS_CLIST, definition=function(x) R.atan(x))
RandomFields/R/RQmodels.R:setMethod("atan2", signature = c(CLASS_CLIST,'ANY'), definition=function(y, x) R.atan2(y, x))
RandomFields/R/RQmodels.R:setMethod("atan2", signature = c('ANY',CLASS_CLIST), definition=function(y, x) R.atan2(y, x))
RandomFields/R/RQmodels.R:setMethod("cos", signature = CLASS_CLIST, definition=function(x) R.cos(x))
RandomFields/R/RQmodels.R:setMethod("sin", signature = CLASS_CLIST, definition=function(x) R.sin(x))
RandomFields/R/RQmodels.R:setMethod("tan", signature = CLASS_CLIST, definition=function(x) R.tan(x))
RandomFields/R/RQmodels.R:setMethod("acosh", signature = CLASS_CLIST, definition=function(x) R.acosh(x))
RandomFields/R/RQmodels.R:setMethod("asinh", signature = CLASS_CLIST, definition=function(x) R.asinh(x))
RandomFields/R/RQmodels.R:setMethod("atanh", signature = CLASS_CLIST, definition=function(x) R.atanh(x))
RandomFields/R/RQmodels.R:setMethod("cosh", signature = CLASS_CLIST, definition=function(x) R.cosh(x))
RandomFields/R/RQmodels.R:setMethod("sinh", signature = CLASS_CLIST, definition=function(x) R.sinh(x))
RandomFields/R/RQmodels.R:setMethod("tanh", signature = CLASS_CLIST, definition=function(x) R.tanh(x))
RandomFields/R/RQmodels.R:setMethod("exp", signature = CLASS_CLIST, definition=function(x) R.exp(x))
RandomFields/R/RQmodels.R:setMethod("log", signature = CLASS_CLIST, definition=function(x) R.log(x))
RandomFields/R/RQmodels.R:setMethod("expm1", signature = CLASS_CLIST, definition=function(x) R.expm1(x))
RandomFields/R/RQmodels.R:setMethod("log1p", signature = CLASS_CLIST, definition=function(x) R.log1p(x))
RandomFields/R/RQmodels.R:setMethod("log2", signature = CLASS_CLIST, definition=function(x) R.log2(x))
RandomFields/R/RQmodels.R:setMethod("^", signature = c(CLASS_CLIST,'ANY'), definition=function(e1, e2) R.pow(e1, e2))
RandomFields/R/RQmodels.R:setMethod("^", signature = c('ANY',CLASS_CLIST), definition=function(e1, e2) R.pow(e1, e2))
RandomFields/R/RQmodels.R:setMethod("sqrt", signature = CLASS_CLIST, definition=function(x) R.sqrt(x))
RandomFields/R/RQmodels.R:setMethod("ceiling", signature = CLASS_CLIST, definition=function(x) R.ceil(x))
RandomFields/R/RQmodels.R:setMethod("abs", signature = CLASS_CLIST, definition=function(x) R.fabs(x))
RandomFields/R/RQmodels.R:setMethod("floor", signature = CLASS_CLIST, definition=function(x) R.floor(x))
RandomFields/R/RQmodels.R:setMethod("%%", signature = c(CLASS_CLIST,'ANY'), definition=function(e1, e2) R.fmod(e1, e2))
RandomFields/R/RQmodels.R:setMethod("%%", signature = c('ANY',CLASS_CLIST), definition=function(e1, e2) R.fmod(e1, e2))
RandomFields/R/RQmodels.R:setMethod("round", signature = c(CLASS_CLIST, 'missing'), definition=function(x, digits=0) R.round(x))
RandomFields/R/RQmodels.R:setMethod("trunc", signature = CLASS_CLIST, definition=function(x) R.trunc(x))
RandomFields/R/RQmodels.R:setMethod("lgamma", signature = CLASS_CLIST, definition=function(x) R.lgamma(x))
RandomFields/R/fitpoisson.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/fitpoisson.R:## Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/R/fitpoisson.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/fitpoisson.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/fitbernoulli.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/fitbernoulli.R:## Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/R/fitbernoulli.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/fitbernoulli.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/Methods-aux.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/Methods-aux.R:## Copyright (C) 2012 -- 2014 Alexander Malinowski & Martin Schlather
RandomFields/R/Methods-aux.R:##               2015 -- 2017 Martin Schlather
RandomFields/R/Methods-aux.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/Methods-aux.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/Methods-aux.R:  ##IMPORTANT NOTE! DO NOT CHANGE THE VARIABLE NAMES IN THIS SIGNATURE
RandomFields/R/Methods-aux.R:      !(COORD_NAMES_GENERAL[2] %in% names(obj@grid@cellcentre.offset)))
RandomFields/R/Methods-aux.R:    idxT1 <- which(COORD_NAMES_GENERAL[2] ==names(obj@grid@cellcentre.offset))
RandomFields/R/Methods-aux.R:  idxT1 <- which(COORD_NAMES_GENERAL[2] == colnames(obj@coords))
RandomFields/R/Methods-aux.R:setMethod("RFspDataFrame2conventional",
RandomFields/R/Methods-aux.R:setMethod("RFspDataFrame2conventional", signature=c("RFgridDataFrame"),
RandomFields/R/Methods-aux.R:setMethod("RFspDataFrame2conventional",
RandomFields/R/Methods-aux.R:setMethod("RFspDataFrame2conventional", signature=c("RFpointsDataFrame"),
RandomFields/R/Methods-aux.R:### ist keine Methode im engeren Sinne. Habe ich aus Methods-RFsp.R
RandomFields/R/Methods-aux.R:### rausgenommen, da bei jeglicher Aenderung in Methods-RFsp.R ich
RandomFields/R/Methods-aux.R:    ## naechste Zeile eingefuegt !! und (Martin 30.6.13) wieder
RandomFields/R/RMmodelsBasics.R:CheckMixed <- function(arg, subst, names) {
RandomFields/R/RMmodelsBasics.R:    p <- -pmatch(arg, PROJECTION_NAMES)
RandomFields/R/RMmodelsBasics.R:	  pmatch("time", PROJECTION_NAMES) -1 -length(PROJECTION_NAMES)
RandomFields/R/RMmodelsBasics.R:CheckMaths <- function(arg, subst, distr) {
RandomFields/R/RMmodelsBasics.R:  ## See also CheckArg in PrepareModel
RandomFields/R/simu-plots.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/simu-plots.R:## Copyright (C) 2012 -- 2014 Alexander Malinowski & Martin Schlather
RandomFields/R/simu-plots.R:##               2015 -- 2017 Martin Schlather
RandomFields/R/simu-plots.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/simu-plots.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/simu-plots.R:                            MARGIN, n,
RandomFields/R/simu-plots.R:  if (!(length(MARGIN)==2)) stop("MARGIN must have length 2")
RandomFields/R/simu-plots.R:  if (!all(MARGIN %in% 1:tsdim)) stop("chosen MARGINS are out of bounds")
RandomFields/R/simu-plots.R:  lab <- xylabs(names.coords[MARGIN[1]], names.coords[MARGIN[2]],
RandomFields/R/simu-plots.R:          stop("number of colours is one -- please choose an appropriate colour palette. Maybe 'RFpar(col=NULL)' will help.")
RandomFields/R/simu-plots.R:                             MARGIN =c(1,2),# which dimensions are to be plotted
RandomFields/R/simu-plots.R:                             MARGIN.slices =NULL,
RandomFields/R/simu-plots.R:                             n.slices = if (is.null(MARGIN.slices)) 1 else 10,
RandomFields/R/simu-plots.R:                             MARGIN.movie = NULL,
RandomFields/R/simu-plots.R:  do.slices <- !is.null(MARGIN.slices)
RandomFields/R/simu-plots.R:  do.movie <- !is.null(MARGIN.movie)
RandomFields/R/simu-plots.R:  if (length(MARGIN.slices) > 1) stop("MARGIN.slices must be a scalar.")
RandomFields/R/simu-plots.R:  if (length(MARGIN.movie) > 1) stop("MARGIN.movie must be a scalar.")
RandomFields/R/simu-plots.R:        stop("'MARGIN.slices' must be 'NULL' and 'n.slices' must be 1.")
RandomFields/R/simu-plots.R:  NEWMARGIN <- MARGIN
RandomFields/R/simu-plots.R:      stop("sollte nicht auftauchen: programming error in plotRFspatialGridDataFrame, tsdim wrong ... (AM)")
RandomFields/R/simu-plots.R:      if (!(MARGIN.slices <= tsdim))
RandomFields/R/simu-plots.R:        stop("chosen MARGIN.slices out of bounds")
RandomFields/R/simu-plots.R:      if (MARGIN.slices %in% MARGIN)
RandomFields/R/simu-plots.R:        stop("MARGIN.slices must be different from MARGIN")
RandomFields/R/simu-plots.R:    if (!all(MARGIN %in% 1:(length(dim_data) - 2))) stop("MARGIN out of range.")
RandomFields/R/simu-plots.R:    if (any(MARGIN.slices %in% MARGIN.movie))
RandomFields/R/simu-plots.R:      stop("MARGIN.slices and MARGIN.movie are not disjoint.")
RandomFields/R/simu-plots.R:    if (length(MARGIN.slices) < 1)
RandomFields/R/simu-plots.R:      MARGIN.slices <-
RandomFields/R/simu-plots.R:        (1:(max(MARGIN, MARGIN.movie) + 1))[-c(MARGIN, MARGIN.movie)][1]
RandomFields/R/simu-plots.R:    if (length(MARGIN.movie) < 1)
RandomFields/R/simu-plots.R:      MARGIN.movie <-
RandomFields/R/simu-plots.R:        (1:(max(MARGIN, MARGIN.slices) + 1))[-c(MARGIN, MARGIN.slices)][1]
RandomFields/R/simu-plots.R:    if (!all(c(MARGIN.movie, MARGIN.slices) %in%
RandomFields/R/simu-plots.R:             1:(length(dim_data) - 2))) stop("MARGINs out of range.")
RandomFields/R/simu-plots.R:    xx <- x.grid.vectors[[MARGIN[1]]]
RandomFields/R/simu-plots.R:    xy <- x.grid.vectors[[MARGIN[2]]]
RandomFields/R/simu-plots.R:    ## to the dimensions not covered by MARGIN*
RandomFields/R/simu-plots.R:    mar.vec <- c(MARGIN, MARGIN.slices, MARGIN.movie)
RandomFields/R/simu-plots.R:    ## re-oredered dimensions such that MARGIN and MARGIN.slices
RandomFields/R/simu-plots.R:    ## and MARGIN.movie are the first 4 dimensions
RandomFields/R/simu-plots.R:    NEWMARGIN <- 1:2
RandomFields/R/simu-plots.R:    MARGIN.slices <- 3
RandomFields/R/simu-plots.R:    MARGIN.movie <- 4
RandomFields/R/simu-plots.R:      mar.len <- dim_data[MARGIN.slices]
RandomFields/R/simu-plots.R:      ## the first dimension which is not in MARGIN
RandomFields/R/simu-plots.R:    m.range <- if (do.movie) 1:dim_data[MARGIN.movie] else 1    
RandomFields/R/simu-plots.R:    coords <- x@coords[, MARGIN]
RandomFields/R/simu-plots.R:      stop("'y' and 'MARGIN.slices' may not be given at the same time")
RandomFields/R/simu-plots.R:                               plot.var=plot.variance, MARGIN=NEWMARGIN,
RandomFields/R/simu-plots.R:                   legend=paste(image.par$names.coords[MARGIN.slices], "=",
RandomFields/R/simu-plots.R:                       x.grid.vectors[[MARGIN.slices]][slices.ind[i[2]]]))
RandomFields/R/simu-plots.R:              xy <- trans3d(y.coords[, MARGIN[1]], y.coords[, MARGIN[2]],
RandomFields/R/simu-plots.R:                            list(xy=xy.coords(y.coords[, MARGIN[1]],
RandomFields/R/simu-plots.R:                                     y.coords[, MARGIN[2]]),
RandomFields/R/simu-plots.R:errMsgNoPlotAvailable <- function(x, y)
RandomFields/R/simu-plots.R:setMethod(f="plot", signature(x="RFgridDataFrame", y="missing"),
RandomFields/R/simu-plots.R:setMethod(f="plot", signature(x="RFpointsDataFrame", y="missing"),
RandomFields/R/simu-plots.R:setMethod(f="plot", signature(x="RFspatialGridDataFrame", y="missing"),
RandomFields/R/simu-plots.R:setMethod(f="plot", signature(x="RFspatialPointsDataFrame", y="missing"),
RandomFields/R/simu-plots.R:setMethod(f="plot", signature(x="RFgridDataFrame", y="matrix"),
RandomFields/R/simu-plots.R:setMethod(f="plot", signature(x="RFpointsDataFrame", y="matrix"),
RandomFields/R/simu-plots.R:setMethod(f="plot", signature(x="RFspatialGridDataFrame", y="matrix"),
RandomFields/R/simu-plots.R:setMethod(f="plot", signature(x="RFspatialPointsDataFrame", y="matrix"),
RandomFields/R/simu-plots.R:setMethod(f="plot", signature(x="RFgridDataFrame", y="data.frame"),
RandomFields/R/simu-plots.R:setMethod(f="plot", signature(x="RFpointsDataFrame", y="data.frame"),
RandomFields/R/simu-plots.R:setMethod(f="plot", signature(x="RFspatialGridDataFrame", y="data.frame"),
RandomFields/R/simu-plots.R:setMethod(f="plot", signature(x="RFspatialPointsDataFrame", y="data.frame"),
RandomFields/R/simu-plots.R:setMethod(f="plot", signature(x="RFgridDataFrame", y="RFgridDataFrame"),
RandomFields/R/simu-plots.R:setMethod(f="plot", signature(x="RFgridDataFrame", y="RFpointsDataFrame"),
RandomFields/R/simu-plots.R:setMethod(f="plot", signature(x="RFpointsDataFrame", y="RFgridDataFrame"),
RandomFields/R/simu-plots.R:setMethod(f="plot", signature(x="RFpointsDataFrame", y="RFpointsDataFrame"),
RandomFields/R/simu-plots.R:setMethod(f="plot",
RandomFields/R/simu-plots.R:setMethod(f="plot",
RandomFields/R/simu-plots.R:setMethod(f="plot", signature(x="RFspatialPointsDataFrame",
RandomFields/R/simu-plots.R:            errMsgNoPlotAvailable(x, y)
RandomFields/R/simu-plots.R:setMethod(f="plot",
RandomFields/R/simu-plots.R:setMethod(f="persp",
RandomFields/R/RFempvario.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/R/RFempvario.R:## Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/R/RFempvario.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/R/RFempvario.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/R/RFempvario.R:                        alpha=VARIOGRAM, ...
RandomFields/R/RFempvario.R:#  Print(pseudo, alpha,  PSEUDO, PSEUDOMADOGRAM)
RandomFields/R/RFempvario.R:    if (RFopt$basic$printlevel >= PL_SUBIMPORTANT)
RandomFields/R/RFempvario.R:    alpha %in% c(VARIOGRAM, PSEUDO) && !dist.given
RandomFields/R/RFempvario.R:    ## MARTINS CODE WENN FFT == FALSE
RandomFields/R/RFempvario.R:    ## END OF MARPINS CODE WENN FFT == FALSE
RandomFields/R/RFempvario.R:  if (RFopt$general$spConform) l <- do.call("new", c(list(CLASS_EMPIR), l))
RandomFields/R/RFempvario.R:  else class(l) <- CLASS_EMPIR
RandomFields/R/RFempvario.R:## END OF MAIN FUNCTION 
RandomFields/cleanup:rm -rf config.* src/Makevars
Binary file RandomFields/data/ca20.rda matches
Binary file RandomFields/data/soil.txt.gz matches
Binary file RandomFields/data/weather.rda matches
Binary file RandomFields/src/PoissonPolygon.o matches
Binary file RandomFields/src/init.cov.o matches
Binary file RandomFields/src/Huetchen.o matches
RandomFields/src/avltr_modified.h:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
RandomFields/src/avltr_modified.h:   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
RandomFields/src/avltr_modified.h:   Internet, or as Ben Pfaff, 12167 Airport Rd, DeWitt MI 48820, USA
RandomFields/src/avltr_modified.h:/* Martin Schlather: 21 October, 2011,
RandomFields/src/avltr_modified.h:#ifndef AVL_MAX_HEIGHT
RandomFields/src/avltr_modified.h:#define AVL_MAX_HEIGHT	32
RandomFields/src/avltr_modified.h:/* *** Martin Schlather: uncomment the following lines
RandomFields/src/Makevars.win:PKG_LIBS = $(LAPACK_LIBS) $(BLAS_LIBS) $(SHLIB_OPENMP_CXXFLAGS) $(FLIBS) 
RandomFields/src/Makevars.win:PKG_CXXFLAGS =  $(SHLIB_OPENMP_CXXFLAGS)
RandomFields/src/MachineSchlather.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/MachineSchlather.h: Copyright (C) 2017 -- 2017 Martin Schlather
RandomFields/src/MachineSchlather.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/MachineSchlather.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/MachineSchlather.h:#ifndef RF_MACHINE_SCHLATHERS
RandomFields/src/MachineSchlather.h:#define RF_MACHINE_SCHLATHERS 1
RandomFields/src/MachineSchlather.h:#ifdef SCHLATHERS_MACHINEX // SCHLATHERS_MACHINEX kein Tippfehler mit 
RandomFields/src/MachineSchlather.h:#ifndef RANDOMFIELDS_DEBUGGING
RandomFields/src/MachineSchlather.h:#define LASTSYSTEM(sys) __extension__\
RandomFields/src/MachineSchlather.h:#define CUMXOHNE(sys,s) __extension__\
RandomFields/src/MachineSchlather.h:  ({iCorrect(sys,3,s); (s)<=0 ? 0 : CUMXMITi(sys[(s) - 1]); })
RandomFields/src/MachineSchlather.h:#define CUMXMIT(sys,s) __extension__\
RandomFields/src/MachineSchlather.h:  ({iCorrect(sys,4,s); CUMXMITi(sys[s]); })
RandomFields/src/MachineSchlather.h:#define TOTALXDIM(sys) __extension__({\
RandomFields/src/MachineSchlather.h:      assert_sys(sys,5); assert(CUMXMITi((sys)[LASTSYSTEM(sys)])>0);	\
RandomFields/src/MachineSchlather.h:      CUMXMITi(sys[LASTSYSTEM(sys)]); })
RandomFields/src/MachineSchlather.h:#define XDIM(sys,s) __extension__({assert_sys(sys,5a);			\
RandomFields/src/MachineSchlather.h:      assert((s)>=0 && (s) <= LASTSYSTEM(sys)); XDIMi((sys)[s]); })  // OK
RandomFields/src/MachineSchlather.h:#define LOGDIM(sys,s) __extension__\
RandomFields/src/MachineSchlather.h:  ({iCorrect(sys,6,s); LOGDIMi((sys)[s]); })
RandomFields/src/MachineSchlather.h:#define MAXDIM(sys,s) __extension__\
RandomFields/src/MachineSchlather.h:  ({iCorrect(sys,7,s); assert(MAXDIMi((sys)[s]) != 0); MAXDIMi((sys)[s]); })
RandomFields/src/MachineSchlather.h:#define DOM(sys,s) __extension__\
RandomFields/src/MachineSchlather.h:  ({iCorrect(sys,9,s); DOMi((sys)[s]); })
RandomFields/src/MachineSchlather.h:#define ANYDIMOF(cov) __extension__({ \
RandomFields/src/MachineSchlather.h:       assert(OWNTOTALXDIM == PREVTOTALXDIM &&\
RandomFields/src/MachineSchlather.h:	     OWNTOTALXDIM == total_logicaldim(SYSOF(cov)) &&\
RandomFields/src/MachineSchlather.h:	     PREVLASTSYSTEM  == OWNLASTSYSTEM && \
RandomFields/src/MachineSchlather.h:	     Loctsdim(cov) == OWNTOTALXDIM); \
RandomFields/src/MachineSchlather.h:      OWNTOTALXDIM;})
RandomFields/src/MachineSchlather.h://#define ANYDIMOF(cov)  __extension__({assert_cov(cov); assert(false); OWNTOTALXDIM; })
RandomFields/src/MachineSchlather.h:#define ANYOWNDIM __extension__\
RandomFields/src/MachineSchlather.h:  ({assert(OWNTOTALXDIM == OWNLOGDIM(OWNLASTSYSTEM)); OWNTOTALXDIM;})
RandomFields/src/MachineSchlather.h:#define SYSMODEL(sys) __extension__				\
RandomFields/src/MachineSchlather.h:  ({assert_sys(to,to3); assert_sys(from,from3); MEMCOPY(to, from, sizeof(system_type));})
RandomFields/src/MachineSchlather.h:#define  COPYALLSYSTEMS(to, from, keepnr) __extension__({		\
RandomFields/src/MachineSchlather.h:  int nr_ = keepnr ? SYSMODEL(to) : MISMATCH;				\
RandomFields/src/MachineSchlather.h:  MEMCOPY(to, from, sizeof(Systems_type));				\
RandomFields/src/MachineSchlather.h:#define COPYALLSYSTEMS_COND(to, from, keepnr) __extension__({		\
RandomFields/src/MachineSchlather.h:    int nr_ = MISMATCH; if (gatter_set_ && keepnr) nr_= SYSMODEL(to);	\
RandomFields/src/MachineSchlather.h:    MEMCOPY(to, from__, sizeof(Systems_type));				\
RandomFields/src/MachineSchlather.h:#define STRUCT(Cov, NM)  __extension__\
RandomFields/src/MachineSchlather.h:  ({ASSERT_GATTER(Cov); DefList[FIRSTGATTER].Struct(Cov, NM);})
RandomFields/src/MachineSchlather.h:#define PARAM(Cov, IDX) __extension__\
RandomFields/src/MachineSchlather.h:  ({assert(DefList[MODELNR(Cov)].kappatype[IDX] == REALSXP);  (Cov)->px[IDX];})
RandomFields/src/MachineSchlather.h:#define PARAMINT(Cov, IDX) __extension__({\
RandomFields/src/MachineSchlather.h:      assert(DefList[MODELNR(Cov)].kappatype[IDX] == INTSXP);\
RandomFields/src/MachineSchlather.h:#define PARAMCHAR(Cov, IDX) __extension__({\
RandomFields/src/MachineSchlather.h:      assert(DefList[MODELNR(Cov)].kappatype[IDX] == STRSXP);	\
RandomFields/src/MachineSchlather.h://#define PARAMVEC(Cov, IDX) __extension__({assert(DefList[MODELNR(Cov)].kappatype[IDX] == VECSXP);  ((SEXP) (Cov)->px[IDX]);})
RandomFields/src/MachineSchlather.h:#define PARAMVEC(Cov, IDX) __extension__({\
RandomFields/src/MachineSchlather.h:      assert(DefList[MODELNR(Cov)].kappatype[IDX] == VECSXP);  \
RandomFields/src/MachineSchlather.h:#define PARAMENV(Cov, IDX) __extension__({\
RandomFields/src/MachineSchlather.h:      assert(DefList[MODELNR(Cov)].kappatype[IDX] == ENVSXP);\
RandomFields/src/MachineSchlather.h:#define PARAMLANG(Cov, IDX) __extension__({\
RandomFields/src/MachineSchlather.h:      assert(DefList[MODELNR(Cov)].kappatype[IDX] == LANGSXP);\
RandomFields/src/MachineSchlather.h:#define PARAMLIST(Cov, IDX) __extension__({\
RandomFields/src/MachineSchlather.h:      assert(DefList[MODELNR(Cov)].kappatype[IDX] >= LISTOF);  \
RandomFields/src/MachineSchlather.h:#define LPARAM(Cov, IDX) __extension__({\
RandomFields/src/MachineSchlather.h:      assert(DefList[MODELNR(Cov)].kappatype[IDX] == LISTOF + REALSXP); \
RandomFields/src/MachineSchlather.h:      assert(PARAMLIST(Cov, IDX) != NULL); \
RandomFields/src/MachineSchlather.h:      ((double *) (PARAMLIST(Cov, IDX)->lpx[SET_IDX(Cov, IDX)]));})
RandomFields/src/MachineSchlather.h:#define LPARAMINT(Cov, IDX) __extension__({\
RandomFields/src/MachineSchlather.h:      assert(DefList[MODELNR(Cov)].kappatype[IDX] == LISTOF + INTSXP); \
RandomFields/src/MachineSchlather.h:      assert(PARAMLIST(Cov, IDX) != NULL); \
RandomFields/src/MachineSchlather.h:      ((int *) (PARAMKLIST(Cov, IDX)->lpx[SET_IDX(Cov, IDX)]));})
RandomFields/src/MachineSchlather.h:#define PARAM0(Cov, IDX) __extension__\
RandomFields/src/MachineSchlather.h:  ({assert(PARAM(Cov, IDX) != NULL); PARAM(Cov, IDX)[0];})
RandomFields/src/MachineSchlather.h:#define PARAM0INT(Cov, IDX)  __extension__\
RandomFields/src/MachineSchlather.h:  ({assert(PARAMINT(Cov, IDX) != NULL); PARAMINT(Cov, IDX)[0];})
RandomFields/src/MachineSchlather.h:#define PARAM0CHAR(Cov, IDX)  __extension__\
RandomFields/src/MachineSchlather.h:  ({assert(PARAMCHAR(Cov, IDX) != NULL); PARAMCHAR(Cov, IDX)[0];})
RandomFields/src/MachineSchlather.h:#define LPARAM0(Cov, IDX) __extension__({\
RandomFields/src/MachineSchlather.h:      assert(LPARAM(Cov, IDX) != NULL); LPARAM(Cov, IDX)[0];})
RandomFields/src/MachineSchlather.h:#define LPARAM0INT(Cov, IDX)  __extension__({\
RandomFields/src/MachineSchlather.h:      assert(LPARAMINT(Cov, IDX) != NULL); LPARAMINT(Cov, IDX)[0];})
RandomFields/src/MachineSchlather.h:#define PCOPY(TO, FROM, IDX) 					\
RandomFields/src/MachineSchlather.h:  {if (!((TO) != NULL && (FROM) != NULL &&			\
RandomFields/src/MachineSchlather.h:	 (TO)->px[IDX] != NULL && (FROM)->px[IDX] &&IDX > 0 &&	\
RandomFields/src/MachineSchlather.h:	 (FROM)->ncol[IDX] == (TO)->ncol[IDX] &&		\
RandomFields/src/MachineSchlather.h:	 (FROM)->nrow[IDX] == (TO)->nrow[IDX] &&			\
RandomFields/src/MachineSchlather.h:	 (DefList[MODELNR(FROM)].kappatype[IDX] ==			\
RandomFields/src/MachineSchlather.h:	  DefList[MODELNR(TO)].kappatype[IDX]) &&			\
RandomFields/src/MachineSchlather.h:	 (DefList[MODELNR(FROM)].kappatype[IDX]==REALSXP ||		\
RandomFields/src/MachineSchlather.h:	  DefList[MODELNR(FROM)].kappatype[IDX]==INTSXP)  )) BUG;	\
RandomFields/src/MachineSchlather.h:    MEMCOPY((TO)->px[IDX], (FROM)->px[IDX],				\
RandomFields/src/MachineSchlather.h:	    ((FROM)->nrow[IDX]) * ((FROM)->ncol[IDX]) *			\
RandomFields/src/MachineSchlather.h:	    (DefList[MODELNR(FROM)].kappatype[IDX]==REALSXP ? sizeof(double) : \
RandomFields/src/MachineSchlather.h:	     DefList[MODELNR(FROM)].kappatype[IDX]==INTSXP ? sizeof(int) : \
RandomFields/src/def.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/def.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/src/def.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/def.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/def.h:#ifdef _OPENMP
RandomFields/src/def.h:#define LOCAL_ERRLOC_MSG char ERRMSG[LENERRMSG];
RandomFields/src/nugget.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/nugget.cc: Copyright (C) 2001 -- 2017 Martin Schlather, 
RandomFields/src/nugget.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/nugget.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/nugget.cc:  if (MODELNR(cov) == GAUSSPROC) cov = cov->calling;
RandomFields/src/nugget.cc:      if (PisNULL(DPROJ)) ans = Nproj != PREVXDIM(0);
RandomFields/src/nugget.cc:	  getMinimalAbsEigenValue(P(DANISO), cov->nrow[DANISO]) < 1e-13;
RandomFields/src/nugget.cc:	  getMinimalAbsEigenValue(P(DAUSER), cov->nrow[DAUSER]) < 1e-13;
RandomFields/src/nugget.cc:    vdim   = VDIM0,
RandomFields/src/nugget.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/nugget.cc:  //if (!cov->Snugget->simuspatialnugget) PMI0(cov);
RandomFields/src/nugget.cc:    dim = OWNXDIM(0),
RandomFields/src/nugget.cc:    vdim   = VDIM0,
RandomFields/src/nugget.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/nugget.cc:  int vdim   = VDIM0;
RandomFields/src/nugget.cc:  int dim = PREVTOTALXDIM;
RandomFields/src/nugget.cc:  //PMI0(cov);
RandomFields/src/nugget.cc:  int  err ; // taken[MAX DIM],
RandomFields/src/nugget.cc:  if (!hasAnyEvaluationFrame(cov) && !hasAnyProcessFrame(cov)) ILLEGAL_FRAME;
RandomFields/src/nugget.cc:  if (PisNULL(NUGGET_VDIM)) {
RandomFields/src/nugget.cc:    if (VDIM0 <= 0) VDIM0 = VDIM1 = 1;
RandomFields/src/nugget.cc:    kdefault(cov, NUGGET_VDIM, VDIM0);
RandomFields/src/nugget.cc:    VDIM0 = VDIM1 = P0INT(NUGGET_VDIM);
RandomFields/src/nugget.cc:    NEWSTOMODEL;
RandomFields/src/nugget.cc:  range->min[NUGGET_VDIM]  = 1.0;
RandomFields/src/nugget.cc:  range->max[NUGGET_VDIM]  = MAXINT;
RandomFields/src/nugget.cc:  range->pmin[NUGGET_VDIM] = 1.0;
RandomFields/src/nugget.cc:  range->pmax[NUGGET_VDIM] = 10.0;
RandomFields/src/nugget.cc:  range->openmin[NUGGET_VDIM] = false;
RandomFields/src/nugget.cc:  range->openmax[NUGGET_VDIM] = true;
RandomFields/src/nugget.cc:    NEWSTOMODEL;
RandomFields/src/nugget.cc:      ( (PisNULL(NUGGET_VDIM) || P0INT(NUGGET_VDIM) == 1) &&
RandomFields/src/nugget.cc:     NEWSTOMODEL;
RandomFields/src/nugget.cc:    if (PisNULL(NUGGET_VDIM) || P0INT(NUGGET_VDIM) == 1)
RandomFields/src/nugget.cc:    NEWSTOMODEL;
RandomFields/src/nugget.cc:  for (int i=FIRST_DOMAIN; i<LAST_DOMAINUSER; D[i++]=false);
RandomFields/src/nugget.cc:     NEWSTOMODEL;
RandomFields/src/nugget.cc:     if (PisNULL(NUGGET_VDIM) ||  P0INT(NUGGET_VDIM) == 1)
RandomFields/src/nugget.cc:      I[SYMMETRIC] = I[EARTH_SYMMETRIC] = I[SPHERICAL_SYMMETRIC] = true;
RandomFields/src/nugget.cc:    NEWSTOMODEL;
RandomFields/src/nugget.cc:    if (!equalsNugget(MODELNR(intern))) {
RandomFields/src/nugget.cc:    if (!PisNULL(NUGGET_PROC_VDIM)) 
RandomFields/src/nugget.cc:      kdefault(intern, NUGGET_VDIM, P0INT(NUGGET_PROC_VDIM));
RandomFields/src/nugget.cc:				SUBMODEL_DEP, EvaluationType))
RandomFields/src/nugget.cc:   if (!PARAMisNULL(intern, NUGGET_TOL))
RandomFields/src/nugget.cc:      kdefault(cov, NUGGET_PROC_TOL, PARAM0(intern, NUGGET_TOL));  
RandomFields/src/nugget.cc:    if (!PARAMisNULL(intern,NUGGET_VDIM))
RandomFields/src/nugget.cc:      kdefault(cov, NUGGET_PROC_VDIM, PARAM0INT(intern, NUGGET_VDIM));
RandomFields/src/nugget.cc:    if (intern == NULL || MODELNR(intern) != NUGGET_INTERN) {
RandomFields/src/nugget.cc:    if (!PisNULL(NUGGET_PROC_VDIM)) 
RandomFields/src/nugget.cc:      kdefault(intern, NUGGET_PROC_VDIM, P0INT(NUGGET_PROC_VDIM));
RandomFields/src/nugget.cc:    if ((err = CHECK(key, OWNLOGDIM(0), PREVXDIM(0),
RandomFields/src/nugget.cc:		     SUBMODEL_DEP, GaussMethodType)) != NOERROR) {
RandomFields/src/nugget.cc:  VDIM0 = next->vdim[0];  
RandomFields/src/nugget.cc:  VDIM1 = next->vdim[1];  
RandomFields/src/nugget.cc:  cov->frame = GaussMethodType;
RandomFields/src/nugget.cc:  case NUGGET_PROC_VDIM :
RandomFields/src/nugget.cc:// uses global RANDOM !!!
RandomFields/src/nugget.cc:  int dim = OWNXDIM(0);
RandomFields/src/nugget.cc:    vdim = VDIM0;
RandomFields/src/nugget.cc:  //  matrix_type anisotype = TypeMdiag
RandomFields/src/nugget.cc:  if ((s->datapos = (int*) MALLOC(loc->totalpoints * sizeof(int))) ==NULL) {
RandomFields/src/nugget.cc:    err=ERRORMEMORYALLOCATION; goto ErrorHandling;
RandomFields/src/nugget.cc:    if (tol==0.0 && PL>=PL_IMPORTANT) {
RandomFields/src/nugget.cc:    if ( (s->simugrid = loc->grid && isMdiag(anisotype))) { // =  not ==
RandomFields/src/nugget.cc:      assert(dim == OWNLOGDIM(0));
RandomFields/src/nugget.cc:	  warning("'%.50s' is larger than the grid step, but smaller than the whole grid in direction %d. This looks odd.", KNAME(NUGGET_PROC_TOL), d);	
RandomFields/src/nugget.cc:	if ((s->red_field=(double *) MALLOC(sizeof(double) * vdim *
RandomFields/src/nugget.cc:	    (s->index = (int*) MALLOC(dim * sizeof(int))) == NULL
RandomFields/src/nugget.cc:	    ){ err=ERRORMEMORYALLOCATION; goto ErrorHandling; }	
RandomFields/src/nugget.cc:	   (int*) MALLOC(sizeof(int) * tot)) == NULL ||
RandomFields/src/nugget.cc:	  (s->index = (int*) MALLOC(sizeof(int) * tot)) == NULL ||
RandomFields/src/nugget.cc:	  (refpos = (int*) MALLOC(sizeof(int) * tot)) == NULL
RandomFields/src/nugget.cc:	err=ERRORMEMORYALLOCATION; goto ErrorHandling;
RandomFields/src/nugget.cc:      if ((s->red_field=(double *) MALLOC(sizeof(double) * vdim *
RandomFields/src/nugget.cc:	err=ERRORMEMORYALLOCATION; goto ErrorHandling; 
RandomFields/src/nugget.cc:  //  PMI0(cov);
RandomFields/src/nugget.cc:  //  PMI0(cov);
RandomFields/src/nugget.cc:    vdim = VDIM0;
RandomFields/src/nugget.cc:      res[nx] = (double) GAUSS_RANDOM(1.0);
RandomFields/src/nugget.cc:      int d, dim, dimM1, *red_dim, *prod_dim;
RandomFields/src/nugget.cc:      dim = OWNTOTALXDIM;
RandomFields/src/nugget.cc:      dimM1 = dim - 1;
RandomFields/src/nugget.cc:	field[i] = (double) GAUSS_RANDOM(1.0);
RandomFields/src/nugget.cc:	while (d < dimM1 && s->index[d] >= loc->xgr[d][XLENGTH]) { 
RandomFields/src/nugget.cc:      for (int i=0; i<vdimtotal; field[i++] = GAUSS_RANDOM(1.0));
RandomFields/src/nugget.cc:  if (!hasGaussMethodFrame(cov)) {
RandomFields/src/families.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/families.cc: Copyright (C) 2013 -- 2017 Martin Schlather
RandomFields/src/families.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/families.cc:Foundation, Inc., 59 Temple Place - Suix2te 330, Boston, MA  02111-1307, USA.  
RandomFields/src/families.cc:  mehr in der Mitte aufgeschnitten, sondern wo linke und rechte
RandomFields/src/families.cc: else *v = 1.0 / (M_PI * scale * y * SQRT(y / PIHALF - 1.0)); 
RandomFields/src/families.cc:       u = UNIFORM_RANDOM;
RandomFields/src/families.cc:    cov->mpp.mM[0] = cov->mpp.mMplus[0] = 1.0; 
RandomFields/src/families.cc:  else PROTECT(Y = allocMatrix(REALSXP, nrow, ncol));
RandomFields/src/families.cc:  MEMCOPY(REAL(Y), z, sizeof(double) * size);
RandomFields/src/families.cc:  else PROTECT(Y = allocMatrix(INTSXP, nrow, ncol));
RandomFields/src/families.cc:  MEMCOPY(INTEGER(Y), z, sizeof(int) * size);
RandomFields/src/families.cc:  // PMI(cov);
RandomFields/src/families.cc:  //  PMI(cov);
RandomFields/src/families.cc:  assert(OWNXDIM(0) == size);
RandomFields/src/families.cc:  if (ANYOWNDIM == 1) {
RandomFields/src/families.cc:      // Siebformel !! ueber 2^size Moeglichkeiten
RandomFields/src/families.cc:  *nc = *nr = i < DefList[COVNR].kappas ? SIZE_NOT_DETERMINED : -1;
RandomFields/src/families.cc:  ASSERT_ONESYSTEM;
RandomFields/src/families.cc:  VDIM0 = P0INT(DISTR_NROW);
RandomFields/src/families.cc:  VDIM1 = P0INT(DISTR_NCOL);
RandomFields/src/families.cc:  cov->mpp.mM[0] = cov->mpp.mMplus[0] = 1.0;
RandomFields/src/families.cc:#define GAUSS_PARAMETER_BASICS					\
RandomFields/src/families.cc:  double *m = P(GAUSS_DISTR_MEAN),		\
RandomFields/src/families.cc:#define GAUSS_PARAMETERS						\
RandomFields/src/families.cc:  GAUSS_PARAMETER_BASICS;						\
RandomFields/src/families.cc:     len_mean = cov->nrow[GAUSS_DISTR_MEAN],	\
RandomFields/src/families.cc:    dim = OWNXDIM(0)	
RandomFields/src/families.cc:  GAUSS_PARAMETERS;
RandomFields/src/families.cc:  GAUSS_PARAMETERS;
RandomFields/src/families.cc:  GAUSS_PARAMETERS;
RandomFields/src/families.cc:  GAUSS_PARAMETERS; 
RandomFields/src/families.cc:  GAUSS_PARAMETERS; 
RandomFields/src/families.cc:  GAUSS_PARAMETER_BASICS; 
RandomFields/src/families.cc:  GAUSS_PARAMETERS; 
RandomFields/src/families.cc:  GAUSS_PARAMETERS; 
RandomFields/src/families.cc:  if (i == GAUSS_DISTR_SD || i== GAUSS_DISTR_MEAN) {
RandomFields/src/families.cc:    *nr = SIZE_NOT_DETERMINED;
RandomFields/src/families.cc:  GAUSS_PARAMETER_BASICS;						
RandomFields/src/families.cc:  if (m == NULL) kdefault(cov, GAUSS_DISTR_MEAN, 0.0);
RandomFields/src/families.cc:   VDIM0 = PREVXDIM(0);
RandomFields/src/families.cc:  VDIM1 = 1;
RandomFields/src/families.cc:  GAUSS_PARAMETERS; 
RandomFields/src/families.cc:    cov->mpp.mM[0] = cov->mpp.mMplus[0] = 1.0; 
RandomFields/src/families.cc:      cov->mpp.mM[1] = cov->mpp.mMplus[1] = m[0];
RandomFields/src/families.cc:	cov->mpp.mM[2] = cov->mpp.mMplus[2] = SD * SD + m[0] * m[0] ;
RandomFields/src/families.cc:  cov->mpp.mM[0] = cov->mpp.mMplus[0] = 1.0;
RandomFields/src/families.cc:    len_mean = cov->nrow[GAUSS_DISTR_MEAN],	
RandomFields/src/families.cc:    dim = ANYOWNDIM;		
RandomFields/src/families.cc:  range->min[GAUSS_DISTR_MEAN] = RF_NEGINF;
RandomFields/src/families.cc:  range->max[GAUSS_DISTR_MEAN] = RF_INF;
RandomFields/src/families.cc:  range->pmin[GAUSS_DISTR_MEAN] = - 1e8;
RandomFields/src/families.cc:  range->pmax[GAUSS_DISTR_MEAN] = 1e8;
RandomFields/src/families.cc:  range->openmin[GAUSS_DISTR_MEAN] = true;
RandomFields/src/families.cc:  range->openmax[GAUSS_DISTR_MEAN] = true;
RandomFields/src/families.cc:#define SPHERIC_SPACEDIM 0
RandomFields/src/families.cc:#define SPHERIC_BALLDIM 1
RandomFields/src/families.cc:      double dummy = UNIFORM_RANDOM;
RandomFields/src/families.cc:    dim = P0INT(SPHERIC_SPACEDIM),
RandomFields/src/families.cc:    balldim = P0INT(SPHERIC_BALLDIM);  
RandomFields/src/families.cc:  kdefault(cov, SPHERIC_SPACEDIM, 1);
RandomFields/src/families.cc:  kdefault(cov, SPHERIC_BALLDIM, P0INT(SPHERIC_SPACEDIM));
RandomFields/src/families.cc:  if (OWNLOGDIM(0) != 1) SERR("only dimension 1 allowed");
RandomFields/src/families.cc:  VDIM0 = PREVXDIM(0);
RandomFields/src/families.cc:  VDIM1 = 1;
RandomFields/src/families.cc:  range->min[SPHERIC_SPACEDIM] = 1; 
RandomFields/src/families.cc:  range->max[SPHERIC_SPACEDIM] = RF_INF;
RandomFields/src/families.cc:  range->pmin[SPHERIC_SPACEDIM] = 0;
RandomFields/src/families.cc:  range->pmax[SPHERIC_SPACEDIM] = 10;
RandomFields/src/families.cc:  range->openmin[SPHERIC_SPACEDIM] = false;
RandomFields/src/families.cc:  range->openmax[SPHERIC_SPACEDIM] = true;
RandomFields/src/families.cc:  range->min[SPHERIC_BALLDIM] = 1; 
RandomFields/src/families.cc:  range->max[SPHERIC_BALLDIM] = RF_INF;
RandomFields/src/families.cc:  range->pmin[SPHERIC_BALLDIM] = 0;
RandomFields/src/families.cc:  range->pmax[SPHERIC_BALLDIM] = 10;
RandomFields/src/families.cc:  range->openmin[SPHERIC_BALLDIM] = false;
RandomFields/src/families.cc:  range->openmax[SPHERIC_BALLDIM] = true;
RandomFields/src/families.cc:    dim = P0INT(SPHERIC_SPACEDIM),
RandomFields/src/families.cc:    balldim = P0INT(SPHERIC_BALLDIM),
RandomFields/src/families.cc:    *M = cov->mpp.mM,  
RandomFields/src/families.cc:    *Mplus = cov->mpp.mMplus;
RandomFields/src/families.cc:  // printf("ball mppM2 %10g\n", cov->mpp.mM2);
RandomFields/src/families.cc://   //	 P0INT(SPHERIC_BALLDIM));// assert(false);
RandomFields/src/families.cc:  for (M[0] = 1.0, m=1; m < nmvdim; M[m++] = 0.0);
RandomFields/src/families.cc:      M[m] += dummy;
RandomFields/src/families.cc:    M[m] = dummy * (double) testn;
RandomFields/src/families.cc:    Mplus[m] = M[m];
RandomFields/src/families.cc:    //printf("M: %d %10g\n", d, M[d]);
RandomFields/src/families.cc:    dummy = 0.5 * OWNLOGDIM(0) + 1.0;
RandomFields/src/families.cc:    PRINTF("init_spheric %10g %10g %10g\n", M[nm], 
RandomFields/src/families.cc:	   EXP( (balldim - dim) * M_LN_SQRT_PI // LOG(SQRT(pi)) 
RandomFields/src/families.cc:	   EXP( - dim * M_LN_SQRT_PI // LOG(SQRT(pi)) 
RandomFields/src/families.cc:  cov->mpp.mM[0] = cov->mpp.mMplus[0] = 1.0;
RandomFields/src/families.cc:#define DETERM_MEAN 0
RandomFields/src/families.cc:#define DETERM_PARAMETERS						\
RandomFields/src/families.cc:  double *mean = P(DETERM_MEAN);					\
RandomFields/src/families.cc:     dim = OWNTOTALXDIM,				\
RandomFields/src/families.cc:    len_mean = cov->nrow[DETERM_MEAN]
RandomFields/src/families.cc:#define DETERMFOR for(mi=i=0; i<dim; i++, mi=(mi + 1) % len_mean)
RandomFields/src/families.cc:  DETERM_PARAMETERS;
RandomFields/src/families.cc:  DETERMFOR if (x[i] != mean[mi]) {
RandomFields/src/families.cc:  DETERM_PARAMETERS;
RandomFields/src/families.cc:  DETERMFOR left[i] = right[i] = mean[mi];
RandomFields/src/families.cc:  DETERM_PARAMETERS;
RandomFields/src/families.cc:  DETERMFOR {
RandomFields/src/families.cc:  DETERM_PARAMETERS;
RandomFields/src/families.cc:    DETERMFOR {
RandomFields/src/families.cc:    DETERMFOR {
RandomFields/src/families.cc:  v[0] = P0(DETERM_MEAN);
RandomFields/src/families.cc:  DETERM_PARAMETERS;
RandomFields/src/families.cc:  if (x==NULL) DETERMFOR v[i] = mean[i]; 
RandomFields/src/families.cc:    DETERMFOR v[i] = !R_FINITE(x[i]) || x[i] == mean[mi] ? mean[mi] : RF_NA;
RandomFields/src/families.cc:  *nr = i == 0 ? OWNTOTALXDIM  : i == 1 ? 1 : -1;
RandomFields/src/families.cc:  DETERM_PARAMETERS;
RandomFields/src/families.cc:    DETERMFOR v[i] = FABS(y[i]) > mean[mi] ? mean[mi] : RF_NA;    
RandomFields/src/families.cc:    DETERMFOR v[i] = x[i] < mean[mi] && y[i] > mean[mi] ? mean[mi] : RF_NA;
RandomFields/src/families.cc:    dim = OWNTOTALXDIM;  
RandomFields/src/families.cc:  if (PisNULL(DETERM_MEAN)) kdefault(cov, DETERM_MEAN, 0.0);
RandomFields/src/families.cc:  VDIM0 = dim;
RandomFields/src/families.cc:  VDIM1 = 1;
RandomFields/src/families.cc:  range->min[DETERM_MEAN] = RF_NEGINF;
RandomFields/src/families.cc:  range->max[DETERM_MEAN] = RF_INF;
RandomFields/src/families.cc:  range->pmin[DETERM_MEAN] = - 1e10;
RandomFields/src/families.cc:  range->pmax[DETERM_MEAN] = 1e10;
RandomFields/src/families.cc:  range->openmin[DETERM_MEAN] = true;
RandomFields/src/families.cc:  range->openmax[DETERM_MEAN] = true;
RandomFields/src/families.cc:  cov->mpp.mM[0] = cov->mpp.mMplus[0] = 1.0;
RandomFields/src/families.cc:  VTLG_D(x, info, cov->sub[SETPARAM_LOCAL], v);
RandomFields/src/families.cc:  VTLG_DLOG(x, info, cov->sub[SETPARAM_LOCAL], v);
RandomFields/src/families.cc:  INVERSENONSTAT_D(v, cov->sub[SETPARAM_LOCAL], left, right);
RandomFields/src/families.cc:  VTLG_P(x, info, cov->sub[SETPARAM_LOCAL], v);
RandomFields/src/families.cc:  VTLG_P2SIDED(x, y, info, cov->sub[SETPARAM_LOCAL], v);
RandomFields/src/families.cc:  VTLG_Q(x, cov->sub[SETPARAM_LOCAL], v);
RandomFields/src/families.cc:  VTLG_R(x, info, cov->sub[SETPARAM_LOCAL], v);
RandomFields/src/families.cc:  VTLG_R2SIDED(x, y, info, cov->sub[SETPARAM_LOCAL], v);
RandomFields/src/families.cc:  model *next= cov->sub[SETPARAM_LOCAL];
RandomFields/src/families.cc:    dim = OWNTOTALXDIM;
RandomFields/src/families.cc:  kdefault(cov, SET_PERFORMDO, true);
RandomFields/src/families.cc:  VDIM0 = next->vdim[0];
RandomFields/src/families.cc:  VDIM1 = next->vdim[1];
RandomFields/src/families.cc:    cov->mpp.mM[0] = cov->mpp.mMplus[0];     
RandomFields/src/families.cc:    cov->mpp.mMplus[0] = next->mpp.mMplus[0];
RandomFields/src/families.cc:  model *next= cov->sub[SETPARAM_LOCAL];
RandomFields/src/families.cc:  GETSTOMODEL ;
RandomFields/src/families.cc:  if (STOMODEL->remote != NULL) {
RandomFields/src/families.cc:    X->set(cov->sub[0], STOMODEL->remote, X->variant);
RandomFields/src/families.cc:    cov->mpp.mM[0] = next->mpp.mM[0];   
RandomFields/src/families.cc:    cov->mpp.mMplus[0] = next->mpp.mMplus[0];
RandomFields/src/families.cc:  model *next = cov->sub[SETPARAM_LOCAL];
RandomFields/src/families.cc:  bool performDo = P0INT(SET_PERFORMDO);
RandomFields/src/families.cc:  if (performDo) { DORANDOM(next, v); } 
RandomFields/src/families.cc:    range->min[SETPARAM_VARIANT] = 0;
RandomFields/src/families.cc:    range->max[SETPARAM_VARIANT] = 0;
RandomFields/src/families.cc:    range->pmin[SETPARAM_VARIANT] = 0;
RandomFields/src/families.cc:    range->pmax[SETPARAM_VARIANT] = 0;
RandomFields/src/families.cc:    range->openmin[SETPARAM_VARIANT] = false;
RandomFields/src/families.cc:    range->openmax[SETPARAM_VARIANT] = false;
RandomFields/src/families.cc:#define LOC_PARAMETER_BASICS			\
RandomFields/src/families.cc:  int dim=OWNTOTALXDIM;		\
RandomFields/src/families.cc:#define LOC_PARAMETERS				\
RandomFields/src/families.cc:  LOC_PARAMETER_BASICS;				\
RandomFields/src/families.cc:  assert(OWNTOTALXDIM == OWNLOGDIM(0))
RandomFields/src/families.cc:  LOC_PARAMETERS;
RandomFields/src/families.cc:  LOC_PARAMETERS;
RandomFields/src/families.cc:  LOC_PARAMETERS;
RandomFields/src/families.cc:  LOC_PARAMETERS;
RandomFields/src/families.cc:  LOC_PARAMETER_BASICS;  
RandomFields/src/families.cc:  LOC_PARAMETERS;
RandomFields/src/families.cc:  LOC_PARAMETERS;  
RandomFields/src/families.cc:    *nr = SIZE_NOT_DETERMINED;
RandomFields/src/families.cc:    dim = OWNTOTALXDIM;
RandomFields/src/families.cc:  //PMI(cov);
RandomFields/src/families.cc:  VDIM0 = next->vdim[0];
RandomFields/src/families.cc:  VDIM1 = next->vdim[1];
RandomFields/src/families.cc:  LOC_PARAMETERS;
RandomFields/src/families.cc:    cov->mpp.mM[0] = cov->mpp.mMplus[0] = 1.0; 
RandomFields/src/families.cc:      cov->mpp.mM[1] = cov->mpp.mM[1] * scale[0] + location[0];
RandomFields/src/families.cc:      cov->mpp.mMplus[1] = location[0] == 0.0
RandomFields/src/families.cc:	? cov->mpp.mMplus[1] * scale[0] : RF_NA;
RandomFields/src/families.cc:	cov->mpp.mM[2] = cov->mpp.mM[2] * ssq +
RandomFields/src/families.cc:	  location[0] * (2.0 * cov->mpp.mM[1] - location[0]);
RandomFields/src/families.cc:	cov->mpp.mMplus[1] =
RandomFields/src/families.cc:	  location[0] == 0.0 ? cov->mpp.mMplus[1] * ssq : RF_NA;
RandomFields/src/families.cc:  cov->mpp.mM[0] = next->mpp.mM[0];
RandomFields/src/families.cc:  cov->mpp.mMplus[0] = next->mpp.mMplus[0];
RandomFields/src/families.cc:  DORANDOM(cov->sub[0], v);
RandomFields/src/families.cc:  range->pmin[LOC_POWER] = -OWNTOTALXDIM;
RandomFields/src/families.cc:  range->pmax[LOC_POWER] = +OWNTOTALXDIM;
RandomFields/src/families.cc:#define UNIF_PARAMETER_BASICS				\
RandomFields/src/families.cc:   *min = (double*) P(UNIF_MIN),	\
RandomFields/src/families.cc:     *max= (double*) P(UNIF_MAX)		
RandomFields/src/families.cc:#define UNIF_PARAMETERS							\
RandomFields/src/families.cc:  UNIF_PARAMETER_BASICS;						\
RandomFields/src/families.cc:     len_min = cov->nrow[UNIF_MIN],			\
RandomFields/src/families.cc:     len_max = cov->nrow[UNIF_MAX],		\
RandomFields/src/families.cc:    dim = ANYOWNDIM
RandomFields/src/families.cc:  UNIF_PARAMETERS;
RandomFields/src/families.cc:  bool normed = P0INT(UNIF_NORMED);
RandomFields/src/families.cc:  UNIF_PARAMETERS;
RandomFields/src/families.cc:   if (P0INT(UNIF_NORMED)) UNIFOR area *= max[maxi] - min[mini];  
RandomFields/src/families.cc:  UNIF_PARAMETERS;
RandomFields/src/families.cc:  bool normed = P0INT(UNIF_NORMED);
RandomFields/src/families.cc:  UNIF_PARAMETERS;
RandomFields/src/families.cc:  bool normed = P0INT(UNIF_NORMED);
RandomFields/src/families.cc:  UNIF_PARAMETER_BASICS;
RandomFields/src/families.cc:  if (P0INT(UNIF_NORMED)) {
RandomFields/src/families.cc:  UNIF_PARAMETERS;
RandomFields/src/families.cc:      v[i] = min[mini] + UNIFORM_RANDOM * (max[maxi] - min[mini]);
RandomFields/src/families.cc:	v[i] = min[mini] + UNIFORM_RANDOM * (max[maxi] - min[mini]);
RandomFields/src/families.cc:  UNIF_PARAMETERS;
RandomFields/src/families.cc:    v[i] = a + UNIFORM_RANDOM * (b-a);
RandomFields/src/families.cc:  if (i == UNIF_MIN || i == UNIF_MAX) {
RandomFields/src/families.cc:    *nr = SIZE_NOT_DETERMINED;
RandomFields/src/families.cc:  } else if (i == UNIF_NORMED) {
RandomFields/src/families.cc:  if (PisNULL(UNIF_MIN)) kdefault(cov, UNIF_MIN, 0.0);
RandomFields/src/families.cc:  if (PisNULL(UNIF_MAX)) kdefault(cov, UNIF_MAX, 1.0);
RandomFields/src/families.cc:  kdefault(cov, UNIF_NORMED, true); // see call of unif by special
RandomFields/src/families.cc:  VDIM0 = OWNLOGDIM(0);
RandomFields/src/families.cc:  VDIM1 = 1;
RandomFields/src/families.cc:  UNIF_PARAMETERS;
RandomFields/src/families.cc:  if (P0INT(UNIF_NORMED)) {
RandomFields/src/families.cc:      cov->mpp.mM[0] = cov->mpp.mMplus[0] = 1.0; 
RandomFields/src/families.cc:	cov->mpp.mM[1] = 0.5 * (min[0] + max[0]);
RandomFields/src/families.cc:	cov->mpp.mMplus[1] = max[0] <= 0.0 ? 0.0 : 0.5 * max[0];
RandomFields/src/families.cc:	  cov->mpp.mM[2] = max[0] - min[0];
RandomFields/src/families.cc:	cov->mpp.mM[2] *= cov->mpp.mM[2] / 12.0;
RandomFields/src/families.cc:    cov->mpp.mM[0] = cov->mpp.mMplus[0] = cov->mpp.unnormedmass;
RandomFields/src/families.cc:  // PMI(cov);
RandomFields/src/families.cc:  range->min[UNIF_MIN] = RF_NEGINF;
RandomFields/src/families.cc:  range->max[UNIF_MIN] = RF_INF;
RandomFields/src/families.cc:  range->pmin[UNIF_MIN] = - 1e8;
RandomFields/src/families.cc:  range->pmax[UNIF_MIN] = 1e8;
RandomFields/src/families.cc:  range->openmin[UNIF_MIN] = true;
RandomFields/src/families.cc:  range->openmax[UNIF_MIN] = true;
RandomFields/src/families.cc:  range->min[UNIF_MAX] = RF_NEGINF;
RandomFields/src/families.cc:  range->max[UNIF_MAX] = RF_INF;
RandomFields/src/families.cc:  range->pmin[UNIF_MAX] = - 1e8;
RandomFields/src/families.cc:  range->pmax[UNIF_MAX] = 1e8;
RandomFields/src/families.cc:  range->openmin[UNIF_MAX] = true;
RandomFields/src/families.cc:  range->openmax[UNIF_MAX] = true;
RandomFields/src/families.cc:  booleanRange(UNIF_NORMED);
RandomFields/src/families.cc:  X = UNIFORM_RANDOM * (start + end);			     \
RandomFields/src/families.cc:  Y = (2.0 * UNIFORM_RANDOM - 1.0) * (end - start);	     \
RandomFields/src/families.cc:  i0 = UNIFORM_RANDOM < 0.5;				     \
RandomFields/src/families.cc:    x[0] = (2.0 * UNIFORM_RANDOM - 1.0) * (end - start);
RandomFields/src/families.cc:    X = UNIFORM_RANDOM * (massTube + massEnds);
RandomFields/src/families.cc:	x[2] = (2.0 * UNIFORM_RANDOM - 1.0) * start;
RandomFields/src/families.cc:      x[0] = (2.0 * UNIFORM_RANDOM - 1.0) * end;
RandomFields/src/families.cc:      x[1] = (2.0 * UNIFORM_RANDOM - 1.0) * end;
RandomFields/src/families.cc:      Z = (2.0 * UNIFORM_RANDOM - 1.0) * (end - start);
RandomFields/src/families.cc:  X = UNIFORM_RANDOM * 2 * dist;  \
RandomFields/src/families.cc:    x[0] = UNIFORM_RANDOM < 0.5 ? dist : -dist;
RandomFields/src/families.cc:    if ( (X = UNIFORM_RANDOM * 6) > 2 ) { // Roehre
RandomFields/src/families.cc:	x[2] = (2.0 * UNIFORM_RANDOM - 1.0) * dist;
RandomFields/src/families.cc:      x[0] = (2.0 * UNIFORM_RANDOM - 1.0) * dist;
RandomFields/src/families.cc:      x[1] = (2.0 * UNIFORM_RANDOM - 1.0) * dist;
RandomFields/src/families.cc:// Marco's Idee um Kirstins Sachen zu implementieren
RandomFields/src/families.cc:#define ASSIGN_IDX_MISMATCH (-IDX_STEPS - 2)
RandomFields/src/families.cc:#define INNER_CUM  rect->weight[IDX_INNER]
RandomFields/src/families.cc:#define OUTER_CUM  rect->weight[IDX_OUTER]
RandomFields/src/families.cc:#define TMP (rect->tmp_n)
RandomFields/src/families.cc:#define TMP_WEIGHT rect->tmp_weight
RandomFields/src/families.cc:#define ASSIGNMENT(IDX) rect->asSign[IDX] // for control only
RandomFields/src/families.cc:#define RECTANGULAR_PARAMETER_BASICS		\
RandomFields/src/families.cc:  int VARIABLE_IS_NOT_USED dim = ANYOWNDIM;	\
RandomFields/src/families.cc:#define RECTANGULAR_PARAMETERS				\
RandomFields/src/families.cc:  RECTANGULAR_PARAMETER_BASICS;				\
RandomFields/src/families.cc:#define DEBUG_CUMSUM false
RandomFields/src/families.cc:  RECTANGULAR_PARAMETERS;
RandomFields/src/families.cc:  int d, kstep, dM1,
RandomFields/src/families.cc:  TMP = 0;
RandomFields/src/families.cc:  dM1 = d - 1;
RandomFields/src/families.cc:    if (DEBUG_CUMSUM) {
RandomFields/src/families.cc:	cumsum[TMP] = OUTER_CUM;
RandomFields/src/families.cc:	TMP++;
RandomFields/src/families.cc:	assert(cumsum[TMP-1] >= 0);
RandomFields/src/families.cc:      RIGHT_END(TMP) = INNER + kstep * STEP;
RandomFields/src/families.cc:      SQUEEZED(TMP)  = - MAXINT / 2;
RandomFields/src/families.cc:      ASSIGNMENT(TMP)= ASSIGN_IDX_MISMATCH;
RandomFields/src/families.cc:      if (DEBUG_CUMSUM) {
RandomFields/src/families.cc:	PRINTF("0. TMP=%d kstep=%d ass=%d\n", TMP, kstep,  ASSIGNMENT(TMP));
RandomFields/src/families.cc:      cumsum[TMP++] = WEIGHT(kstep - 1);
RandomFields/src/families.cc:      assert(cumsum[TMP-1] >= 0);
RandomFields/src/families.cc:	RIGHT_END(TMP) = INNER + (k + IDX_STEPS) * STEP;
RandomFields/src/families.cc:	SQUEEZED(TMP)  = dM1;
RandomFields/src/families.cc:	ASSIGNMENT(TMP) = k == -IDX_STEPS ? ASSIGN_IDX_INNER : k;
RandomFields/src/families.cc:	if (DEBUG_CUMSUM) {
RandomFields/src/families.cc:	  PRINTF("1. TMP=%d k=%d ass=%d\n", TMP, k,  ASSIGNMENT(TMP));
RandomFields/src/families.cc:	cumsum[TMP++]  = WEIGHT(k);
RandomFields/src/families.cc:	assert(cumsum[TMP-1] >= 0);
RandomFields/src/families.cc:    zneu[dM1] = INNER + STEP * kstep; 
RandomFields/src/families.cc:    start_cumul = TMP;
RandomFields/src/families.cc:    //    printf("AA d=%d %d %10g %10g\n", d, TMP, zneu[dM1], INNER);
RandomFields/src/families.cc:    dM1 = d - 1;
RandomFields/src/families.cc:    //  printf("X d=%d %d dim=%d\n", d, TMP, dim);
RandomFields/src/families.cc:     if (zneu[d] == zneu[dM1]) continue;
RandomFields/src/families.cc:    //printf("%10g == %10g %d\n",zneu[d],  zneu[dM1], zneu[d] == zneu[dM1] );
RandomFields/src/families.cc:   //   printf("A d=%d %d dim=%d\n", d, TMP, dim);
RandomFields/src/families.cc:    if (zneu[dM1] < INNER) {
RandomFields/src/families.cc:      min = RIGHT_END(TMP) = zneu[d] <= INNER ? zneu[d] : INNER;
RandomFields/src/families.cc:      SQUEEZED(TMP) = dM1;
RandomFields/src/families.cc:      ASSIGNMENT(TMP) = ASSIGN_IDX_INNER;
RandomFields/src/families.cc:      cumsum[TMP++] = INNER_CONST * 
RandomFields/src/families.cc:	PoweredVolOfCube(ysort, zneu[dM1], min, INNER_POW, dim, dM1);
RandomFields/src/families.cc:      if (DEBUG_CUMSUM) {
RandomFields/src/families.cc:	PRINTF("2. TMP=%d kstep=%d asS=%d cum=%10g inner_c=%10g start=%10g ende=%10g pow=%10g dim=%d squ=%d\n", TMP-1, kstep,  ASSIGNMENT(TMP-1), cumsum[TMP-1], //
RandomFields/src/families.cc:	       INNER_CONST, zneu[dM1],
RandomFields/src/families.cc:	       min,PoweredVolOfCube(ysort, zneu[dM1], min, INNER_POW, dim, dM1),
RandomFields/src/families.cc:	       dim, dM1);
RandomFields/src/families.cc:	assert(cumsum[TMP-1] >= 0);
RandomFields/src/families.cc:      zneu[dM1] = INNER;
RandomFields/src/families.cc:    if (zneu[dM1] < OUTER) {
RandomFields/src/families.cc:	steps = (min - zneu[dM1]) / STEP;
RandomFields/src/families.cc:      double a = zneu[dM1];
RandomFields/src/families.cc:      //printf("d=%d min=%10g %10g %10g\n", d, min, zneu[dM1], zneu[d]);
RandomFields/src/families.cc:      assert(TMP <= NSTEP + 2 + dim);
RandomFields/src/families.cc:	RIGHT_END(TMP) = a + STEP;
RandomFields/src/families.cc:	SQUEEZED(TMP) = dM1;
RandomFields/src/families.cc:	ASSIGNMENT(TMP) = kstep; // NICHT k !
RandomFields/src/families.cc:	cumsum[TMP++] = 
RandomFields/src/families.cc:	  VolumeOfCubeRing(ysort, a, a + STEP, dim, dM1) * VALUE(kstep);
RandomFields/src/families.cc: 	assert(cumsum[TMP-1] >= 0);	
RandomFields/src/families.cc:	if (DEBUG_CUMSUM) {
RandomFields/src/families.cc:	  PRINTF("3. TMP=%d kstep=%d asS=%d a=%4.2f st=%4.2f end=%4.2f val=%4.2e, tot=%4.4f %d\n", TMP-1, kstep,  ASSIGNMENT(TMP-1), a, STEP, RIGHT_END(TMP-1), //
RandomFields/src/families.cc:		 VALUE(kstep), cumsum[TMP-1], ASSIGNMENT(0));
RandomFields/src/families.cc:      // printf("B %d %d\n", d, TMP);
RandomFields/src/families.cc:      assert(TMP <= NSTEP + 2 + dim);
RandomFields/src/families.cc:	RIGHT_END(TMP) = min;
RandomFields/src/families.cc:	SQUEEZED(TMP) = dM1;
RandomFields/src/families.cc:	ASSIGNMENT(TMP) = kstep;
RandomFields/src/families.cc:	assert(TMP > 0);
RandomFields/src/families.cc:	if (DEBUG_CUMSUM) {
RandomFields/src/families.cc:	  PRINTF("4. TMP=%d k=%d ass=%d\n", TMP, kstep, ASSIGNMENT(TMP));
RandomFields/src/families.cc:	cumsum[TMP++] = VolumeOfCubeRing(ysort, a, min, dim, dM1) * VALUE(kstep);
RandomFields/src/families.cc:	assert(cumsum[TMP-1] >= 0);
RandomFields/src/families.cc:      // printf("outer=%10g %10g %10g %10e %d %d %d\n", OUTER, a,  cumsum[TMP-1], 
RandomFields/src/families.cc:      //        OUTER - a, OUTER == min, dM1, kstep < NSTEP);
RandomFields/src/families.cc:      // printf("C %d %d\n", d, TMP);
RandomFields/src/families.cc:    RIGHT_END(TMP) = zneu[d];
RandomFields/src/families.cc:    SQUEEZED(TMP) = dM1;
RandomFields/src/families.cc:    ASSIGNMENT(TMP) = ASSIGN_IDX_OUTER;
RandomFields/src/families.cc:    if (DEBUG_CUMSUM) {
RandomFields/src/families.cc:      PRINTF("5. TMP=%d k=%d ass=%d %10g p=%10g right=%10g\n",
RandomFields/src/families.cc:	     TMP, 9999, ASSIGNMENT(TMP), OUTER, OUTER_POW, zneu[d]);
RandomFields/src/families.cc:      cumsum[TMP++] = 0.0;
RandomFields/src/families.cc:      //		  OUTER_POW_CONST, dim, dM1),
RandomFields/src/families.cc:      //				    OUTER_POW_CONST, dim, dM1)	     
RandomFields/src/families.cc:      cumsum[TMP++] = OUTER_CONST * ExpVolOfCube(OUTER, zneu[d], OUTER_POW, 
RandomFields/src/families.cc:						 OUTER_POW_CONST, dim, dM1);
RandomFields/src/families.cc:      if (DEBUG_CUMSUM) {
RandomFields/src/families.cc:	PRINTF("6. TMP=%d k=%d ass=%d oc=%10g c=%10g op=%10g opc=%10g dim=%d %d right=%10g\n", TMP, 10001, ASSIGNMENT(TMP-1),OUTER_CONST, OUTER, OUTER_POW,
RandomFields/src/families.cc:	       OUTER_POW_CONST, dim, dM1, zneu[d]);
RandomFields/src/families.cc:      //  printf("TMP=%d %10g\n", TMP, cumsum[TMP-1]);
RandomFields/src/families.cc:      // if (cumsum[TMP-1] < 0) {
RandomFields/src/families.cc:      //fori=1; i<TMP; i++) {
RandomFields/src/families.cc:      //	PMI(cov);
RandomFields/src/families.cc:      assert(cumsum[TMP-1] >= 0);
RandomFields/src/families.cc:      assert(R_FINITE(cumsum[TMP-1]));
RandomFields/src/families.cc:      cumsum[TMP++]= OUTER_CONST * 
RandomFields/src/families.cc:	PoweredVolOfCube(ysort, OUTER, zneu[d], OUTER_POW, dim, dM1);
RandomFields/src/families.cc:      assert(cumsum[TMP-1] >= 0);
RandomFields/src/families.cc:  //PMI(cov);
RandomFields/src/families.cc:  for (d=start_cumul; d<TMP; d++) {
RandomFields/src/families.cc:     //  printf("cumsum %d [%d,%d] c=%10e %10e asSign=%d (-1)=%d end=%10g inner=%10g ASS_I_OUT=%d\n", d, start_cumul, TMP, cumsum[d], cumsum[d]-cumsum[d-1], ASSIGNMENT(d), ASSIGNMENT(d-1), RIGHT_END(d), INNER, ASSIGN_IDX_OUTER);
RandomFields/src/families.cc:    assert(ASSIGNMENT(d)==ASSIGN_IDX_OUTER || ASSIGNMENT(d) >= ASSIGNMENT(d-1));
RandomFields/src/families.cc:  //APMI(cov);  
RandomFields/src/families.cc:  RECTANGULAR_PARAMETERS;
RandomFields/src/families.cc:  RECTANGULAR_PARAMETER_BASICS;			       
RandomFields/src/families.cc:  // printf("rectD %10g %10g %d %10g\n", max, *v, P0INT(RECT_NORMED), OUTER_CUM);
RandomFields/src/families.cc:  if (P0INT(RECT_NORMED)) *v /= OUTER_CUM; 
RandomFields/src/families.cc:  RECTANGULAR_PARAMETERS;
RandomFields/src/families.cc:  if (P0INT(RECT_NORMED)) v *= OUTER_CUM; // unnormed v
RandomFields/src/families.cc: // RECTANGULAR_PARAMETERS;
RandomFields/src/families.cc:  RECTANGULAR_PARAMETER_BASICS;	
RandomFields/src/families.cc:  //for (d=0; d<dim; d++) {// To Do ?? Stimmt das? Oder Masse der dimension d-k ?? SCJEINT NICHT ZU STIMMEN!!
RandomFields/src/families.cc:  //  CumSum(y, false, cov, TMP_WEIGHT);
RandomFields/src/families.cc:  //  double tw = TMP_WEIGHT[TMP-1];
RandomFields/src/families.cc:  CumSum(y, true, cov, TMP_WEIGHT);
RandomFields/src/families.cc:  *v = TMP_WEIGHT[TMP-1];
RandomFields/src/families.cc:  if (P0INT(RECT_NORMED)) *v /= OUTER_CUM;
RandomFields/src/families.cc:    if (isMonotone(next->monotone)) { /* rejection sampling */		\
RandomFields/src/families.cc:      if (UNIFORM_RANDOM >= newquot) {					\
RandomFields/src/families.cc:    } else { /* MCMC */							\
RandomFields/src/families.cc:	if (UNIFORM_RANDOM * cov->q[quot] >= newquot) { /* keep old one */ \
RandomFields/src/families.cc:	  MEMCOPYX(v, cov->q, bytes);					\
RandomFields/src/families.cc:	  MEMCOPYX(cov->q, v, bytes);					\
RandomFields/src/families.cc:	cov->q[ni] = P0INT(RECT_MCMC_N) - 1.0;				\
RandomFields/src/families.cc:	MEMCOPYX(cov->q, v, bytes);					\
RandomFields/src/families.cc:      cov->q[ni] = P0INT(RECT_MCMC_N);					\
RandomFields/src/families.cc:  RECTANGULAR_PARAMETERS;
RandomFields/src/families.cc:  int i = CeilIndex(UNIFORM_RANDOM * OUTER_CUM, rect->weight, NSTEP + 2);
RandomFields/src/families.cc:  //int i = searchFirstGreater(rect->weight, NSTEP + 2, UNIFORM_RANDOM  * OUTER_CUM);
RandomFields/src/families.cc:    RandomPointOnCubeSurface(POW(UNIFORM_RANDOM, 1.0 / (INNER_POW+dim)) * INNER,
RandomFields/src/families.cc:      u = POW(POW(OUTER, OUTER_POW) - LOG(UNIFORM_RANDOM) / OUTER_POW_CONST,
RandomFields/src/families.cc:    else u = POW(UNIFORM_RANDOM, 1.0 / (OUTER_POW + dim)) * OUTER; // p+d < 0 !
RandomFields/src/families.cc:  RECTANGULAR_PARAMETERS;
RandomFields/src/families.cc:==23772==    by 0x11F0CA7A: EvaluateModel (userinterfaces.cc:661)
RandomFields/src/families.cc:  CumSum(y, false, cov, TMP_WEIGHT); // ACHTUNG! reck->z gesetzt
RandomFields/src/families.cc:  //assert(TMP_WEIGHT[TMP-1] >= 2.1 && TMP_WEIGHT[TMP-1] <= 2.2);
RandomFields/src/families.cc:  assert(TMP > 0);
RandomFields/src/families.cc:  double random = UNIFORM_RANDOM * TMP_WEIGHT[TMP-1];
RandomFields/src/families.cc:  bool final = SQUEEZED(TMP-1) == 0 && 
RandomFields/src/families.cc:  sel = CeilIndex(random, TMP_WEIGHT, TMP);
RandomFields/src/families.cc:  //printf("r=%10g inner=%10g o.tmp=%10g lst.step.tmp=%10g\n", random,   TMP_WEIGHT[IDX_INNER],   TMP_WEIGHT[TMP-1], TMP_WEIGHT[TMP-1]);
RandomFields/src/families.cc:  //	 y[0], dim, SQUEEZED(sel), sel, random,  TMP_WEIGHT[TMP-1], TMP);
RandomFields/src/families.cc:  u = TMP_WEIGHT; // nutzen des Platzes...
RandomFields/src/families.cc:  //printf("assess %d %d %d\n", ASSIGNMENT(sel), sel, TMP);
RandomFields/src/families.cc:  if (ASSIGNMENT(sel) == ASSIGN_IDX_INNER) {
RandomFields/src/families.cc:    //   RandomPointOnCubeSurface(POW(UNIFORM_RANDOM, 1.0 / (INNER_POW+dim))
RandomFields/src/families.cc:      r = POW((UNIFORM_RANDOM - a) * binv, 1 / p);
RandomFields/src/families.cc:    //   printf("inner %d %d ap=%10g r=%10g inner=%10g w=%10g tmp=%10g, %10g\n", dim, SQUEEZED(sel), ap, r, INNER, INNER_CUM, TMP_WEIGHT[IDX_INNER], TMP_WEIGHT[IDX_INNER+1]);
RandomFields/src/families.cc:  } else if (ASSIGNMENT(sel) == ASSIGN_IDX_OUTER) {
RandomFields/src/families.cc:      w = POW(op - LOG(1.0 - UNIFORM_RANDOM * factor) / OUTER_POW_CONST,
RandomFields/src/families.cc:		  UNIFORM_RANDOM *(1.0 - POW(end/OUTER, OUTER_POW + red_dim)),
RandomFields/src/families.cc:    //printf("sel=%d asS=%d %d\n",sel, ASSIGNMENT(sel), NSTEP);
RandomFields/src/families.cc:    assert(ASSIGNMENT(sel) >= 0 && ASSIGNMENT(sel) < NSTEP);
RandomFields/src/families.cc:    // APMI(cov->calling);
RandomFields/src/families.cc:    v[idx[d] - 1] = (2.0 * UNIFORM_RANDOM - 1.0) * ysort[d];//idx[d] indiziert ab 1
RandomFields/src/families.cc:    // v[idx[d] - 1] = 2 *  UNIFORM_RANDOM - 1; /* print */
RandomFields/src/families.cc:int GetMajorant(model *cov) {
RandomFields/src/families.cc:  RECTANGULAR_PARAMETERS;
RandomFields/src/families.cc:    min_steps = P0(RECT_MINSTEPLENGTH), // middle
RandomFields/src/families.cc:    EMsafety = 1.0 - safety,
RandomFields/src/families.cc:    inner_min = P0(RECT_INNERMIN),
RandomFields/src/families.cc:    outer_max = P0(RECT_OUTERMAX),
RandomFields/src/families.cc:  assert(!PisNULL(RECT_MAXSTEPS));
RandomFields/src/families.cc:    max_steps = P0INT(RECT_MAXSTEPS),
RandomFields/src/families.cc:    max_iterations =  P0INT(RECT_MAXIT);
RandomFields/src/families.cc:  INNER_POW = inpownot0 ? in_pow * EMsafety - dimsafety : 0.0;
RandomFields/src/families.cc:    if (inpownot0) INNER_POW = INNER_POW * EMsafety - dimsafety;
RandomFields/src/families.cc:    //PMI(cov);
RandomFields/src/families.cc:      SERR2("%d iterations performed without success. Increase the value of '%.50s'", max_iterations, distr[RECT_MAXIT]);
RandomFields/src/families.cc:    // APMI(cov);
RandomFields/src/families.cc:	SERR1("No majorant found. Function does not allow for a majorant or increase '%.50s'", distr[RECT_MAXIT]);
RandomFields/src/families.cc:  // PMI(cov, "getm");
RandomFields/src/families.cc:    dim = OWNXDIM(0);
RandomFields/src/families.cc:  kdefault(cov, RECT_MINSTEPLENGTH, global->distr.minsteplen);
RandomFields/src/families.cc:  kdefault(cov, RECT_MAXSTEPS, global->distr.maxsteps);
RandomFields/src/families.cc:  kdefault(cov, RECT_MAXIT, global->distr.maxit);
RandomFields/src/families.cc:  kdefault(cov, RECT_INNERMIN, global->distr.innermin);
RandomFields/src/families.cc:  kdefault(cov, RECT_OUTERMAX, global->distr.outermax);
RandomFields/src/families.cc:  kdefault(cov, RECT_MCMC_N, global->distr.mcmc_n);
RandomFields/src/families.cc:  kdefault(cov, RECT_NORMED, true); // currently only the normed version 
RandomFields/src/families.cc:  if (next->randomkappa) RETURN_ERR(ERRORRANDOMKAPPA);
RandomFields/src/families.cc:  // if (!isMonotone(next->monotone)) SERR("only monotone submodels are allowed");
RandomFields/src/families.cc:    //    APMI(next);
RandomFields/src/families.cc:  //  PMI(next);
RandomFields/src/families.cc:  //PMI(next);
RandomFields/src/families.cc:    //PMI(next);
RandomFields/src/families.cc:  VDIM0 = OWNLOGDIM(0);
RandomFields/src/families.cc:  VDIM1 = 1;
RandomFields/src/families.cc:  //PMI(cov);
RandomFields/src/families.cc:  RECTANGULAR_PARAMETERS; // muss nach obigen stehen und vor allem anderen
RandomFields/src/families.cc:    //PMI(cov);
RandomFields/src/families.cc:  if ((err = GetMajorant(cov)) != NOERROR) RETURN_ERR(err); // muss genau nach MALLOC oben und MALLOC unten stehen
RandomFields/src/families.cc:  //   APMI(cov);
RandomFields/src/families.cc:  if ((rect->value = (double*) MALLOC(sizeof(double) * abschnitte)) == NULL ||
RandomFields/src/families.cc:      (rect->weight = (double*) MALLOC(sizeof(double) * abschnitte)) == NULL||
RandomFields/src/families.cc:      (TMP_WEIGHT = (double*) CALLOC(tmp_n, sizeof(double))) == NULL ||
RandomFields/src/families.cc:      (rect->right_endpoint = (double*) MALLOC(sizeof(double) * tmp_n)) ==NULL||
RandomFields/src/families.cc:      (rect->ysort = (double*) MALLOC(sizeof(double) * (dim + 1))) == NULL ||
RandomFields/src/families.cc:      (rect->z = (double*) MALLOC(sizeof(double) * (dim + 1))) == NULL ||//dummy
RandomFields/src/families.cc:      (rect->squeezed_dim = (int*) MALLOC(sizeof(int) * tmp_n)) == NULL ||
RandomFields/src/families.cc:      (rect->asSign = (int*) MALLOC(sizeof(int) * tmp_n)) == NULL ||
RandomFields/src/families.cc:      (rect->idx = (int*) MALLOC(sizeof(int) * (dim + 1))) == NULL)
RandomFields/src/families.cc:    RETURN_ERR(ERRORMEMORYALLOCATION);
RandomFields/src/families.cc:  for(d=0; d<dim; d++)  TMP_WEIGHT[d] = RF_INF;
RandomFields/src/families.cc:  CumSum(TMP_WEIGHT, false, cov, rect->weight);
RandomFields/src/families.cc:  cov->mpp.mM[0] = cov->mpp.mMplus[0] = P0INT(RECT_NORMED) ? 1.0 : OUTER_CUM;
RandomFields/src/families.cc:  assert(R_FINITE(OUTER_CUM));
RandomFields/src/families.cc:    double f = cov->mpp.mM[0] / next->mpp.mM[0];
RandomFields/src/families.cc:    cov->mpp.mM[1] = next->mpp.mM[1] * f;
RandomFields/src/families.cc:    cov->mpp.mMplus[1] = next->mpp.mMplus[1] * f; 
RandomFields/src/families.cc:    if (!R_FINITE(cov->mpp.mM[1])){
RandomFields/src/families.cc:      //      crash();      APMI(cov);
RandomFields/src/families.cc:  if (isMonotone(next->monotone))
RandomFields/src/families.cc:  cov->mpp.unnormedmass = OUTER_CUM;
RandomFields/src/families.cc:  // if (OUTER_CUM < 1.0) { APMI(cov); }
RandomFields/src/families.cc:	u += w * 4 * M_PI / 3 * (powl(xx + mini, 3) - powl(xx, 3));
RandomFields/src/families.cc:  //  printf("totalweight=%10g\n", OUTER_CUM);
RandomFields/src/families.cc:  assert(OUTER_CUM >= 1.0 || NEXTNR != STROKORB_MONO); 
RandomFields/src/families.cc:  //  printf("init rect %d %d\n", NSTEP, TMP);
RandomFields/src/families.cc:  assert(NSTEP == TMP - 2);
RandomFields/src/families.cc:  range->min[RECT_MINSTEPLENGTH] = 0;
RandomFields/src/families.cc:  range->max[RECT_MINSTEPLENGTH] = RF_INF;
RandomFields/src/families.cc:  range->pmin[RECT_MINSTEPLENGTH] = 0.01;
RandomFields/src/families.cc:  range->pmax[RECT_MINSTEPLENGTH] = 10;
RandomFields/src/families.cc:  range->openmin[RECT_MINSTEPLENGTH] = false;
RandomFields/src/families.cc:  range->openmax[RECT_MINSTEPLENGTH] = true;
RandomFields/src/families.cc:  range->min[RECT_MAXSTEPS] = 1;
RandomFields/src/families.cc:  range->max[RECT_MAXSTEPS] = RF_INF;
RandomFields/src/families.cc:  range->pmin[RECT_MAXSTEPS] = 2;
RandomFields/src/families.cc:  range->pmax[RECT_MAXSTEPS] = 10000;
RandomFields/src/families.cc:  range->openmin[RECT_MAXSTEPS] = false;
RandomFields/src/families.cc:  range->openmax[RECT_MAXSTEPS] = true;
RandomFields/src/families.cc:  range->min[RECT_MAXIT] = 1;
RandomFields/src/families.cc:  range->max[RECT_MAXIT] = RF_INF;
RandomFields/src/families.cc:  range->pmin[RECT_MAXIT] = 2;
RandomFields/src/families.cc:  range->pmax[RECT_MAXIT] = 10;
RandomFields/src/families.cc:  range->openmin[RECT_MAXIT] = false;
RandomFields/src/families.cc:  range->openmax[RECT_MAXIT] = true;
RandomFields/src/families.cc:  range->min[RECT_INNERMIN] = 0;
RandomFields/src/families.cc:  range->max[RECT_INNERMIN] = RF_INF;
RandomFields/src/families.cc:  range->pmin[RECT_INNERMIN] = 1e-100;
RandomFields/src/families.cc:  range->pmax[RECT_INNERMIN] = 1;
RandomFields/src/families.cc:  range->openmin[RECT_INNERMIN] = true;
RandomFields/src/families.cc:  range->openmax[RECT_INNERMIN] = true;
RandomFields/src/families.cc:  range->min[RECT_OUTERMAX] = 0;
RandomFields/src/families.cc:  range->max[RECT_OUTERMAX] = RF_INF;
RandomFields/src/families.cc:  range->pmin[RECT_OUTERMAX] = 1;
RandomFields/src/families.cc:  range->pmax[RECT_OUTERMAX] = 1e10;
RandomFields/src/families.cc:  range->openmin[RECT_OUTERMAX] = true;
RandomFields/src/families.cc:  range->openmax[RECT_OUTERMAX] = true;
RandomFields/src/families.cc:  range->min[RECT_MCMC_N] = 1;
RandomFields/src/families.cc:  range->max[RECT_MCMC_N] = MAXINT;
RandomFields/src/families.cc:  range->pmin[RECT_MCMC_N] = 0;
RandomFields/src/families.cc:  range->pmax[RECT_MCMC_N] = 1000;
RandomFields/src/families.cc:  range->openmin[RECT_MCMC_N] = false;
RandomFields/src/families.cc:  range->openmax[RECT_MCMC_N] = true;
RandomFields/src/families.cc:  booleanRange(RECT_NORMED);
RandomFields/src/families.cc:  range->pmax[RECT_ONESIDED] = range->max[RECT_ONESIDED] = OWNLOGDIM(0)==1;
RandomFields/src/families.cc:#define MCMC_FCTN 0
RandomFields/src/families.cc:#define MCMC_MCMC_N 0
RandomFields/src/families.cc:#define MCMC_MCMC_SIGMA 1
RandomFields/src/families.cc:#define MCMC_NORMED 2
RandomFields/src/families.cc:#define MCMC_MAXDENSITY 3
RandomFields/src/families.cc:#define MCMC_RANDLOC 4
RandomFields/src/families.cc:#define MCMC_GIBBS 5
RandomFields/src/families.cc:#define MCMC_LAST_PARAM MCMC_GIBBS
RandomFields/src/families.cc:  *nr = (i == MCMC_MCMC_SIGMA) ? 0 : (i <= MCMC_LAST_PARAM) ? 1 : -1;
RandomFields/src/families.cc:  bool normed = P0INT(MCMC_NORMED);
RandomFields/src/families.cc:  PINT(MCMC_NORMED)[0] = false;
RandomFields/src/families.cc:  while (cov->q[MCMC_CURR_N] >= 1.0) {
RandomFields/src/families.cc:    cov->q[MCMC_CURR_SUM] -= 1.0;
RandomFields/src/families.cc:  model *next = cov->sub[MCMC_FCTN];
RandomFields/src/families.cc:  //  int mcmc_n =  P0INT(MCMC_MCMC_N);
RandomFields/src/families.cc:  if (P0INT(MCMC_NORMED)) {
RandomFields/src/families.cc:  model *next = cov->sub[MCMC_FCTN];
RandomFields/src/families.cc:    n = P0INT(MCMC_MCMC_N);
RandomFields/src/families.cc:    maxdens = P0(MCMC_MAXDENSITY),
RandomFields/src/families.cc:    *sigma = P(MCMC_MCMC_SIGMA),
RandomFields/src/families.cc:    gibbs = (bool) P0INT(MCMC_GIBBS),
RandomFields/src/families.cc:    randlocation = (bool) P0INT(MCMC_RANDLOC);
RandomFields/src/families.cc:      int idx = (int) (UNIFORM_RANDOM * (double) vdim);
RandomFields/src/families.cc:			rnorm(0.0, sigma[idx % cov->nrow[MCMC_MCMC_SIGMA]]));
RandomFields/src/families.cc:	//	printf("%d %d %10g %10g\n", d, d % cov->nrow[MCMC_MCMC_SIGMA], 
RandomFields/src/families.cc:	//	       sigma[d % cov->nrow[MCMC_MCMC_SIGMA]], proposed[d]);	
RandomFields/src/families.cc:		       += rnorm(0.0, sigma[d % cov->nrow[MCMC_MCMC_SIGMA]]));
RandomFields/src/families.cc:	    (double) ((int) UNIFORM_RANDOM * (loc->xgr[d][XLENGTH] - 1.0));
RandomFields/src/families.cc:	  *xx = loc->x + vdim * (int) (loc->spatialtotalpoints*UNIFORM_RANDOM);
RandomFields/src/families.cc:	  int vM1 = vdim - 1;
RandomFields/src/families.cc:	  for (d = 0; d < vM1; d++) proposed[d] += xx[d];
RandomFields/src/families.cc:	    (double) ((int) UNIFORM_RANDOM * (loc->T[XLENGTH] - 1.0));
RandomFields/src/families.cc:    if (proposedvalue > posvalue || proposedvalue > posvalue*UNIFORM_RANDOM) {
RandomFields/src/families.cc:  model *next = cov->sub[MCMC_FCTN];
RandomFields/src/families.cc:  kdefault(cov, MCMC_NORMED, false);
RandomFields/src/families.cc:  if (P0INT(MCMC_NORMED)) NotProgrammedYet("mcmc (normed=TRUE)"); // OK
RandomFields/src/families.cc:  if (vdim != OWNTOTALXDIM) SERR("inconsistent dimensions given.");
RandomFields/src/families.cc:  VDIM0 = vdim;
RandomFields/src/families.cc:  VDIM1 = 1;
RandomFields/src/families.cc:  if (PisNULL(MCMC_MCMC_SIGMA)) {
RandomFields/src/families.cc:      PALLOC(MCMC_MCMC_SIGMA, vdim, 1);
RandomFields/src/families.cc:	P(MCMC_MCMC_SIGMA)[d] = loc->xgr[d][XSTEP] * 0.1;
RandomFields/src/families.cc:      SERR1("'%.50s' must be given.", KNAME(MCMC_MCMC_SIGMA));
RandomFields/src/families.cc:  kdefault(cov, MCMC_MCMC_N, global->distr.mcmc_n);
RandomFields/src/families.cc:  kdefault(cov, MCMC_MAXDENSITY, 1000);
RandomFields/src/families.cc:  kdefault(cov, MCMC_RANDLOC, false); // scattering among 
RandomFields/src/families.cc:  kdefault(cov, MCMC_GIBBS, false);
RandomFields/src/families.cc:  model *next = cov->sub[MCMC_FCTN];
RandomFields/src/families.cc:    maxdens = P0(MCMC_MAXDENSITY);
RandomFields/src/families.cc:  //PMI(cov);
RandomFields/src/families.cc:      int vM1 = vdim - 1;
RandomFields/src/families.cc:      for (d=0; d<vM1; d++) pos[d] = loc->x[d];
RandomFields/src/families.cc:  model *next = cov->sub[MCMC_FCTN];//int err;
RandomFields/src/families.cc:  range->min[MCMC_MCMC_N] = 1;
RandomFields/src/families.cc:  range->max[MCMC_MCMC_N] = RF_INF;
RandomFields/src/families.cc:  range->pmin[MCMC_MCMC_N] = 20;
RandomFields/src/families.cc:  range->pmax[MCMC_MCMC_N] = 50;
RandomFields/src/families.cc:  range->openmin[MCMC_MCMC_N] = false;
RandomFields/src/families.cc:  range->openmax[MCMC_MCMC_N] = true;
RandomFields/src/families.cc:  range->min[MCMC_MCMC_SIGMA] = 0;
RandomFields/src/families.cc:  range->max[MCMC_MCMC_SIGMA] = RF_INF;
RandomFields/src/families.cc:  range->pmin[MCMC_MCMC_SIGMA] = 1e-7;
RandomFields/src/families.cc:  range->pmax[MCMC_MCMC_SIGMA] = 1e7;
RandomFields/src/families.cc:  range->openmin[MCMC_MCMC_SIGMA] = true;
RandomFields/src/families.cc:  range->openmax[MCMC_MCMC_SIGMA] = true;
RandomFields/src/families.cc:  booleanRange(MCMC_NORMED);
RandomFields/src/families.cc:  range->min[MCMC_MAXDENSITY] = 0;
RandomFields/src/families.cc:  range->max[MCMC_MAXDENSITY] = RF_INF;
RandomFields/src/families.cc:  range->pmin[MCMC_MAXDENSITY] = 1e-7;
RandomFields/src/families.cc:  range->pmax[MCMC_MAXDENSITY] = 1e7;
RandomFields/src/families.cc:  range->openmin[MCMC_MAXDENSITY] = true;
RandomFields/src/families.cc:  range->openmax[MCMC_MAXDENSITY] = true;
RandomFields/src/families.cc:  booleanRange(MCMC_RANDLOC);
RandomFields/src/families.cc:  booleanRange(MCMC_GIBBS);
RandomFields/src/families.cc:    cov->mpp.mM[0] = next->mpp.mM[0];
RandomFields/src/families.cc:    cov->mpp.mMplus[0] = next->mpp.mMplus[0];
RandomFields/src/families.cc:    Eminus = cov->mpp.mMplus[1] - cov->mpp.mM[1];
RandomFields/src/families.cc:    cov->mpp.mMplus[1] = 
RandomFields/src/families.cc:      P(SIGN_P)[0] * (cov->mpp.mMplus[1] - Eminus) + Eminus; 
RandomFields/src/families.cc:    cov->mpp.mM[1] = 0.0;
RandomFields/src/families.cc:  cov->q[0] = 2.0 * (UNIFORM_RANDOM <= P0(SIGN_P)) - 1.0;
RandomFields/src/families.cc:  if (hasGaussMethodFrame(cov) || hasPoissonFrame(cov)) {
RandomFields/src/PoissonPolygon.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/PoissonPolygon.cc:               2017 Martin Schlather (slightly modified)
RandomFields/src/PoissonPolygon.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/PoissonPolygon.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/PoissonPolygon.cc:			phi[0] = 2*PI*UNIFORM_RANDOM;
RandomFields/src/PoissonPolygon.cc:			phi[1] = 2*PI*UNIFORM_RANDOM;
RandomFields/src/PoissonPolygon.cc:			phi[2] = 2*PI*UNIFORM_RANDOM;
RandomFields/src/PoissonPolygon.cc:		if(amax*UNIFORM_RANDOM<a) onceagain=0;
RandomFields/src/PoissonPolygon.cc:      phi[0] = TWOPI * UNIFORM_RANDOM;
RandomFields/src/PoissonPolygon.cc:      phi[1] = TWOPI * UNIFORM_RANDOM;
RandomFields/src/PoissonPolygon.cc:      phi[2] = TWOPI * UNIFORM_RANDOM;
RandomFields/src/PoissonPolygon.cc:    if(amax * UNIFORM_RANDOM < a) break;
RandomFields/src/PoissonPolygon.cc: *   Stochastic Geometry. Edited by W. Kendall and I. Molchanov. Oxford 
RandomFields/src/PoissonPolygon.cc:	double R,T,RRight,RLeft,RMax,uprim[2],pprim,udual[2],pdual;
RandomFields/src/PoissonPolygon.cc:	RMax = T/COS(0.5*(phi[1]-phi[0]));
RandomFields/src/PoissonPolygon.cc:	if(R>RMax) RMax = R;
RandomFields/src/PoissonPolygon.cc:	if(R>RMax) RMax = R;
RandomFields/src/PoissonPolygon.cc:		if(RRight+R>RMax){
RandomFields/src/PoissonPolygon.cc:			R = RMax-RRight;
RandomFields/src/PoissonPolygon.cc:			  Err = ERRORMEMORYALLOCATION;
RandomFields/src/PoissonPolygon.cc:			  Err = ERRORMEMORYALLOCATION;
RandomFields/src/PoissonPolygon.cc:				psi = TWOPI*UNIFORM_RANDOM;
RandomFields/src/PoissonPolygon.cc:				pprim = RLeft+R*UNIFORM_RANDOM;
RandomFields/src/InternalCov.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/InternalCov.cc: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/src/InternalCov.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/InternalCov.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/InternalCov.cc://  printf("L=%d E=%d cov:err=%d err_lev=%d %s\n", L, X, cov->err,  cov->err_level, NAME(cov));
RandomFields/src/InternalCov.cc:#define RETURN(L, X) { LEVEL_UPDATE(L,X);  if (cov->err != NOERROR) {PRINTF("error %d L=%d in '%s'.\n", cov->err, L, NAME(cov));} return cov->err; }
RandomFields/src/InternalCov.cc:#define ERR_RETURN(L, X) { FERR(X); LEVEL_UPDATE(L,ERRORM);PRINTF("error in '%s': %s\n", NAME(cov), ERRORM); return cov->err; }
RandomFields/src/InternalCov.cc:#define ERR_RETURN1(L,X,Y) { FERR1(X,Y); LEVEL_UPDATE(L,ERRORM); PRINTF("error in '%s': %s\n", NAME(cov), ERRORM);return cov->err;}
RandomFields/src/InternalCov.cc:#define ERR_RETURN2(L,X,Y,Z) {FERR2(X,Y,Z); LEVEL_UPDATE(L,ERRORM); PRINTF("error in '%s': %s\n", NAME(cov), ERRORM); return cov->err;}
RandomFields/src/InternalCov.cc:#define CONT(L) { levels[dom] = L; PRINTF("cont'd: error %d L=%d in '%s'.\n", errs[dom], L, NAME(cov)); continue;}
RandomFields/src/InternalCov.cc:#define ERR_RETURN(L, X) { FERR(X); LEVEL_UPDATE(L,ERRORM); return cov->err; }
RandomFields/src/InternalCov.cc:#define ERR_RETURN1(L,X,Y) { FERR1(X,Y); LEVEL_UPDATE(L,ERRORM); return cov->err;}
RandomFields/src/InternalCov.cc:#define ERR_RETURN2(L,X,Y,Z) {FERR2(X,Y,Z); LEVEL_UPDATE(L,ERRORM); return cov->err;}
RandomFields/src/InternalCov.cc:#define LEVEL_DOM 40
RandomFields/src/InternalCov.cc:    errorMSG(errs[dom], cov->err_msg, KT, ERRSTR[dom]);			\
RandomFields/src/InternalCov.cc:    if (PL > PL_ERRORS) { PRINTF("check level %d failed for %s (%d), %s %s.\n", levels[dom], NAME(cov), errs[dom], KT->error_location, ERRSTR[dom]);} \
RandomFields/src/InternalCov.cc:  COPYALLSYSTEMS(PREV, s, false);
RandomFields/src/InternalCov.cc:  ASSERT_ONESYSTEM;
RandomFields/src/InternalCov.cc:  int vdim = DefList[SYSMODEL(s)].vdim;
RandomFields/src/InternalCov.cc:  return check2X(cov, vdim == PARAM_DEP ? vdim0 : vdim,
RandomFields/src/InternalCov.cc:		    vdim == PARAM_DEP ? vdim1 : vdim, 
RandomFields/src/InternalCov.cc:  COPYALLSYSTEMS(PREV, s, false);
RandomFields/src/InternalCov.cc:  COPYALLSYSTEMS(PREV, s, false);
RandomFields/src/InternalCov.cc:  ASSERT_ONESYSTEM; 
RandomFields/src/InternalCov.cc:  //  printf("check2x: type=%s\n", TYPE_NAMES[type]);
RandomFields/src/InternalCov.cc:  COPYALLSYSTEMS(PREV, SYSOF(calling), false);
RandomFields/src/InternalCov.cc:  int last = PREVLASTSYSTEM;
RandomFields/src/InternalCov.cc:  if (dom != KEEPCOPY_DOM) for (int j=0; j<=last; j++) set_dom(PREV, j, dom);
RandomFields/src/InternalCov.cc:  COPYALLSYSTEMS(PREV, CALLING, false);
RandomFields/src/InternalCov.cc:  // genutzt von RMS
RandomFields/src/InternalCov.cc:  //  PMI0(cov->calling);  PMI0(cov);
RandomFields/src/InternalCov.cc:  //  PMI0(cov->calling);
RandomFields/src/InternalCov.cc:#if MAXSYSTEMS == 1    
RandomFields/src/InternalCov.cc:  //  printf("check2xx %s\n", NAME(cov));
RandomFields/src/InternalCov.cc:#if MAXSYSTEMS > 1
RandomFields/src/InternalCov.cc:    prev_lastsystem = PREVLASTSYSTEM;
RandomFields/src/InternalCov.cc:    //    PMI0(cov);
RandomFields/src/InternalCov.cc:    PRINTF("InternalCov.cc: frame %d %s %d %d\n", frame,TYPE_NAMES[frame],equalsInterface(frame), //
RandomFields/src/InternalCov.cc:	 equalsGaussMethod(frame) ||
RandomFields/src/InternalCov.cc:	 equalsBrMethod(frame) ||
RandomFields/src/InternalCov.cc:	 equalsGaussMethod(frame) ||
RandomFields/src/InternalCov.cc:	 equalsBrMethod(frame) ||
RandomFields/src/InternalCov.cc:  //  printf("basic %s %s(%d)\n", NAME(cov), TYPE_NAMES[frame], frame);
RandomFields/src/InternalCov.cc:  if (isManifold(frame) || isBad(frame)) {
RandomFields/src/InternalCov.cc:  //  printf("'%s' variant = %d %d %d is.interface=%d\n", NAME(cov), cov->variant, frame, BadType, isInterface(cov));
RandomFields/src/InternalCov.cc:    // PMI(cov);    crash();
RandomFields/src/InternalCov.cc:    ERR_RETURN1(2, "'%.50s' may be used only as top model", NAME(cov));
RandomFields/src/InternalCov.cc:    assert(!equalsIsoMismatch(curiso));
RandomFields/src/InternalCov.cc:    if (isManifold(curtype) || isBad(curtype)) {
RandomFields/src/InternalCov.cc:      ERR_RETURN2(3, "type '%.50s' not allowed for %.50s", TYPE_NAMES[curtype], NAME(cov));
RandomFields/src/InternalCov.cc:    if (equalsKernel(PREVDOM(s)) &&
RandomFields/src/InternalCov.cc:      //      printf("%s %s %s\n", DOMAIN_NAMES[PREVDOM(s)],  ISO_NAMES[PREVISO(s)], TYPE_NAMES[curtype]);
RandomFields/src/InternalCov.cc:      //      PMI(cov);
RandomFields/src/InternalCov.cc:      //      APMI0(cov);
RandomFields/src/InternalCov.cc:    if (equalsXonly(PREVDOM(s)) && isNegDef(PREVTYPE(s)) &&
RandomFields/src/InternalCov.cc:      //      PMI0(cov->calling);
RandomFields/src/InternalCov.cc:      //      APMI0(cov);
RandomFields/src/InternalCov.cc:    if (PREVXDIM(s) < 1) ERR_RETURN(5, "dimension less than 1"); 
RandomFields/src/InternalCov.cc:  check2X : anything concerning OWN, except DOMain (and xdim, logdim if no TRAFO)
RandomFields/src/InternalCov.cc:  COPYALLSYSTEMS(OWN, DEF, true);
RandomFields/src/InternalCov.cc:  case SubModelI :
RandomFields/src/InternalCov.cc:  case not SubModelI: 
RandomFields/src/InternalCov.cc:  COPYALLSYSTEMS(OWN, PREV, prev)
RandomFields/src/InternalCov.cc:  sets OWNDOMoop
RandomFields/src/InternalCov.cc:    // PMIR(cov); 
RandomFields/src/InternalCov.cc:  //  printf("C HECK2X%s %s(%d) call=%ld root=%ld %ld\n", NAME(cov), TYPE_NAMES[PREVTYPE(0)], PREVTYPE(0), (Long) cov->calling, (Long) cov->root, (Long) cov->base);
RandomFields/src/InternalCov.cc:    prev_lastsystem = PREVLASTSYSTEM,
RandomFields/src/InternalCov.cc:  bool left[MAXVARIANTS];
RandomFields/src/InternalCov.cc:    if (TOTALXDIM(PREVSYSOF(cov->calling)) != TOTALXDIM(SYSOF(cov->calling)))
RandomFields/src/InternalCov.cc:  // set / try out anything concerning OWN, except DOMain 
RandomFields/src/InternalCov.cc:  //  PMI(cov);
RandomFields/src/InternalCov.cc:    if (!cov->IallowedDone || isPrevModelI(C)) {
RandomFields/src/InternalCov.cc:      // printf("get allowed %s\n", NAME(cov));
RandomFields/src/InternalCov.cc:	// PMI(cov);      printI(cov);
RandomFields/src/InternalCov.cc:	// PMI0(cov); //
RandomFields/src/InternalCov.cc:	//printf("end printi %s\n", NAME(cov));
RandomFields/src/InternalCov.cc:  if (PREVTOTALXDIM < 2) cov->allowedI[DOUBLEISOTROPIC] = false;
RandomFields/src/InternalCov.cc:  if (C->Dallowed != NULL && (!cov->DallowedDone || isPrevModelD(C))) {
RandomFields/src/InternalCov.cc:    assert(equalsXonly(FIRST_DOMAIN));
RandomFields/src/InternalCov.cc:      for(int i=FIRST_DOMAIN ; i<=LAST_DOMAINUSER; cov->allowedD[i++] = false);
RandomFields/src/InternalCov.cc:      cov->allowedD[PREVDOM(0)] = true;
RandomFields/src/InternalCov.cc:      int i = (int)FIRST_DOMAIN;
RandomFields/src/InternalCov.cc:      for (; i <= (int) LAST_DOMAINUSER; i++) if (cov->allowedD[i]) break;
RandomFields/src/InternalCov.cc:      if (i > LAST_DOMAINUSER) BUG;
RandomFields/src/InternalCov.cc:      if (PREVDOM(0) < i || (i > XONLY && isAnyIsotropic(PREVISO(0)))) {
RandomFields/src/InternalCov.cc:	//	printf("here\n"); TREE0(cov); APMI(cov);
RandomFields/src/InternalCov.cc:	RETURN(10, CERRORWRONGDOM);
RandomFields/src/InternalCov.cc:    domain_type dom = DEFDOM(0);
RandomFields/src/InternalCov.cc:    if (dom <= LAST_DOMAINUSER && PREVDOM(0) < dom) RETURN(11, ERRORWRONGDOM);
RandomFields/src/InternalCov.cc:      //  PRINTF("C HECKct%s %s(%d)\n", NAME(cov), TYPE_NAMES[PREVTYPE(0)], PREVTYPE(0));
RandomFields/src/InternalCov.cc:	       TYPE_NAMES[PREVTYPE(0)], TYPE_NAMES[DEFTYPE(0)],
RandomFields/src/InternalCov.cc:	//     	PMI(cov->calling);
RandomFields/src/InternalCov.cc:	printf("Err : here ct = %d %s;  %d %s --> %d %s\n", ct, NAME(cov), PREVISO(0),ISO_NAMES[PREVISO(0)],  owniso, ISO_NAMES[owniso]);//
RandomFields/src/InternalCov.cc:	PMI0(cov); // 
RandomFields/src/InternalCov.cc:      PRINTF(" ------------ variant=%d owniso='%s' in '%s' [n=%d] \n", cov->variant, ISO_NAMES[owniso], NAME(cov), n);
RandomFields/src/InternalCov.cc:      if (isSubModelI(owniso)) {
RandomFields/src/InternalCov.cc:	//	printf("%s :: SubmodelI\n", NAME(cov));	
RandomFields/src/InternalCov.cc:	COPYALLSYSTEMS(OWN, DEF, true);
RandomFields/src/InternalCov.cc:	set_xdim(OWN, 0, PREVXDIM(0));
RandomFields/src/InternalCov.cc:	set_logdim(OWN, 0, PREVLOGDIM(0));
RandomFields/src/InternalCov.cc:	  //	  printf("\n\nsSETDI !!! %d %s\n\n", owniso, ISO_NAMES[owniso]);
RandomFields/src/InternalCov.cc:	  if (!isSubModelI(owniso)) {
RandomFields/src/InternalCov.cc:	    isotropy_type iso[MAXSYSTEMS + 1];
RandomFields/src/InternalCov.cc:	      // printf("%s not allowed in DI case\n", ISO_NAMES[owniso]);
RandomFields/src/InternalCov.cc:#if MAXSYSTEMS > 1
RandomFields/src/InternalCov.cc:	if (isSubModelI(owniso)) {
RandomFields/src/InternalCov.cc:	  //	  printf("%s ::|| SubmodelI\n", NAME(cov));	
RandomFields/src/InternalCov.cc:	//	  printf("XAA %d %s\n", COVNR, NAME(cov));	
RandomFields/src/InternalCov.cc:	  isotropy_type iso[MAXSYSTEMS],
RandomFields/src/InternalCov.cc:	    start[MAXSYSTEMS] = { ISO_MISMATCH }, // rest initialised with 0
RandomFields/src/InternalCov.cc:	    end[MAXSYSTEMS] = { ISO_MISMATCH };
RandomFields/src/InternalCov.cc:	  assert(n < MAXSYSTEMS);
RandomFields/src/InternalCov.cc:	    // printf("hiere %d %d PREVISO = %s; %s; %s ######\n", s, n, ISO_NAMES[previso], ISO_NAMES[newiso], ISO_NAMES[OWNISO(0)]);
RandomFields/src/InternalCov.cc:	      start[s] =  OWNXDIM(0) > 2 ? SPHERICAL_SYMMETRIC :FIRST_SPHERICAL;
RandomFields/src/InternalCov.cc:	      //  ? SPHERICAL_SYMMETRIC
RandomFields/src/InternalCov.cc:	      //	      printf("xdim = %d\n", OWNXDIM(0));
RandomFields/src/InternalCov.cc:	      //  start[s] = OWNXDIM(0) > 2 ? EARTH_SYMMETRIC : FIRST_EARTH;
RandomFields/src/InternalCov.cc:	      start[s] = OWNXDIM(0) > 2 ? SPHERICAL_SYMMETRIC : FIRST_SPHERICAL;
RandomFields/src/InternalCov.cc:	      // ? EARTH_SYMMETRIC 
RandomFields/src/InternalCov.cc:	      //	      ? LOGCART_SYMMETRIC
RandomFields/src/InternalCov.cc:	      //PMI0(cov->calling);
RandomFields/src/InternalCov.cc:	      //	      PMI0(cov);
RandomFields/src/InternalCov.cc:	      // printf("newiso = %s %s\n", ISO_NAMES[newiso], ISO_NAMES[previso]);
RandomFields/src/InternalCov.cc:	  Err = XERRORCHANGESYSTEM;
RandomFields/src/InternalCov.cc:	    PRINTF("while !!!!!!!!!!!!!!!!!!! %s %d %s; [... %s] max-ct=%d ct=%d allwd=%d\n", NAME(cov), n, ISO_NAMES[iso[0]], ISO_NAMES[end[0]], coord_trafo, ct, cov->allowedI[iso[0]]); printI(cov); //
RandomFields/src/InternalCov.cc:	    //	    printf("%s %d\n", ISO_NAMES[iso[0]], cov->allowedI[iso[0]]);
RandomFields/src/InternalCov.cc:	    //	    if (iso[0] != ISOTROPIC) APMI0(cov);
RandomFields/src/InternalCov.cc:#if MAXSYSTEMS > 1
RandomFields/src/InternalCov.cc:	      PRINTF(" ++++++++++++++= xxxxxx ct=%d [%s]\n", ct, ISO_NAMES[iso[0]]);
RandomFields/src/InternalCov.cc:	      PRINTF("back from set_own_dom %d %s err = %d\n", COVNR, NAME(cov), Err);
RandomFields/src/InternalCov.cc:	    assert(n < MAXSYSTEMS);
RandomFields/src/InternalCov.cc:	    n = MIN(n, MAXSYSTEMS - 1);
RandomFields/src/InternalCov.cc:	      assert(s < MAXSYSTEMS);
RandomFields/src/InternalCov.cc:	      assert(s < MAXSYSTEMS);
RandomFields/src/InternalCov.cc:	left[cov->variant] = Err==CERRORCHANGESYSTEM;//indifferent when ct=true
RandomFields/src/InternalCov.cc:        bool def_Unreduced = isPrevModelI(C) || equalsUnreduced(C);
RandomFields/src/InternalCov.cc:	//	printf("def_unred %d %d; def_unred=%d %d %s\n",  isPrevModelI(C) , equalsUnreduced(C), def_Unreduced, hasFullXdim(owniso), NAME(cov));
RandomFields/src/InternalCov.cc:	  // printf("prev->own %s\n", NAME(cov));
RandomFields/src/InternalCov.cc:	  COPYALLSYSTEMS(OWN, PREV, true);
RandomFields/src/InternalCov.cc:	    nn = PREVLASTSYSTEM;
RandomFields/src/InternalCov.cc:	    COPYALLSYSTEMS(OWN, PREV, true);
RandomFields/src/InternalCov.cc:	    COPYALLSYSTEMS(OWN, DEF, true);
RandomFields/src/InternalCov.cc:	    //PMI0(cov);
RandomFields/src/InternalCov.cc:	    isotropy_type iso[MAXSYSTEMS];
RandomFields/src/InternalCov.cc:	    set_iso(OWN, 0, equalsPrevModelI(owniso) ? PREVISO(0) : owniso);
RandomFields/src/InternalCov.cc:  //  if (Err != 0) { printI(cov); printD(cov); printf("Err=%d %d in %s\n", Err, cov->err_level, NAME(cov));PMI(cov);}
RandomFields/src/InternalCov.cc:  //  PMI0(cov);
RandomFields/src/InternalCov.cc:  //printf("SetX %s %s(%d) %s\n", NAME(cov), TYPE_NAMES[OWNTYPE(0)], OWNTYPE(0),
RandomFields/src/InternalCov.cc:  //	 ISO_NAMES[*Iso]);
RandomFields/src/InternalCov.cc:      set_logdim(OWN, sneu, PREVLOGDIM(s));
RandomFields/src/InternalCov.cc:      // printf("%s %s %d \n", NAME(cov), ISO_NAMES[iso], isAnyIsotropic(iso));
RandomFields/src/InternalCov.cc:      else if (equalsUnreduced(iso)) { set_xdim(OWN, sneu, PREVXDIM(s));}
RandomFields/src/InternalCov.cc:#if MAXSYSTEMS == 1	
RandomFields/src/InternalCov.cc:	if (PREVXDIM(s) < 2) {
RandomFields/src/InternalCov.cc:	  ERR_RETURN2(20, "'%.50s' not possible in %.50s", ISO_NAMES[iso], NAME(cov));
RandomFields/src/InternalCov.cc:	assert(PREVLOGDIM(s) == PREVXDIM(s) ||
RandomFields/src/InternalCov.cc:	if (s==0 && (PREVXDIM(s) > 1)) {
RandomFields/src/InternalCov.cc:	  assert(PREVLOGDIM(s) == PREVXDIM(s));
RandomFields/src/InternalCov.cc:	  set_logdim(OWN, sneu, PREVLOGDIM(s) - 1);
RandomFields/src/InternalCov.cc:	  (sneu)++; assert(sneu < MAXSYSTEMS);
RandomFields/src/InternalCov.cc:      } else set_xdim(OWN, sneu, PREVXDIM(s));
RandomFields/src/InternalCov.cc:	case VECTORISOTROPIC: case SYMMETRIC: case CARTESIAN_COORD:
RandomFields/src/InternalCov.cc:	set_logdim(OWN, sneu, PREVLOGDIM(s));
RandomFields/src/InternalCov.cc:	set_xdim(OWN, sneu, isAnyIsotropic(iso) ? 1 : PREVXDIM(s)); 
RandomFields/src/InternalCov.cc:      //    APMI(cov);
RandomFields/src/InternalCov.cc:#if defined RANDOMFIELDS_DEBUGGING
RandomFields/src/InternalCov.cc:     || (cov->err_level >= LEVEL_DOM && cov->err_level <= LEVEL_LAST)) {
RandomFields/src/InternalCov.cc:    // APMI0(cov);
RandomFields/src/InternalCov.cc:  printf("initial level%s\n", NAME(cov));//
RandomFields/src/InternalCov.cc:  printf("XX initial level%s %d\n", NAME(cov), Err); //
RandomFields/src/InternalCov.cc:  //  printf("out cov=%s (z=%d L=%d E=%d) calling=%s(z=%d, L=%d E=%d) err=%d \n", NAME(cov), cov->zaehler, cov->err_level,  cov->err,  cov->calling == NULL ? "NONE" : NAME(cov->calling),cov->calling == NULL ? -999 : cov->calling->zaehler, cov->calling == NULL ? -999 : cov->calling->err_level, cov->calling == NULL ? -999 : cov->calling->err, Err);
RandomFields/src/InternalCov.cc:  if (Err >= ERRORM && Err <= ERRORMEND && calling != NULL &&
RandomFields/src/InternalCov.cc:  // printf("\t\t\t    calling=%s(z=%d, L=%d E=%d) \n",NAME(cov->calling),cov->calling->zaehler, cov->calling->err_level, cov->calling->err);
RandomFields/src/InternalCov.cc:  // PMIE(calling); PMIE(cov);
RandomFields/src/InternalCov.cc:  // printf("entring set_own_domain %s\n", NAME(cov));
RandomFields/src/InternalCov.cc:  domain_type prevdom = PREVDOM(0);
RandomFields/src/InternalCov.cc:  if (isManifold(OWNTYPE(0))) set_type(OWN, 0, PREVTYPE(0));
RandomFields/src/InternalCov.cc:  if ( C->setDI != NULL && (!isFixed(iso) || !isFixed(OWNDOM(0)))
RandomFields/src/InternalCov.cc:       && !C->setDI(cov) ) { // muss i.A. ein 2. Mal
RandomFields/src/InternalCov.cc:    // aufgerufen werden (1. Mal in check2x, da beim 1. Aufruf u.U.
RandomFields/src/InternalCov.cc:  //  printf("B here %s;  %d %s --> %d %s\n", NAME(cov), previso,ISO_NAMES[previso],  iso, ISO_NAMES[iso]); 
RandomFields/src/InternalCov.cc:	PMI0(cov->calling);//
RandomFields/src/InternalCov.cc:	printf("wrong iso: own=%s prev=%s coordtrafo=%d\n", ISO_NAMES[iso], ISO_NAMES[previso], coord_trafo);//
RandomFields/src/InternalCov.cc:	APMI(cov);//
RandomFields/src/InternalCov.cc:  // Function itself sets OWNDOM and special check for spherical coord
RandomFields/src/InternalCov.cc:    first_dom = LAST_DOMAIN,
RandomFields/src/InternalCov.cc:    last_dom = FIRST_DOMAIN,
RandomFields/src/InternalCov.cc:    defdom = DEFDOM(0); 
RandomFields/src/InternalCov.cc:  //printf("gonna up here (%s) %s \n", NAME(cov), DOMAIN_NAMES[defdom]);
RandomFields/src/InternalCov.cc:  case DOMAIN_MISMATCH : 
RandomFields/src/InternalCov.cc:  case PREVMODEL_D :
RandomFields/src/InternalCov.cc:  case PARAMDEP_D : {
RandomFields/src/InternalCov.cc:    domain_type owndom = OWNDOM(0);
RandomFields/src/InternalCov.cc:      PMI(cov->calling); //
RandomFields/src/InternalCov.cc:  case KEEPCOPY_DOM : BUG; break;
RandomFields/src/InternalCov.cc:  case SUBMODEL_D : case PREV_SUB_D :
RandomFields/src/InternalCov.cc:  //printf("dom %s %s\n", DOMAIN_NAMES[first_dom], DOMAIN_NAMES[last_dom]);
RandomFields/src/InternalCov.cc:  //  PMI0(cov);
RandomFields/src/InternalCov.cc:  //printf("dom %s %s\n", DOMAIN_NAMES[first_dom], DOMAIN_NAMES[last_dom]);
RandomFields/src/InternalCov.cc:  // if (isSubModelD(last_dom) && KERNEL <= GATTERDOM(0)) last_dom = KERNEL;
RandomFields/src/InternalCov.cc:  //  printf("\nfirst=%d last=%d def=%d %s %d\n", first_dom, last_dom, defdom, NAME(cov), !STRCMP(NAME(cov), "prod"));
RandomFields/src/InternalCov.cc:  //assert(STRCMP(NAME(cov), "prod"));
RandomFields/src/InternalCov.cc:      LPRINT("(%s dom.start=%d, end=%d)\n", NAME(cov), first_dom, last_dom);
RandomFields/src/InternalCov.cc:    //PMI0(cov);
RandomFields/src/InternalCov.cc:    RETURN(32, ERRORNOSTATMATCH);
RandomFields/src/InternalCov.cc:	 NAME(cov), first_dom, last_dom,
RandomFields/src/InternalCov.cc:    errs[LAST_DOMAINUSER + 1],
RandomFields/src/InternalCov.cc:    levels[LAST_DOMAINUSER + 1],
RandomFields/src/InternalCov.cc:  errorstring_type ERRSTR[LAST_DOMAINUSER + 1] = {""},
RandomFields/src/InternalCov.cc:  bool save_errorm = save_err >= ERRORM && save_err <= ERRORMEND,
RandomFields/src/InternalCov.cc:  //  printf("!! %s %d err_lev=%d err=%d '%s' negdef=%d dom=(%d, %d)\n", NAME(cov), cov->zaehler, cov->err_level, cov->err , cov->err_msg, isnowNegDef(cov), first_dom, last_dom);
RandomFields/src/InternalCov.cc:    //    printf(">>>>>> cov=%s dom=%d\n", NAME(cov), dom);
RandomFields/src/InternalCov.cc:      LEVEL(LEVEL_DOM, CERRORNOSTATMATCH); // 40
RandomFields/src/InternalCov.cc:    // FROM HERE ON, GATTER SHOULD ALWAYS BE WELL-DEFINED
RandomFields/src/InternalCov.cc:    //    printf("@@ %s %d  err_lev=%d err=%d '%s'\n", NAME(cov), cov->zaehler, cov->err_level, cov->err , cov->err_msg);
RandomFields/src/InternalCov.cc:    //    PMI0(cov);
RandomFields/src/InternalCov.cc:    //    printf("!!!! check = %d %s\n", errs[dom], NAME(cov));
RandomFields/src/InternalCov.cc:      if (errs[dom] >= ERRORM && errs[dom] <= ERRORMEND)
RandomFields/src/InternalCov.cc:      //      PMI(cov);
RandomFields/src/InternalCov.cc:   if (cov->monotone == PARAM_DEP) BUG;
RandomFields/src/InternalCov.cc:	//	printf("up %s %d err_lev=%d err=%d '%s'\n", NAME(cov), cov->zaehler, cov->err_level, cov->err , cov->err_msg);
RandomFields/src/InternalCov.cc:      //     printf("RE %s %d err_lev=%d err=%d '%s'\n", NAME(cov), cov->zaehler, cov->err_level, cov->err , cov->err_msg);
RandomFields/src/InternalCov.cc:	     NAME(cov), cov->err_level, cov->err, cov->err_msg);
RandomFields/src/InternalCov.cc:      //APMI(cov);     
RandomFields/src/InternalCov.cc:    int dim = PREVTOTALXDIM;
RandomFields/src/InternalCov.cc:#define MAXEARTHDIM 4 // sphere + height + time
RandomFields/src/InternalCov.cc:      double rl[MAXEARTHDIM], rr[MAXEARTHDIM];
RandomFields/src/InternalCov.cc:      if (dim > MAXEARTHDIM) BUG;      
RandomFields/src/InternalCov.cc:      // printf("xxxx= %s %d\n", NAME(cov), dim);
RandomFields/src/InternalCov.cc:	  // printf("%s d=%d %e %e %e %e\n", NAME(cov->sub[0]), d, range, rl[d], rr[d], rr[d]-9.9);
RandomFields/src/InternalCov.cc:    if (!(isSpherical(iso) && range <= M_PI) || (isEarth(iso) && range <= 180)){
RandomFields/src/InternalCov.cc:		  NICK(cov->sub[0]),COORD_SYS_NAMES[GetCoordSystem(iso)]);
RandomFields/src/InternalCov.cc:  //printf("CHECKED = true %s", NAME(cov));
RandomFields/src/InternalCov.cc:  //  printf("set_own ENDE %s %s(%d)\n", NAME(cov), TYPE_NAMES[OWNTYPE(0)], OWNTYPE(0));
RandomFields/src/InternalCov.cc:#define RERR(X) { STRCPY(ERRSTR, X); return ERRORM; }
RandomFields/src/InternalCov.cc:#define RERR1(X,A) {SPRINTF(ERRSTR,X,A); return ERRORM; }
RandomFields/src/InternalCov.cc:#define RERR2(X,A,B) {SPRINTF(ERRSTR,X,A,B); return ERRORM; }
RandomFields/src/InternalCov.cc:#define RERR3(X,A,B,C) {SPRINTF(ERRSTR,X,A,B,C); return ERRORM; }
RandomFields/src/InternalCov.cc:#define RERR4(X,A,B,C,D) {SPRINTF(ERRSTR,X,A,B,C,D); return ERRORM; }
RandomFields/src/InternalCov.cc:#define RERR5(X,A,B,C,D,E) {SPRINTF(ERRSTR,X,A,B,C,D,E); return ERRORM; }
RandomFields/src/InternalCov.cc:#define RERR6(X,A,B,C,D,E,F) {SPRINTF(ERRSTR,X,A,B,C,D,E,F); return ERRORM; }
RandomFields/src/InternalCov.cc:#define RERR7(X,A,B,C,D,E,F,G) {SPRINTF(ERRSTR,X,A,B,C,D,E,F,G); return ERRORM;}
RandomFields/src/InternalCov.cc:  bool def_Unreduced = isPrevModelI(C) || equalsUnreduced(C);
RandomFields/src/InternalCov.cc:    COPYALLSYSTEMS(GATTER, PREV, false);
RandomFields/src/InternalCov.cc:  } else if (isSubModelI(OWNISO(0))) {
RandomFields/src/InternalCov.cc:    COPYALLSYSTEMS(GATTER, PREV, false);
RandomFields/src/InternalCov.cc:  } else if (equalsParamDepI(OWNISO(0)) || equalsParamDepD(OWNDOM(0))) {
RandomFields/src/InternalCov.cc:    COPYALLSYSTEMS(GATTER, PREV, false);
RandomFields/src/InternalCov.cc:	NRERR(ERRORCHANGESYSTEM, "unexpected reduced system of coordinates");
RandomFields/src/InternalCov.cc:	if (OWNLOGDIM(eo) == UNSET) set_logdim(OWN, eo, PREVLOGDIM(ep));
RandomFields/src/InternalCov.cc:	else if (OWNLOGDIM(eo) != PREVLOGDIM(ep))
RandomFields/src/InternalCov.cc:	  NRERR(ERRORCHANGESYSTEM, "mismatch of logical dimensions");
RandomFields/src/InternalCov.cc:	if (OWNXDIM(eo) == UNSET) { set_xdim(OWN, eo, PREVXDIM(ep)); }
RandomFields/src/InternalCov.cc:	else if (OWNXDIM(eo) != PREVXDIM(ep))
RandomFields/src/InternalCov.cc:	  NRERR(ERRORCHANGESYSTEM, "mismatch of dimensions");
RandomFields/src/InternalCov.cc:	  ) NRERR(ERRORCHANGESYSTEM, "coordinate systems cannot be matched");
RandomFields/src/InternalCov.cc:      xdims += PREVXDIM(ep);         assert(PREVXDIM(ep) > 0);
RandomFields/src/InternalCov.cc:      logdims += PREVLOGDIM(ep);     assert(PREVLOGDIM(ep) > 0);
RandomFields/src/InternalCov.cc:    //    printf("c1=%s\n", ISO_NAMES[c1]);
RandomFields/src/InternalCov.cc:	     ISO_NAMES[c0], ISO_NAMES[c2], eo, maxo,
RandomFields/src/InternalCov.cc:	     so,isSameAsPrev(OWNTYPE(eo)), c1, c0, c2, ISO_NAMES[c1], ep);
RandomFields/src/InternalCov.cc:      if (OWNXDIM(eo) != UNSET) {
RandomFields/src/InternalCov.cc:	//	printf("eo=%d %d\n", eo, OWNXDIM(eo));
RandomFields/src/InternalCov.cc:	xdims -= OWNXDIM(eo);
RandomFields/src/InternalCov.cc:	assert(OWNXDIM(eo) > 0);
RandomFields/src/InternalCov.cc:      if (OWNLOGDIM(eo) != UNSET) {
RandomFields/src/InternalCov.cc:	logdims -= OWNLOGDIM(eo);
RandomFields/src/InternalCov.cc: 	assert(OWNLOGDIM(eo) > 0);
RandomFields/src/InternalCov.cc:      //APMI(cov);
RandomFields/src/InternalCov.cc:      NRERR(ERRORCHANGESYSTEM,
RandomFields/src/InternalCov.cc:    //    PMI(cov);
RandomFields/src/InternalCov.cc:      NRERR(ERRORCHANGESYSTEM,
RandomFields/src/InternalCov.cc:	if (OWNXDIM(i) == UNSET) {
RandomFields/src/InternalCov.cc:	if (OWNLOGDIM(i) == UNSET) {
RandomFields/src/InternalCov.cc:    NRERR(ERRORCHANGESYSTEM, "non-matching coordinate systems"); 
RandomFields/src/InternalCov.cc:    curlogdim = PREVLOGDIM(curprev);
RandomFields/src/InternalCov.cc:  COPYALLSYSTEMS(GATTER, OWN, false);
RandomFields/src/InternalCov.cc:    set_xdim(GATTER, i, PREVXDIM(curprev));
RandomFields/src/InternalCov.cc:    set_dom(GATTER, i, PREVDOM(curprev));
RandomFields/src/InternalCov.cc:    curlogdim -= OWNLOGDIM(i);      
RandomFields/src/InternalCov.cc:      if (!fullxdim) NRERR(ERRORCHANGESYSTEM, "coordinate change does not work.");
RandomFields/src/InternalCov.cc:	if (curprev > PREVLASTSYSTEM) BUG;
RandomFields/src/InternalCov.cc:	    PREVDOM(curprev) != GATTERDOM(i) ||
RandomFields/src/InternalCov.cc:	  NRERR(ERRORCHANGESYSTEM, "coordinate change does not work");
RandomFields/src/InternalCov.cc:	curlogdim += PREVLOGDIM(curprev);
RandomFields/src/InternalCov.cc:      if (curprev > PREVLASTSYSTEM) {
RandomFields/src/InternalCov.cc:      } else curlogdim = PREVLOGDIM(curprev);	
RandomFields/src/InternalCov.cc:    //    PSYS(cov); PMI(cov->calling);
RandomFields/src/InternalCov.cc:      if (GATTERXDIM(i) == UNSET) {set_xdim(GATTER, i, GATTERLOGDIM(i));}
RandomFields/src/InternalCov.cc:      else if (GATTERXDIM(i) != GATTERLOGDIM(i)) {
RandomFields/src/InternalCov.cc:	//	printf("i=%d %d %d\n", i, GATTERXDIM(i), GATTERLOGDIM(i)); 
RandomFields/src/InternalCov.cc:	//	APMI0(cov);
RandomFields/src/InternalCov.cc:      if (GATTERXDIM(i) != PREVXDIM(i)) BUG;
RandomFields/src/InternalCov.cc:    set_cumxmit(GATTER, i, GATTERXDIM(i));
RandomFields/src/InternalCov.cc:    //if (i>0) set_cumxmit(GATTER, i, CUMXMIT(GATTER, i) + CUMXMIT(GATTER, i-1)); 
RandomFields/src/InternalCov.cc:  int err = CERRORCHANGESYSTEM;
RandomFields/src/InternalCov.cc:     int err = setgatter_but_nr(cov, 0, PREVSYSTEMS, 0, OWNSYSTEMS);
RandomFields/src/InternalCov.cc:      err = setgatter_but_nr(cov, 0, PREVSYSTEMS, 0, OWNSYSTEMS, ERRSTR);
RandomFields/src/InternalCov.cc:     if (coordinate_trafo == falsch || err != CERRORCHANGESYSTEM) {
RandomFields/src/InternalCov.cc:      //PMI(cov);
RandomFields/src/InternalCov.cc:  if (isnowNegDef(cov) && equalsXonly(PREVDOM(0))) RET_ENR(ERRORWRONGDOM);
RandomFields/src/InternalCov.cc:  COPYALLSYSTEMS_COND((cov)->gatter, OWN, true); // nicht GATTER, da unset
RandomFields/src/InternalCov.cc:    logdimprev = PREVLOGDIM(0),
RandomFields/src/InternalCov.cc:    xdimprev = PREVXDIM(0);
RandomFields/src/InternalCov.cc:  case EARTH_COORD : case EARTH_SYMMETRIC: {
RandomFields/src/InternalCov.cc:      if (STRCMP(global->coords.newunits[0], UNITS_NAMES[units_km]) == 0){
RandomFields/src/InternalCov.cc:	set_trafo(equalsGnomonic(isogatter) ? EARTHKM2GNOMONIC
RandomFields/src/InternalCov.cc:		  : equalsOrthographic(isogatter) ?  EARTHKM2ORTHOGRAPHIC
RandomFields/src/InternalCov.cc:		  : EARTHKM2CART);
RandomFields/src/InternalCov.cc:      } else if (STRCMP(global->coords.newunits[0], 
RandomFields/src/InternalCov.cc:			UNITS_NAMES[units_miles]) == 0) {
RandomFields/src/InternalCov.cc:	set_trafo(equalsGnomonic(isogatter) ? EARTHMILES2GNOMONIC  
RandomFields/src/InternalCov.cc:		  : equalsOrthographic(isogatter) ?  EARTHMILES2ORTHOGRAPHIC
RandomFields/src/InternalCov.cc:		  : EARTHMILES2CART);
RandomFields/src/InternalCov.cc:	      UNITS_NAMES[units_km], UNITS_NAMES[units_miles], 
RandomFields/src/InternalCov.cc:      set_dom(GATTER, 0, PREVDOM(0));
RandomFields/src/InternalCov.cc:    if (err == NOERROR || (err == ERRORNOSTATMATCH && !checkerror))
RandomFields/src/InternalCov.cc:  //ERR("XDIM != UNSET beruecksichtigen"); // irgendwas fehlt noch
RandomFields/src/InternalCov.cc:  // hinzubekommen. Muss gelockert werden, dass gleiches ISO
RandomFields/src/InternalCov.cc:  int n = OWNSYSTEMS;
RandomFields/src/InternalCov.cc:  assert(n == GATTERSYSTEMS);
RandomFields/src/InternalCov.cc:    domain_type owndom = OWNDOM(s),
RandomFields/src/InternalCov.cc:      gdom = GATTERDOM(s);
RandomFields/src/InternalCov.cc:    //PMI(cov);
RandomFields/src/InternalCov.cc:	    DOMAIN_NAMES[(int) owndom], DOMAIN_NAMES[(int) gdom]);
RandomFields/src/InternalCov.cc:	//RERR1("'%.50s' is not genuinely cartesian", ISO_NAMES[(int) owniso]);
RandomFields/src/InternalCov.cc:	      ISO_NAMES[(int) owniso], ISO_NAMES[(int) giso]);
RandomFields/src/InternalCov.cc:	case VECTORISOTROPIC: case SYMMETRIC: 
RandomFields/src/InternalCov.cc:	case CARTESIAN_COORD: case GNOMONIC_PROJ: case ORTHOGRAPHIC_PROJ:
RandomFields/src/InternalCov.cc:		   DOMAIN_NAMES[gdom], ISO_NAMES[giso], 
RandomFields/src/InternalCov.cc:		   DOMAIN_NAMES[owndom], ISO_NAMES[owniso]);
RandomFields/src/InternalCov.cc:	    //   A 	    PMI(cov);
RandomFields/src/InternalCov.cc:	  else nr = isSpherical(owniso) ? Sph2SphIso : ISO_MISMATCH; 	
RandomFields/src/InternalCov.cc:	  else nr =  (isSpherical(owniso) ? Sph2Sph : ISO_MISMATCH);	
RandomFields/src/InternalCov.cc:	else nr =  (isSpherical(owniso) ? Sph2Sph : ISO_MISMATCH);
RandomFields/src/InternalCov.cc:#define PERR(X) { SPRINTF(ERRSTR, "'%.50s' : %.500s", param_name, X); return ERRORM;}
RandomFields/src/InternalCov.cc:#define PERRX(ERR, X) { errorstring_type msg_1; errorMSG(ERR, msg_1);	\
RandomFields/src/InternalCov.cc:    SPRINTF(ERRSTR, "'%.50s' : %.500s (%.50s)", param_name, X, msg_1); return ERRORM;}
RandomFields/src/InternalCov.cc:  char param_name[PARAMMAXCHAR]; // used in PERR
RandomFields/src/InternalCov.cc:    if (SortOf(cov, i, 0, 0, original_model) == DONOTVERIFYPARAM) {
RandomFields/src/InternalCov.cc:	if (nr==SIZE_NOT_DETERMINED || nc==SIZE_NOT_DETERMINED) 
RandomFields/src/InternalCov.cc:	if (nr==SIZE_NOT_DETERMINED || nc==SIZE_NOT_DETERMINED) {
RandomFields/src/InternalCov.cc:	    //	    printf("check_r %s : vdim = %d\n", NAME(ks), d);
RandomFields/src/InternalCov.cc:	      //    printf("zweites check_r %s : vdim = %d\n", NAME(ks), d);
RandomFields/src/InternalCov.cc:	      if (MODELNR(ks) == DISTRIBUTION) {
RandomFields/src/InternalCov.cc:		if (PARAMINT(ks, DISTR_NROW) != NULL) 
RandomFields/src/InternalCov.cc:		  nr = PARAM0INT(ks, DISTR_NROW);
RandomFields/src/InternalCov.cc:		if (PARAMINT(ks, DISTR_NCOL) != NULL) 
RandomFields/src/InternalCov.cc:		  nc = PARAM0INT(ks, DISTR_NCOL);
RandomFields/src/InternalCov.cc:	  //if (nr==SIZE_NOT_DETERMINED || nc==SIZE_NOT_DETERMINED)
RandomFields/src/InternalCov.cc:	  //	  PMI(ks);
RandomFields/src/InternalCov.cc:	  // printf("drittes check_r %s : vdim = %d\n", NAME(ks), len);
RandomFields/src/InternalCov.cc:	//printf("init_random %s : vdim = %d\n", NAME(ks), 5);
RandomFields/src/InternalCov.cc:	    (err = INIT_RANDOM(ks, 0, cov->Sgen, P(i))) != NOERROR) { 
RandomFields/src/InternalCov.cc:    if ( (nc < 1 && nc != SIZE_NOT_DETERMINED) || 
RandomFields/src/InternalCov.cc:	 (nr < 1 && nr != SIZE_NOT_DETERMINED)) {
RandomFields/src/InternalCov.cc:      printf("check of kappas failed: %s %d %d %d\n", NAME(cov), i, nc, nr); //
RandomFields/src/InternalCov.cc:      // nc==0, nr==0 is coded as SIZE_NOT_DETERMINED
RandomFields/src/InternalCov.cc:      if (nr!=SIZE_NOT_DETERMINED) SPRINTF(msg2, "%.50s%d, ", msg, nr);
RandomFields/src/InternalCov.cc:      if (nc!=SIZE_NOT_DETERMINED) SPRINTF(msg, "%.50s%d)", msg2, nc);
RandomFields/src/InternalCov.cc:      //      crash();      APMI0(cov);
RandomFields/src/InternalCov.cc:  int n = OWNSYSTEMS;
RandomFields/src/InternalCov.cc:  assert(n == SYSTEMS(def));
RandomFields/src/InternalCov.cc:    if (MAXDIM(def, s) >= 0 && MAXDIM(OWN, s) > MAXDIM(def, s)) {
RandomFields/src/InternalCov.cc:      set_maxdim(OWN, s, MAXDIM(def, s));
RandomFields/src/InternalCov.cc:      assert(MAXDIM(def, s) > 0);
RandomFields/src/InternalCov.cc:  if (VDIM0 <= 0 || VDIM1 <= 0) RET_ENR(ERRORBADVDIM);
RandomFields/src/InternalCov.cc:  if ((vdim0 > 0 && VDIM0 != vdim0) || (vdim1 > 0 && VDIM1 != vdim1))
RandomFields/src/InternalCov.cc:	  NICK(cov), VDIM0, VDIM1, NAME(cov), vdim0, vdim1, 
RandomFields/src/InternalCov.cc:	  calling == NULL ? "-- none --" :  NAME(calling));
RandomFields/src/InternalCov.cc:  char Msg[255];
RandomFields/src/InternalCov.cc:    RERR3("Max. dimension in '%.50s' is %d. Got %d",
RandomFields/src/InternalCov.cc:	  NAME(cov), OWNMAXDIM(s), OWNLOGDIM(s));
RandomFields/src/InternalCov.cc:    if (!STRCMP(C->kappanames[K], FREEVARIABLE)) {  // i.e. equal
RandomFields/src/InternalCov.cc:      STRCPY(Msg, "is not finite"); goto ErrorHandling;
RandomFields/src/InternalCov.cc:    err = CERRORM; 
RandomFields/src/InternalCov.cc:	//	printf("%s k=%d %d %d\n", NAME(cov), K, i, j);
RandomFields/src/InternalCov.cc:	  else { STRCPY(Msg, "is not finite"); goto ErrorHandling; }
RandomFields/src/InternalCov.cc:	  addmsg(value, ">", range.min, Msg);
RandomFields/src/InternalCov.cc:	  addmsg(value, ">=", range.min, Msg); 
RandomFields/src/InternalCov.cc:	  addmsg(value, "<", range.max, Msg); 
RandomFields/src/InternalCov.cc:	  addmsg(value, "<=", range.max, Msg);
RandomFields/src/InternalCov.cc:	   __FILE__, C->name, C->kappanames[K], K, err, Msg);
RandomFields/src/InternalCov.cc:  RERR4("%.50s[%d,%d]=%.50s does not hold.", C->kappanames[K], i+1, j+1, Msg);
RandomFields/src/InternalCov.cc:  char Msg[255];
RandomFields/src/InternalCov.cc:    RERR3("Max. dimension in '%.50s' is %d. Got %d", NAME(cov), OWNMAXDIM(s), OWNLOGDIM(s));
RandomFields/src/InternalCov.cc:    if (!STRCMP(C->kappanames[i], FREEVARIABLE)) {
RandomFields/src/InternalCov.cc:    err = CERRORM; 
RandomFields/src/InternalCov.cc:      else { STRCPY(Msg, "is not finite"); goto ErrorHandling; }
RandomFields/src/InternalCov.cc:	else { STRCPY(Msg, "is not finite"); goto ErrorHandling; }
RandomFields/src/InternalCov.cc:	addmsg(value, ">", min, Msg);
RandomFields/src/InternalCov.cc:	addmsg(value, ">=", min, Msg); 
RandomFields/src/InternalCov.cc:	addmsg(value, "<", max, Msg); 
RandomFields/src/InternalCov.cc:	addmsg(value, "<=", max, Msg);
RandomFields/src/InternalCov.cc:	   __FILE__, C->name, C->kappanames[i], i, err, Msg);
RandomFields/src/InternalCov.cc: 	     C->kappanames[i], k+1, Msg, OWNLOGDIM(0)); // + r eturn
RandomFields/src/InternalCov.cc:   RERR3("%.50s[%d]=%.50s does not hold.", C->kappanames[i], k+1, Msg);
RandomFields/src/InternalCov.cc:int check_recursive_range(model *cov, bool NAOK) {  // FOR MLE ONLY !!
RandomFields/src/InternalCov.cc:      called by "Set And GetModelInfo"
RandomFields/src/InternalCov.cc:  for (i=0; i<MAXSUB; i++) {
Binary file RandomFields/src/D.H.o matches
RandomFields/src/Makevars.in:PKG_LIBS =  $(LAPACK_LIBS) $(BLAS_LIBS)  $(SHLIB_OPENMP_CXXFLAGS) $(FLIBS) 
RandomFields/src/Makevars.in:PKG_CXXFLAGS =    $(SHLIB_OPENMP_CXXFLAGS) @RANDOMFIELDS_CXXFLAGS@ 
RandomFields/src/Machine.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/Machine.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/src/Machine.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/Machine.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/Machine.h:#ifndef RFMachines_H
RandomFields/src/Machine.h:#define RFMachines_H 1
RandomFields/src/Machine.h:#define CUMXMITi(sys) (sys).cumxdim
RandomFields/src/Machine.h:#define XDIMi(sys) (sys).xdim // OK
RandomFields/src/Machine.h:#define LOGDIMi(sys) (sys).logicaldim
RandomFields/src/Machine.h:#define MAXDIMi(sys) (sys).maxdim
RandomFields/src/Machine.h:#define DOMi(sys) (sys).dom
RandomFields/src/Machine.h:#define MODELNR(cov) SYSMODEL(SYSOF(cov))
RandomFields/src/Machine.h:#define ANYDIM ANYDIMOF(cov)
RandomFields/src/Machine.h:#define SYSTEMS(s) (LASTSYSTEM(s) + 1)
RandomFields/src/Machine.h:#define CALLINGNR SYSMODEL(CALLING)
RandomFields/src/Machine.h:#define PREVCUMXOHNE(s) CUMXOHNE(PREV, s)
RandomFields/src/Machine.h:#define PREVCUMXMIT(s) CUMXMIT(PREV, s)
RandomFields/src/Machine.h:#define PREVXDIM(s) XDIM(PREV, s)
RandomFields/src/Machine.h:#define PREV_INITIALISED (isSetLastSystem(PREVSYSOF(cov)) && XDIM(PREV, 0) != UNSET) // siehe settrafo in op...cc
RandomFields/src/Machine.h:#define CONDPREVISO(s) (PREV_INITIALISED ? PREVISO(s) : ISO_MISMATCH)
RandomFields/src/Machine.h:#define CONDPREVDOM(s) (PREV_INITIALISED ? PREVDOM(s) : DOMAIN_MISMATCH)
RandomFields/src/Machine.h:#define PREVDOM(s) DOM(PREV, s)
RandomFields/src/Machine.h:#define PREVLOGDIM(s) LOGDIM(PREV, s)
RandomFields/src/Machine.h:#define PREVTOTALXDIM TOTALXDIM(PREV)
RandomFields/src/Machine.h:#define PREVLASTSYSTEM LASTSYSTEM(PREV)
RandomFields/src/Machine.h:#define PREVSYSTEMS SYSTEMS(PREV)
RandomFields/src/Machine.h:#define TRAFONR SYSMODEL(PREV)
RandomFields/src/Machine.h:#define GATTERCUMXOHNE(s) CUMXOHNE(GATTER, s)
RandomFields/src/Machine.h:#define GATTERCUMXMIT(s) CUMXMIT(GATTER, s)
RandomFields/src/Machine.h:#define GATTERXDIM(s) XDIM(GATTER, s)
RandomFields/src/Machine.h:#define GATTERDOM(s) DOM(GATTER, s)
RandomFields/src/Machine.h:#define GATTERLOGDIM(s) LOGDIM(GATTER, s)
RandomFields/src/Machine.h:#define GATTERTOTALXDIM TOTALXDIM(GATTER)
RandomFields/src/Machine.h:#define GATTERLASTSYSTEM LASTSYSTEM(GATTER)
RandomFields/src/Machine.h:#define GATTERSYSTEMS SYSTEMS(GATTER)
RandomFields/src/Machine.h:#define GATTERNR SYSMODEL(GATTER)
RandomFields/src/Machine.h:#define OWNCUMXOHNE(s) CUMXOHNE(OWN, s)
RandomFields/src/Machine.h:#define OWNCUMXMIT(s) CUMXMIT(OWN, s)
RandomFields/src/Machine.h:#define OWNXDIM(s) XDIM(OWN, s)
RandomFields/src/Machine.h:#define OWNDOM(s) DOM(OWN, s)
RandomFields/src/Machine.h:#define CONDOWNISO(s) (PREV_INITIALISED ? OWNISO(s) : ISO_MISMATCH)
RandomFields/src/Machine.h:#define CONDOWNDOM(s) (PREV_INITIALISED ? OWNDOM(s) : DOMAIN_MISMATCH)
RandomFields/src/Machine.h:#define OWNLOGDIM(s) LOGDIM(OWN, s)
RandomFields/src/Machine.h:#define OWNMAXDIM(s) MAXDIM(OWN, s)
RandomFields/src/Machine.h:#define OWNTOTALXDIM TOTALXDIM(OWN)
RandomFields/src/Machine.h:#define OWNLASTSYSTEM LASTSYSTEM(OWN)
RandomFields/src/Machine.h:#define OWNSYSTEMS SYSTEMS(OWN)
RandomFields/src/Machine.h:#define COVNR (SYSMODEL(OWN))
RandomFields/src/Machine.h:#define VDIM0 cov->vdim[0]
RandomFields/src/Machine.h:#define VDIM1 cov->vdim[1]
RandomFields/src/Machine.h:#define SUBCUMXOHNE(s) CUMXOHNE(SUB, s)
RandomFields/src/Machine.h:#define SUBCUMXMIT(s) CUMXMIT(SUB, s)
RandomFields/src/Machine.h:#define SUBXDIM(s) XDIM(SUB, s)
RandomFields/src/Machine.h:#define SUBDOM(s) DOM(SUB, s)
RandomFields/src/Machine.h:#define SUBLOGDIM(s) LOGDIM(SUB, s)
RandomFields/src/Machine.h:#define SUBMAXDIM(s) MAXDIM(SUB, s)
RandomFields/src/Machine.h:#define SUBTOTALXDIM TOTALXDIM(SUB)
RandomFields/src/Machine.h:#define SUBLASTSYSTEM LASTSYSTEM(SUB)
RandomFields/src/Machine.h:#define SUBSYSTEMS SYSTEMS(SUB)
RandomFields/src/Machine.h:#define SUBNR SYSMODEL(SUB)
RandomFields/src/Machine.h:#define NEXTCUMXOHNE(s) CUMXOHNE(NEXT, s)
RandomFields/src/Machine.h:#define NEXTCUMXMIT(s) CUMXMIT(NEXT, s)
RandomFields/src/Machine.h:#define NEXTXDIM(s) XDIM(NEXT, s)
RandomFields/src/Machine.h:#define NEXTDOM(s) DOM(NEXT, s)
RandomFields/src/Machine.h:#define NEXTLOGDIM(s) LOGDIM(NEXT, s)
RandomFields/src/Machine.h:#define NEXTMAXDIM(s) MAXDIM(NEXT, s)
RandomFields/src/Machine.h:#define NEXTTOTALXDIM TOTALXDIM(NEXT)
RandomFields/src/Machine.h:#define NEXTLASTSYSTEM LASTSYSTEM(NEXT)
RandomFields/src/Machine.h:#define NEXTSYSTEMS SYSTEMS(NEXT)
RandomFields/src/Machine.h:#define NEXTNR SYSMODEL(NEXT)
RandomFields/src/Machine.h:#define DEFSYS(Cov) DefList[MODELNR(Cov)].systems[(Cov)->variant == UNSET \
RandomFields/src/Machine.h:#define DEFDOM(s) DOM(DEF, s)
RandomFields/src/Machine.h:#define DEFMAXDIM(s) MAXDIM(DEF, s)
RandomFields/src/Machine.h:#define DEFSYSTEMS SYSTEMS(DEF)
RandomFields/src/Machine.h:#define DEFLASTSYSTEM LASTSYSTEM(DEF)
RandomFields/src/Machine.h:#define P(IDX) PARAM(cov, IDX) 
RandomFields/src/Machine.h:#define PINT(IDX) PARAMINT(cov, IDX)
RandomFields/src/Machine.h:#define PCHAR(IDX) PARAMCHAR(cov, IDX)
RandomFields/src/Machine.h:#define P0(IDX) PARAM0(cov, IDX) 
RandomFields/src/Machine.h:#define P0INT(IDX) PARAM0INT(cov, IDX)
RandomFields/src/Machine.h:#define P0CHAR(IDX) PARAM0CHAR(cov, IDX)
RandomFields/src/Machine.h:#define PVEC(IDX) PARAMVEC(cov, IDX) 
RandomFields/src/Machine.h:#define PENV(IDX) PARAMENV(cov, IDX) 
RandomFields/src/Machine.h:#define PLANG(IDX) PARAMLANG(cov, IDX) 
RandomFields/src/Machine.h:#define PLIST(IDX) PARAMLIST(cov, IDX)
RandomFields/src/Machine.h:#define PARAMSEXP(Cov, IDX) ((sexp_type *) (Cov)->px[IDX]) /* kein assert! */
RandomFields/src/Machine.h:#define PSEXP(IDX) PARAMSEXP(cov, IDX)
RandomFields/src/Machine.h:#define LP(IDX) LPARAM(cov, IDX) 
RandomFields/src/Machine.h:#define LPINT(IDX) LPARAMINT(cov, IDX)
RandomFields/src/Machine.h:#define LP0(IDX) LPARAM0(cov, IDX) 
RandomFields/src/Machine.h:#define LP0INT(IDX) LPARAM0INT(cov, IDX)
RandomFields/src/Machine.h:#define LNRC_(I, rc) PLIST(I)->rc[SET_IDX(cov, I)] /* see also Machine*.h */
RandomFields/src/Machine.h:#define LPARAMNROW(Cov, IDX) PARAMLIST(Cov, IDX)->nrow[SET_IDX(Cov, IDX)]
RandomFields/src/Machine.h:#define LPARAMNCOL(Cov, IDX) PARAMLIST(Cov, IDX)->ncol[SET_IDX(Cov, IDX)]
RandomFields/src/Machine.h:#define PARAMFREE(Cov, IDX) if ((Cov)->px[IDX] == NULL) { } else {	\
RandomFields/src/Machine.h:  if (DefList[MODELNR(Cov)].kappatype[IDX] < LISTOF) {		\
RandomFields/src/Machine.h:#define PARAMALLOC(Cov, IDX, ROW, COL) {				\
RandomFields/src/Machine.h:    int _PARAMsize;							\
RandomFields/src/Machine.h:    switch(DefList[MODELNR(Cov)].kappatype[IDX]) {			\
RandomFields/src/Machine.h:    case REALSXP : _PARAMsize = sizeof(double); break;			\
RandomFields/src/Machine.h:    case INTSXP : _PARAMsize = sizeof(int); break;			\
RandomFields/src/Machine.h:      if ((Cov)->kappasub[IDX]!=NULL && MODELNR((Cov)->kappasub[IDX])==DISTRIBUTION) { \
RandomFields/src/Machine.h:	  ERR("argument value recognized as distribution family although it should not. Maybe the error is caused by a non-existing variable."); \
RandomFields/src/Machine.h:	 (double*) CALLOC((ROW) * (COL), _PARAMsize)) == NULL) {	\
RandomFields/src/Machine.h:      XERR(ERRORMEMORYALLOCATION)					\
RandomFields/src/Machine.h:#define PALLOC(IDX, ROW, COL) PARAMALLOC(cov, IDX, ROW, COL)
RandomFields/src/Machine.h:#define PFREE(IDX) PARAMFREE(cov, IDX)
RandomFields/src/Machine.h:#define PARAMisNULL(Cov, IDX) ((Cov)->px[IDX] == NULL)
RandomFields/src/Machine.h:#define PisNULL(IDX) PARAMisNULL(cov, IDX)
RandomFields/src/Machine.h:#define PARAMtoNULL(Cov, IDX) (Cov)->px[IDX] = NULL
RandomFields/src/Machine.h:#define PtoNULL(IDX) PARAMtoNULL(cov, IDX)
RandomFields/src/Machine.h:#define set_xdim_blank(S, I, V) XDIMi((S)[I])=V // OK
RandomFields/src/Machine.h:#define set_logdim(S, I, V) LOGDIMi((S)[I])=V
RandomFields/src/Machine.h:#define set_maxdim(S,I,V) MAXDIMi((S)[I])=V
RandomFields/src/Machine.h:#define set_dom(S,I,V) DOMi((S)[I])=V
RandomFields/src/Machine.h:#define set_cumxmit(S,I,V) CUMXMITi((S)[I])=V
RandomFields/src/Machine.h:  if (Loc(cov) != NULL) { } else {PMI(cov); LOC_NOT_INITIALISED;}
RandomFields/src/Machine.h:#define ASSERT_QUASIONESYSTEM if (QuasiOneSystem(cov)) { } else BUG;
RandomFields/src/Machine.h:#define ASSERT_ONESYSTEM {						\
RandomFields/src/Machine.h:    if (OWNLASTSYSTEM != 0 && (OWNLASTSYSTEM != 1 ||			\
RandomFields/src/Machine.h:#define ASSERT_UNREDUCED {assert(OWNXDIM(0) == OWNLOGDIM(0) && PREVXDIM(0) == OWNLOGDIM(0));}
RandomFields/src/Machine.h:#define ASSERT_GAUSS_METHOD(METHOD) DEBUGINFO;				\
RandomFields/src/Machine.h:  if(!hasGaussMethodFrame(cov) || cov->method != (METHOD))	{ \
RandomFields/src/Machine.h:	  DefList[(METHOD) == RandomCoin ? RANDOMCOIN_USER	:	\
RandomFields/src/Machine.h:		 gaussmethod[METHOD] - 				\
RandomFields/src/Machine.h:		 DefList[gaussmethod[METHOD]].internal].nick,		\
RandomFields/src/Machine.h:	  TYPE_NAMES[cov->frame],					\
RandomFields/src/Machine.h:	  gaussmethod[cov->method] <= 0 ? "MISMATCH"	:\
RandomFields/src/Machine.h:	  DefList[cov->method == RandomCoin ? RANDOMCOIN_USER	:	\
Binary file RandomFields/src/QMath.o matches
RandomFields/src/auxiliary.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/auxiliary.cc: Copyright (C) 2001 -- 2017 Martin Schlather, 
RandomFields/src/auxiliary.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURSE.  See the
RandomFields/src/auxiliary.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/auxiliary.cc:#ifndef SCHLATHERS_MACHINE
RandomFields/src/auxiliary.cc:#ifdef RANDOMFIELDS_DEBUGGING
RandomFields/src/auxiliary.cc:RANDOMFIELDS_DEBUGGING IS NOT ALLOWED
RandomFields/src/auxiliary.cc:double getMinimalAbsEigenValue(double *Aniso, int dim) {
RandomFields/src/auxiliary.cc:  if ((D =(double *) MALLOC(sizeof(double) * dim))==NULL ||
RandomFields/src/auxiliary.cc:      (work = (double *) MALLOC(sizeof(double) * optim_work))==NULL ||
RandomFields/src/auxiliary.cc:      (iwork = (int *) MALLOC(sizeof(int) * 8 * dim))==NULL ||
RandomFields/src/auxiliary.cc:      (SICH =(double *) MALLOC(sizeof(double) * dimSq))==NULL) {
RandomFields/src/auxiliary.cc:    Err=ERRORMEMORYALLOCATION; goto ErrorHandling;
RandomFields/src/auxiliary.cc:  MEMCOPY(SICH, Aniso, sizeof(double) * dimSq);
RandomFields/src/auxiliary.cc:  if ((D =(double *) MALLOC(sizeof(double) * dim))==NULL ||
RandomFields/src/auxiliary.cc:      (work = (double *) MALLOC(sizeof(double) * optim_work))==NULL ||
RandomFields/src/auxiliary.cc:      (iwork = (int *) MALLOC(sizeof(int) * 8 * dim))==NULL ||
RandomFields/src/auxiliary.cc:      (SICH =(double *) MALLOC(sizeof(double) * dimSq))==NULL) {
RandomFields/src/auxiliary.cc:    Err=ERRORMEMORYALLOCATION; goto ErrorHandling;
RandomFields/src/auxiliary.cc:  MEMCOPY(SICH, Aniso, sizeof(double) * dimSq);
RandomFields/src/auxiliary.cc:  PROTECT(Dist = allocMatrix(REALSXP, n, n));
RandomFields/src/auxiliary.cc:  PROTECT(DIST = allocMatrix(REALSXP, rows, rescols));
RandomFields/src/auxiliary.cc:int xMatch(char *name, char **list, unsigned int llen)  {
RandomFields/src/auxiliary.cc:  // == NOMATCHING, -1, if no matching function is found
RandomFields/src/auxiliary.cc:  // == MULTIPLEMATCHING,-2, if multiple matching fctns are found,
RandomFields/src/auxiliary.cc:  // see also GetModelNr !
RandomFields/src/auxiliary.cc:  while ((nr < llen) && STRNCMP(name, list[nr], ln)) {
RandomFields/src/auxiliary.cc:    while (j < llen && STRNCMP(name, list[j], ln)) j++;
RandomFields/src/auxiliary.cc:      else return MULTIPLEMATCHING; // multiple matching
RandomFields/src/auxiliary.cc:  } else return NOMATCHING; // unmatched
RandomFields/src/auxiliary.cc:#ifndef SCHLATHERS_MACHINE 
RandomFields/src/auxiliary.cc:  // diag, falls durch einfuegen von spalten diag-Matrix erhalten
RandomFields/src/auxiliary.cc:  taken = (bool *) MALLOC(row * sizeof(bool));
RandomFields/src/auxiliary.cc:double *EinheitsMatrix(int dim) {
RandomFields/src/auxiliary.cc:      PMI(lprint_z); //
RandomFields/src/auxiliary.cc:#ifdef SCHLATHERS_MACHINE  
RandomFields/src/auxiliary.cc:    P_kM1 = 1.0,
RandomFields/src/auxiliary.cc:    P_kM2 = 0.0,
RandomFields/src/auxiliary.cc:    P_k = ((2.0 * k-1.0) x * P_kM1 - (k - 1.0) * P_kM2 ) / k; 
RandomFields/src/auxiliary.cc:    P_kM2 = P_kM1;
RandomFields/src/auxiliary.cc:    P_kM1 = P_k;
RandomFields/src/auxiliary.cc:  double delta = 1.0 + UNIFORM_RANDOM;
RandomFields/src/kleinkram.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/kleinkram.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/src/kleinkram.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/kleinkram.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/kleinkram.h:#define LAST_R_TYPE_NAME 32
RandomFields/src/kleinkram.h:extern const char *RTYPE_NAMES[LAST_R_TYPE_NAME + 1];
RandomFields/src/kleinkram.h:#define R_TYPE_NAME(X) RTYPE_NAMES[MIN(X, LAST_R_TYPE_NAME)]
RandomFields/src/kleinkram.h:typedef char name_type[][MAXCHAR];
RandomFields/src/kleinkram.h:#define NUM Real(el, name, 0)
RandomFields/src/kleinkram.h:#define POS0NUM NonNegReal(el, name)
RandomFields/src/kleinkram.h:#define NEG0NUM NonPosReal(el, name)
RandomFields/src/kleinkram.h:#define POSNUM PositiveReal(el, name)
RandomFields/src/kleinkram.h://SEXP String(char V[][MAXCHAR], int n, int max);
RandomFields/src/kleinkram.h:SEXP Mat(double* V, int row, int col, int max);
RandomFields/src/kleinkram.h:SEXP Mat_t(double* V, int row, int col, int max);
RandomFields/src/kleinkram.h:SEXP MatInt(int* V, int row, int col, int max) ;
RandomFields/src/kleinkram.h:SEXP MatString(char **V, int row, int col, int max);
RandomFields/src/kleinkram.h:SEXP Mat(double* V, int row, int col);
RandomFields/src/kleinkram.h:SEXP Mat_t(double* V, int row, int col);
RandomFields/src/kleinkram.h:SEXP MatInt(int* V, int row, int col) ;
RandomFields/src/kleinkram.h:SEXP MatString(char** V, int row, int col);
RandomFields/src/kleinkram.h:SEXP String(char V[][MAXCHAR], int n);
RandomFields/src/kleinkram.h:void String(SEXP el, char *name, char names[][MAXCHAR], int maxlen);
RandomFields/src/kleinkram.h:#define MULTIPLEMATCHING -2
RandomFields/src/kleinkram.h:#define NOMATCHING -1
RandomFields/src/kleinkram.h:#define MATCHESINTERNAL -3
RandomFields/src/kleinkram.h:int Match(char *name, const char * List[], int n);
RandomFields/src/kleinkram.h:int Match(char *name, name_type List, int n);
RandomFields/src/kleinkram.h:#define Mod(Z, modulus) ((Z) - FLOOR((Z) / (modulus)) * (modulus))
Binary file RandomFields/src/Specific.o matches
Binary file RandomFields/src/AutoRandomFields.o matches
RandomFields/src/MachineDebugging.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/MachineDebugging.h: Copyright (C) 2017 -- 2017 Martin Schlather
RandomFields/src/MachineDebugging.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/MachineDebugging.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/MachineDebugging.h:#ifndef RF_MACHINE_DEBUG
RandomFields/src/MachineDebugging.h:#define RF_MACHINE_DEBUG 1
RandomFields/src/MachineDebugging.h:#undef INIT_RANDOM
RandomFields/src/MachineDebugging.h:#undef CHECK_VDIM
RandomFields/src/MachineDebugging.h:#undef CHECK_PASSFRAME
RandomFields/src/MachineDebugging.h:#undef INIT_RANDOM
RandomFields/src/MachineDebugging.h:#define NICK(Cov) (DefList[MODELNR(Cov)].nick)
RandomFields/src/MachineDebugging.h:      PRINTF("(%s, %s, line %d : %s)\n", Z, __FILE__, __LINE__, NAME(cov)) 
RandomFields/src/MachineDebugging.h:#define ANYSTART(C, MESS, SIGN)  __extension__({	\
RandomFields/src/MachineDebugging.h:  LLPRINT(SIGN, C, MESS);			\
RandomFields/src/MachineDebugging.h:#define ANYEND(C,MESS, SIGN) 						\
RandomFields/src/MachineDebugging.h:  else { LLPRINT(SIGN, C, "#MESS FAILED"); errorstring_type msg_0;		\
RandomFields/src/MachineDebugging.h:    errorMSG(_x, cov->err_msg, cov->base, msg_0); PRINTF("%s\n", msg_0);} \
RandomFields/src/MachineDebugging.h:#define CHECK_VDIM(C,T,X,type,D,I,V0,V1,R) CHECKSTART(C)		\
RandomFields/src/MachineDebugging.h:  int _x = check2passframe(C, OWN, VDIM0, VDIM1, cov->frame);		\
RandomFields/src/MachineDebugging.h:#define CHECK_PASSFRAME(C,R) CHECKSTART(C)	\
RandomFields/src/MachineDebugging.h:  int _x = check2passframe(C, OWN, VDIM0, VDIM1, R);		\
RandomFields/src/MachineDebugging.h:  int _x = check2passtype(C, OWN, T, VDIM0, VDIM1, cov->frame);		\
RandomFields/src/MachineDebugging.h:#define INIT(C, Moments, S) ANYSTART(C,"INIT", INITSIGN);		\
RandomFields/src/MachineDebugging.h:      int _x = INIT_intern(C, Moments, S);			\
RandomFields/src/MachineDebugging.h:#define REINIT(C, Moments, S) ANYSTART(C,"REINIT", INITSIGN);	\
RandomFields/src/MachineDebugging.h:  int _x = REINIT_intern(C, Moments, S);	\
RandomFields/src/MachineDebugging.h:#define INIT_RANDOM(C, Moments, S, P) ANYSTART(C,"INITRANDOM", INITSIGN); \
RandomFields/src/MachineDebugging.h:      int _x = INIT_RANDOM_intern(C, Moments, S, P);\
RandomFields/src/MachineDebugging.h:#define STRUCT(C, NM) ANYSTART(C,"STRUCT", STRUCTSIGN);		 \
RandomFields/src/MachineDebugging.h:	   int _x = DefList[FIRSTGATTER].Struct(C, NM);		 \
RandomFields/src/MachineDebugging.h:   /*  printf("//%ld %ld %d %d %d idx=%d\n", (TO)->px[IDX], (FROM)->px[IDX], \
RandomFields/src/MachineDebugging.h:       (FROM)->nrow[IDX], (FROM)->ncol[IDX],				\
RandomFields/src/MachineDebugging.h:       DefList[MODELNR(Cov)].kappatype[IDX]==REALSXP ? sizeof(double) :	\
RandomFields/src/MachineDebugging.h:       DefList[MODELNR(Cov)].kappatype[IDX]==INTSXP ? sizeof(int) :	\
RandomFields/src/cubicsolver.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/cubicsolver.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/cubicsolver.cc:    roots[1][0] = -term1 + r13*COS((dum1 + 2.0*M_PI)/3.0);
RandomFields/src/cubicsolver.cc:    roots[2][0] = -term1 + r13*COS((dum1 + 4.0*M_PI)/3.0);
RandomFields/src/bigdata.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/bigdata.cc: Copyright (C) 2001 -- 2017 Martin Schlather, 
RandomFields/src/bigdata.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/bigdata.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/bigdata.cc:		     SEXP Cumgridlen, SEXP Boxes, SEXP MAXN) {
RandomFields/src/bigdata.cc:    *nb = (int*) MALLOC(sizeof(int) * dim), 
RandomFields/src/bigdata.cc:    *location = (int*) MALLOC(sizeof(int) * dim), 
RandomFields/src/bigdata.cc:    maxn = INTEGER(MAXN)[0],
RandomFields/src/bigdata.cc:  if ((elm = (int **) MALLOC(sizeof(int*) * total)) == NULL ||
RandomFields/src/bigdata.cc:      (count = (int*) MALLOC(sizeof(int) * total)) == NULL) {
RandomFields/src/bigdata.cc:    err = ERRORMEMORYALLOCATION;
RandomFields/src/bigdata.cc:    else if ((elm[i] = (int *) MALLOC(sizeof(int) * boxes[i])) == NULL) {
RandomFields/src/bigdata.cc:      err = ERRORMEMORYALLOCATION;
RandomFields/src/bigdata.cc:    *nb = (int*) MALLOC(sizeof(int) * dim), 
RandomFields/src/bigdata.cc:    *location = (int*) MALLOC(sizeof(int) * dim), 
RandomFields/src/bigdata.cc:  if ( (neighb = (int **) MALLOC(sizeof(int*) * total)) == NULL) {
RandomFields/src/bigdata.cc:    err =  ERRORMEMORYALLOCATION;
RandomFields/src/bigdata.cc:    if ((neighb[i] = (int *) MALLOC(sizeof(int) * neighbours[i])) == NULL) {
RandomFields/src/bigdata.cc:      err =  ERRORMEMORYALLOCATION;
Binary file RandomFields/src/circulant.o matches
Binary file RandomFields/src/operator.gaussmethod.o matches
Binary file RandomFields/src/RandomFields.so matches
RandomFields/src/init.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/init.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/src/init.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/init.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/init.h:  GAUSS, NUGGET, PLUS, MLEPLUS, BALL, MULT, CONST, BIND, PROJ_MODEL,
RandomFields/src/init.h:  DISTRIBUTION,  DETERM_DISTR, GAUSS_DISTR, SETPARAM, SET_DISTR, PROD, ANGLE,
RandomFields/src/init.h:  COVMATRIX, RFGET, COVFCTN, FCTNFCTN,
RandomFields/src/init.h:  LIKELIHOOD_CALL, LINEARPART_CALL, MATRIX,
RandomFields/src/init.h:  POWER_DOLLAR,  MLE_ENDCOV,  SPLIT, SCATTER, MCMC_PGS,
RandomFields/src/init.h:  MCMC,
RandomFields/src/init.h:  FIRST_TRAFO, LAST_TRAFO, EARTHKM2CART, EARTHMILES2CART,
RandomFields/src/init.h:  EARTHKM2GNOMONIC, EARTHMILES2GNOMONIC,
RandomFields/src/init.h:  EARTHKM2ORTHOGRAPHIC, EARTHMILES2ORTHOGRAPHIC, 
RandomFields/src/init.h:  STROKORB_MONO, STROKORB_BALL_INNER, POLYGON, RECTANGULAR,
RandomFields/src/init.h:  IDCOORD, MULT_INVERSE,
RandomFields/src/init.h:  SHAPESTP, SHAPEAVE, SPHERICAL, UNIF, MPPPLUS, ZHOU, BALLANI,
RandomFields/src/init.h:  STATIONARY_SHAPE, STANDARD_SHAPE, TRAFO, TRAFOPROC, PROJMODEL, COVARIATE,
RandomFields/src/init.h:  VARIOGRAM_CALL, SIMULATE, FIXCOV, DUMMY,
RandomFields/src/init.h:  BRORIGINAL_USER, BRMIXED_USER, BRSHIFTED_USER, BRNORMED,  
RandomFields/src/init.h:  SCALEMODEL, BUBBLE, MATHDIV,
RandomFields/src/init.h:  BRORIGINAL_INTERN, BRMIXED_INTERN, BRSHIFTED_INTERN,
RandomFields/src/init.h:  MISSING_COV, NULL_MODEL, TBM_OP, USER, 
RandomFields/src/init.h:  DOLLAR_PROC, PLUS_PROC,  VARIOGRAM2COV, VAR2COV_PROC,
RandomFields/src/init.h:  MPPPLUS_PROC, MULT_PROC, // SCAHPE_FCT_PROC,
RandomFields/src/init.h:  SCHLATHERPROC, SMITHPROC, CHI2PROC, TPROC, EXTREMALTPROC, SHAPE_FCT_PROC,
RandomFields/src/init.h:  CIRCEMBED, CUTOFF, STEIN, SPECTRAL_PROC_USER, SPECTRAL_PROC_INTERN, 
RandomFields/src/init.h:  RANDOMCOIN_USER, CE_CUTOFFPROC_USER, CE_CUTOFFPROC_INTERN, 
RandomFields/src/init.h:  CE_INTRINPROC_USER, CE_INTRINPROC_INTERN, TBM_PROC_USER, TBM_PROC_INTERN, 
RandomFields/src/init.h:  SPECIFIC, SELECTNR, M_PROC,
RandomFields/src/init.h:  BRSHIFTED, BRMIXED, BRORIGINAL, EXTREMALGAUSSIAN, RANDOMSIGN,
RandomFields/src/init.h:  TBM2NR, FIRSTVECTOR, LASTVECTOR;
RandomFields/src/init.h:extern pref_type PREF_ALL, PREF_NOTHING, PREF_TREND, PREF_AUX, PREF_MATHDEF;
RandomFields/src/init.h:extern name_type STANDARDPARAM, STANDARDSUB;
RandomFields/src/init.h:extern const char *METHOD_NAMES[Forbidden+1],  
RandomFields/src/init.h:  *CAT_TYPE_NAMES[OtherType + 1],
RandomFields/src/init.h:  *REG_NAMES[MODEL_MAX+1],
RandomFields/src/init.h:  **LIST_OF_NAMES[nNamesOfNames],
RandomFields/src/init.h:  *POSITIVITY_NAMES[pt_mismatch + 1];
RandomFields/src/init.h:void includeOtherModels();
RandomFields/src/init.h:void includeCovModels();
RandomFields/src/Options.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/Options.cc: Copyright (C) 20017 -- 2017 Martin Schlather, 
RandomFields/src/Options.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/Options.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/Options.cc:const char * OPTIM_VAR_NAMES[nOptimVar] = 
RandomFields/src/Options.cc:#define NM ((int) startmode)   /* normal mode */
RandomFields/src/Options.cc:#ifdef SCHLATHERS_MACHINE
RandomFields/src/Options.cc:void SetDefaultOutputModeValues(output_modes mode, bool local){
RandomFields/src/Options.cc:void SetDefaultModeValues(int old, int m, bool local){
RandomFields/src/Options.cc:  global->krige.locsplitn[NEIGHB_MIN]  = MINSPLITN(locmaxn[m]);
RandomFields/src/Options.cc:  global->krige.locsplitn[NEIGHB_SPLIT]  = MEDSPLITN(locmaxn[m]);
RandomFields/src/Options.cc:  global->krige.locsplitn[NEIGHB_MAX]  = MAXSPLITN(locmaxn[m]);
RandomFields/src/Options.cc:  global->fit.locsplitn[NEIGHB_MIN] = MINCLIQUE(maxclique[m]);
RandomFields/src/Options.cc:  global->fit.locsplitn[NEIGHB_MED] = MEDCLIQUE(maxclique[m]);
RandomFields/src/Options.cc:  global->fit.locsplitn[NEIGHB_MAX] = MAXCLIQUE(maxclique[m]);
RandomFields/src/Options.cc:  f->suboptimiser = f->optimiser = Match(dummy, OPTIMISER_NAMES, nOptimiser);
RandomFields/src/Options.cc:  //  printf("optimiser %d %s\n", f->optimiser,  OPTIMISER_NAMES[f->optimiser]);
RandomFields/src/Options.cc:     PRINTF("Note that the option '%s' is still in an experimental stage, so that the behaviour may change (slightly) in future.\n", general[GENERAL_MODUS]);
RandomFields/src/Options.cc:	      char units[MAXCOORDNAMES][MAXUNITSCHAR], 
RandomFields/src/Options.cc:	      char units2[MAXCOORDNAMES][MAXUNITSCHAR]) {  
RandomFields/src/Options.cc:    for (i=j=0; i<MAXCOORDNAMES; i++, j=(j + 1) % l) {
RandomFields/src/Options.cc:      strcopyN(units[i], CHAR(STRING_ELT(el, j)), MAXUNITSCHAR);
RandomFields/src/Options.cc:	strcopyN(units2[i], CHAR(STRING_ELT(el, j)), MAXUNITSCHAR);
RandomFields/src/Options.cc:SEXP UNITS(char units[MAXCOORDNAMES][MAXUNITSCHAR]) {
RandomFields/src/Options.cc:  PROTECT(unitnames = allocVector(STRSXP, MAXCOORDNAMES)); 
RandomFields/src/Options.cc:  for (nn=0; nn<MAXCOORDNAMES; nn++) {
RandomFields/src/Options.cc:    Real(el, name, cp->mmin, MAXCEDIM) ;
RandomFields/src/Options.cc:    for (d=0; d<MAXCEDIM; d++) {
RandomFields/src/Options.cc:    cp->maxGB = POSNUM;
RandomFields/src/Options.cc:    if (!isList) cp->maxmem = MAXINT;	
RandomFields/src/Options.cc:  case 5: cp->tol_im = POS0NUM; break;
RandomFields/src/Options.cc:  case 6: cp->tol_re = NEG0NUM; break;
RandomFields/src/Options.cc:  case 7: cp->trials = NUM;
RandomFields/src/Options.cc:  case 10: cp->approx_grid_step = POS0NUM; break;
RandomFields/src/Options.cc:   "special", OBSOLETENAME, "ignore"  // 24
RandomFields/src/Options.cc:// IMPORTANT: all names of general has at least 3 letters  !!!
RandomFields/src/Options.cc:const char * pTBM[pTBMN] = {"reduceddim", "fulldim", "center", 
RandomFields/src/Options.cc:			  // "samplingdist", "samplingr",// MPP_cc
RandomFields/src/Options.cc:   "variobound", "deltaAM"};
RandomFields/src/Options.cc:			     pnugget, sequ, spectral, pTBM, mpp,
RandomFields/src/Options.cc:		     pnuggetN,  sequN, spectralN, pTBMN, mppN,
RandomFields/src/Options.cc:    case GENERAL_MODUS: {
RandomFields/src/Options.cc:      gp->mode = GetName(el, name, MODE_NAMES, nr_modes, normal);
RandomFields/src/Options.cc:#ifndef SCHLATHERS_MACHINE
RandomFields/src/Options.cc:      SetDefaultModeValues(old_mode, gp->mode, local);
RandomFields/src/Options.cc:	  if (nr>=0 && nr<=MODEL_MAX) {
RandomFields/src/Options.cc:	  for (int nr=0; nr<=MODEL_MAX; nr++) {
RandomFields/src/Options.cc:	  for (int kn=0; kn<PIDMODULUS; kn++) {
RandomFields/src/Options.cc:    case 3: gp->gridtolerance = NUM; break;
RandomFields/src/Options.cc:      SetDefaultOutputModeValues(LOGI ? output_sp : output_rf, local);
RandomFields/src/Options.cc:	GetName(el, name, DUPLICATEDLOC_NAMES, nDuplicatedloc); break; 
RandomFields/src/Options.cc:      SetDefaultOutputModeValues((output_modes) 
RandomFields/src/Options.cc:				 GetName(el, name, OUTPUTMODE_NAMES, 
RandomFields/src/Options.cc:      gp->reportcoord = GetName(el, name, REPORTCOORD_NAMES, 
RandomFields/src/Options.cc:    case 2: gp->approx_zero = POS0NUM; break;
RandomFields/src/Options.cc:      double boxcox[2 * MAXBOXCOXVDIM];      
RandomFields/src/Options.cc:      if (len > 2 * MAXBOXCOXVDIM) {
RandomFields/src/Options.cc:	RFERROR1("Box-Cox transformations can be applied only to the first %d multivariate dimensions",	MAXBOXCOXVDIM);
RandomFields/src/Options.cc:    case DIRECT_MAXVAR_PARAM : {
RandomFields/src/Options.cc:	     direct[DIRECT_MAXVAR_PARAM], gauss[GAUSS_BEST_DIRECT], 
RandomFields/src/Options.cc:      //#define MAX_DIRECT_MAXVAR 30000
RandomFields/src/Options.cc:      if (mv > MAX_DIRECT_MAXVAR) {
RandomFields/src/Options.cc:	if (dp->maxvariables <= MAX_DIRECT_MAXVAR) {
RandomFields/src/Options.cc:		direct[DIRECT_MAXVAR_PARAM], MAX_DIRECT_MAXVAR, mv);
RandomFields/src/Options.cc:      sp->max_chol= MAX(mv, DIRECT_ORIG_MAXVAR);
RandomFields/src/Options.cc:    case 0: np->tol = POS0NUM; break;
RandomFields/src/Options.cc:    case 0: Integer(el, name, sp->lines, MAXTBMSPDIM); break;
RandomFields/src/Options.cc:    case SPECTRAL_PROPFACTOR: sp->prop_factor = POS0NUM;
RandomFields/src/Options.cc:    case 3: sp->sigma = NUM; break;
RandomFields/src/Options.cc:  case 8: {// TBM
RandomFields/src/Options.cc:    case 2: Real(el, name, tp->center, MAXTBMSPDIM);  break;
RandomFields/src/Options.cc:    case 4: Integer(el, name, tp->lines, MAXTBMDIM); break;
RandomFields/src/Options.cc:    case 1: Real(el, name, mp->intensity, MAXMPPDIM); break;
RandomFields/src/Options.cc:      // case 2: mp->refradius_factor = POS0NUM; break;
RandomFields/src/Options.cc:    case 2: mp->about_zero = POS0NUM; break;
RandomFields/src/Options.cc:    case 3: mp->shape_power = NUM; break;
RandomFields/src/Options.cc:      Integer(el, name, mp->scatter_max, MAXMPPDIM) ;
RandomFields/src/Options.cc:      Real(el, name, mp->scatter_step, MAXMPPDIM) ;
RandomFields/src/Options.cc:    case 3: hp->mar_param = NUM; break;
RandomFields/src/Options.cc:    case 0: ep->standardmax = POS0NUM; break;
RandomFields/src/Options.cc:    case 2: ep->GEV_xi = NUM; break;
RandomFields/src/Options.cc:    case 3: ep->density_ratio = POS0NUM; break;
RandomFields/src/Options.cc:    case EXTREME_FLAT: ep->flathull = USRLOG; 
RandomFields/src/Options.cc:      // RFERROR1("currently only '%.50s=FALSE' allowed", extreme[EXTREME_FLAT]);
RandomFields/src/Options.cc:    case 8: ep->eps_zhou = POSNUM; break;
RandomFields/src/Options.cc:    case 10: ep->min_shape_gumbel = NEG0NUM; break;
RandomFields/src/Options.cc:	(coord_sys_enum) GetName(el, name, POISSON_SCATTER_NAMES,
RandomFields/src/Options.cc:    case 1: ep->BRmeshsize = POSNUM; break;
RandomFields/src/Options.cc:    case 4: ep->BRoptimtol = POS0NUM; break;
RandomFields/src/Options.cc:    case 5: ep->variobound = NUM; break;
RandomFields/src/Options.cc:    case 6: ep->deltaAM = POSINT; break;
RandomFields/src/Options.cc:    case 0: ep->safety=POSNUM; break;
RandomFields/src/Options.cc:    case 1: ep->minsteplen=POS0NUM; break;
RandomFields/src/Options.cc:    case 5: ep->innermin=POSNUM; break;
RandomFields/src/Options.cc:    case 6: ep->outermax=POSNUM; break;
RandomFields/src/Options.cc:    case 7: ep->mcmc_n=POSNUM; break;
RandomFields/src/Options.cc:    case 8: ep->repetitions=POSNUM; break;
RandomFields/src/Options.cc:    case 0: ef->bin_dist_factor = POS0NUM; break; //
RandomFields/src/Options.cc:    case 1: ef->upperbound_scale_factor = POS0NUM; break; //
RandomFields/src/Options.cc:    case 2: ef->lowerbound_scale_factor = POS0NUM; break; //
RandomFields/src/Options.cc:    case 3: ef->lowerbound_scale_LS_factor = POS0NUM; break; //
RandomFields/src/Options.cc:    case 4: ef->upperbound_var_factor = POS0NUM; break; //
RandomFields/src/Options.cc:    case 5: ef->lowerbound_var_factor = POS0NUM; break;//
RandomFields/src/Options.cc:      //    case 6: ef->lowerbound_sill = POS0NUM; break; 
RandomFields/src/Options.cc:    case 6: ef->scale_max_relative_factor = POS0NUM; break; //
RandomFields/src/Options.cc:    case 7: ef->minbounddistance = POS0NUM; break;//
RandomFields/src/Options.cc:    case 8: ef->minboundreldist = POS0NUM; break;// 
RandomFields/src/Options.cc:	if (length(el) > 2 * MAXBOXCOXVDIM)
RandomFields/src/Options.cc:	  RFERROR1("Box-Cox transformations can be applied only to the first %d multivariate dimensions", MAXBOXCOXVDIM);
RandomFields/src/Options.cc:	Real(el, name, ef->BC_lambdaLB, 2 * MAXBOXCOXVDIM);
RandomFields/src/Options.cc:      if (length(el) > 2 * MAXBOXCOXVDIM)
RandomFields/src/Options.cc:	RFERROR1("Box-Cox transformations can be applied only to the first %d multivariate dimensions", MAXBOXCOXVDIM);
RandomFields/src/Options.cc:      Real(el, name, ef->BC_lambdaUB, 2 * MAXBOXCOXVDIM);
RandomFields/src/Options.cc:      if (ii >= LENMSG) {
RandomFields/src/Options.cc:	ii = LENMSG - 1;  
RandomFields/src/Options.cc:    case 16: ef->scale_ratio = NUM; break;//
RandomFields/src/Options.cc:    case FIT_MAXNEIGHBOUR: ef->locmaxn = POS0INT; break;//
RandomFields/src/Options.cc:    case 23: ef->min_diag = NUM; break;//
RandomFields/src/Options.cc:      GetName(el, name, OPTIMISER_NAMES, nOptimiser, 0);
RandomFields/src/Options.cc:      ef->algorithm = GetName(el, name, NLOPTR_NAMES, nNLOPTR); //
RandomFields/src/Options.cc:	GetName(el, name, LIKELIHOOD_NAMES, nLikelihood); ; break; 
RandomFields/src/Options.cc:    case 32: ef->pgtol = POSNUM; break;//
RandomFields/src/Options.cc:    case 33: ef->pgtol_recall = POSNUM; break;//
RandomFields/src/Options.cc:    case 34: ef->factr = POSNUM; break;//
RandomFields/src/Options.cc:    case 35: ef->factr_recall = POSNUM; break;//
RandomFields/src/Options.cc:    case 36: ef->addNAlintrend = POS0NUM; break;
RandomFields/src/Options.cc:      double m = NUM;
RandomFields/src/Options.cc:      else RFERROR("'emp_method' not witin {RC_VARIOGRAM, RC_PSEUDO, RC_COVARIANCE}");
RandomFields/src/Options.cc:	GetName(el, name, OPTIMISER_NAMES, nOptimiser, 0); //
RandomFields/src/Options.cc:      ep->phi0=POS0NUM;
RandomFields/src/Options.cc:      ep->theta0=POS0NUM;
RandomFields/src/Options.cc:    case 2: ep->tol=NUM; break;    
RandomFields/src/Options.cc:      if (n > MAXBINS)
RandomFields/src/Options.cc:	RFERROR3("'%.50s' takes at most %d values. Got %d\n", name, MAXBINS, n);
RandomFields/src/Options.cc:	ep->phi0=NUM;
RandomFields/src/Options.cc:	ep->theta0=NUM;
RandomFields/src/Options.cc:	gp->method = GetName(el, name, METHOD_NAMES, Forbidden + 1, Nothing);
RandomFields/src/Options.cc:	case 2 : gp->height = NUM; break;
RandomFields/src/Options.cc:	    if (!gp->onefile && STRCMP(gp->filename, old) !=0) gp->number = 0;
RandomFields/src/Options.cc:	case 8 : gp->resolution = POSNUM; break;
RandomFields/src/Options.cc:	case 10 : gp->width = NUM; break;
RandomFields/src/Options.cc:	case 13 : gp->xlim = POSNUM; break;
RandomFields/src/Options.cc:	    if ((keynr<0) || (keynr>MODEL_MAX))
RandomFields/src/Options.cc:      if ((predict<0) || (predict>MODEL_MAX))
RandomFields/src/Options.cc:      if ((likelihood<0) || (likelihood>MODEL_MAX))
RandomFields/src/Options.cc:	    wp->examples_reduced < MAX_LEN_EXAMPLES)
RandomFields/src/Options.cc:	  wp->examples_reduced = MAX_LEN_EXAMPLES;
RandomFields/src/Options.cc:      case MESSAGES_NEWANISO: wp->warn_Aniso = LOGI;       break;
RandomFields/src/Options.cc:      case MESSAGES_ONGRID: wp->warn_on_grid = LOGI;       break;
RandomFields/src/Options.cc:      case MESSAGES_COORD_CHANGE: wp->warn_coord_change = LOGI;       break;
RandomFields/src/Options.cc:      case MESSAGES_ZENIT: wp->warn_zenit = LOGI;       break;
RandomFields/src/Options.cc:      case MESSAGES_PARALLEL : wp->warn_parallel = LOGI;       break;
RandomFields/src/Options.cc:      case MESSAGES_RAW: wp->warn_raw_covariates = LOGI; break;
RandomFields/src/Options.cc:      case MESSAGES_ONGRID :  wp->warn_on_grid = LOGI; break;
RandomFields/src/Options.cc:      case MESSAGES_COORD_CHANGE: wp->warn_coord_change = LOGI;       break;
RandomFields/src/Options.cc:      case MESSAGES_ZENIT: wp->warn_zenit = LOGI;       break;
RandomFields/src/Options.cc:      case MESSAGES_PARALLEL : wp->warn_parallel = LOGI;       break;
RandomFields/src/Options.cc:      case MESSAGES_RAW: wp->warn_raw_covariates = LOGI; break; 	
RandomFields/src/Options.cc:	(coord_sys_enum) GetName(el, name, COORD_SYS_NAMES, nr_coord_sys,
RandomFields/src/Options.cc:	  PRINTF("Angle mode switches to '%s'.\n", ANGLE_NAMES[cp->anglemode]);
RandomFields/src/Options.cc:	if (n > MAXDATANAMES)
RandomFields/src/Options.cc:	  RFERROR1("maximum number named variables is %d", MAXDATANAMES);
RandomFields/src/Options.cc:    case COORDS_DATANAMES:
RandomFields/src/Options.cc:	if (n > MAXCOORDNAMES)
RandomFields/src/Options.cc:	  RFERROR1("maximum number named variables is %d", MAXCOORDNAMES);
RandomFields/src/Options.cc:    case COORDS_XNAMES:
RandomFields/src/Options.cc:	(coord_sys_enum) GetName(el, name, COORD_SYS_NAMES, nr_coord_sys,
RandomFields/src/Options.cc:	(angle_modes) GetName(el, name, ANGLE_NAMES, last_angle_mode + 1, -1);
RandomFields/src/Options.cc:    case 14: STR(cp->data_col_initial, MAXCHAR-1);
RandomFields/src/Options.cc:	  !STRCMP(cp->data_col_initial,cp->coord_initial)) {
RandomFields/src/Options.cc:    case 15: STR(cp->coord_initial, MAXCHAR-1);
RandomFields/src/Options.cc:	  !STRCMP(cp->data_col_initial,cp->coord_initial)) {
RandomFields/src/Options.cc:    ADD(ScalarString(mkChar(MODE_NAMES[p->mode])));
RandomFields/src/Options.cc:    ADD(ScalarString(mkChar(DUPLICATEDLOC_NAMES[p->duplicated_loc])));
RandomFields/src/Options.cc:    ADD(ScalarString(mkChar(OUTPUTMODE_NAMES[p->output])));
RandomFields/src/Options.cc:    ADD(ScalarString(mkChar(REPORTCOORD_NAMES[p->reportcoord])));
RandomFields/src/Options.cc:    SET_VECTOR_ELT(sublist, k++, Num(p->boxcox, 2 * MAXBOXCOXVDIM)); 
RandomFields/src/Options.cc:    SET_VECTOR_ELT(sublist, k++, Num(p->mmin, MAXCEDIM)); 
RandomFields/src/Options.cc:    SET_VECTOR_ELT(sublist, k++, Int(p->lines, MAXTBMSPDIM));
RandomFields/src/Options.cc:    SET_VECTOR_ELT(sublist, k++, Num(p->center, MAXTBMSPDIM));
RandomFields/src/Options.cc:    // ADD(p->method>=0 ? ScalarString(mkChar(METHOD_NAMES[p->method])) : 
RandomFields/src/Options.cc:     SET_VECTOR_ELT(sublist, k++, Int(p->lines, MAXTBMDIM));
RandomFields/src/Options.cc:    SET_VECTOR_ELT(sublist, k++, Num(p->intensity, MAXMPPDIM));
RandomFields/src/Options.cc:    SET_VECTOR_ELT(sublist, k++, Num(p->scatter_step, MAXMPPDIM)); 
RandomFields/src/Options.cc:    SET_VECTOR_ELT(sublist, k++, Int(p->scatter_max, MAXMPPDIM)); 
RandomFields/src/Options.cc:     //    SET_VECTOR_ELT(sublist, k++, Num(p->plus, MAXMPPDIM ,MAXMPPDIM));
RandomFields/src/Options.cc:    ADD(ScalarString(mkChar(POISSON_SCATTER_NAMES[p->scatter_method])));
RandomFields/src/Options.cc:    ADD(ScalarInteger(p->deltaAM));
RandomFields/src/Options.cc:    SET_VECTOR_ELT(sublist, k++, Num(p->BC_lambdaLB, 2 * MAXBOXCOXVDIM));
RandomFields/src/Options.cc:    SET_VECTOR_ELT(sublist, k++, Num(p->BC_lambdaUB, 2 * MAXBOXCOXVDIM));
RandomFields/src/Options.cc:    ADD(p->optimiser>=0 ? ScalarString(mkChar(OPTIMISER_NAMES[p->optimiser])) 
RandomFields/src/Options.cc:			    NLOPTR_NAMES[p->algorithm]
RandomFields/src/Options.cc:    ADD(ScalarString(mkChar(LIKELIHOOD_NAMES[p->likelihood])));
RandomFields/src/Options.cc:	? ScalarString(mkChar(OPTIMISER_NAMES[p->suboptimiser])) 
RandomFields/src/Options.cc:    ADD(p->method>=0 ? ScalarString(mkChar(METHOD_NAMES[p->method])) 
RandomFields/src/Options.cc:    ADD(ScalarString(mkChar(COORD_SYS_NAMES[p->coord_system])));
RandomFields/src/Options.cc:    ADD(ScalarString(mkChar(COORD_SYS_NAMES[p->new_coord_system]))); //9
RandomFields/src/Options.cc:    ADD(ScalarString(mkChar(ANGLE_NAMES[p->anglemode])));
RandomFields/src/Options.cc:  global_utils->solve.max_chol = DIRECT_ORIG_MAXVAR;
RandomFields/src/Options.cc:  InitModelList();
RandomFields/src/Options.cc:#ifdef ReturnAttachMessage
RandomFields/src/Options.cc:  ReturnAttachMessage(RandomFields, true);
Binary file RandomFields/src/metropolis.o matches
RandomFields/src/operator.gaussmethod.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/operator.gaussmethod.cc: Copyright (C) 2005 -- 2017 Martin Schlather
RandomFields/src/operator.gaussmethod.cc:               2015-2017 Olga Moreva (cutoff, modified)
RandomFields/src/operator.gaussmethod.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/operator.gaussmethod.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/operator.gaussmethod.cc:  model *next = cov->sub[TBMOP_COV];
RandomFields/src/operator.gaussmethod.cc:    vdim = VDIM0,
RandomFields/src/operator.gaussmethod.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/operator.gaussmethod.cc:struct TBM2_integr{
RandomFields/src/operator.gaussmethod.cc:void TBM2NumIntegrFct(double *u,  int n, void *ex) {
RandomFields/src/operator.gaussmethod.cc:  TBM2_integr *integrand = (TBM2_integr*) ex;
RandomFields/src/operator.gaussmethod.cc:  TBM2_integr integrand;
RandomFields/src/operator.gaussmethod.cc:#define MAXSUBDIVISIONS 100
RandomFields/src/operator.gaussmethod.cc:  int maxsubdivisions = MAXSUBDIVISIONS, 
RandomFields/src/operator.gaussmethod.cc:      lenw = 4 * MAXSUBDIVISIONS;
RandomFields/src/operator.gaussmethod.cc:  double abserr, work[4 * MAXSUBDIVISIONS];
RandomFields/src/operator.gaussmethod.cc:  int subdivisions, integralevaluations, err, iwork[MAXSUBDIVISIONS];
RandomFields/src/operator.gaussmethod.cc:  //                 in TBM2NumIntegrFct ...
RandomFields/src/operator.gaussmethod.cc:  Rdqags(TBM2NumIntegrFct, (void *) &integrand, &a, &b, &eps, &eps,
RandomFields/src/operator.gaussmethod.cc:#define DO_NUMERIC 0
RandomFields/src/operator.gaussmethod.cc:  model *next = cov->sub[TBMOP_COV];
RandomFields/src/operator.gaussmethod.cc:    fulldim = P0INT(TBMOP_FULLDIM),
RandomFields/src/operator.gaussmethod.cc:    tbmdim = P0INT(TBMOP_TBMDIM);
RandomFields/src/operator.gaussmethod.cc:  // if (!hasGaussMethodFrame(cov) && !hasAnyEvaluationFrame(cov)) { BUG; } else
RandomFields/src/operator.gaussmethod.cc:    if (cov->q[DO_NUMERIC]) tbm2num(x, cov, v);
RandomFields/src/operator.gaussmethod.cc:      // APMI(next);
RandomFields/src/operator.gaussmethod.cc:      TBM2CALL(x, info, next, v);
RandomFields/src/operator.gaussmethod.cc:      // DefList[MODELNR(next)].tbm2(x, next, v);
RandomFields/src/operator.gaussmethod.cc:  else XERR(ERRORTBMCOMBI);
RandomFields/src/operator.gaussmethod.cc:  model *next = cov->sub[TBMOP_COV];
RandomFields/src/operator.gaussmethod.cc:    fulldim = P0INT(TBMOP_FULLDIM),
RandomFields/src/operator.gaussmethod.cc:    vdim = VDIM0,
RandomFields/src/operator.gaussmethod.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/operator.gaussmethod.cc:   tbmdim = (double) P0INT(TBMOP_TBMDIM),
RandomFields/src/operator.gaussmethod.cc:  else XERR(ERRORTBMCOMBI);
RandomFields/src/operator.gaussmethod.cc:  model *next=cov->sub[TBMOP_COV];
RandomFields/src/operator.gaussmethod.cc:  ASSERT_ONESYSTEM;
RandomFields/src/operator.gaussmethod.cc:  kdefault(cov, TBMOP_FULLDIM, PisNULL(TBMOP_TBMDIM) || gp->tbmdim >= 0
RandomFields/src/operator.gaussmethod.cc:	   ? gp->fulldim : P0INT(TBMOP_TBMDIM) - gp->tbmdim);
RandomFields/src/operator.gaussmethod.cc:  kdefault(cov, TBMOP_TBMDIM, gp->tbmdim > 0 
RandomFields/src/operator.gaussmethod.cc:	   ? gp->tbmdim : P0INT(TBMOP_FULLDIM) + gp->tbmdim);
RandomFields/src/operator.gaussmethod.cc:  kdefault(cov, TBMOP_LAYERS, (int) gp->layers);
RandomFields/src/operator.gaussmethod.cc:  //PMI0(cov);
RandomFields/src/operator.gaussmethod.cc:    tbmdim = P0INT(TBMOP_TBMDIM),
RandomFields/src/operator.gaussmethod.cc:    fulldim = P0INT(TBMOP_FULLDIM),
RandomFields/src/operator.gaussmethod.cc:    vdim = VDIM0,
RandomFields/src/operator.gaussmethod.cc:    storedlayer = P0INT(TBMOP_LAYERS);
RandomFields/src/operator.gaussmethod.cc:    OWNXDIM(0) == tbmdim + 1 && equalsSpaceIsotropic(OWN);
RandomFields/src/operator.gaussmethod.cc:  if(VDIM0 != VDIM1) BUG;
RandomFields/src/operator.gaussmethod.cc:	   KNAME(TBMOP_TBMDIM), tbmdim, KNAME(TBMOP_FULLDIM), fulldim);
RandomFields/src/operator.gaussmethod.cc:  if (OWNLOGDIM(0) > fulldim + layers) RETURN_ERR(ERRORWRONGDIM);
RandomFields/src/operator.gaussmethod.cc:  if (OWNXDIM(0) > tbmdim + layers) {
RandomFields/src/operator.gaussmethod.cc:  if ((err = CHECK_PASSFRAME(next, EvaluationType)) != NOERROR) {
RandomFields/src/operator.gaussmethod.cc:    // APMI(cov);
RandomFields/src/operator.gaussmethod.cc:  if (next->pref[TBM] == PREF_NONE) RETURN_ERR(ERRORPREFNONE);
RandomFields/src/operator.gaussmethod.cc:  cov->monotone=NOT_MONOTONE;
RandomFields/src/operator.gaussmethod.cc:  // But difficult to get around for MLE calls that do not allow 
RandomFields/src/operator.gaussmethod.cc:  PINT(TBMOP_LAYERS)[0] = layers;
RandomFields/src/operator.gaussmethod.cc:  bool layers = P0INT(TBMOP_LAYERS);
RandomFields/src/operator.gaussmethod.cc:  //  printf("i=%d %.50s\n",i, ISO_NAMES[i]);
RandomFields/src/operator.gaussmethod.cc:      ((OWNXDIM(0) == 1) xor equalsIsotropic(i)) ||
RandomFields/src/operator.gaussmethod.cc:       ((OWNXDIM(0) == 2) xor equalsSpaceIsotropic(i)) ||
RandomFields/src/operator.gaussmethod.cc:      (OWNXDIM(0) > 2) ||
RandomFields/src/operator.gaussmethod.cc:      !equalsXonly(OWNDOM(0))) return BadType;
RandomFields/src/operator.gaussmethod.cc:  // critical parameter TBMOP_LAYER is already treated by SUBMODEL_I
RandomFields/src/operator.gaussmethod.cc:  kdefault(cov, TBMOP_LAYERS, (int) gp->layers);
RandomFields/src/operator.gaussmethod.cc:  set_iso(OWN, 0, P0INT(TBMOP_LAYERS) ? DOUBLEISOTROPIC : ISOTROPIC);
RandomFields/src/operator.gaussmethod.cc:  kdefault(cov, TBMOP_LAYERS, (int) gp->layers);
RandomFields/src/operator.gaussmethod.cc:  I[P0INT(TBMOP_LAYERS) ? DOUBLEISOTROPIC : ISOTROPIC] = true;
RandomFields/src/operator.gaussmethod.cc:    TBMDIM = tbmop ? TBMOP_TBMDIM : TBM_TBMDIM,
RandomFields/src/operator.gaussmethod.cc:    FULLDIM = tbmop ? TBMOP_FULLDIM : TBM_FULLDIM,
RandomFields/src/operator.gaussmethod.cc:    LAYERS = tbmop ? TBMOP_LAYERS : TBM_LAYERS;
RandomFields/src/operator.gaussmethod.cc:  range->min[FULLDIM] = 1.0;
RandomFields/src/operator.gaussmethod.cc:  range->max[FULLDIM] = RF_INF;
RandomFields/src/operator.gaussmethod.cc:  range->pmin[FULLDIM] = 1.0;
RandomFields/src/operator.gaussmethod.cc:  range->pmax[FULLDIM] = 100;
RandomFields/src/operator.gaussmethod.cc:  range->openmin[FULLDIM] = false;
RandomFields/src/operator.gaussmethod.cc:  range->openmax[FULLDIM] = true;
RandomFields/src/operator.gaussmethod.cc:  range->min[TBMDIM] = RF_NEGINF;
RandomFields/src/operator.gaussmethod.cc:  range->max[TBMDIM] = RF_INF;
RandomFields/src/operator.gaussmethod.cc:  range->pmin[TBMDIM] = RF_NEGINF;
RandomFields/src/operator.gaussmethod.cc:  range->pmax[TBMDIM] = 100;
RandomFields/src/operator.gaussmethod.cc:  range->openmin[TBMDIM] = false;
RandomFields/src/operator.gaussmethod.cc:  range->openmax[TBMDIM] = true;
RandomFields/src/operator.gaussmethod.cc:    rM1 = r - 1.0, 
RandomFields/src/operator.gaussmethod.cc:  q->intrinsic.B  = (r == 1.0) ? 0.0 : dummy / (rM1 * dsq);
RandomFields/src/operator.gaussmethod.cc:  q->intrinsic.A0 = 0.5 * rM1 / rP1 * phi2 + phi1 / rP1 - phi0;
RandomFields/src/operator.gaussmethod.cc:    return MSGLOCAL_INITINTRINSIC;
RandomFields/src/operator.gaussmethod.cc:  // radius = MAXINT;
RandomFields/src/operator.gaussmethod.cc:  if (VDIM0 > LOCALCE_MAXVDIM || VDIM1 > LOCALCE_MAXVDIM) BUG;
RandomFields/src/operator.gaussmethod.cc:    return MSGLOCAL_NOTSYMMETRICMULTIVARIATE;
RandomFields/src/operator.gaussmethod.cc:    //    APMI(cov->calling);
RandomFields/src/operator.gaussmethod.cc:    return MSGLOCAL_WRONGRADII;
RandomFields/src/operator.gaussmethod.cc:  //PMI(cov);
RandomFields/src/operator.gaussmethod.cc:  assert(VDIM0 > 0 && VDIM0 <= LOCALCE_MAXVDIM);
RandomFields/src/operator.gaussmethod.cc:  if (VDIM0 > 1) return set_cutoff_q2variate(cov, a, d);
RandomFields/src/operator.gaussmethod.cc:                return MSGLOCAL_SIGNPHISND;
RandomFields/src/operator.gaussmethod.cc:      q->cube.M = m;
RandomFields/src/operator.gaussmethod.cc:      if (radius <= 0.0) return MSGLOCAL_NOPOSITIVEROOT;
RandomFields/src/operator.gaussmethod.cc:      if (q->cube.constant <= 0.0) return MSGLOCAL_SIGNPHI;
RandomFields/src/operator.gaussmethod.cc:    if (phi0 <= 0.0) return MSGLOCAL_SIGNPHI;
RandomFields/src/operator.gaussmethod.cc:    if (phi1 >= 0.0) return MSGLOCAL_SIGNPHIFST;
RandomFields/src/operator.gaussmethod.cc:      if (phi1 >= 0.0) return MSGLOCAL_SIGNPHIFST;
RandomFields/src/operator.gaussmethod.cc:      q->cube.M = m;
RandomFields/src/operator.gaussmethod.cc:      if (radius <= 0.0) return MSGLOCAL_NOPOSITIVEROOT;
RandomFields/src/operator.gaussmethod.cc:      if (q->cube.constant <= 0.0) return MSGLOCAL_SIGNPHI;
RandomFields/src/operator.gaussmethod.cc:		 Methods method, 
RandomFields/src/operator.gaussmethod.cc:  // PMI(cov);
RandomFields/src/operator.gaussmethod.cc:    dim = OWNLOGDIM(0),
RandomFields/src/operator.gaussmethod.cc:		   OWNDOM(0), OWNISO(0), SUBMODEL_DEP, EvaluationType)) != NOERROR) {
RandomFields/src/operator.gaussmethod.cc:		      OWNDOM(0), OWNISO(0), SUBMODEL_DEP, EvaluationType)) != NOERROR)
RandomFields/src/operator.gaussmethod.cc:  if (VDIM0 > LOCALCE_MAXVDIM)
RandomFields/src/operator.gaussmethod.cc:    SERR1("vdim of submodel must be less than %d", LOCALCE_MAXVDIM + 1);
RandomFields/src/operator.gaussmethod.cc:  if (init == NULL) RETURN_ERR(ERRORUNKNOWNMETHOD);
RandomFields/src/operator.gaussmethod.cc:  if (PisNULL(pLOC_DIAM)) {  
RandomFields/src/operator.gaussmethod.cc:    kdefault(cov, pLOC_DIAM, diameter);
RandomFields/src/operator.gaussmethod.cc:    d = P0(pLOC_DIAM);
RandomFields/src/operator.gaussmethod.cc:      msg = XMSGLOCAL_FAILED;
RandomFields/src/operator.gaussmethod.cc:	    MEMCOPY(q, q2, sizeof(localvariabArray));
RandomFields/src/operator.gaussmethod.cc:      if (msg == MSGLOCAL_FAILED) {
RandomFields/src/operator.gaussmethod.cc:	// APMI(cov);
RandomFields/src/operator.gaussmethod.cc:      SERR1("'%.50s' must be a scale", KNAME(pLOC_A));
RandomFields/src/operator.gaussmethod.cc:    MEMCOPY(q, q2, sizeof(localvariabArray));
RandomFields/src/operator.gaussmethod.cc:    diameter = P0(pLOC_DIAM),  
RandomFields/src/operator.gaussmethod.cc:  // assert(hasGaussMethodFrame(cov) || hasAnyEvaluationFrame(cov));
RandomFields/src/operator.gaussmethod.cc:  //VDIM0 or next->vdim[0]?
RandomFields/src/operator.gaussmethod.cc:  if ( VDIM0 > 1 ) {
RandomFields/src/operator.gaussmethod.cc:	    q->cube.B * POW((q->R - y), q->cube.M) +
RandomFields/src/operator.gaussmethod.cc:  // 1 ? 2? More than 2? or inside set_cutoff_q2variate
RandomFields/src/operator.gaussmethod.cc:  //PMI(cov);assert(next->vdim[0]>0);
RandomFields/src/operator.gaussmethod.cc:  range->min[pLOC_DIAM] = 0.0; //  CUTOFF_DIAM
RandomFields/src/operator.gaussmethod.cc:  range->max[pLOC_DIAM] = RF_INF;
RandomFields/src/operator.gaussmethod.cc:  range->pmin[pLOC_DIAM] = 1e-10;
RandomFields/src/operator.gaussmethod.cc:  range->pmax[pLOC_DIAM] = 1e10;
RandomFields/src/operator.gaussmethod.cc:  range->openmin[pLOC_DIAM] = true;
RandomFields/src/operator.gaussmethod.cc:  range->openmax[pLOC_DIAM] = true;
RandomFields/src/operator.gaussmethod.cc:    diameter = P0(pLOC_DIAM);
RandomFields/src/operator.gaussmethod.cc:  // assert(hasAnyEvaluationFrame(cov) || hasGaussMethodFrame(cov));
RandomFields/src/operator.gaussmethod.cc:  range->min[pLOC_DIAM] = 0.0; 
RandomFields/src/operator.gaussmethod.cc:  range->max[pLOC_DIAM] = RF_INF;
RandomFields/src/operator.gaussmethod.cc:  range->pmin[pLOC_DIAM] = 0.01;
RandomFields/src/operator.gaussmethod.cc:  range->pmax[pLOC_DIAM] = 100;
RandomFields/src/operator.gaussmethod.cc:  range->openmin[pLOC_DIAM] = true;
RandomFields/src/operator.gaussmethod.cc:  range->openmax[pLOC_DIAM] = true;
Binary file RandomFields/src/xport_import.o matches
RandomFields/src/Error.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/Error.cc: Copyright (C) 2017 -- 2018 Martin Schlather
RandomFields/src/Error.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/Error.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/Error.cc:#define SCPY(A,B) STRNCPY(A,B,LENERRMSG);
RandomFields/src/Error.cc:void errorMSG(int err, errorstring_type errorstring, KEY_type *KT,
RandomFields/src/Error.cc:	      char* M, int len) {
RandomFields/src/Error.cc:  char m[LENERRMSG];
RandomFields/src/Error.cc:  if (err >= ERRORM && err <= ERRORMEND) err = ERRORM;
RandomFields/src/Error.cc:  case ERRORM: case XERRORCHANGESYSTEM:
RandomFields/src/Error.cc:    //  case XERRORTRAFOSYSTEM:
RandomFields/src/Error.cc:   case XERRORVDIMNOTPROGRAMMEDYET :    
RandomFields/src/Error.cc:  case XERRORDECOMPOSITION:
RandomFields/src/Error.cc:  case XERRORNOMULTIVARIATE :
RandomFields/src/Error.cc:  case XERROR_MATRIX_SQUARE :
RandomFields/src/Error.cc:  case XERROR_MATRIX_VDIM :
RandomFields/src/Error.cc:  case XERROR_MATRIX_POSDEF :
RandomFields/src/Error.cc:    //  case XERROR_MATRIX_ :   SCPY(m, ""); break;
RandomFields/src/Error.cc:  case XERRORCEDIM: 
RandomFields/src/Error.cc:	    MAXCEDIM);break;
RandomFields/src/Error.cc:    //  case XERROR_MATRIX_ :   SCPY(m, ""); break;
RandomFields/src/Error.cc:  case ERRORDIM: 
RandomFields/src/Error.cc:  case XERRORTOOMANYLOC:
RandomFields/src/Error.cc:    SCPY(m,"unstationary scale not allowed yet for RMS con-struct-ions");
RandomFields/src/Error.cc:  case XERRORNOSTATMATCH : 
RandomFields/src/Error.cc:  case XERRORUNKNOWNMETHOD:
RandomFields/src/Error.cc:  case XERRORWRONGDIM:
RandomFields/src/Error.cc:  case XERROROUTOFMETHODLIST:
RandomFields/src/Error.cc:  case XERRORWRONGDOM:
RandomFields/src/Error.cc:  case XERRORBADVDIM: 
RandomFields/src/Error.cc:  case XERRORSUBMETHODFAILED:
RandomFields/src/Error.cc:   case XERRORNOVARIOGRAM:
RandomFields/src/Error.cc:  case XERRORNORMALMIXTURE:
RandomFields/src/Error.cc:  case XERRORMAXDIMMETH:
RandomFields/src/Error.cc:  case XERRORTBMCOMBI: 
RandomFields/src/Error.cc:  case XERRORINVALIDMODEL : // gauss distribution, no method
RandomFields/src/Error.cc:  case XERRORODDMODEL : // gauss distribution, no method
RandomFields/src/Error.cc:  case XERRORDIAMETERNOTGIVEN:
RandomFields/src/Error.cc: case XERRORRANDOMKAPPA:
RandomFields/src/Error.cc:  case XERRORUNKNOWNMAXTYPE :
RandomFields/src/Error.cc:  case XERRORATOMP :
RandomFields/src/Error.cc:  case MSGLOCAL_OK :
RandomFields/src/Error.cc:  case XMSGLOCAL_JUSTTRY :
RandomFields/src/Error.cc:  case XMSGLOCAL_NUMOK :
RandomFields/src/Error.cc:  case XMSGLOCAL_ENDOFLIST :
RandomFields/src/Error.cc:  case XMSGLOCAL_SIGNPHI :
RandomFields/src/Error.cc:  case XMSGLOCAL_SIGNPHIFST :
RandomFields/src/Error.cc:  case XMSGLOCAL_SIGNPHISND :
RandomFields/src/Error.cc: case XMSGLOCAL_NOPOSITIVEROOT :
RandomFields/src/Error.cc:  case XMSGLOCAL_INITINTRINSIC :
RandomFields/src/Error.cc:  case ERRORNOTPROGRAMMEDYET :    // imported from Utils 
RandomFields/src/Error.cc:  case ERRORMEMORYALLOCATION:     // imported from Utils 
RandomFields/src/Error.cc:    // case ERRORDUMMY : SCPY(m,"none (dummy)"); break; 
RandomFields/src/Error.cc:  case TOOLS_DIM :
RandomFields/src/Error.cc:  case TOOLS_METHOD:
RandomFields/src/Error.cc:  case XMSGLOCAL_FAILED :
RandomFields/src/Error.cc:  case XMSGLOCAL_WRONGRADII :
RandomFields/src/Error.cc:  char m2[LENERRMSG];
RandomFields/src/Error.cc:  STRNCPY(M, m2, MAXERRORSTRING);
RandomFields/src/Error.cc:  // printf("!!!! err=%d M=%s m2=%s m=%s\n", err, M, m2, m);
RandomFields/src/Error.cc:void errorMSG(int err, char* m, errorstring_type err_msg) {
RandomFields/src/Error.cc:  errorMSG(err, err_msg, NULL, m, MAXERRORSTRING);}
RandomFields/src/Error.cc:void errorMSG(int err, errorstring_type err_msg, KEY_type *KT, char* m) {
RandomFields/src/Error.cc:  errorMSG(err, err_msg, KT, m, MAXERRORSTRING); }
RandomFields/src/Error.cc://errorstring_type err_msg = "error could not be identified in multicore modus. Recompile without OMP to see the error msg.";
RandomFields/src/Error.cc:void errorMSG(int err, char* m) {
RandomFields/src/Error.cc:  errorMSG(err, err_msg, NULL, m, MAXERRORSTRING);
RandomFields/src/Error.cc:void errorMSG(int err, KEY_type *KT, char* m) {
RandomFields/src/Error.cc:  errorMSG(err, err_msg, KT, m, MAXERRORSTRING);
RandomFields/src/Error.cc:  char m[MAXERRORSTRING];
RandomFields/src/Error.cc:  errorMSG(Err, errmsg, NULL, m, MAXERRORSTRING);
RandomFields/src/Error.cc:  char m[MAXERRORSTRING];
RandomFields/src/Error.cc:  errorMSG(Err, errmsg, KT, m, MAXERRORSTRING);
RandomFields/src/Error.cc:  char m[MAXERRORSTRING];
RandomFields/src/Error.cc:  errorMSG(Err,
RandomFields/src/Error.cc:	   cov->base, m, MAXERRORSTRING);
RandomFields/src/fft.cc: *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/fft.cc:#include <limits.h> /* for INT_MAX */
RandomFields/src/fft.cc: * PROBLEM (see fftmx  below):	nfac[] is overwritten by fftmx() in fft_work()
RandomFields/src/fft.cc:    rad = M_PI_4;/* = pi/4 =^= 45 degrees */
RandomFields/src/fft.cc:    s120 = 0.5*M_SQRT_3;/* sin(120) = sqrt(3)/2 */
RandomFields/src/fft.cc:#ifdef TRUNCATED_ARITHMETIC
RandomFields/src/fft.cc:#ifdef TRUNCATED_ARITHMETIC
RandomFields/src/fft.cc:#ifdef TRUNCATED_ARITHMETIC
RandomFields/src/fft.cc:    /* Here, nfac[] is overwritten... -- now CUMULATIVE ("cumprod") factors */
RandomFields/src/fft.cc:	    if (j > INT_MAX - 2)
RandomFields/src/questions.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/questions.cc: Copyright (C) 2001 -- 2017 Martin Schlather
RandomFields/src/questions.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/questions.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/questions.cc:  for (; i<=LASTSYSTEM(s); i++) if (DOM(s, i) != DOM(s,0)) break;
RandomFields/src/questions.cc:  return i > LASTSYSTEM(s);
RandomFields/src/questions.cc:  return equalsXonly(DOM(s, 0));
RandomFields/src/questions.cc:  return equalsKernel(DOM(s, 0));
RandomFields/src/questions.cc:bool equalsDomMismatch(domain_type dom) { return dom == DOMAIN_MISMATCH; }
RandomFields/src/questions.cc:bool equalsPrevModelD(domain_type dom) { return dom == PREVMODEL_D;}
RandomFields/src/questions.cc:bool isPrevModelD(domain_type dom) {
RandomFields/src/questions.cc:  return dom == PREVMODEL_D || dom == PREV_SUB_D ;
RandomFields/src/questions.cc:bool isPrevModelD(defn *C){
RandomFields/src/questions.cc:  assert(LASTSYSTEM(C->systems[0]) >= 0);
RandomFields/src/questions.cc:  bool is = isPrevModelD(DOM(C->systems[0], 0));
RandomFields/src/questions.cc:  assert(!is || LASTSYSTEM(C->systems[0]) == 0);
RandomFields/src/questions.cc:// bool equalsSubModelD(domain_type dom) { return dom == SUBMODEL_D;}
RandomFields/src/questions.cc:bool isSubModelD(domain_type dom) {
RandomFields/src/questions.cc:  return dom == SUBMODEL_D || dom == PREV_SUB_D ;
RandomFields/src/questions.cc:bool isSubModelD(defn *C){
RandomFields/src/questions.cc:  assert(LASTSYSTEM(C->systems[0]) >= 0);
RandomFields/src/questions.cc:  bool is = isSubModelD(DOM(C->systems[0], 0));
RandomFields/src/questions.cc:  assert(!is || LASTSYSTEM(C->systems[0]) == 0);
RandomFields/src/questions.cc:bool equalsParamDepD(domain_type dom) { return dom == PARAMDEP_D;}
RandomFields/src/questions.cc:  assert(LASTSYSTEM(C->systems[0]) >= 0);
RandomFields/src/questions.cc:  bool is = equalsParamDepD(DOM(C->systems[0], 0));
RandomFields/src/questions.cc:  assert(!is || LASTSYSTEM(C->systems[0]) == 0);
RandomFields/src/questions.cc:bool equalsParamDepI(isotropy_type iso) { return iso == PARAMDEP_I;}
RandomFields/src/questions.cc:  assert(LASTSYSTEM(C->systems[0]) >= 0);
RandomFields/src/questions.cc:  assert(!is || LASTSYSTEM(C->systems[0]) == 0);
RandomFields/src/questions.cc:  return LASTSYSTEM(sys) == 0 && equalsIsotropic(ISO(sys, 0)); }
RandomFields/src/questions.cc:  return LASTSYSTEM(s) == 0 && equalsIsotropic(ISO(s, 0)) &&
RandomFields/src/questions.cc:    equalsXonly(DOM(s, 0)); }
RandomFields/src/questions.cc:#if MAXSYSTEMS == 1
RandomFields/src/questions.cc:  return LASTSYSTEM(sys) == 1 && equalsIsotropic(ISO(sys, 0)) && 
RandomFields/src/questions.cc:    equalsIsotropic(ISO(sys, 1)) && LOGDIM(sys, 1) == 1;
RandomFields/src/questions.cc:bool isSymmetric(isotropy_type iso) { return iso <= SYMMETRIC; }
RandomFields/src/questions.cc:bool equalsSymmetric(isotropy_type iso) { return iso == SYMMETRIC; }
RandomFields/src/questions.cc:  return LASTSYSTEM(sys) >= s && isCartesian(ISO(sys, s));}
RandomFields/src/questions.cc:  int L = LASTSYSTEM(sys);
RandomFields/src/questions.cc:bool equalsGnomonic(isotropy_type iso) { return iso == GNOMONIC_PROJ; }
RandomFields/src/questions.cc:  return iso == SPHERICAL_SYMMETRIC;
RandomFields/src/questions.cc:  return iso == EARTH_SYMMETRIC;
RandomFields/src/questions.cc:  return false; // LASTSYSTEM(sys) >= s && isLogCart(ISO(sys, s));
RandomFields/src/questions.cc:  return false; //iso == LOGCART_SYMMETRIC;
RandomFields/src/questions.cc:  return isCartesian(iso) && iso > LAST_REDUCEDXDIM_CART; }
RandomFields/src/questions.cc:bool equalsPrevModelI(isotropy_type iso) { return iso == PREVMODEL_I;}
RandomFields/src/questions.cc:bool isPrevModelI(isotropy_type iso) {
RandomFields/src/questions.cc:  return iso == PREVMODEL_I || iso == PREV_SUB_I ;
RandomFields/src/questions.cc:bool isPrevModelI(defn *C){
RandomFields/src/questions.cc:  assert(LASTSYSTEM(C->systems[0]) >= 0);
RandomFields/src/questions.cc:  bool is = isPrevModelI(ISO(C->systems[0], 0));
RandomFields/src/questions.cc:  assert(!is || LASTSYSTEM(C->systems[0]) == 0);
RandomFields/src/questions.cc:bool equalsSubModelI(isotropy_type iso) { return iso == SUBMODEL_I;}
RandomFields/src/questions.cc:bool isSubModelI(isotropy_type iso) {
RandomFields/src/questions.cc:  return iso == SUBMODEL_I || iso == PREV_SUB_I;
RandomFields/src/questions.cc:bool isSubModelI(defn *C){
RandomFields/src/questions.cc:  assert(LASTSYSTEM(C->systems[0]) >= 0);
RandomFields/src/questions.cc:  bool is = isSubModelI(ISO(C->systems[0], 0));
RandomFields/src/questions.cc:  assert(!is || LASTSYSTEM(C->systems[0]) == 0);
RandomFields/src/questions.cc:bool equalsIsoMismatch(isotropy_type iso) { return iso == ISO_MISMATCH; }
RandomFields/src/questions.cc:  return dom <= LAST_DOMAINUSER;
RandomFields/src/questions.cc:bool isMonotone(monotone_type  monotone) {
RandomFields/src/questions.cc:  return monotone >= MONOTONE && monotone <= COMPLETELY_MON; }
RandomFields/src/questions.cc:bool isMonotone(model *cov) { return isMonotone(cov->monotone); }
RandomFields/src/questions.cc:bool isCompletelyMonotone(monotone_type monotone) { return monotone == COMPLETELY_MON; }
RandomFields/src/questions.cc:bool isNormalMixture(monotone_type monotone) {
RandomFields/src/questions.cc:  return monotone == NORMAL_MIXTURE || isCompletelyMonotone(monotone);}
RandomFields/src/questions.cc:bool isNormalMixture(model *cov) { return isNormalMixture(cov->monotone); }
RandomFields/src/questions.cc:  return monotone == GNEITING_MON || isCompletelyMonotone(monotone);}
RandomFields/src/questions.cc:bool isManifold(defn *C) {
RandomFields/src/questions.cc:  bool is = isManifold(SYSTYPE(C->systems[0], 0));
RandomFields/src/questions.cc:  return COVNR == SHAPE_FCT_PROC || isMathDef(DefList + COVNR) || COVNR==COVARIATE;
RandomFields/src/questions.cc:bool isMathDef(defn *C) {
RandomFields/src/questions.cc:  return LASTSYSTEM(C->systems[0]) == 0 &&
RandomFields/src/questions.cc:    SYSTYPE(C->systems[0], 0) == MathDefType;
RandomFields/src/questions.cc:  //  printf("isdefcl = %s\n", NAME(cov));
RandomFields/src/questions.cc:  //  if (LASTi((sys)[0]) < 0) { printf(" %d %d\n",cov->variant, (LASTi((sys)[0])));TREE0(cov);PMI0(cov); crash();}
RandomFields/src/questions.cc:  int n = SYSTEMS(sys);
RandomFields/src/questions.cc:  if (equalsManifold(type)) return false;
RandomFields/src/questions.cc:  //    //   printf("call of TypeFct in isDefCL by is(%s)\n", NAME(cov));
RandomFields/src/questions.cc:  //  printf("name = %s %d\n", NAME(cov), isTypus(type));
RandomFields/src/questions.cc:  int n = OWNSYSTEMS;
RandomFields/src/questions.cc:bool isMaxStable(Types type) {
RandomFields/src/questions.cc:  return type == BrMethodType || type == SmithType || type == SchlatherType; }
RandomFields/src/questions.cc:bool isnowMaxStable(model *cov) { return isNow(isMaxStable, cov, true); }
RandomFields/src/questions.cc:bool hasMaxStableFrame(model *cov) { return isMaxStable(cov->frame); }
RandomFields/src/questions.cc:QuestionIsNow(Process, ProcessType || type == GaussMethodType ||
RandomFields/src/questions.cc:	      isMaxStable(type) || type == NormedProcessType, true)
RandomFields/src/questions.cc:Question(GaussMethod, true) 
RandomFields/src/questions.cc:Question(BrMethod, true)//
RandomFields/src/questions.cc:QuestionIsNow(Shape, ShapeType || isNegDef(type) || isMathDef(type), true)
RandomFields/src/questions.cc:QuestionNow(Trend, TrendType || isMathDef(type) ||  type == ShapeType , false)
RandomFields/src/questions.cc:Question(Manifold, true) 
RandomFields/src/questions.cc:Question(MathDef, true)
RandomFields/src/questions.cc:  //  PMI(cov);
RandomFields/src/questions.cc:    isnowTrend(cov) && (SortOf(cov, i, 0, 0, original_model) == TRENDPARAM);
RandomFields/src/questions.cc:  //  PMI(cov);
RandomFields/src/questions.cc:  //printf("equalsnowTrend %s i=%d %s %d %d\n", NAME(cov), i, C->kappanames[i], equalsnowTrend(cov), SortOf(cov, i, 0, 0, original_model) == TRENDPARAM);
RandomFields/src/questions.cc:    equalsnowTrend(cov) && (SortOf(cov, i, 0, 0, original_model) == TRENDPARAM);
RandomFields/src/questions.cc:	last = LASTSYSTEM(C->systems[i]);
RandomFields/src/questions.cc:    n = OWNLASTSYSTEM;
RandomFields/src/questions.cc:  int n = LASTSYSTEM(fst);
RandomFields/src/questions.cc:  if (n != LASTSYSTEM(snd)) return false;
RandomFields/src/questions.cc:  int tot =LOGDIM(sys, 0),
RandomFields/src/questions.cc:    last = LASTSYSTEM(sys);
RandomFields/src/questions.cc:  for (int s=1; s<=last; s++) tot += LOGDIM(sys, s);
RandomFields/src/questions.cc:  int last = OWNLASTSYSTEM;
RandomFields/src/questions.cc:    int max = OWNMAXDIM(s);
RandomFields/src/questions.cc:    if (max >= 0 && max < OWNLOGDIM(s)) return s;
RandomFields/src/questions.cc:  int n = OWNSYSTEMS;
RandomFields/src/questions.cc:  domain_type dom = OWNDOM(0);
RandomFields/src/questions.cc:    if (dom != OWNDOM(s)) return false;
RandomFields/src/questions.cc:#define NOTMATCHING -1
RandomFields/src/questions.cc:  return NOTMATCHING;
RandomFields/src/questions.cc:  int last = SYSTEMS(sys);
RandomFields/src/questions.cc:  if (isManifold(C)) {
RandomFields/src/questions.cc:    //     printf("tc=%d %s\n", tc, NAME(cov));
RandomFields/src/questions.cc:  int n = OWNSYSYEMS;
RandomFields/src/questions.cc:	if (j > last) return NOTMATCHING;
RandomFields/src/questions.cc:  return NOTMATCHING;
RandomFields/src/questions.cc:bool isMiso(matrix_type type) { 
RandomFields/src/questions.cc:  return type == TypeMiso;
RandomFields/src/questions.cc:bool isMproj(matrix_type type) { 
RandomFields/src/questions.cc:  assert(TypeMtimesepproj == 2);
RandomFields/src/questions.cc: return type == TypeMproj || type <= TypeMtimesepproj;
RandomFields/src/questions.cc:bool isMdiag(matrix_type type) { 
RandomFields/src/questions.cc:  return type <= TypeMdiag;
RandomFields/src/questions.cc:bool isMtimesep(matrix_type type) { 
RandomFields/src/questions.cc:  assert(TypeMtimesep == 3);
RandomFields/src/questions.cc:  return type <= TypeMtimesep;
RandomFields/src/questions.cc:bool isPlusMal(model *cov) {
RandomFields/src/questions.cc:  return nr == COVFCTN || nr == COVMATRIX ;
RandomFields/src/questions.cc:  int last = OWNLASTSYSTEM;
RandomFields/src/questions.cc:    if (OWNMAXDIM(s) >= 0 &&  OWNMAXDIM(s) < OWNLOGDIM(s)) return -s;
RandomFields/src/questions.cc:  if (iso == as) return true; // e.g. MISMATCH; PARAM_DEP, etc.
RandomFields/src/questions.cc:  if (isPrevModelI(iso) || isSubModelI(iso)) return true;
RandomFields/src/questions.cc:  //  printf("atleast %s as %s; isprevmodeli=%d\n", ISO_NAMES[iso], ISO_NAMES[as],	 isPrevModelI(iso));
RandomFields/src/questions.cc:    //  printf("%s %s\n", ISO_NAMES[iso], ISO_NAMES[as]);
RandomFields/src/questions.cc:  //printf("tc: %s %s\n", TYPE_NAMES[requiredtype], TYPE_NAMES[deliveredtype]);
RandomFields/src/questions.cc:  if (isManifold(deliveredtype)) BUG;
RandomFields/src/questions.cc:    // case ManifoldType: BUG;
RandomFields/src/questions.cc:  case GaussMethodType: return isGaussMethod(deliveredtype) ? deliveredtype
RandomFields/src/questions.cc:  case BrMethodType: return isBrMethod(deliveredtype) ? deliveredtype : BadType;
RandomFields/src/questions.cc:    // case MathDefType: BUG;
RandomFields/src/questions.cc:  default : // printf("%s\n", TYPE_NAMES[requiredtype]);
RandomFields/src/questions.cc:  assert(!isManifold(requiredtype));
RandomFields/src/questions.cc:  assert(!isSubModelI(requirediso));
RandomFields/src/questions.cc:  assert(!equalsIsoMismatch(requirediso));
RandomFields/src/questions.cc:  assert(!equalsIsoMismatch(requirediso));
RandomFields/src/questions.cc:  //  PMI0(cov);
RandomFields/src/questions.cc:  PRINTF(">>>! typeconsist: %s requ=('%s' %s) %s\n", NAME(cov), TYPE_NAMES[requiredtype], ISO_NAMES[requirediso], ISO_NAMES[OWNISO(0)]);
RandomFields/src/questions.cc:  //   PMI(cov); 
RandomFields/src/questions.cc:    PRINTF("MANIFOLD %s requ:%s, %s (own=%s)\n", NAME(cov), TYPE_NAMES[requiredtype], ISO_NAMES[requirediso], ISO_NAMES[OWNISO(0)]);
RandomFields/src/questions.cc:    PRINTF("tc=%s\n", TYPE_NAMES[tc]);
RandomFields/src/questions.cc:      PMI(cov); //
RandomFields/src/questions.cc:    if (!isBad(tc) && isnowManifold(cov)) set_type(OWN, 0, (Types) tc);
RandomFields/src/questions.cc:    //    PMI(cov);
RandomFields/src/questions.cc:    //    printf("V unset %s\n", NAME(cov));
RandomFields/src/questions.cc:      PRINTF("V for=%d(%d %d) %d %s atleast=%d\n", V, minV, maxV, TypeConsistency(requiredtype, SYSTYPE(C->systems[V], 0)), ISO_NAMES[ISO(C->systems[V],0)], atleastSpecialised(ISO(C->systems[V], 0), requirediso));
RandomFields/src/questions.cc:  assert(V >= 0 && V < MAXVARIANTS);
RandomFields/src/questions.cc:  //  PMI(cov->calling);
RandomFields/src/questions.cc:  PRINTF("W=%d type=%s requ=%s consist=%d (%d!=%d & %d) && %s requ.iso=%s\n", V,  TYPE_NAMES[type],TYPE_NAMES[requiredtype], consist, TypeConsistency(requiredtype, type), BadType, atleastSpecialised(iso, requirediso), ISO_NAMES[iso], ISO_NAMES[requirediso]);
RandomFields/src/questions.cc:  // if (!consist && equalsTrend(PREVTYPE(0))) {PMI(cov); BUG;}
RandomFields/src/questions.cc:  return Aniso!=NULL && DefList[MODELNR(Aniso)].check == checkAngle;
RandomFields/src/questions.cc:  return isCartesian(iso) && iso > LAST_REDUCEDXDIM_CART;
RandomFields/src/questions.cc:  return covnr == RANDOMCOIN_USER || covnr == AVERAGE_USER ||
RandomFields/src/questions.cc:    covnr == POISSONPROC || covnr == SMITHPROC;
RandomFields/src/questions.cc:	PMI0(cov);//
RandomFields/src/questions.cc:	PMI0(cov);//
RandomFields/src/questions.cc:  for (int i=maxsub; i < MAXSUB; i++) {
RandomFields/src/questions.cc:	    NAME(cov), i+1, TH(i+1), nsub);
RandomFields/src/questions.cc:    GETSTOMODEL;
RandomFields/src/questions.cc:      model *sub = STOMODEL->keys[i];
RandomFields/src/questions.cc:	if (i > 0 && STOMODEL->keys[i-1] != NULL) { //either all or none NULL!
RandomFields/src/questions.cc:	  PMI0(cov); //
RandomFields/src/questions.cc:	  PMI0(cov); //
RandomFields/src/questions.cc:  // PMI0(cov);
RandomFields/src/questions.cc:  // if (!PREV_INITIALISED) {PMI0(cov); crash();}
RandomFields/src/questions.cc:  //  PMI0(cov);
RandomFields/src/questions.cc:    PMI0(cov->calling); //
RandomFields/src/questions.cc:    PMI0(cov);//
RandomFields/src/questions.cc:	   NAME(cov), FIRSTGATTER, GATTERNR, LASTGATTER, 
RandomFields/src/questions.cc:  return pt == ONLYRETURN || pt == DONOTVERIFYPARAM  || pt == IGNOREPARAM ||
RandomFields/src/questions.cc:    pt == FORBIDDENPARAM;
RandomFields/src/RMS.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/RMS.cc:   in RFsimu.h, since there is gno error check (e.g. initialization of RANDOM)
RandomFields/src/RMS.cc: * definitions for the random coin method can be found in MPPFcts.cc
RandomFields/src/RMS.cc:   SophisticatedModel.cc; hyper models also in Hypermodel.cc
RandomFields/src/RMS.cc: Copyright (C) 2001 -- 2003 Martin Schlather
RandomFields/src/RMS.cc: Copyright (C) 2004 -- 2004 Yindeng Jiang & Martin Schlather
RandomFields/src/RMS.cc: Copyright (C) 2005 -- 2017 Martin Schlather
RandomFields/src/RMS.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/RMS.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/RMS.cc:    *nr = OWNTOTALXDIM;
RandomFields/src/RMS.cc:    *nc = SIZE_NOT_DETERMINED;
RandomFields/src/RMS.cc:    *nr = SIZE_NOT_DETERMINED;
RandomFields/src/RMS.cc:    *nc = OWNTOTALXDIM;
RandomFields/src/RMS.cc:    *nr = SIZE_NOT_DETERMINED;
RandomFields/src/RMS.cc:    vdim = VDIM0,
RandomFields/src/RMS.cc:    vdim = VDIM0,
RandomFields/src/RMS.cc:	  DefList[MODELNR(cov->kappasub[DANISO])].check==checkAngle)&& 
RandomFields/src/RMS.cc:	  DefList[MODELNR(cov->kappasub[DAUSER])].check==checkAngle));
RandomFields/src/RMS.cc:    vdim = VDIM0,
RandomFields/src/RMS.cc:    int xdimown = OWNTOTALXDIM;
RandomFields/src/RMS.cc:    xdimown = OWNTOTALXDIM,   
RandomFields/src/RMS.cc:    vdim = VDIM0,
RandomFields/src/RMS.cc:      ERR1("'%.50s' must be a positive function", KNAME(DSCALE));
RandomFields/src/RMS.cc:    //  if (x[0]!=1.0) printf("\n%.50s x=%10g,%10g %10g y=%10g,%10g %10g; %d\n", NAME(Scale), x[0], x[1], s1, y[0], y[1], s2, xdimown);
RandomFields/src/RMS.cc:    vdim = VDIM0;
RandomFields/src/RMS.cc:  assert(dim == PREVTOTALXDIM);
RandomFields/src/RMS.cc:     StandardCovMatrix(cov, ignore_y, v); 
RandomFields/src/RMS.cc:    XERR(ERRORMEMORYALLOCATION);
RandomFields/src/RMS.cc:  int L = OWNLASTSYSTEM; if (L != LASTSYSTEM(PREVSYSOF(next))) BUG;
RandomFields/src/RMS.cc:    if (XDIM(PREVSYSOF(next), s) != NEXTXDIM(s)) {
RandomFields/src/RMS.cc:      CovarianceMatrix(cov, ignore_y, v); 
RandomFields/src/RMS.cc:  COPYALLSYSTEMS(prev, PREVSYSOF(next), false);
RandomFields/src/RMS.cc:  COPYALLSYSTEMS(gatter, GATTERSYSOF(next), false);
RandomFields/src/RMS.cc:  COPYALLSYSTEMS(own, NEXT, false);
RandomFields/src/RMS.cc:  COPYALLSYSTEMS(PREVSYSOF(next), PREV, false);
RandomFields/src/RMS.cc:  COPYALLSYSTEMS(GATTERSYSOF(next), GATTER, false);
RandomFields/src/RMS.cc:  COPYALLSYSTEMS(NEXT, OWN, true);
RandomFields/src/RMS.cc:  COPYALLSYSTEMS(PREVSYSOF(next), prev, false);
RandomFields/src/RMS.cc:  COPYALLSYSTEMS(GATTERSYSOF(next), gatter, false);
RandomFields/src/RMS.cc:  COPYALLSYSTEMS(NEXT, own, false);
RandomFields/src/RMS.cc:    vdim = VDIM0,
RandomFields/src/RMS.cc:    vdim = VDIM0,
RandomFields/src/RMS.cc:    vdim = VDIM0,
RandomFields/src/RMS.cc:    vdim = VDIM0,
RandomFields/src/RMS.cc:    xdimown = OWNTOTALXDIM,
RandomFields/src/RMS.cc:	    KNAME(idx[i])); 
RandomFields/src/RMS.cc:    dim = PREVTOTALXDIM,
RandomFields/src/RMS.cc:    if (isMiso(Type(aniso, cov->nrow[DANISO], cov->ncol[DANISO]))) 
RandomFields/src/RMS.cc:    dim = PREVTOTALXDIM,
RandomFields/src/RMS.cc:    //   printf("logS %f  %f %f %s\n", y, *left, *right, NAME(next));    
RandomFields/src/RMS.cc:    //    printf("S %f  %e %e x=%f, var=%f  %s\n", y, *left, *right, *x, var, NAME(next));
RandomFields/src/RMS.cc:    //if (y > 1.0) {PMI(cov); crash();}
RandomFields/src/RMS.cc:    if (isMiso(Type(aniso, cov->nrow[DANISO], cov->ncol[DANISO]))) s/=aniso[0];
RandomFields/src/RMS.cc:	    ERR("Multiprocessor conflict. Plse inform maintainer & try again");
RandomFields/src/RMS.cc:	  ERR("Multiprocessor conflict. Plse inform maintainer & try again");
RandomFields/src/RMS.cc:	MEMCOPY(save_aniso, P(DANISO), bytes);
RandomFields/src/RMS.cc:	MEMCOPY(inv_aniso, P(DANISO), bytes);
RandomFields/src/RMS.cc:	if (Ext_invertMatrix(inv_aniso, nrow) != NOERROR) XERR(ERRORANISO_INV);
RandomFields/src/RMS.cc:	Ext_sleepMicro(&sleep);
RandomFields/src/RMS.cc:      MEMCOPY(LR, right, size);
RandomFields/src/RMS.cc:      MEMCOPY(LR, left, size);
RandomFields/src/RMS.cc:    if (DefList[MODELNR(Aniso)].inverse == inverseErr) XERR(ERRORANISO_INV);
RandomFields/src/RMS.cc:    MEMCOPY(LR, right, size);
RandomFields/src/RMS.cc:    MEMCOPY(LR, left, size);
RandomFields/src/RMS.cc:    int nextdim = NEXTTOTALXDIM;
RandomFields/src/RMS.cc:    //    PMI0(cov);
RandomFields/src/RMS.cc:  //  PMI0(cov);
RandomFields/src/RMS.cc:  //  printf("SS %f  %e %e %f dim=%d %s\n", y, *left, right[0], s, dim, NAME(next));
RandomFields/src/RMS.cc:      if (y[0] == 0.0) COV(y, info, next, v) else TBM2CALL(y, info, next, v);
RandomFields/src/RMS.cc: 	TBM2CALL(y, info, next, v);
RandomFields/src/RMS.cc:	  TBM2CALL(y, info, next, v);
RandomFields/src/RMS.cc:      if (OWNTOTALXDIM == 2){
RandomFields/src/RMS.cc:	if (y[0] == 0.0) COV(y, info, next, v) else TBM2CALL(y, info, next, v);
RandomFields/src/RMS.cc:	TBM2CALL(y, info, next, v);
RandomFields/src/RMS.cc:      if (OWNTOTALXDIM == 2)
RandomFields/src/RMS.cc:      TBM2CALL(y, info, next, v);
RandomFields/src/RMS.cc:     TBM2CALL(xy, info, next, v);
RandomFields/src/RMS.cc:// TODO : Aniso=Matrix: direkte implementierung in S,
RandomFields/src/RMS.cc:     //xdimgatter = GATTERTOTALXDIM,
RandomFields/src/RMS.cc:     // KOMMENTAR NICHT LOESCHEN
RandomFields/src/RMS.cc:     last = OWNLASTSYSTEM; 
RandomFields/src/RMS.cc:  matrix_type mtype = TypeMany;
RandomFields/src/RMS.cc:  if ( (!PisNULL(DSCALE) || Scale != NULL) && OWNLASTSYSTEM != 0)
RandomFields/src/RMS.cc:	  KNAME(DSCALE));
RandomFields/src/RMS.cc:  int dim = OWNLOGDIM(0);
RandomFields/src/RMS.cc:      OWNLASTSYSTEM == 0 && OWNXDIM(0) == dim) {
RandomFields/src/RMS.cc:		     SUBMODEL_DEP, cov->frame)) == NOERROR) {
RandomFields/src/RMS.cc: 	 AngleMatrix(Aniso, P(DAUSER));
RandomFields/src/RMS.cc:    SERR1("'%.50s' may not be a function.", KNAME(DANISO));
RandomFields/src/RMS.cc:    //      PRINTF("NOTE! Starting with RandomFields 3.0, the use of '%s' is different from\nthe former '%s' insofar that '%s' is multiplied from the right by 'x' (i.e. Ax),\nwhereas '%s' had been multiplied from the left by 'x' (i.e. xA).\n", KNAME(DAUSER), KNAME(DANISO), KNAME(DANISO), KNAME(DAUSER));
RandomFields/src/RMS.cc:	if (ISNAN(pA[j])) ERR("(Parts of) 'Aniso' may not be estimated. Instead 'anisoT', which equals 't(Aniso)', must be used. See ?RMS for details.");
RandomFields/src/RMS.cc:    if ((err = CHECK(Var, OWNLOGDIM(0), OWNXDIM(0), 
RandomFields/src/RMS.cc:		     ShapeType, // only!! -- for pos def use RMprod
RandomFields/src/RMS.cc:	SERR2("positivity of '%.50s' required. Got '%.50s'", KNAME(DVAR), 
RandomFields/src/RMS.cc:	      POSITIVITY_NAMES[Var->ptwise_definite]);
RandomFields/src/RMS.cc:  int xdimNeu = OWNXDIM(0);
RandomFields/src/RMS.cc:      SERR2("if '%.50s' is an arbitrary function, only '%.50s' may be given as additional parameter.", KNAME(DAUSER), KNAME(DVAR));
RandomFields/src/RMS.cc:    if ((err = CHECK(Aniso, OWNLOGDIM(0), OWNXDIM(0), ShapeType, XONLY,
RandomFields/src/RMS.cc:		     CARTESIAN_COORD, SUBMODEL_DEP, cov->frame)) != NOERROR) {
RandomFields/src/RMS.cc:	    KNAME(DANISO), Aniso->vdim[0], Aniso->vdim[1]);
RandomFields/src/RMS.cc:      ASSERT_QUASIONESYSTEM;
RandomFields/src/RMS.cc:		      OWNTYPE(0), OWNDOM(0), owniso, 
RandomFields/src/RMS.cc:		      SUBMODEL_DEP, cov->frame)) != NOERROR) {
RandomFields/src/RMS.cc:      cov->pref[Hyperplane] = cov->pref[SpectralTBM] = cov->pref[TBM] = 
RandomFields/src/RMS.cc:       SERR2("if '%.50s' is an arbitrary function, only '%.50s' may be given as additional parameter.", KNAME(DSCALE), KNAME(DVAR));
RandomFields/src/RMS.cc:    if ((err = CHECK(Scale, OWNLOGDIM(0), OWNXDIM(0), ShapeType, XONLY,
RandomFields/src/RMS.cc:	    KNAME(DSCALE), Aniso->vdim[0], Aniso->vdim[1]);
RandomFields/src/RMS.cc:      ASSERT_QUASIONESYSTEM;
RandomFields/src/RMS.cc:      if ((err = CHECK(sub, OWNLOGDIM(0), OWNXDIM(0),
RandomFields/src/RMS.cc:		       SYSTYPE(OWN, 0), OWNDOM(0), 
RandomFields/src/RMS.cc:		       owniso, SUBMODEL_DEP, cov->frame)) != NOERROR) {
RandomFields/src/RMS.cc:      if (!isNormalMixture(next)) 
RandomFields/src/RMS.cc:      cov->pref[Hyperplane] = cov->pref[SpectralTBM] = cov->pref[TBM] = 
RandomFields/src/RMS.cc:    int xdimown = OWNTOTALXDIM;
RandomFields/src/RMS.cc:    if (xdimown != OWNLOGDIM(0) && nrow != ncol)
RandomFields/src/RMS.cc:	  if (OWNXDIM(0) != 1) RETURN_ERR(ERRORANISO);
RandomFields/src/RMS.cc:	  if (!isMiso(mtype)) RETURN_ERR(ERRORANISO); 
RandomFields/src/RMS.cc:	case SYMMETRIC: case CARTESIAN_COORD :
RandomFields/src/RMS.cc:	case PREVMODEL_I : BUG;      
RandomFields/src/RMS.cc:	case GNOMONIC_PROJ :  case ORTHOGRAPHIC_PROJ:
RandomFields/src/RMS.cc:	if (!isMiso(mtype)) cov->pref[SpectralTBM] = cov->pref[TBM] = PREF_NONE;
RandomFields/src/RMS.cc:	ASSERT_ONESYSTEM;
RandomFields/src/RMS.cc:	err = CHECK(sub, ncol, ncol, SYSTYPE(OWN, 0), OWNDOM(0), 
RandomFields/src/RMS.cc:		    SUBMODEL_DEP, cov->frame);
RandomFields/src/RMS.cc:	  cov->full_derivs =  cov->rese_derivs = isMdiag(mtype) ? 2 : 0;
RandomFields/src/RMS.cc:	  if (nrow != 2 || !isMdiag(mtype)) {
RandomFields/src/RMS.cc:	cov->full_derivs = cov->rese_derivs = isMdiag(mtype) ? 2 : 0;
RandomFields/src/RMS.cc:	if (nrow != 2 || !isMdiag(mtype)) 
RandomFields/src/RMS.cc:	COPYALLSYSTEMS(PREVSYSOF(sub), OWN, false);
RandomFields/src/RMS.cc:	err = CHECK_GEN(sub, SUBMODEL_DEP, SUBMODEL_DEP, cov->frame, false);
RandomFields/src/RMS.cc:      if (!isMdiag(mtype) ) 
RandomFields/src/RMS.cc:	SERR1("If several coordinate systems are envolved, currently '%.50s' can only be a diagonal matrix", KNAME(DANISO));
RandomFields/src/RMS.cc:      COPYALLSYSTEMS(PREVSYSOF(sub), OWN, false);
RandomFields/src/RMS.cc:      if ((err = CHECK_GEN(sub, SUBMODEL_DEP, SUBMODEL_DEP, cov->frame, false)) 
RandomFields/src/RMS.cc:      cov->pref[SpectralTBM] = cov->pref[TBM] = PREF_NONE;
RandomFields/src/RMS.cc:    if (!isMdiag(mtype)) 
RandomFields/src/RMS.cc:    if (owniso != DOUBLEISOTROPIC && !isMiso(mtype))
RandomFields/src/RMS.cc:      cov->pref[SpectralTBM] = cov->pref[TBM] = PREF_NONE;
RandomFields/src/RMS.cc:      if ((err = CHECK(suib, ncol, ncol, cov->typus, OWNDOM(0), 
RandomFields/src/RMS.cc:		 SUBMODEL_DEP, cov->frame))
RandomFields/src/RMS.cc:    if (!isMdiag(mtype)) 
RandomFields/src/RMS.cc:    COPYALLSYSTEMS(PREVSYSOF(sub), OWN, false);
RandomFields/src/RMS.cc:    int xdim = OWNTOTALXDIM,
RandomFields/src/RMS.cc:      PPROJ = (int*) MALLOC(bytes);
RandomFields/src/RMS.cc:      MEMCOPY(PPROJ, PINT(DPROJ), bytes); // #define PPROJ
RandomFields/src/RMS.cc:	SERR1("values 'space' and 'time' in argument '%.50s' do not allow additional values", KNAME(DPROJ));
RandomFields/src/RMS.cc:#if MAXSYSTEMS == 1
RandomFields/src/RMS.cc:	   || (isAnySpherical(PREVISO(0)) && PREVXDIM(0) > 2)
RandomFields/src/RMS.cc:	SERR1("unallowed use of '%.50s' or model too complicated.", KNAME(DPROJ));
RandomFields/src/RMS.cc:      assert(Space || p  == PROJ_TIME);
RandomFields/src/RMS.cc:	PPROJ = (int*) MALLOC(sizeof(int) * Nproj);
RandomFields/src/RMS.cc:	PPROJ = (int*) MALLOC(sizeof(int) * Nproj);
RandomFields/src/RMS.cc:      cov->pref[TBM] = cov->pref[SpectralTBM] = cov->pref[Average]
RandomFields/src/RMS.cc:      if (idx < 1) SERR1("only positive values allowed for '%.50s'", KNAME(DPROJ))
RandomFields/src/RMS.cc:	else if (idx > max) SERR2("value of %.50s[%d] too large", KNAME(DPROJ), i);
RandomFields/src/RMS.cc:	if (jdx == idx) SERR1("values of '%.50s' must be distinct.", KNAME(DPROJ));
RandomFields/src/RMS.cc:		ISO_NAMES[DOUBLEISOTROPIC]);
RandomFields/src/RMS.cc:#if MAXSSYSTEMS == 1
RandomFields/src/RMS.cc:	  set_logdim(PREVSYSOF(sub), 0, OWNLOGDIM(0) - 1);
RandomFields/src/RMS.cc:	if (OWNXDIM(0) != 1) RETURN_ERR(ERRORANISO);
RandomFields/src/RMS.cc:      case SYMMETRIC: case CARTESIAN_COORD:
RandomFields/src/RMS.cc:      case GNOMONIC_PROJ :  case ORTHOGRAPHIC_PROJ :
RandomFields/src/RMS.cc:      case PREVMODEL_I : BUG;      
RandomFields/src/RMS.cc:      case SPHERICAL_SYMMETRIC : case EARTH_SYMMETRIC :
RandomFields/src/RMS.cc:	    if (PPROJ[ii] <= 2) APMI0(cov); // RETURN_ERR(ERRORANISO);
RandomFields/src/RMS.cc:	  /// ehemals  owniso = SYMMETRIC; -- ueberall owniso
RandomFields/src/RMS.cc:	  set_iso(PREVSYSOF(sub), 0, SYMMETRIC);
RandomFields/src/RMS.cc:    //    if ((err = CHECK(sub, nproj, nproj, OWNTYPE(0), OWNDOM(0), owniso,
RandomFields/src/RMS.cc:    //		     SUBMODEL_DEP, cov->frame)) != NOERROR)  RETURN_ERR(err); 
RandomFields/src/RMS.cc:			 VDIM0, // SUBMODEL_DEP; geaendert 20.7.14
RandomFields/src/RMS.cc:			 VDIM1, cov->frame, true)) != NOERROR) {
RandomFields/src/RMS.cc:    COPYALLSYSTEMS(PREVSYSOF(sub), OWN, false);
RandomFields/src/RMS.cc:			 VDIM0, // SUBMODEL_DEP; geaendert 20.7.14
RandomFields/src/RMS.cc:			 VDIM1, cov->frame, true)) != NOERROR) {
RandomFields/src/RMS.cc:	 if ((err = CHECK_NO_TRAFO(next, tsdim, xdim Neu, cov->typus, OWNDOM(0),
RandomFields/src/RMS.cc:	 VDIM0, // SUBMODEL_DEP; geaendert 20.7.14
RandomFields/src/RMS.cc:	 if (next->domown == OWNDOM(0) &&
RandomFields/src/RMS.cc:	 OWNDOM(0), owniso,
RandomFields/src/RMS.cc:	 SUBMODEL_DEP, cov->frame)) != NOERROR) RETURN_ERR(err);
RandomFields/src/RMS.cc:  for (int s=0; s<=last; s++) set_maxdim(OWN, s, OWNLOGDIM(s));
RandomFields/src/RMS.cc:      int max = MAXDIM(SUB, s);
RandomFields/src/RMS.cc:      if (MAXDIM(OWN, s) < max) set_maxdim(OWN, s, max);
RandomFields/src/RMS.cc:  //      cov->pref[TBM] = cov->pref[SpectralTBM] = 0;
RandomFields/src/RMS.cc:  if ( (PisNULL(DANISO) || isMiso(mtype)) && PisNULL(DPROJ)) {
RandomFields/src/RMS.cc:  ASSERT_ONESYSTEM;
RandomFields/src/RMS.cc:    MEMCOPY(cov->pref, PREF_NOTHING, sizeof(pref_shorttype)); 
RandomFields/src/RMS.cc:       (PPROJ[0] != PROJ_TIME && (Nproj != 1 || PPROJ[0] <= 2))) &&
RandomFields/src/RMS.cc:       P0(DSCALE) < (STRCMP(global->coords.newunits[0], "km")== 0 ? 10 : 6.3))
RandomFields/src/RMS.cc:    assert(LAST_DOMAINUSER == 1);
RandomFields/src/RMS.cc:  //  APMI(cov);
RandomFields/src/RMS.cc:    assert(SYMMETRIC == 2 + DOUBLEISOTROPIC);
RandomFields/src/RMS.cc:    isotropy_type previso = hasprev ? PREVISO(0) : ISO_MISMATCH;
RandomFields/src/RMS.cc:      time = proj[0] == PROJ_TIME || (nproj == 1 && proj[0] == OWNLOGDIM(0));
RandomFields/src/RMS.cc:		equalsAnySymmetric(previso) ? SYMMETRIC : CARTESIAN_COORD);
RandomFields/src/RMS.cc:      if (hasprev && (!anyEarth || PREVLOGDIM(0)<=2)) {
RandomFields/src/RMS.cc:      last = //angle ? SYMMETRIC :
RandomFields/src/RMS.cc:    while (i <= (int) SYMMETRIC && !I[i]) i++;
RandomFields/src/RMS.cc:    I[SYMMETRIC] = i <= SYMMETRIC;
RandomFields/src/RMS.cc:    for ( ; i < (int) SYMMETRIC; I[i++] = false);
RandomFields/src/RMS.cc:    I[EARTH_SYMMETRIC] |= I[EARTH_ISOTROPIC];
RandomFields/src/RMS.cc:    I[SPHERICAL_SYMMETRIC] |= I[SPHERICAL_ISOTROPIC];		       
RandomFields/src/RMS.cc:  range->max[DPROJ] = GATTERTOTALXDIM;
RandomFields/src/RMS.cc:    ncol = PisNULL(DANISO) ? OWNLOGDIM(0) : cov->ncol[DANISO];
RandomFields/src/RMS.cc:  double sube[MAXTBMSPDIM],
RandomFields/src/RMS.cc:  assert(!PARAMisNULL(to, LOC_SCALE));
RandomFields/src/RMS.cc:  assert(!PARAMisNULL(from, DSCALE));
RandomFields/src/RMS.cc:  PARAM(to, LOC_SCALE)[0] = PARAM0(from, DSCALE);
RandomFields/src/RMS.cc:    addModel(newmodel, LOC, calling);
RandomFields/src/RMS.cc:    addModel(newmodel, LOC, calling);
RandomFields/src/RMS.cc:    addSetDistr(newmodel, Scale->calling, ScaleDollarToLoc, true, MAXINT);
RandomFields/src/RMS.cc:  bool maxstable = hasMaxStableFrame(shape);
RandomFields/src/RMS.cc:  char msg[nPOISSON_SCATTER - 1][LENERRMSG];
RandomFields/src/RMS.cc:      errorMSG(err, msg[i-1]);
RandomFields/src/RMS.cc:    addModel(Key, pgs[i], shape->calling);
RandomFields/src/RMS.cc:    if (MODELNR(*Key) != ZHOU) continue;
RandomFields/src/RMS.cc:    if (MODELNR(dummy) != LOC) BUG;
RandomFields/src/RMS.cc:    // errorMSG(err, xx, cov->base, msg[i-1]);
RandomFields/src/RMS.cc:    assert(hasGaussMethodFrame(cov));
RandomFields/src/RMS.cc:    SERR1("complicated models including arbitrary functions for '%.50s' cannot be simulated yet", KNAME(DAUSER));
RandomFields/src/RMS.cc:  ASSERT_NEWMODEL_NOT_NULL;
RandomFields/src/RMS.cc:    SERR2("Arbitrary functions for '%.50s' should be replaced by multiplicative models using '%.50s'", KNAME(DVAR), DefList[PROD].nick);
RandomFields/src/RMS.cc:    ASSERT_ONESYSTEM; 
RandomFields/src/RMS.cc:    ASSERT_NEWMODEL_NOT_NULL; // ?
RandomFields/src/RMS.cc:      if (!isMonotone(next) || !isIsotropicXonly(next) ||
RandomFields/src/RMS.cc:      anisoScale = 1.0 / getMinimalAbsEigenValue(P(DANISO), cov->nrow[DANISO]);
RandomFields/src/RMS.cc:    int logdim = OWNLOGDIM(0),
RandomFields/src/RMS.cc:      xdim = OWNXDIM(0);
RandomFields/src/RMS.cc:      if ((err = CHECK(*newmodel, logdim, xdim, type, OWNDOM(0), OWNISO(0),
RandomFields/src/RMS.cc:      // ??   addModel(newmodel, FIRSTDOLLAR); // 2.2.19
RandomFields/src/RMS.cc:      if ((err = CHECK(*newmodel, OWNLOGDIM(0), PREVXDIM(0), type, PREVDOM(0),
RandomFields/src/RMS.cc:	if ((err = addPGSLocal(newmodel, dummy, local, OWNLOGDIM(0), VDIM0,
RandomFields/src/RMS.cc:  case SchlatherType: case BrMethodType:
RandomFields/src/RMS.cc:      if (!isMonotone(next) || !isIsotropicXonly(next) ||
RandomFields/src/RMS.cc:  case GaussMethodType :
RandomFields/src/RMS.cc:    //    PMI(*newmodel); PMI(cov);
RandomFields/src/RMS.cc:      addModelX(newmodel, LOC);
RandomFields/src/RMS.cc:      addModelX(newmodel, FIRSTDOLLAR);
RandomFields/src/RMS.cc:	  NICK(cov), TYPE_NAMES[cov->frame]);      
RandomFields/src/RMS.cc:    *projM = cov->kappasub[DPROJ];
RandomFields/src/RMS.cc:    vdim = VDIM0,
RandomFields/src/RMS.cc:    ASSERT_ONESYSTEM;
RandomFields/src/RMS.cc:      var[MAXMPPVDIM],
RandomFields/src/RMS.cc:    int dim = OWNLOGDIM(0);
RandomFields/src/RMS.cc:	projM!= NULL || (Aniso != NULL && (!angle || Aniso->randomkappa))){
RandomFields/src/RMS.cc:     // Achtung I-NIT_RANDOM ueberschreibt mpp.* !!
RandomFields/src/RMS.cc:      if ((err = INIT_RANDOM(Var, nm_neu, s, P(DVAR))) != NOERROR) RETURN_ERR(err); 
RandomFields/src/RMS.cc:	var[i] = smith ? P0(DVAR) : Var->mpp.mM[idx + 1];      
RandomFields/src/RMS.cc:      if ((err = INIT_RANDOM(Scale, dim_neu, s, P(DSCALE)))
RandomFields/src/RMS.cc:      scale = smith ? P0(DSCALE) : Scale->mpp.mM[1];      
RandomFields/src/RMS.cc:      cov->mpp.mM[i] = next->mpp.mM[i]; 
RandomFields/src/RMS.cc:      cov->mpp.mMplus[i] = next->mpp.mMplus[i]; 
RandomFields/src/RMS.cc:	cov->mpp.mM[i] *= Var->mpp.mM[i];
RandomFields/src/RMS.cc:	cov->mpp.mMplus[i] *= Var->mpp.mMplus[i];
RandomFields/src/RMS.cc:	  cov->mpp.mM[k] *= pow_var;
RandomFields/src/RMS.cc:	  cov->mpp.mMplus[k] *= pow_var;
RandomFields/src/RMS.cc:	double pow_scale = Scale->mpp.mM[dim + j * nmP1];
RandomFields/src/RMS.cc:	  cov->mpp.mM[k] *= pow_scale;
RandomFields/src/RMS.cc:	  cov->mpp.mMplus[k] *= pow_scale;
RandomFields/src/RMS.cc:	cov->mpp.mM[i] *= pow_scale;
RandomFields/src/RMS.cc:	cov->mpp.mMplus[i] *= pow_scale;
RandomFields/src/RMS.cc:	cov->mpp.mM[i] *= invdet;
RandomFields/src/RMS.cc:	cov->mpp.mMplus[i] *= invdet;
RandomFields/src/RMS.cc:	  *diag = PARAM(Aniso, ANGLE_DIAG);
RandomFields/src/RMS.cc:	  invdet = PARAM0(Aniso, ANGLE_RATIO);
RandomFields/src/RMS.cc:	SERR("only anisotropy matrices basesd on RMangle allowed.");
RandomFields/src/RMS.cc:	cov->mpp.mM[i] *= invdet;
RandomFields/src/RMS.cc:	cov->mpp.mMplus[i] *= invdet;
RandomFields/src/RMS.cc:      //printf("unnormedmass in $ %.50s\n", NAME(next));
RandomFields/src/RMS.cc:	int maxv = MIN(vdim, MAXMPPVDIM);
RandomFields/src/RMS.cc:      } else RETURN_ERR(ERRORNOTPROGRAMMEDYET);
RandomFields/src/RMS.cc:      int maxv = MIN(vdim, MAXMPPVDIM);
RandomFields/src/RMS.cc:  else if (hasGaussMethodFrame(cov) || hasAnyEvaluationFrame(cov)) {
RandomFields/src/RMS.cc:    assert(key == NULL || ({PMI(cov);false;}));//
RandomFields/src/RMS.cc:    if ((err=INIT(next, 0, s)) != NOERROR) RETURN_ERR(err); // e.g. from MLE
RandomFields/src/RMS.cc:  int vdim = VDIM0;
RandomFields/src/RMS.cc:      DORANDOM(Var, P(DVAR));
RandomFields/src/RMS.cc:      DORANDOM(Scale, P(DSCALE));
RandomFields/src/RMS.cc:    int maxv = MIN(vdim, MAXMPPVDIM);
RandomFields/src/RMS.cc:  else if (hasGaussMethodFrame(cov)) {    
RandomFields/src/RMS.cc:    SERR1("complicated models including arbitrary functions for '%.50s' cannot be simulated yet", KNAME(DAUSER));
RandomFields/src/RMS.cc:  case GaussMethodType : {
RandomFields/src/RMS.cc:    ASSERT_NEWMODEL_NULL;
RandomFields/src/RMS.cc:	  double *xx = (double*) MALLOC(sizeof(double) * dim * 3);
RandomFields/src/RMS.cc:	    MEMCOPY(xx + i * 3,  proj[i] == dim && Time ? T : gr[proj[i] -1],
RandomFields/src/RMS.cc:	    double *x0 = (double*) MALLOC(bytes),
RandomFields/src/RMS.cc:	usr_bool gridexpand = NEXTNR == TBM_PROC_INTERN || isAnyNugget(NEXTNR)
RandomFields/src/RMS.cc:    if (!isGaussMethod(cov->key)) addModelKey(cov, GAUSSPROC);
RandomFields/src/RMS.cc:    ASSERT_ONESYSTEM;
RandomFields/src/RMS.cc:			      VDIM0, GaussMethodType)) != NOERROR) {
RandomFields/src/RMS.cc:	  NICK(cov), TYPE_NAMES[cov->frame]);      
RandomFields/src/RMS.cc:    if (VDIM0 != VDIM1) BUG;
RandomFields/src/RMS.cc:    cov->rf = (double*) MALLOC(sizeof(double) * VDIM0 * prevtotalpts);
RandomFields/src/RMS.cc:	RETURN_ERR(ERRORNOTPROGRAMMEDYET);
RandomFields/src/RMS.cc:      int totptsvdim = prevtotalpts * VDIM0;
RandomFields/src/RMS.cc:      cov->Sdollar->sd = (double*) MALLOC(sizeof(double) * totptsvdim);
RandomFields/src/RMS.cc:    RETURN_ERR(ERRORNOTPROGRAMMEDYET);
RandomFields/src/RMS.cc:    vdim = VDIM0;
RandomFields/src/RMS.cc:  if (hasGaussMethodFrame(cov)) {    
RandomFields/src/RMS.cc:	  XERR(ERRORNOTPROGRAMMEDYET);
RandomFields/src/RMS.cc:	  DORANDOM(Var, P(DVAR));
RandomFields/src/RMS.cc:  else if (hasMaxStableFrame(cov) || hasAnyPoissonFrame(cov)) {
RandomFields/src/RMS.cc:    assert(VDIM0 == VDIM1);
RandomFields/src/RMS.cc:    int maxv = MIN(vdim, MAXMPPVDIM);
RandomFields/src/RMS.cc:    //PMI(cov);
RandomFields/src/xport_import.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/xport_import.cc: Copyright (C) 2015 -- 2017 Martin Schlather, 
RandomFields/src/xport_import.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/xport_import.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/NULL.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/NULL.cc: Copyright (C) 2001 -- 2017 Martin Schlather, 
RandomFields/src/NULL.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/NULL.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/NULL.cc:    MEMSET(x, 0, sizeof(name##_storage));	\
RandomFields/src/NULL.cc:    MEMSET(x, 0, sizeof(name##_storage));	\
RandomFields/src/NULL.cc:  loc->xgr = (double **) MALLOC(dim * sizeof(double *));  
RandomFields/src/NULL.cc:  loc->grY = (double **) MALLOC(dim * sizeof(double *));
RandomFields/src/NULL.cc:  for (i=0; i<n; i++) Loc[i] = (location_type*) MALLOC(sizeof(location_type));
RandomFields/src/NULL.cc:  cov->ownloc = LOCLIST_CREATE(n, OWNXDIM(0));
RandomFields/src/NULL.cc:  listoftype* q = (listoftype *) MALLOC(sizeof(listoftype));
RandomFields/src/NULL.cc:void MPPPROPERTIES_NULL(mpp_properties *Mpp) {
RandomFields/src/NULL.cc:  // Mpp->refradius= 
RandomFields/src/NULL.cc:  for (i=0; i<MAXMPPVDIM; i++) Mpp->maxheights[i] = RF_INF; // maxv
RandomFields/src/NULL.cc:  Mpp->unnormedmass = RF_NA;
RandomFields/src/NULL.cc:  Mpp->mM = Mpp->mMplus = NULL;
RandomFields/src/NULL.cc:  //   Mpp->refsd = 
RandomFields/src/NULL.cc:  //Mpp->totalmass = RF_NA;
RandomFields/src/NULL.cc:  //Mpp->methnr = UNSET;
RandomFields/src/NULL.cc:  //Mpp->loc_done = false;
RandomFields/src/NULL.cc:void MPPPROPERTIES_DELETE(mpp_properties *Mpp) {   
RandomFields/src/NULL.cc:  FREE(Mpp->mM);
RandomFields/src/NULL.cc:  FREE(Mpp->mMplus);
RandomFields/src/NULL.cc:  //  printf("deleting %.50s\n", NAME(cov));
RandomFields/src/NULL.cc:    lastparam = (COVNR < 0) ? MAXPARAM : DefList[COVNR].kappas; 
RandomFields/src/NULL.cc:      cov->ncol[i] = cov->nrow[i] = SIZE_NOT_DETERMINED; // ==0
RandomFields/src/NULL.cc:  MPPPROPERTIES_DELETE(&(cov->mpp));
RandomFields/src/NULL.cc:  //MPPPROPERTIES_DELETE(&(cov->mpp));
RandomFields/src/NULL.cc:    //    TREE0(cov); /* ja nicht PMI, da dies auf geloeschtes zugreift */
RandomFields/src/NULL.cc:  for (i=0; i<MAXPARAM; i++) { // cov->sub[i] // seit 1.10.07: luecken erlaubt
RandomFields/src/NULL.cc:  //  PMI0(cov);  printf("COV_DELETE %.50s top=%d\n", NAME(cov), cov->calling == NULL);
RandomFields/src/NULL.cc:  //  printf("\n\n\n\nCOVALWAYSNULL %s %d\n", NAME(cov), cov->base==NULL); 
RandomFields/src/NULL.cc:  //  printf("base = %ld %s\n", cov->base, NAME(cov));
RandomFields/src/NULL.cc:  cov->mpp.mM = cov->mpp.mMplus = NULL;
RandomFields/src/NULL.cc:void SYSTEM_NULL(system_type *sys, int len) {
RandomFields/src/NULL.cc:    set_dom(sys, i, DOMAIN_MISMATCH);
RandomFields/src/NULL.cc:    set_iso(sys, i, ISO_MISMATCH);    
RandomFields/src/NULL.cc:  //printf("\n\n\n\nCCOVNULL %s %d\n", NAME(cov), base==NULL); 
RandomFields/src/NULL.cc:  MEMSET(cov, 0, sizeof(model));
RandomFields/src/NULL.cc:  //printf("base = %ld %s\n", cov->base, NAME(cov));
RandomFields/src/NULL.cc:  SYSTEM_NULL(PREV, MAXSYSTEMS);
RandomFields/src/NULL.cc:  SYSTEM_NULL(GATTER, MAXSYSTEMS);
RandomFields/src/NULL.cc:  SYSTEM_NULL(OWN, MAXSYSTEMS);
RandomFields/src/NULL.cc:  VDIM0 = VDIM1 = UNSET;
RandomFields/src/NULL.cc:  cov->monotone = MON_UNSET; 
RandomFields/src/NULL.cc:  cov->hess = NOT_IMPLEMENTED;
RandomFields/src/NULL.cc:  MPPPROPERTIES_NULL(&(cov->mpp));
RandomFields/src/NULL.cc:    FREE(x->MuT); 
RandomFields/src/NULL.cc:    } else if (sBR->nr == BRMIXED_INTERN || sBR->nr == BRMIXED_USER) {
RandomFields/src/NULL.cc:    } else if (sBR->nr == BRNORMED) {
RandomFields/src/NULL.cc:  // for (d=0; d<MAXMPPDIM; d++) 
RandomFields/src/NULL.cc:  for (d=0; d<MAXTBMSPDIM; d++) {
RandomFields/src/NULL.cc:  x->Matrix = x->pt_variance = NULL; // DO NOT FREE
RandomFields/src/NULL.cc:  for (int i=0; i<MAX_LIN_COMP; i++) {
RandomFields/src/NULL.cc:  FREE(x->Matrix);
RandomFields/src/NULL.cc:  //  x->Matrix = x->pt_variance = NULL; // DO NOT FREE
RandomFields/src/NULL.cc:  (likelihood_st orage*) MAL LOC(sizeof(likelihood_storage));
RandomFields/src/NULL.cc:  err or("Memory allocation error for 'likelihood'");
RandomFields/src/NULL.cc:ALL_NULL_BUT(covariate, x->matrix_err = MATRIX_NOT_CHECK_YET )
RandomFields/src/NULL.cc:     for (int i=0; i<MAXSUB; i++) COV_DELETE(x->keys + i, save);
RandomFields/src/NULL.cc:  MEMSET(KT->PREF_FAILURE, 0, 90 * Nothing);
RandomFields/src/NULL.cc:  for (int nr=0; nr<=MODEL_MAX; nr++)
RandomFields/src/NULL.cc:    MEMCOPY(&m, &(KT->global.messages), sizeof(messages_param));
RandomFields/src/NULL.cc:  MEMCOPY(&(KT->global), &GLOBAL, sizeof(globalparam));
RandomFields/src/NULL.cc:    MEMCOPY(&(KT->global.messages), &m, sizeof(messages_param));
RandomFields/src/shape.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/shape.cc:   in RFsimu.h, since there is no error check (e.g. initialization of RANDOM)
RandomFields/src/shape.cc: * definitions for the random coin method can be found in MPPFcts.cc
RandomFields/src/shape.cc:   SophisticatedModel.cc; hyper models also in Hypermodel.cc
RandomFields/src/shape.cc: Copyright (C) 2017 -- 2017 Martin Schlather
RandomFields/src/shape.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/shape.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/shape.cc:  //  PMI(cov);
RandomFields/src/shape.cc:     dim = OWNTOTALXDIM;
RandomFields/src/shape.cc:  assert(OWNTOTALXDIM == PREVTOTALXDIM && PREVLASTSYSTEM  == OWNLASTSYSTEM &&
RandomFields/src/shape.cc:	 OWNTOTALXDIM == total_logicaldim(SYSOF(cov)) &&   
RandomFields/src/shape.cc:	 LocLoctsdim(loc) == OWNTOTALXDIM);
RandomFields/src/shape.cc:	    full = M_2_PI;
RandomFields/src/shape.cc:	    half = M_PI;
RandomFields/src/shape.cc:      cov->Scovariate->matrix_err != MATRIX_NOT_CHECK_YET && 
RandomFields/src/shape.cc:    // cov->base->rawConcerns nicht aendern, da Model an anderer
RandomFields/src/shape.cc:			COVARIATE_RAW_NAME, COVARIATE_X_NAME);
RandomFields/src/shape.cc:	       DefList[VAR2COV_PROC].nick, COVARIATE_RAW_NAME);
RandomFields/src/shape.cc:  ASSERT_ONESYSTEM;
RandomFields/src/shape.cc:	       KNAME(COVARIATE_X), NAME(cov));
RandomFields/src/shape.cc:      if (LocPtsdim(S->loc) != OWNLOGDIM(0)) {
RandomFields/src/shape.cc:	      KNAME(COVARIATE_X));
RandomFields/src/shape.cc:  // Achtung! rawConcerns can noch nach Modellerstellung
RandomFields/src/shape.cc:  //printf("%s =? %s\n", ISO_NAMES[OWNISO(0)], COORD_SYS_NAMES[ccs]);
RandomFields/src/shape.cc:	    ISO_NAMES[OWNISO(0)], COORD_SYS_NAMES[ccs]);
RandomFields/src/shape.cc:      addModel(cov, 0, TRAFO);
RandomFields/src/shape.cc:      PARAMINT(next, TRAFO_ISO)[0] = IsotropicOf(PREVISO(0));
RandomFields/src/shape.cc:    if ((err = CHECK(cov->sub[0], OWNLOGDIM(0), OWNXDIM(0), ShapeType,
RandomFields/src/shape.cc:  *nc = *nr = i <= COVARIATE_X  || i == COVARIATE_FACTOR ? SIZE_NOT_DETERMINED
RandomFields/src/shape.cc:    : i <= COVARIATE_NAME ? 1 
RandomFields/src/shape.cc:    dim = OWNXDIM(0); // vdim within covariate, not VDIM!
RandomFields/src/shape.cc:    // NOTE: rawConcerns kann auch nach der Modelldefinition geaendert werden!!
RandomFields/src/shape.cc:    ntot = MAX(Loctotalpoints(cov), LoctotalpointsY(cov));
RandomFields/src/shape.cc:      ERR("Models that have an implicite coordinate transformation inside may not use (implicitely) 'RMcovariate' (up to now).");
RandomFields/src/shape.cc:    ntot = MAX(ntotX, ntotY);
RandomFields/src/shape.cc:      ntot = MAX(ntotX, ntotY);
RandomFields/src/shape.cc:    //    PMI0(cov);
RandomFields/src/shape.cc:	    KNAME(COVARIATE_ADDNA), NAME(cov));
RandomFields/src/shape.cc:      GERR1("%.50s is used with NAs outside a trend definition.", NAME(cov));
RandomFields/src/shape.cc:  assert(VDIM0 > 0 && VDIM1 > 0);
RandomFields/src/shape.cc:  if (hasAnyEvaluationFrame(cov) && VDIM0 != 1)
RandomFields/src/shape.cc:  *nc = *nr = i <= FIXCOV_X || i == FIXCOV_GIVEN ? SIZE_NOT_DETERMINED 
RandomFields/src/shape.cc:    dim = OWNTOTALXDIM,    
RandomFields/src/shape.cc:    vdim = VDIM0,
RandomFields/src/shape.cc:    int max1 = LNROW(FIXCOV_M) / vdim;
RandomFields/src/shape.cc:  if (!ignore_x) matrix = FIXCOV_M;
RandomFields/src/shape.cc:  if (!ignore_y) matrix = matrix == FIXCOV_M ? UNSET : FIXCOV_GIVEN;
RandomFields/src/shape.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/shape.cc:    // NOTE: rawConcerns kann auch nach der Modelldefinition geaendert werden!!
RandomFields/src/shape.cc:    // ******* es darf erst ab hier auf Matrix zugegriffen werden!
RandomFields/src/shape.cc:      ERR("Models that have an implicite coordinate transformation inside may not use (implicitely) 'RMcovariate' (up to now).");
RandomFields/src/shape.cc:    // ******* es darf erst ab hier auf Matrix zugegriffen werden!
RandomFields/src/shape.cc:  for(int i=FIRST_DOMAIN; i<= LAST_DOMAINUSER; i++) cov->allowedD[i] = false;
RandomFields/src/shape.cc:  //PMI(cov->calling);
RandomFields/src/shape.cc:  set_dom(OWN, 0, PREVDOM(0));    
RandomFields/src/shape.cc:  // ACHTUNG TO DO: given coords fuer givenM zu uebergeben wird
RandomFields/src/shape.cc:  //  PMI(cov)
RandomFields/src/shape.cc:	  COVARIATE_X_NAME, NICK(cov));
RandomFields/src/shape.cc:    ERR("In case 'givenM' is given 'raw=TRUE' is obligatory");  
RandomFields/src/shape.cc:      SERR1("distances only allowed for '%.50s' = TRUE", KNAME(FIXCOV_RAW));
RandomFields/src/shape.cc:    if (!(equalsKernel(OWNDOM(0)) && equalsCartCoord(OWNISO(0))))
RandomFields/src/shape.cc:      SERR2("Model only allowed within positive definite kernels, not within positive definite functions. (Got %.50s, %.50s.)",  DOMAIN_NAMES[OWNDOM(0)], ISO_NAMES[OWNISO(0)]);
RandomFields/src/shape.cc:	nrow = LNROW(FIXCOV_M),
RandomFields/src/shape.cc:	ncol = LNCOL(FIXCOV_M),
RandomFields/src/shape.cc:	if (ntotY <= 0) GERR("no locations for 'givenM'");
RandomFields/src/shape.cc:	if (nrow != ncol) ERR("square matrix for 'givenM' expected");
RandomFields/src/shape.cc:    cov->q[0] = VDIM0 = VDIM1 = vdim;
RandomFields/src/shape.cc:  } else VDIM0 = VDIM1 = (int) cov->q[0];
RandomFields/src/shape.cc:    double *c = LP(FIXCOV_M);   
RandomFields/src/shape.cc:  if (S->matrix_err == MATRIX_NOT_CHECK_YET) {
RandomFields/src/shape.cc:	int matrix = m ==0 ? FIXCOV_M : FIXCOV_GIVEN,
RandomFields/src/shape.cc:	  S->matrix_err = err = ERROR_MATRIX_SQUARE; 
RandomFields/src/shape.cc:	      S->matrix_err = err = ERROR_MATRIX_POSDEF;
RandomFields/src/shape.cc:  range->min[FIXCOV_M] = RF_NEGINF;
RandomFields/src/shape.cc:  range->max[FIXCOV_M] = RF_INF;
RandomFields/src/shape.cc:  range->pmin[FIXCOV_M] = - 1e10;
RandomFields/src/shape.cc:  range->pmax[FIXCOV_M] = 1e10;
RandomFields/src/shape.cc:  range->openmin[FIXCOV_M] = true;
RandomFields/src/shape.cc:  range->openmax[FIXCOV_M] = true;
RandomFields/src/shape.cc:  range->min[FIXCOV_M] = RF_NEGINF;
RandomFields/src/shape.cc:  range->max[FIXCOV_M] = RF_INF;
RandomFields/src/shape.cc:  range->pmin[FIXCOV_M] = - 1e10;
RandomFields/src/shape.cc:  range->pmax[FIXCOV_M] = 1e10;
RandomFields/src/shape.cc:  range->openmin[FIXCOV_M] = true;
RandomFields/src/shape.cc:  range->openmax[FIXCOV_M] = true;
RandomFields/src/shape.cc:  ASSERT_NEWMODEL_NOT_NULL;
RandomFields/src/shape.cc:    return addUnifModel(cov, BALL_RADIUS, newmodel);
RandomFields/src/shape.cc:    ILLEGAL_FRAME;
RandomFields/src/shape.cc:      cov->mpp.mM[1] = cov->mpp.mMplus[1] =
RandomFields/src/shape.cc:	VolumeBall(OWNLOGDIM(0), BALL_RADIUS);
RandomFields/src/shape.cc:	cov->mpp.mM[i] = cov->mpp.mMplus[i] = cov->mpp.mM[1];
RandomFields/src/shape.cc:  else ILLEGAL_FRAME;
RandomFields/src/shape.cc:    kdM1 = VolumeBall(dim-1, 1.0);
RandomFields/src/shape.cc:  return intpow(dim * kd / (kdM1 * beta), dim) / kd;
RandomFields/src/shape.cc:    dim = OWNLOGDIM(0);
RandomFields/src/shape.cc:    dim = OWNLOGDIM(0);
RandomFields/src/shape.cc:    // strokorb/schlather, max-stabile Modelle mit gleichen tcf
RandomFields/src/shape.cc:    dim = ANYOWNDIM;
RandomFields/src/shape.cc:  assert(dim <= MAXDIM_POLY);
RandomFields/src/shape.cc:  ASSERT_NEWMODEL_NOT_NULL;
RandomFields/src/shape.cc:      dim = OWNLOGDIM(0),
RandomFields/src/shape.cc:    return addUnifModel(cov,  // to do : zhou approach !
RandomFields/src/shape.cc:    ILLEGAL_FRAME;
RandomFields/src/shape.cc:  if ((ps = (polygon_storage*) MALLOC(sizeof(polygon_storage))) == NULL)
RandomFields/src/shape.cc:  if ((ps->P = (polygon*)  MALLOC(sizeof(polygon))) == NULL) {
RandomFields/src/shape.cc:    dim = OWNLOGDIM(0);
RandomFields/src/shape.cc:    if ((cov->Spolygon = create_polygon()) ==NULL) RETURN_ERR(ERRORMEMORYALLOCATION);
RandomFields/src/shape.cc:   for (i=1; i<=cov->mpp.moments; i++) cov->mpp.mM[i] = cov->mpp.mMplus[i] = c;	
RandomFields/src/shape.cc:  else ILLEGAL_FRAME;
RandomFields/src/shape.cc:  *nc = (i == RATIONAL_A) ? OWNLOGDIM(0) : 1;
RandomFields/src/shape.cc:  *nr = (i == RATIONAL_A) ? OWNLOGDIM(0) : (i==RATIONAL_a) ? 2 : -1;
RandomFields/src/shape.cc:    dim = OWNLOGDIM(0);
RandomFields/src/shape.cc:  *nc = (EAXXA_A == i) ? OWNLOGDIM(0) : 1;
RandomFields/src/shape.cc:  *nr = i < DefList[COVNR].kappas ? OWNLOGDIM(0) : -1;
RandomFields/src/shape.cc:    dim = OWNLOGDIM(0);
RandomFields/src/shape.cc:  double xA[EaxxaMaxDim],
RandomFields/src/shape.cc:    dim = OWNLOGDIM(0);
RandomFields/src/shape.cc:  if (OWNXDIM(0) > EaxxaMaxDim)
RandomFields/src/shape.cc:	    EaxxaMaxDim, OWNXDIM(0));
RandomFields/src/shape.cc:  VDIM0 = VDIM1 = OWNLOGDIM(0);
RandomFields/src/shape.cc:    dim = OWNLOGDIM(0),
RandomFields/src/shape.cc:  double xAR[EaxxaMaxDim], R[9],
RandomFields/src/shape.cc:    double xA[EaxxaMaxDim];
RandomFields/src/shape.cc:    v[k-1] += E[d]; // nur korrekt falls E Vielfaches der EH-Matrix
RandomFields/src/shape.cc:    dim = OWNLOGDIM(0);
RandomFields/src/shape.cc:  if (OWNXDIM(0) != 3) SERR("The space-time dimension must be 3.");
RandomFields/src/shape.cc:  VDIM0 = VDIM1 = OWNLOGDIM(0);
RandomFields/src/shape.cc:    dim = OWNLOGDIM(0),
RandomFields/src/shape.cc:  if (OWNXDIM(0) != 3) SERR("The space-time dimension must be 3.");
RandomFields/src/shape.cc:    dim = OWNLOGDIM(0),
RandomFields/src/shape.cc:  if (OWNXDIM(0) != 3) SERR("The space-time dimension must be 3.");
RandomFields/src/shape.cc:  VDIM0 = VDIM1 = OWNLOGDIM(0);
RandomFields/src/shape.cc:  int xdimown = OWNTOTALXDIM;
RandomFields/src/shape.cc:  //    dim = OWNLOGDIM(0); // taken[MAX DIM],
RandomFields/src/shape.cc:  ASSERT_ONESYSTEM;
RandomFields/src/shape.cc:  set_maxdim(OWN, 0, INFDIM);
RandomFields/src/shape.cc:  cov->monotone = isMonotone(next->monotone) ? MONOTONE : NOT_MONOTONE;
RandomFields/src/shape.cc:  err = CHECK_PASSTF(next, ShapeType, SUBMODEL_DEP, EvaluationType);
RandomFields/src/shape.cc:    if ((err = CHECK_PASSTF(next, ShapeType, SUBMODEL_DEP, TrendType))
RandomFields/src/shape.cc:  ASSERT_NEWMODEL_NOT_NULL;
RandomFields/src/shape.cc:    if ((err = addUnifModel(cov, P0(TRUNC_RADIUS), newmodel)) != NOERROR)
RandomFields/src/shape.cc:  } else ILLEGAL_FRAME_STRUCT;
RandomFields/src/shape.cc:    vdim = VDIM0;
RandomFields/src/shape.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/shape.cc:	err != ERRORILLEGALFRAME) RETURN_ERR(err);
RandomFields/src/shape.cc:    // Eplus, M2 are assumed to be still precise !!
RandomFields/src/shape.cc:    int maxv = MIN(vdim, MAXMPPVDIM);
RandomFields/src/shape.cc:  else ILLEGAL_FRAME;
RandomFields/src/shape.cc:  int vdim = VDIM0;
RandomFields/src/shape.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/shape.cc:  if (next->err != ERRORILLEGALFRAME) {
RandomFields/src/shape.cc:    int maxv = MIN(vdim, MAXMPPVDIM);
RandomFields/src/getNset.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/getNset.cc: Copyright (C) 2001 -- 2017 Martin Schlather, 
RandomFields/src/getNset.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/getNset.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/getNset.cc:    *To = (listoftype *) MALLOC(sizeof(listoftype));
RandomFields/src/getNset.cc:    if (q->lpx[j] == NULL) q->lpx[j] = (double*) MALLOC(n);
RandomFields/src/getNset.cc:    MEMCOPY(q->lpx[j], p->lpx[j], n);	    
RandomFields/src/getNset.cc:  MEMCOPY(q->nrow, p->nrow, sizeint);
RandomFields/src/getNset.cc:  MEMCOPY(q->ncol, p->ncol, sizeint);
RandomFields/src/getNset.cc:void addModel(model **pcov, int covnr, model *calling, bool nullOK) {
RandomFields/src/getNset.cc:  cov = (model*) MALLOC(sizeof(model));
RandomFields/src/getNset.cc:    MEMCOPY(cov->pref, cov->sub[0]->pref, sizeof(pref_shorttype));
RandomFields/src/getNset.cc:    PRINTF("Missing link for model '%s'. Inform author.\n", NICK(cov));
RandomFields/src/getNset.cc:void addModelX(model **pcov, int covnr) {
RandomFields/src/getNset.cc:  addModel(pcov, covnr, NULL, false);
RandomFields/src/getNset.cc:void addModelKey(model *cov, int covnr) {
RandomFields/src/getNset.cc:  addModel(pcov, covnr, cov // NULL 21.10.19
RandomFields/src/getNset.cc:void addModel(model *pcov, int subnr, int covnr) {
RandomFields/src/getNset.cc:  addModel(pcov->sub + subnr, covnr, pcov, false);
RandomFields/src/getNset.cc:void addModelKappa(model *pcov, int subnr, int covnr) {
RandomFields/src/getNset.cc:  addModel(pcov->kappasub + subnr, covnr, pcov, false);
RandomFields/src/getNset.cc:void addModel(model **pcov, int covnr, model *calling) {
RandomFields/src/getNset.cc:  addModel(pcov, covnr, calling, false);
RandomFields/src/getNset.cc:int addUnifModel(model *cov, double radius, model **newmodel) {
RandomFields/src/getNset.cc:  addModel(newmodel, UNIF, cov);
RandomFields/src/getNset.cc:  kdefault(*newmodel, UNIF_MIN, -radius);
RandomFields/src/getNset.cc:  kdefault(*newmodel, UNIF_MAX, radius);
RandomFields/src/getNset.cc:  if (xgr[0] == NULL && (xgr[0] =(double*) MALLOC(totalBytes))==NULL)
RandomFields/src/getNset.cc:    return ERRORMEMORYALLOCATION;
RandomFields/src/getNset.cc:  MEMCOPY(xgr[0], x, totalBytes);
RandomFields/src/getNset.cc:  // folgende Zeile nur beim ersten Mal zu setzen, aber egal
RandomFields/src/getNset.cc:  if (totalpoints >= MAXINT) return XERRORTOOMANYLOC;
RandomFields/src/getNset.cc:    if (len < MAXINT) loc->totalpoints = loc->spatialtotalpoints = (int) len;
RandomFields/src/getNset.cc:    else return XERRORTOOMANYLOC;
RandomFields/src/getNset.cc:	if ((loc->x=(double*) MALLOC(totalBytes))==NULL)
RandomFields/src/getNset.cc:	  return ERRORMEMORYALLOCATION;
RandomFields/src/getNset.cc:	MEMCOPY(loc->x, x, totalBytes);
RandomFields/src/getNset.cc:      if ((loc->x=(double*) MALLOC(totalBytes)) == NULL)
RandomFields/src/getNset.cc:	return ERRORMEMORYALLOCATION; 
RandomFields/src/getNset.cc:      MEMCOPY(loc->x, x, totalBytes);
RandomFields/src/getNset.cc:    MEMCOPY(loc->T, T, sizeof(double) * 3);
RandomFields/src/getNset.cc:      FAILED1("The number of temporal points is not positive. Check the triple definition of 'T' in the man pages of '%.50s'.", DefList[SIMULATE].nick);
RandomFields/src/getNset.cc:    if ((double) loc->totalpoints * loc->T[XLENGTH] >= MAXINT) 
RandomFields/src/getNset.cc:    if (len < MAXINT) loc->totalpointsY = loc->spatialtotalpointsY = (int)len;
RandomFields/src/getNset.cc:      else return XERRORTOOMANYLOC;
RandomFields/src/getNset.cc:      if ((loc->Y=(double*) MALLOC(totalBytes)) == NULL)
RandomFields/src/getNset.cc:	return ERRORMEMORYALLOCATION; 
RandomFields/src/getNset.cc:      MEMCOPY(loc->Y, y, totalBytes);
RandomFields/src/getNset.cc:    MEMCOPY(loc->TY, Ty, sizeof(double) * 3);
RandomFields/src/getNset.cc:      FAILED1("The number of temporal points is not positive. Check the triple definition of 'T' in the man pages of '%.50s'.", DefList[SIMULATE].nick);
RandomFields/src/getNset.cc:    if ((double) loc->totalpointsY * loc->TY[XLENGTH] >= MAXINT) 
RandomFields/src/getNset.cc:  if (totalpoints >= MAXINT ||  totalpointsy >= MAXINT) return XERRORTOOMANYLOC;
RandomFields/src/getNset.cc:    *LLoc = (location_type*) MALLOC(sizeof(location_type));
RandomFields/src/getNset.cc:  if (spatialdim<1) return ERRORDIM;
RandomFields/src/getNset.cc:      spatialdim = INTEGER(VECTOR_ELT(set, XLIST_SPATIALDIM))[0];
RandomFields/src/getNset.cc:      Time =  LOGICAL(VECTOR_ELT(set, XLIST_TIME))[0];
RandomFields/src/getNset.cc:	  spatialdim != INTEGER(VECTOR_ELT(set, XLIST_SPATIALDIM))[0] ||
RandomFields/src/getNset.cc:	  Time != LOGICAL(VECTOR_ELT(set, XLIST_TIME))[0] ||
RandomFields/src/getNset.cc:	loc[i]->rawidx = (int*) MALLOC(bytes);
RandomFields/src/getNset.cc:	MEMCOPY(loc[i]->rawidx, INTEGER(RawIdx), bytes);
RandomFields/src/getNset.cc: if (totalpoints >= MAXINT || totalpointsy >= MAXINT) return XERRORTOOMANYLOC;
RandomFields/src/getNset.cc:  if ((loc->x=(double*) MALLOC(totalBytes)) == NULL)
RandomFields/src/getNset.cc:    return ERRORMEMORYALLOCATION; 
RandomFields/src/getNset.cc:    if ((loc->Y=(double*) MALLOC(totalBytes)) == NULL)
RandomFields/src/getNset.cc:      return ERRORMEMORYALLOCATION; 
RandomFields/src/getNset.cc:    if (totalpoints >= MAXINT) ERR("number of  locations too large.");
RandomFields/src/getNset.cc:    } else if ((e=spatialdim != INTEGER(VECTOR_ELT(set, XLIST_SPATIALDIM))[0])){
RandomFields/src/getNset.cc:	     spatialdim, INTEGER(VECTOR_ELT(set, XLIST_SPATIALDIM))[0]);
RandomFields/src/getNset.cc:    } else if ((e = Time != LOGICAL(VECTOR_ELT(set, XLIST_TIME))[0])) {
RandomFields/src/getNset.cc:    MEMCOPY(loc->TY, loc->T, 3);
RandomFields/src/getNset.cc:    if (totalpointsy >= MAXINT)
RandomFields/src/getNset.cc:    } else if ((e=spatialdim != INTEGER(VECTOR_ELT(set,XLIST_SPATIALDIM))[0])){
RandomFields/src/getNset.cc:	     spatialdim, INTEGER(VECTOR_ELT(set, XLIST_SPATIALDIM))[0]);
RandomFields/src/getNset.cc:    } else if ((e = Time != LOGICAL(VECTOR_ELT(set, XLIST_TIME))[0])) {
RandomFields/src/getNset.cc:  // NOMATCHING, -1, if no matching function is found
RandomFields/src/getNset.cc:  // MULTIPLEMATCHING, -2, if multiple matching fctns are found,
RandomFields/src/getNset.cc:  // MATCHESINTERNAL, -3 if internal name is passed
RandomFields/src/getNset.cc:  if (!STRCMP(name, InternalName)) return MATCHESINTERNAL;
RandomFields/src/getNset.cc:  if ((match = Match(name, CovNickNames, currentNrCov)) >= 0) return match;
RandomFields/src/getNset.cc:  return Match(name, CovNames, currentNrCov);
RandomFields/src/getNset.cc:void MultiDimRange(int set, model *cov, double *natscale) {
RandomFields/src/getNset.cc:    xdimprev = PREVTOTALXDIM,
RandomFields/src/getNset.cc:    vdim = VDIM0,
RandomFields/src/getNset.cc:    lastsystem = PREVLASTSYSTEM,
RandomFields/src/getNset.cc:  bool islogcart[MAXSYSTEMS],
RandomFields/src/getNset.cc:  redxdim = OWNTOTALXDIM;
RandomFields/src/getNset.cc:  //  PMI0(cov);
RandomFields/src/getNset.cc:  if ((dummy = (double*) MALLOC(sizeof(double) * vdim * vdim)) == NULL ||
RandomFields/src/getNset.cc:      (x = (double*) MALLOC(sizeof(double) * redxdim))==NULL) 
RandomFields/src/getNset.cc:    int xdim = PREVXDIM(s);
RandomFields/src/getNset.cc:    x[idx] = islogcart[idx] ? M_E : 1.0; // wrong compiler warning
RandomFields/src/getNset.cc:void MultiDimRange(int *model_nr, int *set, double *natscale) { 
RandomFields/src/getNset.cc:  MultiDimRange(*set, KEY()[*model_nr], natscale); 
RandomFields/src/getNset.cc:  //#define NATSCALE_MLE 3 /* check fitvario when changing !! */
RandomFields/src/getNset.cc:      !equalsXonly(OWNDOM(0)) || 
RandomFields/src/getNset.cc:  if (global->general.naturalscaling != NATSCALE_ORNUMERIC)
RandomFields/src/getNset.cc:  assert(OWNTOTALXDIM == 1); 
RandomFields/src/getNset.cc:  MultiDimRange(0, cov, natscale);
RandomFields/src/getNset.cc://  GetNaturalScaling(KEY()[MODEL_USER], natscale);
RandomFields/src/getNset.cc:  defn *C = DefList + MODELNR(from); // nicht gatternr
RandomFields/src/getNset.cc:  bool same_model = std::abs(MODELNR(to) - MODELNR(from)) <= 1 ||
RandomFields/src/getNset.cc:  for (int i=0; i<MAXPARAM; i++) {
RandomFields/src/getNset.cc:      PARAMFREE(to, i);
RandomFields/src/getNset.cc:      listoftype *p = PARAMLIST(from, i);
RandomFields/src/getNset.cc:      if (pto[i] == NULL || force_allocating) pto[i] = (double*) MALLOC(n);
RandomFields/src/getNset.cc:      MEMCOPY(pto[i], pfrom[i], n);
RandomFields/src/getNset.cc:	  char *ptok = PARAMCHAR(to, i)[k],
RandomFields/src/getNset.cc:	    *pfromk = PARAMCHAR(from, i)[k];
RandomFields/src/getNset.cc:	  ptok = ((char**) (pto[i]))[k] = (char*) MALLOC(bytes);
RandomFields/src/getNset.cc:	  MEMCOPY(ptok, pfromk, bytes);
RandomFields/src/getNset.cc:      } else MEMCOPY(pto[i], pfrom[i], n * total);
RandomFields/src/getNset.cc:    if (to->mpp.moments < 0 && alloc_mpp_M(to, from->mpp.moments)!=NOERROR) 
RandomFields/src/getNset.cc:    int maxv = MIN(vdim, MAXMPPVDIM);
RandomFields/src/getNset.cc:    assert(To->mM != NULL && To->mMplus != NULL);
RandomFields/src/getNset.cc:    MEMCOPY(To->mM, From->mM, nmP1 * sizeof(double));
RandomFields/src/getNset.cc:    MEMCOPY(To->mMplus, From->mMplus, nmP1 * sizeof(double));
RandomFields/src/getNset.cc:      MEMCOPY(to->q, from->q, (to->qlen)* sizeof(double));
RandomFields/src/getNset.cc:    for (int i=0; i<MAXSUB; i++) if (from->sub[i] != NULL) {
RandomFields/src/getNset.cc:  if ((*localcov = (model*) MALLOC(sizeof(model)))==0)
RandomFields/src/getNset.cc:    RETURN_ERR(ERRORMEMORYALLOCATION);
RandomFields/src/getNset.cc:  MEMCOPY(current, cov, sizeof(model)); // replaces COV_NULL(*localcov);
RandomFields/src/getNset.cc:	  (char*) MALLOC(sizeof(char) * (1 + STRLEN(cov->ownkappanames[i])));
RandomFields/src/getNset.cc:    current->q = (double*) MALLOC(n); // QALLOC NOT APPROPRIATE
RandomFields/src/getNset.cc:    MEMCOPY(current->q, cov->q, n);
RandomFields/src/getNset.cc:  for (i=0; i<MAXPARAM; i++) {
RandomFields/src/getNset.cc:    //    printf(" **** COPY %s %d\n", NAME(cov), i);
RandomFields/src/getNset.cc:    for (i=0; i<MAXSUB; i++) {
RandomFields/src/getNset.cc:    for (i=0; i<MAXSUB; i++) current->sub[i] = NULL;
RandomFields/src/getNset.cc:  // rueckwaerts! Muss aber sein, da sonst LOC_DE LETE bei cov->calling==NULL
RandomFields/src/getNset.cc:  // rueckwaerts! Muss aber sein, da sonst LOC_DE LETE bei cov->calling==NULL
RandomFields/src/getNset.cc:  // rueckwaerts! Muss aber sein, da sonst LOC_DE LETE bei cov->calling==NULL
RandomFields/src/getNset.cc:  for (i=0; i<MAXPARAM; i++) {
RandomFields/src/getNset.cc:  for (i=0; i<MAXSUB; i++) {
RandomFields/src/getNset.cc:    GETSTOMODEL;
RandomFields/src/getNset.cc:    MEMCOPY(localcov->Sset, cov->Sset, sizeof(set_storage));
RandomFields/src/getNset.cc:    localcov->Smodel->remote = getRemote(remotecov, rmt, STOMODEL->remote);
RandomFields/src/getNset.cc:  for (i=0; i<MAXPARAM; i++) {
RandomFields/src/getNset.cc:  for (i=0; i<MAXSUB; i++) {
RandomFields/src/getNset.cc:double *getAnisoMatrix(model *cov, bool null_if_id, int *nrow, int *ncol) {
RandomFields/src/getNset.cc:    ani = (double *) MALLOC(bytes);
RandomFields/src/getNset.cc:    MEMCOPY(ani, aniso, bytes); 
RandomFields/src/getNset.cc:double *getAnisoMatrix(model *cov, int *nrow, int *ncol) {
RandomFields/src/getNset.cc:  return getAnisoMatrix(cov, false, nrow, ncol);
RandomFields/src/getNset.cc:      *origmin = (double*) MALLOC(origdim * sizeof(double)),
RandomFields/src/getNset.cc:      *origmax = (double*) MALLOC(origdim * sizeof(double)),
RandomFields/src/getNset.cc:      *origcenter = (double*) MALLOC(origdim * sizeof(double));
RandomFields/src/getNset.cc:      j = (bool*) MALLOC( (origdim + 1) * sizeof(double));
RandomFields/src/getNset.cc:      dummy = (double*) MALLOC(origdim * sizeof(double));
RandomFields/src/getNset.cc:      sx = (double*) MALLOC(spatialdim * sizeof(double));
RandomFields/src/getNset.cc:  dummymin = (double*) MALLOC(origdim * sizeof(double));
RandomFields/src/getNset.cc:  dummymax = (double*) MALLOC(origdim * sizeof(double));
RandomFields/src/getNset.cc:  dummycenter = (double*) MALLOC(origdim * sizeof(double));
RandomFields/src/getNset.cc:#define F_NUMBERS1 3
RandomFields/src/getNset.cc:#define F_NUMBERS2 3
RandomFields/src/getNset.cc:bool HOMEMADE_NICEFFT=false;
RandomFields/src/getNset.cc:  if (HOMEMADE_NICEFFT) {
RandomFields/src/getNset.cc:    int f[F_NUMBERS1]={2,3,5}; 
RandomFields/src/getNset.cc:    for (i=0; i<F_NUMBERS1; i++) 
RandomFields/src/getNset.cc:  } else { // not HOMEMADE_NICEFFT
RandomFields/src/getNset.cc:    int f[F_NUMBERS2]={2,3,5}; 
RandomFields/src/getNset.cc:    return nextn(n, f, F_NUMBERS2);
RandomFields/src/getNset.cc:    dimM1 = olddim - 1; 
RandomFields/src/getNset.cc:  x = *xx = (double*) MALLOC(sizeof(double) * total);
RandomFields/src/getNset.cc:  y = (double*) MALLOC(olddim * sizeof(double));
RandomFields/src/getNset.cc:  yi = (int*) MALLOC(olddim * sizeof(int));
RandomFields/src/getNset.cc:      if (i<dimM1) {
RandomFields/src/getNset.cc:    origdimM1 = origdim - 1;
RandomFields/src/getNset.cc:  (*grani) = (double *) MALLOC(sizeof(double) * 3 * dim);
RandomFields/src/getNset.cc:     for (i=0; i<origdimM1; i++, A++) if (*A != 0.0) break;    
RandomFields/src/getNset.cc:  z = *newx = (double*) MALLOC(sizeof(double) * timespacedim * nx * timelen);
RandomFields/src/getNset.cc:  z = *newx = (double*) MALLOC(sizeof(double) * ncol * nx * timelen); 
RandomFields/src/getNset.cc:    *z = *newx = (double*) MALLOC(sizeof(double) * ncol * nx);  
RandomFields/src/getNset.cc:    MEMCOPY(z, x, sizeof(double) * nx * ncol);
RandomFields/src/getNset.cc:matrix_type Type(double *M, int nrow, int ncol) {
RandomFields/src/getNset.cc:  matrix_type type = TypeMiso; // default
RandomFields/src/getNset.cc:    ncolM1 = ncol - 1,
RandomFields/src/getNset.cc:  double *m = M;
RandomFields/src/getNset.cc:      if (m[i]!= 0.0) return TypeMany;
RandomFields/src/getNset.cc:      newtype = TypeMproj;
RandomFields/src/getNset.cc:      newtype = !R_FINITE(M[0]) || !R_FINITE(m[k]) || m[k]!=M[0] ? TypeMdiag
RandomFields/src/getNset.cc:	: TypeMiso;
RandomFields/src/getNset.cc:    if (k < ncolM1) type = newtype > type ? newtype : type;
RandomFields/src/getNset.cc:      if (type == TypeMtimesep) return i>=nrow-1 ? type : TypeMany;
RandomFields/src/getNset.cc:      if (type == TypeMproj) return i>=nrow-1 ? TypeMtimesepproj : type;
RandomFields/src/getNset.cc:    if (k == ncol - 1) return TypeMany;
RandomFields/src/getNset.cc:    type = TypeMtimesep;
RandomFields/src/getNset.cc:    m = M + k * nrow;
RandomFields/src/getNset.cc:    aniso = getAnisoMatrix(cov, true, &nrow, &ncol); 
RandomFields/src/getNset.cc:      aniso =(double*) MALLOC(bytes);
RandomFields/src/getNset.cc:      MEMCOPY(aniso, locCani->caniso, bytes);
RandomFields/src/getNset.cc:  type = TypeMiso;
RandomFields/src/getNset.cc:    if (gridexpand==True || (gridexpand==GRIDEXPAND_AVOID && !isMproj(type))) {
RandomFields/src/getNset.cc:      if (timesep && isMtimesep(type) && *Time) {	
RandomFields/src/getNset.cc:      if (isMproj(type) && (!same_nr_of_points || ncol==nrow)) {
RandomFields/src/getNset.cc:      } else { // !gridexpand, !isMproj, but still grid
RandomFields/src/getNset.cc:	// z.B. plusmalS.cc falls TBM_INTERN
RandomFields/src/getNset.cc:	(*grani) = (double *) MALLOC(sizeof(double) * 3 * origdim);
RandomFields/src/getNset.cc:    } else if (timesep && isMtimesep(type)) {  // no grid, but timesep
RandomFields/src/getNset.cc:    } else if (ncol == 1 && type == TypeMproj &&  
RandomFields/src/getNset.cc:    } else { // no grid, but time, no timesep || not isMtimesep(type)
RandomFields/src/getNset.cc:      *Red_Matrix = (double *) MALLOC(sizeof(double) * nsel * ncol),
RandomFields/src/getNset.cc:      *endfor = Red_Matrix + nsel * ncol;
RandomFields/src/getNset.cc:  for (red_matrix=Red_Matrix; red_matrix<endfor; m+=nrow) {
RandomFields/src/getNset.cc:  return Red_Matrix;
RandomFields/src/getNset.cc:      *Red_Matrix = (int *) MALLOC(sizeof(int) * nsel * ncol),
RandomFields/src/getNset.cc:      *endfor = Red_Matrix + nsel * ncol;
RandomFields/src/getNset.cc:  for (red_matrix=Red_Matrix; red_matrix<endfor; m+=nrow) {
RandomFields/src/getNset.cc:  return Red_Matrix;
RandomFields/src/getNset.cc:      p = PARAMLIST(min, K);
RandomFields/src/getNset.cc:      qmin = PARAMLIST(min, K)->lpx;
RandomFields/src/getNset.cc:      qmax = PARAMLIST(max, K)->lpx;
RandomFields/src/getNset.cc:      ppmin = PARAMLIST(pmin, K)->lpx;
RandomFields/src/getNset.cc:      ppmax = PARAMLIST(pmax, K)->lpx;
RandomFields/src/getNset.cc:      omin = PARAMLIST(openmin, K)->lpx;
RandomFields/src/getNset.cc:      omax = PARAMLIST(openmax, K)->lpx;
RandomFields/src/getNset.cc:	  if (dmin < -MAXINT) dmin = (double) -MAXINT;
RandomFields/src/getNset.cc:	  if (dmax > MAXINT) dmax = (double) MAXINT;	  
RandomFields/src/getNset.cc:	  PARAM(min, K)[idx] = dmin;
RandomFields/src/getNset.cc:	  PARAM(max, K)[idx] = dmax;
RandomFields/src/getNset.cc:	  PARAM(pmin, K)[idx] = range.pmin;
RandomFields/src/getNset.cc:	  PARAM(pmax, K)[idx] = range.pmax;
RandomFields/src/getNset.cc:	  PARAM(openmin, K)[idx] = dopenmin;
RandomFields/src/getNset.cc:	  PARAM(openmax, K)[idx] = dopenmax;
RandomFields/src/getNset.cc:	  PARAMINT(min, K)[idx] = dmin;
RandomFields/src/getNset.cc:	  PARAMINT(max, K)[idx] = dmax;
RandomFields/src/getNset.cc:	  PARAMINT(pmin, K)[idx] = range.pmin;
RandomFields/src/getNset.cc:	  PARAMINT(pmax, K)[idx] = range.pmax;
RandomFields/src/getNset.cc:	  PARAMINT(openmin, K)[idx] = dopenmin;
RandomFields/src/getNset.cc:	  PARAMINT(openmax, K)[idx] = dopenmax;
RandomFields/src/getNset.cc:    //     printf("cov=%s %d\n", NAME(cov), i);
RandomFields/src/getNset.cc:      if (dmin < -MAXINT) {
RandomFields/src/getNset.cc:	dmin = (double) -MAXINT;
RandomFields/src/getNset.cc:      if (dmax > MAXINT) {
RandomFields/src/getNset.cc:	dmax = (double) MAXINT;	  
RandomFields/src/getNset.cc:	PARAM(min, i)[k] = dmin;
RandomFields/src/getNset.cc:	PARAM(max, i)[k] = dmax;
RandomFields/src/getNset.cc:	PARAM(pmin, i)[k] = dpmin;
RandomFields/src/getNset.cc:	PARAM(pmax, i)[k] = dpmax;
RandomFields/src/getNset.cc:	PARAM(openmin, i)[k] = dopenmin;
RandomFields/src/getNset.cc:	PARAM(openmax, i)[k] = dopenmax;
RandomFields/src/getNset.cc:	PARAMINT(min, i)[k] = dmin;
RandomFields/src/getNset.cc:	PARAMINT(max, i)[k] = dmax;
RandomFields/src/getNset.cc:	PARAMINT(pmin, i)[k] = dpmin;
RandomFields/src/getNset.cc:	PARAMINT(pmax, i)[k] = dpmax;
RandomFields/src/getNset.cc:	PARAMINT(openmin, i)[k] = dopenmin;
RandomFields/src/getNset.cc:	PARAMINT(openmax, i)[k] = dopenmax;
RandomFields/src/getNset.cc:	listoftype *p = PARAMLIST(min, i);
RandomFields/src/getNset.cc:	    *qmin = PARAMLIST(min, i)->lpx[k],
RandomFields/src/getNset.cc:	    *qmax = PARAMLIST(max, i)->lpx[k],
RandomFields/src/getNset.cc:	    *ppmin = PARAMLIST(pmin, i)->lpx[k],
RandomFields/src/getNset.cc:	    *ppmax = PARAMLIST(pmax, i)->lpx[k],
RandomFields/src/getNset.cc:	    *omin = PARAMLIST(openmin, i)->lpx[k],
RandomFields/src/getNset.cc:	    *omax = PARAMLIST(openmax, i)->lpx[k];
RandomFields/src/getNset.cc:	RETURN_ERR(ERRORM);
RandomFields/src/getNset.cc:  for (int i=0; i<MAXPARAM; i++) {
RandomFields/src/getNset.cc:  for (int i=0; i<MAXSUB; i++) {
RandomFields/src/getNset.cc:       (double*) MALLOC(sizeof(double) * Loctotalpoints(cov) * VDIM0))
RandomFields/src/getNset.cc:      == NULL) RETURN_ERR(ERRORMEMORYALLOCATION)
RandomFields/src/getNset.cc:  for (i=0; i<MAXPARAM; i++) 
RandomFields/src/getNset.cc:  int last = LASTSYSTEM(sys);
RandomFields/src/getNset.cc:  XDIMi(sys[s]) = value; // OK
RandomFields/src/getNset.cc:  for (int j=(MAX(s, 1)); j<=last; j++) {
RandomFields/src/getNset.cc:    set_cumxmit(sys, j, CUMXMIT(sys, j-1) + XDIM(sys, j));
RandomFields/src/getNset.cc:  //if (idx >= MAXSYSTEMS) { printf("%d %d\n", idx, MAXSYSTEMS); crash(); }  
RandomFields/src/getNset.cc:  assert(idx < MAXSYSTEMS);
RandomFields/src/getNset.cc:  int last = isSetLastSystem(sys) ? LASTSYSTEM(sys) : 0;  
RandomFields/src/getNset.cc:  XDIMi(sys[idx]) = xdim; // OK
RandomFields/src/getNset.cc:      if (check_unset && (LOGDIM(sys, s) == UNSET || XDIM(sys, s) == UNSET)) {
RandomFields/src/getNset.cc:    set_cumxmit(sys, s, CUMXMIT(sys, s-1) + XDIM(sys, s));
RandomFields/src/getNset.cc:#if MAXSYSTEMS == 1
RandomFields/src/getNset.cc:  int last = LASTSYSTEM(sys);
RandomFields/src/getNset.cc:  int last = LASTSYSTEM(sys);
RandomFields/src/trend.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/trend.cc: Copyright (C) 2011 -- 2015 Marco Oesting & Martin Schlather
RandomFields/src/trend.cc:               2015 -- 2017 Martin Schlather
RandomFields/src/trend.cc:   in RFsimu.h, since there is no error check (e.g. initialization of RANDOM)
RandomFields/src/trend.cc: * definitions for the random coin method can be found in MPPFcts.cc
RandomFields/src/trend.cc:   SophisticatedModel.cc; hyper models also in Hypermodel.cc
RandomFields/src/trend.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/trend.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/trend.cc:#include "QMath.h"
RandomFields/src/trend.cc:  int vdim = VDIM0;
RandomFields/src/trend.cc:    //    PMI0(cov);
RandomFields/src/trend.cc:  model *musub = cov->kappasub[SHAPE_FCT_MEAN];
RandomFields/src/trend.cc:  double *mu = P(SHAPE_FCT_MEAN);
RandomFields/src/trend.cc:  *nr = i == SHAPE_FCT_MEAN ? SIZE_NOT_DETERMINED : -1; 
RandomFields/src/trend.cc:  model *musub = cov->kappasub[SHAPE_FCT_MEAN]; 
RandomFields/src/trend.cc:    set_xdim(OWN, 0, PREVXDIM(0));
RandomFields/src/trend.cc:	    : ISO_MISMATCH);
RandomFields/src/trend.cc:    set_xdim(OWN, 0, PREVXDIM(0));
RandomFields/src/trend.cc:  model *musub = cov->kappasub[SHAPE_FCT_MEAN]; 
RandomFields/src/trend.cc:  model *musub = cov->kappasub[SHAPE_FCT_MEAN]; 
RandomFields/src/trend.cc:    *musub = cov->kappasub[SHAPE_FCT_MEAN];
RandomFields/src/trend.cc:    logdim = OWNLOGDIM(0);
RandomFields/src/trend.cc:  if ((musub != NULL) xor PisNULL(SHAPE_FCT_MEAN))
RandomFields/src/trend.cc:     ILLEGAL_FRAME;
RandomFields/src/trend.cc:  //  PMI(cov);
RandomFields/src/trend.cc:    vdim = cov->nrow[SHAPE_FCT_MEAN];
RandomFields/src/trend.cc:    ASSERT_ONESYSTEM;
RandomFields/src/trend.cc:    if ((err = CHECK(musub, logdim, OWNXDIM(0), ShapeType, XONLY,
RandomFields/src/trend.cc:		     PREVISO(0), SUBMODEL_DEP, TrendType)) != NOERROR) {
RandomFields/src/trend.cc:      //    APMI(cov);
RandomFields/src/trend.cc:    // PMI(cov);
RandomFields/src/trend.cc:  VDIM0 = vdim;
RandomFields/src/trend.cc:  VDIM1 = 1;
RandomFields/src/trend.cc:  //P(SHAPE_FCT_MEAN]: mu / mean
RandomFields/src/trend.cc:  range->min[SHAPE_FCT_MEAN] = RF_NEGINF;
RandomFields/src/trend.cc:  range->max[SHAPE_FCT_MEAN] = RF_INF;
RandomFields/src/trend.cc:  range->pmin[SHAPE_FCT_MEAN] = -1e10;
RandomFields/src/trend.cc:  range->pmax[SHAPE_FCT_MEAN] = 1e10;
RandomFields/src/trend.cc:  range->openmin[SHAPE_FCT_MEAN] = true;
RandomFields/src/trend.cc:  range->openmax[SHAPE_FCT_MEAN] = true;
RandomFields/src/trend.cc:  //  PMI0(cov);
RandomFields/src/trend.cc:  ASSERT_ONESYSTEM;
RandomFields/src/trend.cc:  // printf("proc %d %d %d %d\n", musub != NULL, PisNULL(SHAPE_FCT_MEAN), cov->sub[0] == NULL, cov->key==NULL);
RandomFields/src/trend.cc:    if (cov->kappasub[SHAPE_FCT_MEAN] == NULL) ERR("a function must be given");
RandomFields/src/trend.cc:    assert(PisNULL(SHAPE_FCT_MEAN));
RandomFields/src/trend.cc:    cov->sub[SHAPE_FCT_MEAN] = cov->kappasub[SHAPE_FCT_MEAN];
RandomFields/src/trend.cc:    cov->kappasub[SHAPE_FCT_MEAN] = NULL;
RandomFields/src/trend.cc:  assert(cov->kappasub[SHAPE_FCT_MEAN] == NULL);
RandomFields/src/trend.cc:  model *musub = cov->sub[SHAPE_FCT_MEAN];
RandomFields/src/trend.cc:  if ((musub != NULL) xor PisNULL(SHAPE_FCT_MEAN))
RandomFields/src/trend.cc:    SERR("either a mean 'mu' or an RMmodel must be given");
RandomFields/src/trend.cc:    int newdim = PREVLOGDIM(0);
RandomFields/src/trend.cc:    //    PMI(cov);   printf("iso = %s\n", ISO_NAMES[ PREVISO(0)]);
RandomFields/src/trend.cc:		     PREVISO(0), SUBMODEL_DEP, TrendType)) !=
RandomFields/src/trend.cc:    VDIM0 = musub->vdim[0]; 
RandomFields/src/trend.cc:    VDIM1 = musub->vdim[1];
RandomFields/src/trend.cc:    VDIM0 = cov->nrow[SHAPE_FCT_MEAN];
RandomFields/src/trend.cc:    VDIM1 = cov->ncol[SHAPE_FCT_MEAN];
RandomFields/src/trend.cc:  if (VDIM1 != 1) ERR("matrix-valued functions not allowed as trend")
RandomFields/src/trend.cc:  // FRAME_ASSERT_GAUSS;
RandomFields/src/trend.cc:   model *musub = cov->sub[SHAPE_FCT_MEAN];
RandomFields/src/trend.cc:   if (VDIM0 != 1) NotProgrammedYet("");
RandomFields/src/trend.cc:  if (PL>= PL_STRUCTURE) { PRINTF("\n'%s' is now initialized.\n", NAME(cov));}
RandomFields/src/trend.cc:   model *musub = cov->sub[SHAPE_FCT_MEAN];
RandomFields/src/trend.cc:      vdim = VDIM0,
RandomFields/src/trend.cc:    double *mu = (double *) MALLOC(vdim * sizeof(double));
RandomFields/src/trend.cc:    assert(cov->nrow[SHAPE_FCT_MEAN] == vdim);
RandomFields/src/trend.cc:    MEMCOPY(mu, P(SHAPE_FCT_MEAN), sizeof(double) * vdim);
RandomFields/src/trend.cc:  model *musub = cov->sub[SHAPE_FCT_MEAN]; 
RandomFields/src/trend.cc:    set_xdim(OWN, 0, PREVXDIM(0));
RandomFields/src/trend.cc:	    : ISO_MISMATCH);
RandomFields/src/trend.cc:    set_xdim(OWN, 0, PREVXDIM(0));
RandomFields/src/trend.cc:  model *musub = cov->sub[SHAPE_FCT_MEAN]; 
Binary file RandomFields/src/shape.o matches
Binary file RandomFields/src/primitive.others.o matches
RandomFields/src/userinterfaces.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/userinterfaces.cc: Copyright (C) 2001 -- 2017 Martin Schlather, 
RandomFields/src/userinterfaces.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/userinterfaces.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/userinterfaces.cc:#define PERR(X) {LOCAL_MSG; SPRINTF(MSG, "'%.100s': %.800s", param_name, X); RFERROR(MSG);}
RandomFields/src/userinterfaces.cc:#define PERR1(X,Y) {LOCAL_MSG; LOCAL_ERRMSG2; SPRINTF(MSG, "'%.100s': %.800s", param_name, X); SPRINTF(MSG2, MSG, Y); RFERROR(MSG2);}
RandomFields/src/userinterfaces.cc:    if(STRCMP(CHAR(STRING_ELT(names, i)), str) == 0) {
RandomFields/src/userinterfaces.cc:  // -1 NOMATCHING if no matching name is found
RandomFields/src/userinterfaces.cc:  // -2 MULTIPLEMATCHING if multiple matching fctns are found,
RandomFields/src/userinterfaces.cc:  if (names == R_NilValue) RET(NOMATCHING);
RandomFields/src/userinterfaces.cc:  while ( Nr < n  && STRNCMP(str, CHAR(STRING_ELT(names, Nr)), ln)) Nr++;
RandomFields/src/userinterfaces.cc:	if (STRNCMP(str, CHAR(STRING_ELT(names, i)), ln) == 0)
RandomFields/src/userinterfaces.cc:	  RET(MULTIPLEMATCHING);
RandomFields/src/userinterfaces.cc:      while ( (j<n) && STRNCMP(str, CHAR(STRING_ELT(names, j)), ln)) {j++;}
RandomFields/src/userinterfaces.cc:	    if (STRNCMP(str, CHAR(STRING_ELT(names, j)), ln) == 0) {
RandomFields/src/userinterfaces.cc:	      RET(MULTIPLEMATCHING);
RandomFields/src/userinterfaces.cc:    if (multiplematching) RET(MULTIPLEMATCHING);
RandomFields/src/userinterfaces.cc:  } else RET(NOMATCHING);
RandomFields/src/userinterfaces.cc:  if (!PARAMisNULL(next, i)) {
RandomFields/src/userinterfaces.cc:    if (PisNULL(i)) kdefault(cov, i, PARAM0(next, i));
RandomFields/src/userinterfaces.cc:    else P(i)[0] = P0(i) * PARAM0(next, i);
RandomFields/src/userinterfaces.cc:      *qq = MALLOC(sizeof(double) * len);      
RandomFields/src/userinterfaces.cc:	    FABS(q[j]) > MAXACCEPTED) 
RandomFields/src/userinterfaces.cc:	  RFERROR2("'%.50s' has an absolute value larger than %10e, what is believed to be a misspecification.", param_name, MAXACCEPTED);
RandomFields/src/userinterfaces.cc:	// insures that there is not conflict with PrepareModel2
RandomFields/src/userinterfaces.cc:      *qq = MALLOC(sizeof(int) * len);
RandomFields/src/userinterfaces.cc:      *qq = MALLOC(sizeof(char*) * len);
RandomFields/src/userinterfaces.cc:	q[j] = (char *) MALLOC(sizeof(char) * (nch+1));
RandomFields/src/userinterfaces.cc:     if (STRCMP("setseed", param_name) != 0 && STRCMP("env", param_name)!=0){ 
RandomFields/src/userinterfaces.cc:	 RFERROR1("Models with R commands in the parameters (such as '%.50s') may not be called by obsolete functions.\nSee the notes in '?RMmodelsAdvanced' and set 'RFoldstyle(FALSE)'.", DefList[USER].nick);
RandomFields/src/userinterfaces.cc:    *qq = MALLOC(sizeof(sexp_type));
RandomFields/src/userinterfaces.cc:    if (STRCMP("setseed", param_name) != 0 && STRCMP("env", param_name)!=0){ 
RandomFields/src/userinterfaces.cc:	 RFERROR1("Models with R commands in the parameters (such as '%.50s') may not be called by obsolete functions.\nSee the notes in '?RMmodelsAdvanced' and set 'RFoldstyle(FALSE)'.", DefList[USER].nick);
RandomFields/src/userinterfaces.cc:	      param_name, R_TYPE_NAME(TYPEOF(p)), R_TYPE_NAME(type));
RandomFields/src/userinterfaces.cc:    *qq = MALLOC(sizeof(sexp_type));
RandomFields/src/userinterfaces.cc:     if (STRCMP("setseed", param_name) != 0 && STRCMP("env", param_name)!=0){ 
RandomFields/src/userinterfaces.cc:	 RFERROR1("Models with R commands in the parameters (such as '%.50s') may not be called by obsolete functions.\nSee the notes in '?RMmodelsAdvanced' and set 'RFoldstyle(FALSE)'.", DefList[USER].nick);
RandomFields/src/userinterfaces.cc:	      param_name, R_TYPE_NAME(TYPEOF(p)), R_TYPE_NAME(type));
RandomFields/src/userinterfaces.cc:    *qq = MALLOC(sizeof(sexp_type));
RandomFields/src/userinterfaces.cc:	       param_name, R_TYPE_NAME(TYPEOF(p)), R_TYPE_NAME(type));
RandomFields/src/userinterfaces.cc:    *qq = MALLOC(sizeof(sexp_type));
RandomFields/src/userinterfaces.cc:	       R_TYPE_NAME(TYPEOF(p)),  R_TYPE_NAME(REALSXP));
RandomFields/src/userinterfaces.cc:	if (isMatrix(pi)) {
RandomFields/src/userinterfaces.cc:	  // Achtung isVector ist true falls isMatrix true
RandomFields/src/userinterfaces.cc:      if (locallen > MAX ELEMENTS) PERR("too many list elements");
RandomFields/src/userinterfaces.cc:      *qq = MA LLO C(sizeof(listoftype));
RandomFields/src/userinterfaces.cc:      for (i=0; i<MAX ELEMENTS; i++) {
RandomFields/src/userinterfaces.cc:	  (freelistoftype*) (q->px[k]=(double*) MALLOC(sizeof(freelistoftype)));
RandomFields/src/userinterfaces.cc:	ll->ncol = (int *) MALLOC( sizeof(int*) * lpk); // sel sets of 
RandomFields/src/userinterfaces.cc:	ll->nrow = (int *) MALLOC( sizeof(int*) * lpk); // same kind
RandomFields/src/userinterfaces.cc:	  if (isMatrix(pi)) {
RandomFields/src/userinterfaces.cc:	    // Achtung isVector ist true falls isMatrix true
RandomFields/src/userinterfaces.cc:model *CMbuild(SEXP Model, KEY_type *KT, int cR);
RandomFields/src/userinterfaces.cc:void CheckModel(SEXP Model, double *x, double *Y, double *T, double *Ty,
RandomFields/src/userinterfaces.cc:  char EM2[LENERRMSG] = "";
RandomFields/src/userinterfaces.cc:    isotropy_type iso = ISO_MISMATCH;
RandomFields/src/userinterfaces.cc:    cov = CMbuild(Model, KT, cR);
RandomFields/src/userinterfaces.cc:    //  PREVDOM(0) = totptsy == 0 ? XONLY : KERNEL;
RandomFields/src/userinterfaces.cc:  //    PMI0(cov);    printf("%d\n", SIMULATE); 
RandomFields/src/userinterfaces.cc:		 XONLY, // formal sind alle Interface Modelle nur von 
RandomFields/src/userinterfaces.cc:		 equalsIsoMismatch(iso) ? CARTESIAN_COORD : iso);
RandomFields/src/userinterfaces.cc:	iso = equalsIsoMismatch(iso) ? EARTH_COORD : EARTH_ISOTROPIC;
RandomFields/src/userinterfaces.cc:	iso = equalsIsoMismatch(iso) ? SPHERICAL_COORD : SPHERICAL_ISOTROPIC;
RandomFields/src/userinterfaces.cc:#if MAXSYSTEMS == 1
RandomFields/src/userinterfaces.cc:#if MAXSYSTEMS > 1      
RandomFields/src/userinterfaces.cc:	XO NLY, // formal sind alle Interface Modelle nur von 
RandomFields/src/userinterfaces.cc:		   XONLY, // formal sind alle Interface Modelle nur von 
RandomFields/src/userinterfaces.cc:  //    PMI0(cov);    
RandomFields/src/userinterfaces.cc:      PMI(cov);//OK      
RandomFields/src/userinterfaces.cc:    if ((err = CHECK_GEN(cov, SUBMODEL_DEP, SUBMODEL_DEP, InterfaceType, true))
RandomFields/src/userinterfaces.cc:     //		       SUBMODEL_DEP, Any Type))
RandomFields/src/userinterfaces.cc:	PMI(cov); // OK
RandomFields/src/userinterfaces.cc:      PMI(cov); // OK
RandomFields/src/userinterfaces.cc:    printf("CMbukd checked\n"); //
RandomFields/src/userinterfaces.cc:    SPRINTF(KT->error_location, "%.50s process", TYPE_NAMES[cov->frame]);
RandomFields/src/userinterfaces.cc:    printf("CMbuild struct done\n"); // ok
RandomFields/src/userinterfaces.cc:    assert((COVNR >= COVFCTN && COVNR <= VARIOGRAM_CALL) || cov->initialised);
RandomFields/src/userinterfaces.cc:      PMI(cov); printf("COVNR= %d %d %d; %d  %d %d\n", //
RandomFields/src/userinterfaces.cc:		       COVNR, COVFCTN, VARIOGRAM_CALL,
RandomFields/src/userinterfaces.cc:	   (COVNR >= COVFCTN && COVNR <= VARIOGRAM_CALL) ||
RandomFields/src/userinterfaces.cc:    char EM[LENERRMSG];
RandomFields/src/userinterfaces.cc:    errorMSG(err, causing==NULL ? (char*)"<strange failure>" : causing->err_msg,
RandomFields/src/userinterfaces.cc:	     KT, EM);
RandomFields/src/userinterfaces.cc:    SPRINTF(EM2, "%.50s %.500s", PREF_FAILURE, EM);
RandomFields/src/userinterfaces.cc:    //   printf("location:%.50s  %.50s  %.50rs\n", KT->error_location,  cov->err_msg, EM);
RandomFields/src/userinterfaces.cc:    RFERROR(EM2); 
RandomFields/src/userinterfaces.cc:    PRINTF("To guarantee definiteness use 'RMmodel(var=const)', and not 'const * RMmodel()'.\n");
RandomFields/src/userinterfaces.cc:model *InitIntern(int cR, SEXP Model, SEXP x, bool NA_OK,
RandomFields/src/userinterfaces.cc:    Time = LOGICAL(VECTOR_ELT(set, XLIST_TIME))[0],
RandomFields/src/userinterfaces.cc:    spatialdim = INTEGER(VECTOR_ELT(set, XLIST_SPATIALDIM))[0];
RandomFields/src/userinterfaces.cc:  CheckModel(Model, NULL, NULL, NULL, NULL,
RandomFields/src/userinterfaces.cc:SEXP Init(SEXP model_reg, SEXP Model, SEXP x, SEXP NA_OK) {
RandomFields/src/userinterfaces.cc:  model *cov = InitIntern(INTEGER(model_reg)[0], Model, x,
RandomFields/src/userinterfaces.cc:    PMI(cov);// OK
RandomFields/src/userinterfaces.cc:SEXP EvaluateModel(SEXP X, SEXP I, SEXP Covnr){
RandomFields/src/userinterfaces.cc:    mem = VDIM0 * VDIM1;
RandomFields/src/userinterfaces.cc:  if (len == 2) PROTECT(result = allocMatrix(REALSXP, cov->q[0], cov->q[1]));
RandomFields/src/userinterfaces.cc:void GetCurrentNrOfModels(int *nr) {
RandomFields/src/userinterfaces.cc:SEXP GetAllModelNames(SEXP Newnames){
RandomFields/src/userinterfaces.cc:void GetModelName(int *nr,char **name, char **nick){
RandomFields/src/userinterfaces.cc:    strcopyN(*name,"", MAXCHAR); 
RandomFields/src/userinterfaces.cc:    strcopyN(*nick,"", MAXCHAR); 
RandomFields/src/userinterfaces.cc:  strcopyN(*name, DefList[*nr].name, MAXCHAR);
RandomFields/src/userinterfaces.cc:  strcopyN(*nick, DefList[*nr].nick, MAXCHAR);
RandomFields/src/userinterfaces.cc:    p rintf("%.50s %.50s\n", C->kappanames[i], INTERNAL_PARAM);
RandomFields/src/userinterfaces.cc:    kk += (str cmp(C->kappanames[i], INTERNAL_PARAM) != 0);
RandomFields/src/userinterfaces.cc:void GetModelNr(char **name, int *nr) {
RandomFields/src/userinterfaces.cc:    SET_STRING_ELT(pnames, i, mkChar(CAT_TYPE_NAMES[i]));
RandomFields/src/userinterfaces.cc:  // given. This happens, for instance, for nonstWM
RandomFields/src/userinterfaces.cc:    // since 17 May 2014:
RandomFields/src/userinterfaces.cc:void PMLheader(char* firstcolumn, int nick) {
RandomFields/src/userinterfaces.cc:  const char header1[]=" #    cir cut int TBM spe dir seq tre ave coi hyp spe\n";
RandomFields/src/userinterfaces.cc:void PrintModelList(int *intern, int *operat, int* Nick)
RandomFields/src/userinterfaces.cc:  //char header[]="circ cut intr TBM spec dir seq Mak ave add hyp part\n";
RandomFields/src/userinterfaces.cc:  char firstcolumn[20], name[MAXCHAR];
RandomFields/src/userinterfaces.cc:  int maxchar=10; // <= MAXCHAR=14
RandomFields/src/userinterfaces.cc:  assert(MAXCHAR >= maxchar);
RandomFields/src/userinterfaces.cc:  int type[MAXNRCOVFCTS], op[MAXNRCOVFCTS], monotone[MAXNRCOVFCTS], 
RandomFields/src/userinterfaces.cc:    finite[MAXNRCOVFCTS], simpleArguments[MAXNRCOVFCTS], 
RandomFields/src/userinterfaces.cc:    internal[MAXNRCOVFCTS], dom[MAXNRCOVFCTS], 
RandomFields/src/userinterfaces.cc:    iso[MAXNRCOVFCTS], vdim[MAXNRCOVFCTS], maxdim[MAXNRCOVFCTS],
RandomFields/src/userinterfaces.cc:    paramtype[MAXNRCOVFCTS * MAXPARAM],
RandomFields/src/userinterfaces.cc:    PRINTF("%10s[See also PrintMethodList for the names of the columns();\n", 
RandomFields/src/userinterfaces.cc:      PMLheader(firstcolumn, nick);
RandomFields/src/userinterfaces.cc:	if ( (!isPosDef((Types)(type[i])) && !isManifold((Types) (type[i]))) ||
RandomFields/src/userinterfaces.cc:	if (STRNCMP(C->name, InternalName, STRLEN(InternalName)) ==0) {
RandomFields/src/userinterfaces.cc:	       specialnames[isNormalMixture((monotone_type) monotone[i]) ? 1
RandomFields/src/userinterfaces.cc:			    : isManifold((Types)(type[i])) || 
RandomFields/src/userinterfaces.cc:    PMLheader(firstcolumn, nick);
RandomFields/src/userinterfaces.cc:void PrintModelList() {
RandomFields/src/userinterfaces.cc:  PrintModelList(&wahr, &wahr, &zero);
RandomFields/src/userinterfaces.cc:  void GetModelList(int* idx, int*internal) {
RandomFields/src/userinterfaces.cc:#define MAXPN 10 /* only used for testing purposes */
RandomFields/src/userinterfaces.cc:      dom[j] = DOM(C->systems[v], 0);
RandomFields/src/userinterfaces.cc:      maxdim[j] = MAXDIM(C->systems[v], 0);
RandomFields/src/userinterfaces.cc:      monotone[j] = C->Monotone;
RandomFields/src/userinterfaces.cc:	paramtype[j * MAXPARAM + p] = C->kappaParamType[p];
RandomFields/src/userinterfaces.cc:  case GaussMethodType : return GAUSSPROC;
RandomFields/src/userinterfaces.cc:  case BrMethodType : return BROWNRESNICKPROC;
RandomFields/src/userinterfaces.cc:    else if (nr == PLUS_PROC || nr == MULT_PROC) 
RandomFields/src/userinterfaces.cc:  case ManifoldType:
RandomFields/src/userinterfaces.cc:    if (nr == PLUS || nr == MULT || isDollar(cov) || nr == POWER_DOLLAR || 
RandomFields/src/userinterfaces.cc:SEXP GetProcessType(SEXP model_reg, SEXP Model) {
RandomFields/src/userinterfaces.cc:  model *cov = CMbuild(Model, KEYT(), INTEGER(model_reg)[0]);
RandomFields/src/userinterfaces.cc:void GetModelRegister(char **name, int* nr) {
RandomFields/src/userinterfaces.cc:  *nr = Match(*name, REG_NAMES, MODEL_MAX+1);
RandomFields/src/userinterfaces.cc:  if (*nr<0 || *nr > MODEL_MAX) RFERROR("name for model register unknown");
RandomFields/src/userinterfaces.cc:void CMbuild(SEXP Model, int level, model **Cov,
RandomFields/src/userinterfaces.cc:    len = length(Model);
RandomFields/src/userinterfaces.cc:  char leer[NLEER], name[MAXCHAR], param_name[PARAMMAXCHAR];
RandomFields/src/userinterfaces.cc:  //  methname[METHODMAXCHAR], 
RandomFields/src/userinterfaces.cc:  bool subleft[MAXSUB]; 
RandomFields/src/userinterfaces.cc:  if (TYPEOF(Model) != VECSXP) { // not list8
RandomFields/src/userinterfaces.cc:  PROTECT(names = getAttrib(Model, R_NamesSymbol));
RandomFields/src/userinterfaces.cc:  PROTECT(m = VECTOR_ELT(Model, elt++));
RandomFields/src/userinterfaces.cc:  strcopyN(name, (char*) CHAR(STRING_ELT(m, 0)), MAXCHAR);
RandomFields/src/userinterfaces.cc:  if (covnr == MULTIPLEMATCHING)
RandomFields/src/userinterfaces.cc:    else if (covnr == NOMATCHING) 
RandomFields/src/userinterfaces.cc:      RFERROR("'%.50s' is an unknown model name.\n'RFgetModelNames()' yields the list of models", name);
RandomFields/src/userinterfaces.cc:  addModel(Cov, covnr, calling, true);
RandomFields/src/userinterfaces.cc:    p = VECTOR_ELT(Model, elt);
RandomFields/src/userinterfaces.cc:	     : CHAR(STRING_ELT(names, elt)), PARAMMAXCHAR);     
RandomFields/src/userinterfaces.cc:    bool empty = STRCMP(param_name, "") == 0;
RandomFields/src/userinterfaces.cc:	if ((i = Match(param_name, C->kappanames, nkappas)) < 0) {
RandomFields/src/userinterfaces.cc:	  i = Match(param_name, STANDARDPARAM, nkappas);
RandomFields/src/userinterfaces.cc:      if (i<0 && !STRCMP(C->kappanames[nkappas - 1], FREEVARIABLE)) {
RandomFields/src/userinterfaces.cc:	if ((j = Match(param_name, C->subnames, C->maxsub)) < 0) {
RandomFields/src/userinterfaces.cc:	  j = Match(param_name, STANDARDSUB, MAXSUB);
RandomFields/src/userinterfaces.cc:	  while(STRCMP(C->kappanames[i], FREEVARIABLE) && i<nkappas) i++;
RandomFields/src/userinterfaces.cc:	    (char*) MALLOC(sizeof(char) * (1 + STRLEN(param_name)));
RandomFields/src/userinterfaces.cc:      i = NOMATCHING;
RandomFields/src/userinterfaces.cc:	if ((i = Match(param_name, C->subnames, C->maxsub)) < 0) {
RandomFields/src/userinterfaces.cc:	  i = Match(param_name, STANDARDSUB, MAXSUB);
RandomFields/src/userinterfaces.cc:	  if (PL >= PL_IMPORTANT) {
RandomFields/src/userinterfaces.cc:		   param_name, NAME(cov));
RandomFields/src/userinterfaces.cc:		if (STRCMP(STANDARDSUB[s], C->subnames[s]) != 0) {
RandomFields/src/userinterfaces.cc:	  if (i == MULTIPLEMATCHING) {
RandomFields/src/userinterfaces.cc:#define MMERR(X) {ERR3("%.50s\n%.50s: %.50s", KT->error_location, param_name, X);}
RandomFields/src/userinterfaces.cc:            MMERR("multiple matching of submodel names") 
RandomFields/src/userinterfaces.cc:            MMERR("unmatched covariance name for submodel")
RandomFields/src/userinterfaces.cc:	  MMERR(msg);
RandomFields/src/userinterfaces.cc:      if (!subleft[i]) MMERR("submodel given twice"); 
RandomFields/src/userinterfaces.cc:      CMbuild(p, level + 1, cov->sub + i, cov, KT, root);
RandomFields/src/userinterfaces.cc:      //      if (param_name[0]==ONEARGUMENT_NAME && STRLEN(param_name) == 1) { 
RandomFields/src/userinterfaces.cc:      //     if (STRCMP(param_name, "k") == 0) {
RandomFields/src/userinterfaces.cc:       if (param_name[0] == ONEARGUMENT_NAME && param_name[1] ==  '\0') {
RandomFields/src/userinterfaces.cc:	  PERR1("if '%c' is used as parameter name then only a numerical vector is allowed as value", ONEARGUMENT_NAME);
RandomFields/src/userinterfaces.cc:	  PERR1("length of vector does not match number of parameters. Do not use short name '%c' in complex situtations either.", ONEARGUMENT_NAME);
RandomFields/src/userinterfaces.cc:	  if (true ||  // neu seit 6.8.14, wegen RFgui, modelParam = .Call(C_SetAndGetModelFacts",
RandomFields/src/userinterfaces.cc:      if (STRCMP(param_name, "") == 0 && i < 0) {
RandomFields/src/userinterfaces.cc:	  if (PL >= PL_IMPORTANT) {
RandomFields/src/userinterfaces.cc:		if (STRCMP("", C->kappanames[s]) != 0) {		  
RandomFields/src/userinterfaces.cc:	      for (int s=0; s<C->kappas; s++) PRINTF("'%s', ",STANDARDPARAM[s]);
RandomFields/src/userinterfaces.cc:	  if (i == MULTIPLEMATCHING) PERR("multiple matching of parameter");
RandomFields/src/userinterfaces.cc:	  if (i == NOMATCHING){
RandomFields/src/userinterfaces.cc:	CMbuild(p, level + 1, cov->kappasub + i, cov, KT, root);
RandomFields/src/userinterfaces.cc:	    case 0: List = EQ_NAMES; lenL=nEQ_NAMES; break;
RandomFields/src/userinterfaces.cc:	    case 1: List = ISO_NAMES; lenL=LAST_ISO + 1; break;
RandomFields/src/userinterfaces.cc:	    case 2: List = DOMAIN_NAMES; lenL=LAST_DOMAIN + 1; break;
RandomFields/src/userinterfaces.cc:	    case 3: List = TYPE_NAMES; lenL=LASTTYPE + 1; break;
RandomFields/src/userinterfaces.cc:	    int which = Match((char*) CHAR(STRING_ELT(p, 0)), List, lenL);
RandomFields/src/userinterfaces.cc:	    cov->px[i] = (double*) MALLOC(sizeof(int));
RandomFields/src/userinterfaces.cc:	  if (isMatrix(p) || isVector(p)) {
RandomFields/src/userinterfaces.cc:	  if (isMatrix(p)) {
RandomFields/src/userinterfaces.cc:	    // Achtung isVector ist true falls isMatrix true
RandomFields/src/userinterfaces.cc:      bool emptyOK = EmptySubOK(covnr);//covnr == SCHLATHER || covnr == SMITH ||
RandomFields/src/userinterfaces.cc:	  while (call != NULL && MODELNR(call) != RFGET) //not CALLNR
RandomFields/src/userinterfaces.cc:	    ERR1("'%.100s' does not have enough submodels", NAME(cov));
RandomFields/src/userinterfaces.cc:	if (PL >= PL_IMPORTANT && !emptyOK)  {
RandomFields/src/userinterfaces.cc:	  if (global->general.naturalscaling == NATSCALE_MLE && isDollar(cov)) {
RandomFields/src/userinterfaces.cc:	    if (natsc) addModel(cov, j, NATSC_INTERN); 
RandomFields/src/userinterfaces.cc:	    addModel(cov, j, NATSC_USER);
RandomFields/src/userinterfaces.cc:} // CMbuild
RandomFields/src/userinterfaces.cc:model *CMbuild(SEXP Model, KEY_type *KT, int cR) {
RandomFields/src/userinterfaces.cc:  if (cR < 0 || cR >= MODEL_MAX) BUG;
RandomFields/src/userinterfaces.cc:  CMbuild(Model, 0, Cov, NULL, KT, NULL);
RandomFields/src/basic.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/basic.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/src/basic.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/basic.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/basic.h:#ifdef SCHLATHERS_MACHINE
RandomFields/src/basic.h:#undef SCHLATHERS_MACHINE
RandomFields/src/basic.h:#ifdef RANDOMFIELDS_DEBUGGING
RandomFields/src/basic.h:#undef RANDOMFIELDS_DEBUGGING
RandomFields/src/basic.h:#define MAXNRCOVFCTS 300
RandomFields/src/basic.h:#define MAXUNITSCHAR 10
RandomFields/src/basic.h:#define MAXINVERSIONS 2
RandomFields/src/KeyInfo.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/KeyInfo.cc: Copyright (C) 2001 -- 2017 Martin Schlather, 
RandomFields/src/KeyInfo.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/KeyInfo.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/KeyInfo.cc:// PMI/PMI0
RandomFields/src/KeyInfo.cc:bool PMI_print_dollar = !true,
RandomFields/src/KeyInfo.cc:  PMI_print_mpp = !true,
RandomFields/src/KeyInfo.cc:  PMI_print_pgs = !true, 
RandomFields/src/KeyInfo.cc:  PMI_print_details = !true,
RandomFields/src/KeyInfo.cc:  PMI_print_structure = true,
RandomFields/src/KeyInfo.cc:  PMI_print_loc = true,
RandomFields/src/KeyInfo.cc:  PMI_print_fields = true;
RandomFields/src/KeyInfo.cc:int  PMI_print_rect = 1;  // 0, 1, 2
RandomFields/src/KeyInfo.cc:int MAX_PMI = 5;
RandomFields/src/KeyInfo.cc:#define isInternalKappa(i) (!STRCMP(C->kappanames[i], INTERNAL_PARAM))
RandomFields/src/KeyInfo.cc:#define WHICH_USER_BUT_ONCE_JUMP 6
RandomFields/src/KeyInfo.cc:#define WHICH_INTERNAL_BUT_ONCE_JUMP 7
RandomFields/src/KeyInfo.cc:    which == WHICH_USER_BUT_ONCE_JUMP,
RandomFields/src/KeyInfo.cc:    which==WHICH_INTERNAL_BUT_ONCE_JUMP;
RandomFields/src/KeyInfo.cc:    if (which == WHICH_USER_BUT_ONCE_JUMP) ans = ans->sub[0];
RandomFields/src/KeyInfo.cc:    else if (which == WHICH_INTERNAL_BUT_ONCE_JUMP) ans = ans->key;
RandomFields/src/KeyInfo.cc:SEXP RedMat(double* V, int row, int col, bool drop) {
RandomFields/src/KeyInfo.cc:  return Mat(V, row, col);
RandomFields/src/KeyInfo.cc:SEXP RedMatInt(int* V, int row, int col, bool drop) {
RandomFields/src/KeyInfo.cc:  return MatInt(V, row, col);
RandomFields/src/KeyInfo.cc:      elmts = XLIST_RELEVANT_ELMTS;
RandomFields/src/KeyInfo.cc: 	SET_VECTOR_ELT(l, k++, RedMat(loc->x, loc->xdimOZ, dist_laenge,
RandomFields/src/KeyInfo.cc:	SET_VECTOR_ELT(l, k++, Mat(loc->xgr[0], 3,loc->spatialdim));
RandomFields/src/KeyInfo.cc:      else SET_VECTOR_ELT(l, k++, Mat(loc->x, loc->xdimOZ, loc->totalpoints));
RandomFields/src/KeyInfo.cc:	SET_VECTOR_ELT(l, k++,Mat(loc->grY[0], 3,loc->spatialdim));
RandomFields/src/KeyInfo.cc:      else SET_VECTOR_ELT(l, k++, Mat(loc->Y, loc->xdimOZ, loc->totalpointsY));
RandomFields/src/KeyInfo.cc:	SET_VECTOR_ELT(l, k++, RedMat(loc->x, loc->xdimOZ, dist_laenge,
RandomFields/src/KeyInfo.cc:	  SET_VECTOR_ELT(l, k++, Mat(loc->xgr[0], 3, loc->spatialdim));
RandomFields/src/KeyInfo.cc:	else SET_VECTOR_ELT(l, k++, Mat_t(loc->x, loc->totalpoints, loc->xdimOZ));
RandomFields/src/KeyInfo.cc:	    SET_VECTOR_ELT(l, k++,Mat(loc->grY[0], 3, loc->spatialdim));
RandomFields/src/KeyInfo.cc:	  else SET_VECTOR_ELT(l, k++, Mat(loc->Y, loc->xdimOZ, loc->totalpointsY));
RandomFields/src/KeyInfo.cc:  SET_VECTOR_ELT(l, k++, Mat(loc->xgr[0], loc->grid ? 3 : 0, spdim)); // "xgr"
RandomFields/src/KeyInfo.cc:    Mat(loc->x, loc->xdimOZ, 
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(l, k++, Mat(loc->grY[0], loc->gridY ? 3 : 0, spdim));
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(l, k++, Mat(loc->Y, loc->xdimOZ, loc->gridY ? 0 : loc->totalpointsY));
RandomFields/src/KeyInfo.cc:      return RedMat((double*) p, nrow, ncol, ncol==1 && drop);
RandomFields/src/KeyInfo.cc:      return RedMatInt((int*) p, nrow, ncol, ncol==1 && drop);
RandomFields/src/KeyInfo.cc:      return MatString((char**) p, nrow, ncol);
RandomFields/src/KeyInfo.cc:	  nr==VARIOGRAM2COV || nr==VAR2COV_PROC)
RandomFields/src/KeyInfo.cc:  //  printf("name = %s.%s %dx%d\n", NAME(cov),  DefList[COVNR].kappanames[i], cov->nrow[i], cov->ncol[i]);
RandomFields/src/KeyInfo.cc:#define nsimuMsg 3
RandomFields/src/KeyInfo.cc:  const char *Msg[nsimuMsg] = 
RandomFields/src/KeyInfo.cc:  PROTECT(l = allocVector(VECSXP, nsimuMsg));
RandomFields/src/KeyInfo.cc:  PROTECT(namevec = allocVector(STRSXP, nsimuMsg));
RandomFields/src/KeyInfo.cc:  for (k=0; k<nsimuMsg; k++)
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(namevec, k, mkChar(Msg[k]));
RandomFields/src/KeyInfo.cc:  assert(k==nsimuMsg); 
RandomFields/src/KeyInfo.cc:  assert(k == nsimuMsg);
RandomFields/src/KeyInfo.cc:SEXP IGetModelInfo(model *cov, int prlevel, bool both, int spConform, 
RandomFields/src/KeyInfo.cc:       muss auch GetModelInfo geaendert werden
RandomFields/src/KeyInfo.cc:  SEXP Model, submodels, nameMvec, param, pnames;
RandomFields/src/KeyInfo.cc:    param_ok[MAXPARAM + 1],
RandomFields/src/KeyInfo.cc:  PROTECT(Model = allocVector(VECSXP, nmodelinfo));
RandomFields/src/KeyInfo.cc:  PROTECT(nameMvec = allocVector(STRSXP, nmodelinfo));
RandomFields/src/KeyInfo.cc:  SET_STRING_ELT(nameMvec, k, mkChar("name"));
RandomFields/src/KeyInfo.cc:  while(STRNCMP(CC->name, InternalName, STRLEN(InternalName)) ==0) CC--;
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(Model, k++, mkString(CC->nick));
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(Model, k++, mkString(CC->name));
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar("coordinates")); 
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(Model, k++,
RandomFields/src/KeyInfo.cc:		   mkString(ISO_NAMES[CoordinateSystemOf(OWNISO(0))]));
RandomFields/src/KeyInfo.cc:			 IGetModelInfo(cov->kappasub[i], prlevel, both, 
RandomFields/src/KeyInfo.cc:	    *Aniso = (double*) MALLOC(cov->nrow[i] * cov->ncol[i] * 
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar(prlevel > 5 ? "submodels" : "param"));  
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(Model, k++, param);
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar("covnr"));
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(Model, k++, ScalarInteger(COVNR));
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar("vdim"));
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(Model, k++,  ScalarInteger(VDIM0)
RandomFields/src/KeyInfo.cc:		   // VDIM0 == VDIM1 
RandomFields/src/KeyInfo.cc:		   // ? ScalarInteger(VDIM0) 
RandomFields/src/KeyInfo.cc:    //  SET_STRING_ELT(nameMvec, k, mkChar("naturalscaling"));  
RandomFields/src/KeyInfo.cc:    //  SET_VECTOR_ELT(Model, k++, ScalarInteger(cov->naturalscaling));
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar("logicaldim"));  
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(Model, k++, ScalarInteger(OWNLOGDIM(0)));
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar("prev.xdim"));  
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(Model, k++, ScalarInteger(PREVXDIM(0)));
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar("own.xdim"));  
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(Model, k++, ScalarInteger(OWNXDIM(0)));
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar("indep.of.x"));  
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(Model, k++, ScalarLogical(cov->matrix_indep_of_x));
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar("type"));  
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(Model, k++, Char(TYPE_NAMES + OWNTYPE(0), 1));
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar("frame"));  
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(Model, k++, Char(TYPE_NAMES + cov->frame, 1));
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar("domown"));  
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(Model, k++, mkString(DOMAIN_NAMES[OWNDOM(0)]));
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar("isoown"));
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(Model, k++, mkString(ISO_NAMES[OWNISO(0)]));
RandomFields/src/KeyInfo.cc:      SET_STRING_ELT(nameMvec, k, mkChar("isoprev"));
RandomFields/src/KeyInfo.cc:      SET_VECTOR_ELT(Model, k++, mkString(ISO_NAMES[PREVISO(0)]));
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar("internalq"));  
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(Model, k++, Num(cov->q, cov->qlen));
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar("storage"));
RandomFields/src/KeyInfo.cc:      int which = (VDIM0 > 1) * 2 + (CC->check != check_co);
RandomFields/src/KeyInfo.cc:	SET_STRING_ELT(namestorage, L, mkChar("MAX"));  
RandomFields/src/KeyInfo.cc:	SET_VECTOR_ELT(storage, L++, ScalarReal(S->intrinsic.MAX));
RandomFields/src/KeyInfo.cc:	SET_STRING_ELT(namestorage, L, mkChar("M"));  
RandomFields/src/KeyInfo.cc:	SET_VECTOR_ELT(storage, L++, ScalarReal(S->cube.M));
RandomFields/src/KeyInfo.cc:      SET_VECTOR_ELT(Model, k++, storage);
RandomFields/src/KeyInfo.cc:    } else SET_VECTOR_ELT(Model, k++, allocVector(VECSXP, 0));
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar("pref"));  
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(Model, k++, Int(cov->pref, Nothing + 1));
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar("simu"));  
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(Model, k++, GetSimuInfo(&(cov->simu)));
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar("loc"));
RandomFields/src/KeyInfo.cc:      SET_VECTOR_ELT(Model, k++, GetLocationInfo(loc));
RandomFields/src/KeyInfo.cc:      SET_VECTOR_ELT(Model, k++,
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar("logspeed"));
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(Model, k++, ScalarReal(cov->logspeed));
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar("maxdim"));  
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(Model, k++, ScalarInteger(MAXDIM(OWN, 0)));
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar("full_derivs"));  
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(Model, k++, ScalarInteger(cov->full_derivs));
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar("loggiven"));  
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(Model, k++, ScalarLogical(cov->loggiven));
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar("monotone"));  
RandomFields/src/KeyInfo.cc:    int idx = cov->monotone - (int) MON_UNSET;
RandomFields/src/KeyInfo.cc:    if (idx < 0 || idx > BERNSTEIN - (int) MON_UNSET) {
RandomFields/src/KeyInfo.cc:      PRINTF("monotone %d %d %d\n",  cov->monotone,  MON_UNSET,
RandomFields/src/KeyInfo.cc:	     cov->monotone - (int) MON_UNSET);
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(Model, k++, Char(MONOTONE_NAMES + idx, 1));
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar("finiterange"));  
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(Model, k++, ScalarExtendedLogical(cov->finiterange));
RandomFields/src/KeyInfo.cc:    mpp_properties *Mpp = &(cov->mpp);
RandomFields/src/KeyInfo.cc:      vdim = VDIM0,
RandomFields/src/KeyInfo.cc:    //   SET_STRING_ELT(nameMvec, k, mkChar("mpp.refradius"));  
RandomFields/src/KeyInfo.cc:    //  SET_VECTOR_ELT(Model, k++, ScalarReal(mpp->refradius));
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar("mpp.maxheight"));  
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(Model, k++, Num(Mpp->maxheights, vdim));
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar("mpp.M"));
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k+1, mkChar("mpp.Mplus"));
RandomFields/src/KeyInfo.cc:      SET_VECTOR_ELT(Model, k++, R_NilValue); 
RandomFields/src/KeyInfo.cc:      SET_VECTOR_ELT(Model, k++, R_NilValue);
RandomFields/src/KeyInfo.cc:      SET_VECTOR_ELT(Model, k++, Num(Mpp->mM, nmvdim)); 
RandomFields/src/KeyInfo.cc:      SET_VECTOR_ELT(Model, k++, Num(Mpp->mMplus, nmvdim));
RandomFields/src/KeyInfo.cc:      SET_STRING_ELT(nameMvec, k, mkChar("internal"));  
RandomFields/src/KeyInfo.cc:      SET_VECTOR_ELT(Model, k++,
RandomFields/src/KeyInfo.cc:		     IGetModelInfo(cov->key, prlevel, both, spConform,
RandomFields/src/KeyInfo.cc:    } else if (cov->Smodel != NULL) {  /// COVNR == PLUS / M 
RandomFields/src/KeyInfo.cc:      GETSTOMODEL;
RandomFields/src/KeyInfo.cc:      SET_STRING_ELT(nameMvec, k, mkChar("internal"));  
RandomFields/src/KeyInfo.cc:      for (ii=n=0; ii<subs; ii++) if (STOMODEL->keys[ii] != NULL) n++;
RandomFields/src/KeyInfo.cc:	if (STOMODEL->keys[ii] != NULL)
RandomFields/src/KeyInfo.cc:			 IGetModelInfo(STOMODEL->keys[ii], prlevel, both,
RandomFields/src/KeyInfo.cc:      SET_VECTOR_ELT(Model, k++, keys);
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar("submodels"));  
RandomFields/src/KeyInfo.cc:    for (i=0; i<MAXSUB; i++) {
RandomFields/src/KeyInfo.cc:		       IGetModelInfo(cov->sub[i], prlevel, both, spConform, 
RandomFields/src/KeyInfo.cc:    SET_VECTOR_ELT(Model, k++, submodels);
RandomFields/src/KeyInfo.cc:  setAttrib(Model, R_NamesSymbol, nameMvec);
RandomFields/src/KeyInfo.cc:  UNPROTECT(2); // model + nameModelvec
RandomFields/src/KeyInfo.cc:  return Model;
RandomFields/src/KeyInfo.cc:SEXP GetModelInfo(SEXP keynr, SEXP Prlevel, SEXP spConform, SEXP whichSub,
RandomFields/src/KeyInfo.cc:  if (knr>=0 && knr <= MODEL_MAX && key[knr] != NULL) {
RandomFields/src/KeyInfo.cc:    PROTECT(res = IGetModelInfo(cov, prlevel, both,
RandomFields/src/KeyInfo.cc:	if (STRCMP("prev.xdim", name) == 0) {
RandomFields/src/KeyInfo.cc:	  INTEGER(VECTOR_ELT(res, i))[0] = XDIM(PREVSYSOF(orig), 0);
RandomFields/src/KeyInfo.cc:    GETSTOMODEL;
RandomFields/src/KeyInfo.cc:      if (STOMODEL->keys[i] == sub) {
RandomFields/src/KeyInfo.cc:    if (endfor > MAX_PMI) endfor = MAX_PMI;
RandomFields/src/KeyInfo.cc:void PRINTMAX(double *a, int n, int max) {
RandomFields/src/KeyInfo.cc:void PRINTMAX(int *a, int n, int max) {
RandomFields/src/KeyInfo.cc:#define TREE_MAXSTORAGE 20
RandomFields/src/KeyInfo.cc:int getroot(model *root, model *storage[TREE_MAXSTORAGE]) {
RandomFields/src/KeyInfo.cc:    if (n >= TREE_MAXSTORAGE) BUG;
RandomFields/src/KeyInfo.cc:	 int stor_level, model *storage[TREE_MAXSTORAGE]) {    
RandomFields/src/KeyInfo.cc:#define MNlength 4
RandomFields/src/KeyInfo.cc:  char MN[Forbidden + 1][MNlength], name[100];
RandomFields/src/KeyInfo.cc:  //printf("storage=%d %s %s \n", stor_level,NAME(storage[stor_level]),NAME(cov));
RandomFields/src/KeyInfo.cc:    leer(level); PRINTF("'%s' [%d] left out\n", NAME(cov), cov->zaehler);
RandomFields/src/KeyInfo.cc:    strcopyN(MN[i], METHOD_NAMES[i], MNlength);
RandomFields/src/KeyInfo.cc:  while(STRCMP(CC->name, InternalName) ==0) CC--;
RandomFields/src/KeyInfo.cc:	if (endfor > MAX_PMI) endfor = MAX_PMI;
RandomFields/src/KeyInfo.cc:	    if (endfor > MAX_PMI) endfor = MAX_PMI;
RandomFields/src/KeyInfo.cc:	    if (endfor > MAX_PMI) endfor = MAX_PMI;
RandomFields/src/KeyInfo.cc:	  if (ende > MAX_PMI) { PRINTF("..."); }
RandomFields/src/KeyInfo.cc:	PRINTF("%s (%d)'s kappatype(%d) = %d\n", NAME(cov), COVNR, i,
RandomFields/src/KeyInfo.cc:      if (C->kappatype[i] < LISTOF && size > MAX_PMI) { PRINTF(" ..."); }
RandomFields/src/KeyInfo.cc:    GETSTOMODEL;
RandomFields/src/KeyInfo.cc:    model *from = STOMODEL->remote;
RandomFields/src/KeyInfo.cc:    int which = (VDIM0 > 1) * 2 + (CC->check != check_co);
RandomFields/src/KeyInfo.cc:      leer(level + 1);PRINTF("%-10s %g %g %g %g\n", "MAX",
RandomFields/src/KeyInfo.cc:			     q[0].intrinsic.MAX, q[1].intrinsic.MAX,
RandomFields/src/KeyInfo.cc:			     q[2].intrinsic.MAX, q[3].intrinsic.MAX);
RandomFields/src/KeyInfo.cc:      leer(level + 1);PRINTF("%-10s %g %g %g %g\n", "M",
RandomFields/src/KeyInfo.cc:			     q[0].cube.M, q[1].cube.M, q[2].cube.M,q[3].cube.M);
RandomFields/src/KeyInfo.cc:      printf("%.50s SlocalCE->q2 = %d\n", NAME(cov), which); // ok
RandomFields/src/KeyInfo.cc:    endfor = cov->qlen; if (endfor > MAX_PMI) endfor = MAX_PMI;
RandomFields/src/KeyInfo.cc:  if (level == 0 || PMI_print_structure) {
RandomFields/src/KeyInfo.cc:	    NAME(cov->root), cov->root->zaehler,
RandomFields/src/KeyInfo.cc:  if (PMI_print_structure){
RandomFields/src/KeyInfo.cc:  // ACHTUNG: NICHT DIE ABKUERZUNGEN PREVDOM ETC VERWENDEN, DA HIER
RandomFields/src/KeyInfo.cc:  // KEIN PLAUSIBILITAETS C H E C K   GEMACHT WERDEN SOLL
RandomFields/src/KeyInfo.cc:  p = (int) DOMi(PREV[0]); // OK
RandomFields/src/KeyInfo.cc:  g = (int) DOMi(GATTER[0]); // OK
RandomFields/src/KeyInfo.cc:  o = (int) DOMi(OWN[0]); // OK
RandomFields/src/KeyInfo.cc:		      DOMAIN_NAMES[(int) p],
RandomFields/src/KeyInfo.cc:		      p == g ? DITO : DOMAIN_NAMES[(int) g], 
RandomFields/src/KeyInfo.cc:		      o == g ? DITO : DOMAIN_NAMES[(int) o]);
RandomFields/src/KeyInfo.cc:		      ISO_NAMES[p],
RandomFields/src/KeyInfo.cc:		      p == g ? DITO : ISO_NAMES[g],
RandomFields/src/KeyInfo.cc:		      o == g ? DITO : ISO_NAMES[o]);
RandomFields/src/KeyInfo.cc:  p = (int) XDIMi(PREV[0]); // OK
RandomFields/src/KeyInfo.cc:  g = (int) XDIMi(GATTER[0]); // OK
RandomFields/src/KeyInfo.cc:  o = (int) XDIMi(OWN[0]); // OK
RandomFields/src/KeyInfo.cc:  int lp = (int) LOGDIMi(PREV[0]), // OK
RandomFields/src/KeyInfo.cc:    lg = (int) LOGDIMi(GATTER[0]), // OK
RandomFields/src/KeyInfo.cc:    lo = (int) LOGDIMi(OWN[0]); // OK
RandomFields/src/KeyInfo.cc:		      lp, lg, lo, p, g, o, VDIM0, VDIM1);  // OK
RandomFields/src/KeyInfo.cc:  if (PMI_print_structure) {
RandomFields/src/KeyInfo.cc:    o = (int) MAXDIMi(OWN[0]); // OK
RandomFields/src/KeyInfo.cc:		      TYPE_NAMES[p],
RandomFields/src/KeyInfo.cc:		      p == g ? DITO : TYPE_NAMES[g],
RandomFields/src/KeyInfo.cc:		      o == g ? DITO : TYPE_NAMES[o]);
RandomFields/src/KeyInfo.cc:  leer(level); PRINTF("%-10s %s\n","frame", TYPE_NAMES[cov->frame]);
RandomFields/src/KeyInfo.cc:  if (PMI_print_details) {
RandomFields/src/KeyInfo.cc:    int idx = cov->monotone - (int) MON_UNSET;
RandomFields/src/KeyInfo.cc:    if (idx < 0 || idx > BERNSTEIN - (int) MON_UNSET) {
RandomFields/src/KeyInfo.cc:      PRINTF("monotone %d %d %d\n",  cov->monotone,  MON_UNSET,
RandomFields/src/KeyInfo.cc:	     cov->monotone - (int) MON_UNSET);
RandomFields/src/KeyInfo.cc:			MONOTONE_NAMES[idx], cov->monotone);  
RandomFields/src/KeyInfo.cc:			POSITIVITY_NAMES[cov->ptwise_definite],
RandomFields/src/KeyInfo.cc:			TriNames[cov->finiterange - MISMATCH]);
RandomFields/src/KeyInfo.cc:  if (PMI_print_fields) {
RandomFields/src/KeyInfo.cc:    leer(level); PRINTF("%-10s %s\n","method", METHOD_NAMES[cov->method]);
RandomFields/src/KeyInfo.cc:    for (i=0; i<=Sequential; i++) PRINTF("%s:%d ", MN[i], (int) cov->pref[i]);
RandomFields/src/KeyInfo.cc:    for (; i<=Nothing; i++) PRINTF("%s:%d ", MN[i], (int) cov->pref[i]);
RandomFields/src/KeyInfo.cc:    for (i=0; i<=Sequential; i++) PRINTF("%s:%d ", MN[i], (int) C->pref[i]);
RandomFields/src/KeyInfo.cc:    for (; i<=Nothing; i++) PRINTF("%s:%d ", MN[i], (int) C->pref[i]);
RandomFields/src/KeyInfo.cc:  if (PMI_print_dollar && cov->Sdollar != NULL) {
RandomFields/src/KeyInfo.cc:  if (PMI_print_details) {
RandomFields/src/KeyInfo.cc:      else PRINTMAX(s->a1, s->n_##a1, 10)
RandomFields/src/KeyInfo.cc:  if (PMI_print_mpp) {
RandomFields/src/KeyInfo.cc:      vdim = VDIM0,
RandomFields/src/KeyInfo.cc:      int maxv = MIN(vdim, MAXMPPVDIM);
RandomFields/src/KeyInfo.cc:    leer(level); PRINTF("%-10s ","mpp:M+");
RandomFields/src/KeyInfo.cc:    if (cov->mpp.mMplus == NULL) 
RandomFields/src/KeyInfo.cc:      for (int i=0; i<nmvdim; i++) PRINTF("%g, ", cov->mpp.mMplus[i]);
RandomFields/src/KeyInfo.cc:    leer(level); PRINTF("%-10s ","mpp:M");
RandomFields/src/KeyInfo.cc:    if (cov->mpp.mM == NULL) {
RandomFields/src/KeyInfo.cc:      for (int i=0; i<nmvdim; i++)  PRINTF("%g, ", cov->mpp.mM[i]);
RandomFields/src/KeyInfo.cc:  if (PMI_print_pgs) {
RandomFields/src/KeyInfo.cc:	dim = OWNTOTALXDIM;
RandomFields/src/KeyInfo.cc:	  GETSTOMODEL;
RandomFields/src/KeyInfo.cc:	  PRINTF("%-10s %s [%d]\n","pgs:cov", Nick(STOMODEL->cov),
RandomFields/src/KeyInfo.cc:		 STOMODEL->cov->zaehler);
RandomFields/src/KeyInfo.cc:  if (PMI_print_rect) {
RandomFields/src/KeyInfo.cc:      if (PMI_print_rect > 1 && r->value != NULL) {
RandomFields/src/KeyInfo.cc:  if (PMI_print_loc) {
RandomFields/src/KeyInfo.cc:	  PRINTF("%-10s (%d)\n", "loc:MISMATCH", addressbits(prevloc));
RandomFields/src/KeyInfo.cc:    GETSTOMODEL;
RandomFields/src/KeyInfo.cc:	model *key = STOMODEL->keys[i];
RandomFields/src/KeyInfo.cc:  model *storage[TREE_MAXSTORAGE];
RandomFields/src/KeyInfo.cc:void iexplDollar(model *cov, bool MLEnatsc_only) {
RandomFields/src/KeyInfo.cc:    (COVNR == NATSC_INTERN || (COVNR == NATSC_USER && !MLEnatsc_only));
RandomFields/src/KeyInfo.cc:    p = PARAM(dollar, DSCALE);
RandomFields/src/KeyInfo.cc:       p = PARAM(dollar, DANISO);      
RandomFields/src/KeyInfo.cc:    for (int i=0; i<MAXSUB; i++) { // cov->sub[i]: luecken erlaubt bei PSgen !
RandomFields/src/KeyInfo.cc:      if (cov->sub[i] != NULL) iexplDollar(cov->sub[i], MLEnatsc_only);
RandomFields/src/KeyInfo.cc:SEXP IGetModel(model *cov, int modus, int C_conform, bool solveRandom,
RandomFields/src/KeyInfo.cc:  //  AS_SAVED : Modell wie gespeichert
RandomFields/src/KeyInfo.cc:  //  DEL_NATSC : Modell unter Annahme PracticalRange>0 (natsc werden geloescht)
RandomFields/src/KeyInfo.cc:  //  DEL_MLE : nur natscale_MLE werden geloescht
RandomFields/src/KeyInfo.cc:  //  SOLVE_MLE : nur natscale_MLE  zusammengezogen (natsc werden
RandomFields/src/KeyInfo.cc:  SEXP Model, nameMvec;
RandomFields/src/KeyInfo.cc:  bool ok[MAXPARAM];
RandomFields/src/KeyInfo.cc:  if ((COVNR == NATSC_INTERN && modus != GETMODEL_AS_SAVED) ||
RandomFields/src/KeyInfo.cc:      (COVNR == NATSC_USER && modus == GETMODEL_DEL_NATSC)) { 
RandomFields/src/KeyInfo.cc:    return IGetModel(cov->sub[0], modus, C_conform, solveRandom, whichparam,
RandomFields/src/KeyInfo.cc:   for (i=0; i<MAXSUB; i++) {
RandomFields/src/KeyInfo.cc:     if (cov->sub[i] != NULL //&& MODELNR(cov->sub[i]) != IDCOORD
RandomFields/src/KeyInfo.cc:    ok[i] = !PisNULL(i) && whichparam != NOPARAMETERS;
RandomFields/src/KeyInfo.cc:    ok[i] = whichparam == ALLPARAMETERS ||
RandomFields/src/KeyInfo.cc:       (sort <= LASTUSERSORTOF || sort == IGNOREPARAM)) ||
RandomFields/src/KeyInfo.cc:      (whichparam == INTERNALPARAMETERS && isInternalKappa(i));
RandomFields/src/KeyInfo.cc:  PROTECT(Model = allocVector(VECSXP, nmodelinfo));
RandomFields/src/KeyInfo.cc:  PROTECT(nameMvec = allocVector(STRSXP, nmodelinfo));
RandomFields/src/KeyInfo.cc:  SET_STRING_ELT(nameMvec, k, mkChar("")); // name
RandomFields/src/KeyInfo.cc:   while(STRNCMP(CC->name, InternalName, STRLEN(InternalName)) ==0) CC--;
RandomFields/src/KeyInfo.cc:   SET_VECTOR_ELT(Model, k++, mkString(CC->nick));
RandomFields/src/KeyInfo.cc:   //   if (C_conform >= 1) { SET_VECTOR_ELT(Model, k++, mkString(CC->nick));
RandomFields/src/KeyInfo.cc:   // } else {  SET_VECTOR_ELT(Model, k++, mkString(CC->name)); }
RandomFields/src/KeyInfo.cc:      SET_STRING_ELT(nameMvec, k, mkChar(OWNKAPPA(C, i)));
RandomFields/src/KeyInfo.cc:      SET_VECTOR_ELT(Model, k++,
RandomFields/src/KeyInfo.cc:		     IGetModel(cov->kappasub[i], modus, C_conform, solveRandom,
RandomFields/src/KeyInfo.cc:    SET_STRING_ELT(nameMvec, k, mkChar(OWNKAPPA(C, i)));    
RandomFields/src/KeyInfo.cc:      int value = MISMATCH;
RandomFields/src/KeyInfo.cc:      SET_VECTOR_ELT(Model, k++, 
RandomFields/src/KeyInfo.cc:    } else if (C->kappaParamType[i] == MixedInputType &&
RandomFields/src/KeyInfo.cc:      int value = MISMATCH;
RandomFields/src/KeyInfo.cc:      SET_VECTOR_ELT(Model, k++, 
RandomFields/src/KeyInfo.cc:      SET_VECTOR_ELT(Model, k++, 
RandomFields/src/KeyInfo.cc:			   LIST_OF_NAMES[C->kappaParamType[i] - NN1] + P0INT(i),
RandomFields/src/KeyInfo.cc:      SET_VECTOR_ELT(Model, k++,
RandomFields/src/KeyInfo.cc:  for (i=0; i<MAXSUB; i++) {
RandomFields/src/KeyInfo.cc:    if (cov->sub[i] != NULL // && MODELNR(cov->sub[i]) != IDCOORD
RandomFields/src/KeyInfo.cc:      SET_STRING_ELT(nameMvec, k, mkChar(C->subnames[i]));
RandomFields/src/KeyInfo.cc:      SET_VECTOR_ELT(Model, k++, IGetModel(cov->sub[i], modus, C_conform, 
RandomFields/src/KeyInfo.cc:  setAttrib(Model, R_NamesSymbol, nameMvec);
RandomFields/src/KeyInfo.cc:  return Model;
RandomFields/src/KeyInfo.cc:SEXP GetModel(SEXP keynr, SEXP Modus, SEXP SpConform, SEXP whichSub, 
RandomFields/src/KeyInfo.cc:  //  AS_SAVED : Modell wie gespeichert
RandomFields/src/KeyInfo.cc:  //  DEL_NATSC : Modell unter Annahme PracticalRange>0 (natsc werden geloescht)
RandomFields/src/KeyInfo.cc:  //  DEL_MLE : nur natscale_MLE werden geloescht
RandomFields/src/KeyInfo.cc:  //  SOLVE_MLE : nur natscale_MLE  zusammengezogen (natsc werden
RandomFields/src/KeyInfo.cc:// Nutzer kann 3 Modifikationen des Models in MLE laufen lassen:
RandomFields/src/KeyInfo.cc:    modus = INTEGER(Modus)[0],
RandomFields/src/KeyInfo.cc:  if (knr < 0 || knr  > MODEL_MAX || key[knr] == NULL) XERR(ERRORREGISTER);
RandomFields/src/KeyInfo.cc:  if (modus == GETMODEL_DEL_NATSC || modus == GETMODEL_DEL_MLE)
RandomFields/src/KeyInfo.cc:    return IGetModel(cov, modus, C_conform, solveRandom,
RandomFields/src/KeyInfo.cc:  iexplDollar(dummy, modus == GETMODEL_SOLVE_MLE);
RandomFields/src/KeyInfo.cc:  if (modus == GETMODEL_SOLVE_NATSC) {
RandomFields/src/KeyInfo.cc:    modus = GETMODEL_DEL_NATSC;
RandomFields/src/KeyInfo.cc:  } else if (modus == GETMODEL_SOLVE_MLE) {
RandomFields/src/KeyInfo.cc:    modus = GETMODEL_DEL_MLE;
RandomFields/src/KeyInfo.cc:  PROTECT(value = IGetModel(dummy, modus, C_conform, solveRandom,
RandomFields/src/KeyInfo.cc:  PRINTF("  %s\n", NAME(cov));
RandomFields/src/KeyInfo.cc:  int dim = OWNLOGDIM(0);
RandomFields/src/KeyInfo.cc:	   s, LASTi(sys[s]), NRi(sys[s]), LOGDIMi(sys[s]), XDIMi(sys[s]), // OK
RandomFields/src/KeyInfo.cc:	   nl1[earlybreak], MAXDIMi(sys[s]),  // OK
RandomFields/src/KeyInfo.cc:	   CUMXMITi(sys[s]), nl2[earlybreak], // OK
RandomFields/src/KeyInfo.cc:	   TYPEi(sys[s]), TYPE_NAMES[TYPEi(sys[s])],  // OK
RandomFields/src/KeyInfo.cc:	   DOMi(sys[s]), DOMAIN_NAMES[DOMi(sys[s])],  // OK
RandomFields/src/KeyInfo.cc:	   ISOi(sys[s]), ISO_NAMES[ISOi(sys[s])]); // OK
RandomFields/src/KeyInfo.cc:    PRINTF("%s:%d ", METHOD_NAMES[i], C->pref[i]);
RandomFields/src/KeyInfo.cc:    PRINTF("type=%d (%s) ", s->type, TYPE_NAMES[s->type]);
RandomFields/src/KeyInfo.cc:    PRINTF("dom=%d (%s) ", s->dom, DOMAIN_NAMES[s->dom]);
RandomFields/src/KeyInfo.cc:	  model *storage[TREE_MAXSTORAGE], int n, bool alle) {
RandomFields/src/KeyInfo.cc:  while(STRCMP(CC->name, InternalName) ==0) CC--;
RandomFields/src/KeyInfo.cc:    PRINTF(";%d%d,%d%d", CONDPREVDOM(0), CONDPREVISO(0),
RandomFields/src/KeyInfo.cc:	   CONDOWNDOM(0), CONDOWNISO(0));
RandomFields/src/KeyInfo.cc:      GETSTOMODEL;
RandomFields/src/KeyInfo.cc:      for (int i=0; i < MAXSUB; i++)
RandomFields/src/KeyInfo.cc:  	if ((further = STOMODEL->keys[i] != NULL)) break;
RandomFields/src/KeyInfo.cc:  //  printf("%s %d %d %d\n", NAME(cov), Splus_given, all_subs, cov->Smodel != NULL);
RandomFields/src/KeyInfo.cc:    GETSTOMODEL;
RandomFields/src/KeyInfo.cc:      model *key = STOMODEL->keys[i];
RandomFields/src/KeyInfo.cc:	  PRINTF("%s(%d) -> %s(%d)\n", NAME(cov), cov->zaehler,
RandomFields/src/KeyInfo.cc:		 NAME(cov->sub[i]), (cov->sub[i]->zaehler)); // crash();
RandomFields/src/KeyInfo.cc:  model *storage[TREE_MAXSTORAGE];
RandomFields/src/KeyInfo.cc:    //    printf("%s found = %d all_subs=%d\n", NAME(cov),
RandomFields/src/KeyInfo.cc:    //    PMI(cov->calling);
RandomFields/src/KeyInfo.cc:  for (int i = (int) FIRST_DOMAIN; i<=(int) LAST_DOMAINUSER; i++) {
RandomFields/src/KeyInfo.cc:      PRINTF("%s, ", DOMAIN_NAMES[i]);
RandomFields/src/KeyInfo.cc:  PRINTF("'%s' allows ", NAME(cov));
RandomFields/src/KeyInfo.cc:      PRINTF("%s, ", ISO_NAMES[i]);
RandomFields/src/KeyInfo.cc:  PRINTF("'%s' allows ", NAME(cov));
Binary file RandomFields/src/InternalCov.o matches
RandomFields/src/questions.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/questions.h: Copyright (C) 2015 -- 2017  Martin Schlather
RandomFields/src/questions.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/questions.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/questions.h:bool equalsDomMismatch(domain_type dom); 
RandomFields/src/questions.h:bool equalsPrevModelD(domain_type dom);
RandomFields/src/questions.h:bool isPrevModelD(domain_type dom);
RandomFields/src/questions.h:bool isPrevModelD(defn *C);
RandomFields/src/questions.h://bool equalsSubModelD(domain_type dom);
RandomFields/src/questions.h:bool isSubModelD(domain_type dom);
RandomFields/src/questions.h:bool isSubModelD(defn *C);
RandomFields/src/questions.h:bool equalsPrevModelI(isotropy_type iso); 
RandomFields/src/questions.h:bool isPrevModelI(isotropy_type iso); 
RandomFields/src/questions.h:bool isPrevModelI(defn *C);
RandomFields/src/questions.h://bool equalsSubModelI(isotropy_type iso); 
RandomFields/src/questions.h:bool isSubModelI(isotropy_type iso); 
RandomFields/src/questions.h:bool isSubModelI(defn *C);
RandomFields/src/questions.h:bool equalsSubModelI(isotropy_type iso);
RandomFields/src/questions.h:bool equalsIsoMismatch(isotropy_type iso);
RandomFields/src/questions.h:bool isMtimesep(matrix_type type);
RandomFields/src/questions.h:bool isMproj(matrix_type type);
RandomFields/src/questions.h:bool isMdiag(matrix_type type);
RandomFields/src/questions.h:bool isMiso(matrix_type type);
RandomFields/src/questions.h:bool isGaussMethod(Types type);
RandomFields/src/questions.h:bool isBrMethod(Types type);
RandomFields/src/questions.h:bool isMathDef(Types type);
RandomFields/src/questions.h:bool isManifold(Types type);
RandomFields/src/questions.h:bool isManifold(defn *C);
RandomFields/src/questions.h:bool isMathDef(defn *C);
RandomFields/src/questions.h:bool isGaussMethod(model *cov);
RandomFields/src/questions.h:bool isBrMethod(model *cov);
RandomFields/src/questions.h:bool isnowMaxStable(model *cov);
RandomFields/src/questions.h://bool isnowGaussMethod(model *cov);
RandomFields/src/questions.h://bool isnowManifold(model *cov);
RandomFields/src/questions.h://bool isnowMathDef(model *cov);
RandomFields/src/questions.h:bool equalsnowGaussMethod(model *cov);
RandomFields/src/questions.h:bool equalsnowMathDef(model *cov);
RandomFields/src/questions.h:bool equalsGaussMethod(Types type);
RandomFields/src/questions.h:bool equalsBrMethod(Types type);
RandomFields/src/questions.h:bool equalsManifold(Types type);
RandomFields/src/questions.h:bool hasGaussMethodFrame(model *cov);
RandomFields/src/questions.h:bool hasBrMethodFrame(model *cov);
RandomFields/src/questions.h:bool hasMaxStableFrame(model *cov);
RandomFields/src/questions.h:bool isMonotone(model *cov);
RandomFields/src/questions.h:bool isMonotone(monotone_type montone);
RandomFields/src/questions.h:bool isNormalMixture(monotone_type montone);
RandomFields/src/questions.h:bool isNormalMixture(model *cov);
RandomFields/src/questions.h:bool isCompletelyMonotone(monotone_type monotone);
RandomFields/src/questions.h:bool isMtimesep(matrix_type type);
RandomFields/src/questions.h:bool isMproj(matrix_type type);
RandomFields/src/questions.h:bool isMdiag(matrix_type type);
RandomFields/src/questions.h:bool isMiso(matrix_type type);
RandomFields/src/questions.h:#define isPlus(cov) (MODELNR(cov) == PLUS)
RandomFields/src/questions.h:#define isMal(cov) (MODELNR(cov) == MULT)
RandomFields/src/questions.h:#define isConst(cov) (MODELNR(cov) == CONST)
RandomFields/src/questions.h:bool isPrevModelI(defn *C);
Binary file RandomFields/src/plusmal.o matches
RandomFields/src/primitive.cov.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/primitive.cov.cc: Copyright (C) 2001 -- 2003 Martin Schlather
RandomFields/src/primitive.cov.cc: Copyright (C) 2004 -- 2004 Yindeng Jiang & Martin Schlather
RandomFields/src/primitive.cov.cc: Copyright (C) 2005 -- 2017 Martin Schlather
RandomFields/src/primitive.cov.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/primitive.cov.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/primitive.cov.cc://#define LOG2 M_LN2
RandomFields/src/primitive.cov.cc: 80, RF_INF, // TBM
RandomFields/src/primitive.cov.cc: RF_NA, RF_NA, RF_NA,  // GMRF, ave, nugget
RandomFields/src/primitive.cov.cc:  if (OWNLOGDIM(0) > 2)
RandomFields/src/primitive.cov.cc:	li->msg[0] = li->msg[1] = MSGLOCAL_OK;
RandomFields/src/primitive.cov.cc:	  li->msg[0] =  MSGLOCAL_OK;
RandomFields/src/primitive.cov.cc:	    li->msg[0] =  MSGLOCAL_OK;
RandomFields/src/primitive.cov.cc:	      li->msg[0] = MSGLOCAL_JUSTTRY;
RandomFields/src/primitive.cov.cc:  //PMI(cov);
RandomFields/src/primitive.cov.cc:  ASSERT_GAUSS_METHOD(SpectralTBM);
RandomFields/src/primitive.cov.cc:  // Whenever TBM3Bessel exists, add further check against too small nu! 
RandomFields/src/primitive.cov.cc:  if (OWNLOGDIM(0)>2) cov->pref[SpectralTBM] = PREF_NONE; // do to d > 2 !
RandomFields/src/primitive.cov.cc:  set_maxdim(OWN, 0, ISNAN(dim) || dim >= INFDIM ? INFDIM : (int) dim);
RandomFields/src/primitive.cov.cc:    E12(s, OWNLOGDIM(0), nu > 0 ? SQRT(1.0 - POW(UNIFORM_RANDOM, 1/nu)) : 1, e);
RandomFields/src/primitive.cov.cc:    assert(OWNLOGDIM(0) == 1);
RandomFields/src/primitive.cov.cc:	A = 1.0 - POW(UNIFORM_RANDOM, 1.0 / ( P0(BESSEL_NU) + 0.5));
RandomFields/src/primitive.cov.cc:	if (UNIFORM_RANDOM <= POW(1 + A, nu - 0.5)) break;
RandomFields/src/primitive.cov.cc:  range->min[BESSEL_NU] = 0.5 * ((double) OWNLOGDIM(0) - 2.0);
RandomFields/src/primitive.cov.cc:  ASSERT_NEWMODEL_NOT_NULL;
RandomFields/src/primitive.cov.cc:      addModel(newmodel, BALL, cov);
RandomFields/src/primitive.cov.cc:      int owndim = OWNLOGDIM(0);
RandomFields/src/primitive.cov.cc:      addModelX(newmodel, FIRSTDOLLAR);
RandomFields/src/primitive.cov.cc:	addModelKappa(*newmodel, DSCALE, SCALESPHERICAL);
RandomFields/src/primitive.cov.cc:	kdefault(scale, SPHERIC_SPACEDIM, (double) owndim);
RandomFields/src/primitive.cov.cc:	kdefault(scale, SPHERIC_BALLDIM, (double) dim);
RandomFields/src/primitive.cov.cc:  case PoissonType : return addUnifModel(cov, 1.0, newmodel); // to do: felix
RandomFields/src/primitive.cov.cc:  case SmithType : return addUnifModel(cov, 1.0, newmodel);
RandomFields/src/primitive.cov.cc:#define DAGUM_BETA 0
RandomFields/src/primitive.cov.cc:#define DAGUM_GAMMA 1
RandomFields/src/primitive.cov.cc:#define DAGUM_BETAGAMMA 2
RandomFields/src/primitive.cov.cc:  double gamma = P0(DAGUM_GAMMA), 
RandomFields/src/primitive.cov.cc:    beta=P0(DAGUM_BETA);
RandomFields/src/primitive.cov.cc:  double gamma = P0(DAGUM_GAMMA), 
RandomFields/src/primitive.cov.cc:    beta=P0(DAGUM_BETA);
RandomFields/src/primitive.cov.cc:    gamma = P0(DAGUM_GAMMA), 
RandomFields/src/primitive.cov.cc:    beta=P0(DAGUM_BETA);
RandomFields/src/primitive.cov.cc:  if (PisNULL(DAGUM_GAMMA) || PisNULL(DAGUM_BETA))
RandomFields/src/primitive.cov.cc:    gamma = P0(DAGUM_GAMMA), 
RandomFields/src/primitive.cov.cc:    beta = P0(DAGUM_BETA);
RandomFields/src/primitive.cov.cc:  kdefault(cov, DAGUM_BETAGAMMA, beta/gamma);
RandomFields/src/primitive.cov.cc:  cov->monotone =  beta >= gamma ? MONOTONE 
RandomFields/src/primitive.cov.cc:    : gamma <= 1.0 ? COMPLETELY_MON
RandomFields/src/primitive.cov.cc:    : gamma <= 2.0 ? NORMAL_MIXTURE : MON_MISMATCH;
RandomFields/src/primitive.cov.cc:    gamma = P0(DAGUM_GAMMA), 
RandomFields/src/primitive.cov.cc:    beta = P0(DAGUM_BETA),
RandomFields/src/primitive.cov.cc:    betagamma = P0(DAGUM_BETAGAMMA);
RandomFields/src/primitive.cov.cc:      P(DAGUM_BETAGAMMA)[0] = 1.0;
RandomFields/src/primitive.cov.cc:    if (isna_gamma) P(DAGUM_GAMMA)[0] = beta / betagamma;
RandomFields/src/primitive.cov.cc:  range->min[DAGUM_BETA] = 0.0;
RandomFields/src/primitive.cov.cc:  range->max[DAGUM_BETA] = 1.0;
RandomFields/src/primitive.cov.cc:  range->pmin[DAGUM_BETA] = 0.01;
RandomFields/src/primitive.cov.cc:  range->pmax[DAGUM_BETA] = 1.0;
RandomFields/src/primitive.cov.cc:  range->openmin[DAGUM_BETA] = true;
RandomFields/src/primitive.cov.cc:  range->openmax[DAGUM_BETA] = false;
RandomFields/src/primitive.cov.cc:  range->min[DAGUM_GAMMA] = 0.0;
RandomFields/src/primitive.cov.cc:  range->max[DAGUM_GAMMA] = tcf ? 1.0 : 2.0;
RandomFields/src/primitive.cov.cc:  range->pmin[DAGUM_GAMMA] = 0.01;
RandomFields/src/primitive.cov.cc:  range->pmax[DAGUM_GAMMA] = range->max[DAGUM_GAMMA];
RandomFields/src/primitive.cov.cc:  range->openmin[DAGUM_GAMMA] = true;
RandomFields/src/primitive.cov.cc:  range->openmax[DAGUM_GAMMA] = tcf;
RandomFields/src/primitive.cov.cc:  range->min[DAGUM_BETAGAMMA] = 0.0;
RandomFields/src/primitive.cov.cc:  range->max[DAGUM_BETAGAMMA] = tcf ? 1.0 : RF_INF;
RandomFields/src/primitive.cov.cc:  range->pmin[DAGUM_BETAGAMMA] = 0.01;
RandomFields/src/primitive.cov.cc:  range->pmax[DAGUM_BETAGAMMA] = tcf ? 1.0 : 20.0;
RandomFields/src/primitive.cov.cc:  range->openmin[DAGUM_BETAGAMMA] = true;
RandomFields/src/primitive.cov.cc:  range->openmax[DAGUM_BETAGAMMA] = true;
RandomFields/src/primitive.cov.cc:#define DC_LAMBDA 0
RandomFields/src/primitive.cov.cc:  double y = *x, lambda = P0(DC_LAMBDA);
RandomFields/src/primitive.cov.cc:    lambda = P0(DC_LAMBDA);
RandomFields/src/primitive.cov.cc:  double y = *x, lambda = P0(DC_LAMBDA);
RandomFields/src/primitive.cov.cc:  int dim = INFDIM;
RandomFields/src/primitive.cov.cc:  if (!ISNAN(P0(DC_LAMBDA))) dim = (int) (PIHALF / ATAN(1.0 / P0(DC_LAMBDA)));
RandomFields/src/primitive.cov.cc:  int dim = OWNLOGDIM(0);
RandomFields/src/primitive.cov.cc:    range->min[DC_LAMBDA] = dim==1 ? 0 : dim==2 ? 1 : 1.7320508075688771932;
RandomFields/src/primitive.cov.cc:  else range->min[DC_LAMBDA] = 1.0 / TAN(PIHALF / dim); 
RandomFields/src/primitive.cov.cc:  range->max[DC_LAMBDA] = RF_INF;
RandomFields/src/primitive.cov.cc:  range->pmin[DC_LAMBDA] = range->min[DC_LAMBDA] +  1e-10;
RandomFields/src/primitive.cov.cc:  range->pmax[DC_LAMBDA] = 10;
RandomFields/src/primitive.cov.cc:  range->openmin[DC_LAMBDA] = false;
RandomFields/src/primitive.cov.cc:  range->openmax[DC_LAMBDA] = true;
RandomFields/src/primitive.cov.cc:      li->msg[0] = li->msg[1] = MSGLOCAL_OK;
RandomFields/src/primitive.cov.cc:          li->msg[0] =MSGLOCAL_OK;
RandomFields/src/primitive.cov.cc:              li->msg[0] = MSGLOCAL_OK;
RandomFields/src/primitive.cov.cc:              li->msg[0] = MSGLOCAL_JUSTTRY;
RandomFields/src/primitive.cov.cc:  int d = OWNLOGDIM(0);
RandomFields/src/primitive.cov.cc:      PRINTF("'%s' in '%s' equals %10g for '%s'=%10g\n", KNAME(LOCALLY_BROWN_C),
RandomFields/src/primitive.cov.cc:	     NICK(cov), QVALUE, KNAME(LOCALLY_BROWN_ALPHA), alpha);
RandomFields/src/primitive.cov.cc:  //PMI(cov);
RandomFields/src/primitive.cov.cc:  li->value[0] = (OWNLOGDIM(0) <= 2)
RandomFields/src/primitive.cov.cc:  li->msg[0] = OWNLOGDIM(0) <= 3 ? MSGLOCAL_OK : MSGLOCAL_JUSTTRY;
RandomFields/src/primitive.cov.cc:    mu=P0(GENGNEITING_MU),
RandomFields/src/primitive.cov.cc:// control thanks to http://calc101.com/webMathematica/derivatives.jsp#topdoit
RandomFields/src/primitive.cov.cc:    mu=P0(GENGNEITING_MU), 
RandomFields/src/primitive.cov.cc:    mu=P0(GENGNEITING_MU), 
RandomFields/src/primitive.cov.cc:  double mu=P0(GENGNEITING_MU), 
RandomFields/src/primitive.cov.cc:  set_maxdim(OWN, 0, ISNAN(dim) || dim >= INFDIM ? INFDIM : (int) dim);
RandomFields/src/primitive.cov.cc:  range->min[GENGNEITING_MU] = 0.5 * (double) OWNLOGDIM(0); 
RandomFields/src/primitive.cov.cc:  range->max[GENGNEITING_MU] =  RF_INF;
RandomFields/src/primitive.cov.cc:  range->pmin[GENGNEITING_MU] = range->min[GENGNEITING_MU];
RandomFields/src/primitive.cov.cc:  range->pmax[GENGNEITING_MU] = range->pmin[GENGNEITING_MU] + 10.0;
RandomFields/src/primitive.cov.cc:  range->openmin[GENGNEITING_MU] = false;
RandomFields/src/primitive.cov.cc:  range->openmax[GENGNEITING_MU] = true;
RandomFields/src/primitive.cov.cc:    Mu = P0(GNEITING_MU),
RandomFields/src/primitive.cov.cc:    nu = Mu + 0.5,
RandomFields/src/primitive.cov.cc:    *tildegamma = P(GNEITING_GAMMA), // 11,22,12
RandomFields/src/primitive.cov.cc:    *p_gamma = P(GNEITING_GAMMA),
RandomFields/src/primitive.cov.cc:      SERR7("if '%.50s'=1, then %.50s[2] must be greater than min(%.50s[1], %.50s[3]) / 2 if%.50s[1] and %.50s[3] differ and %.50s[1] otherwise.", KNAME(GNEITING_SRED),
RandomFields/src/primitive.cov.cc:	    KNAME(GNEITING_GAMMA), KNAME(GNEITING_GAMMA),
RandomFields/src/primitive.cov.cc:	    KNAME(GNEITING_GAMMA), KNAME(GNEITING_GAMMA), 
RandomFields/src/primitive.cov.cc:	    KNAME(GNEITING_GAMMA), KNAME(GNEITING_GAMMA));
RandomFields/src/primitive.cov.cc:    if (i==GNEITING_GAMMA || i==GNEITING_C) *nr=3 ;
RandomFields/src/primitive.cov.cc:    mu = P0(GNEITING_MU);
RandomFields/src/primitive.cov.cc:  // wegen ML aufruf immer neu berechnet
RandomFields/src/primitive.cov.cc:    P(GENGNEITING_MU)[0] = mu + S->gamma[i] + 1.0;
RandomFields/src/primitive.cov.cc:  P(GENGNEITING_MU)[0] = mu;
RandomFields/src/primitive.cov.cc:    mu = P0(GENGNEITING_MU);
RandomFields/src/primitive.cov.cc:    P(GENGNEITING_MU)[0] = mu + S->gamma[i] + 1.0;
RandomFields/src/primitive.cov.cc:  P(GENGNEITING_MU)[0] = mu;
RandomFields/src/primitive.cov.cc:    mu = P0(GENGNEITING_MU);
RandomFields/src/primitive.cov.cc:    P(GENGNEITING_MU)[0] = mu + S->gamma[i] + 1.0;
RandomFields/src/primitive.cov.cc:  P(GENGNEITING_MU)[0] = mu;
RandomFields/src/primitive.cov.cc:  if (PisNULL(GNEITING_MU)) QERRC(GNEITING_MU, "must be given.");
RandomFields/src/primitive.cov.cc:  if (PisNULL(GNEITING_GAMMA)) QERRC(GNEITING_GAMMA,"must be given.");
RandomFields/src/primitive.cov.cc:  int dim = 2.0 * P0(GENGNEITING_MU);
RandomFields/src/primitive.cov.cc:  set_maxdim(OWN, 0, ISNAN(dim) || dim >= INFDIM ? INFDIM : (int) dim);
RandomFields/src/primitive.cov.cc:  if (cov->Sbiwm == NULL) return UNKNOWNPARAM;
RandomFields/src/primitive.cov.cc:  case GNEITING_MU :    return CRITICALPARAM;
RandomFields/src/primitive.cov.cc:  case GNEITING_S :     return SCALEPARAM;
RandomFields/src/primitive.cov.cc:  case GNEITING_SRED :  return ANYPARAM;
RandomFields/src/primitive.cov.cc:  case GNEITING_GAMMA : return ANYPARAM;
RandomFields/src/primitive.cov.cc:    return S->cdiag_given || origin != original_model ? VARPARAM : IGNOREPARAM;
RandomFields/src/primitive.cov.cc:    return S->cdiag_given || origin != original_model ? ANYPARAM : IGNOREPARAM;
RandomFields/src/primitive.cov.cc:    return S->cdiag_given || origin == mle_conform ? IGNOREPARAM : ONLYRETURN;
RandomFields/src/primitive.cov.cc: // *mu = P0(GNEITING_MU], 
RandomFields/src/primitive.cov.cc:  range->min[GNEITING_MU] = 0.5 * (double) OWNLOGDIM(0); 
RandomFields/src/primitive.cov.cc:  range->max[GNEITING_MU] =  RF_INF;
RandomFields/src/primitive.cov.cc:  range->pmin[GNEITING_MU] = range->min[GNEITING_MU];
RandomFields/src/primitive.cov.cc:  range->pmax[GNEITING_MU] = range->pmin[GNEITING_MU] + 10.0;
RandomFields/src/primitive.cov.cc:  range->openmin[GNEITING_MU] = false;
RandomFields/src/primitive.cov.cc:  range->openmax[GNEITING_MU] = true;
RandomFields/src/primitive.cov.cc:  //   *gamma = P0(GNEITING_GAMMA], 
RandomFields/src/primitive.cov.cc:  range->min[GNEITING_GAMMA] = 0.0;
RandomFields/src/primitive.cov.cc:  range->max[GNEITING_GAMMA] = RF_INF;
RandomFields/src/primitive.cov.cc:  range->pmin[GNEITING_GAMMA] = 1e-5;
RandomFields/src/primitive.cov.cc:  range->pmax[GNEITING_GAMMA] = 100.0;
RandomFields/src/primitive.cov.cc:  range->openmin[GNEITING_GAMMA] = false;
RandomFields/src/primitive.cov.cc:  range->openmax[GNEITING_GAMMA] = true;
RandomFields/src/primitive.cov.cc:    kdefault(cov, GENGNEITING_MU, gneiting_origmu);
RandomFields/src/primitive.cov.cc:    kdefault(cov, GENGNEITING_MU, mu_gneiting);
RandomFields/src/primitive.cov.cc:#define CES_LAMBDA 1
RandomFields/src/primitive.cov.cc:      lambda=P0(CES_LAMBDA), 
RandomFields/src/primitive.cov.cc:   //   APMI(cov);
RandomFields/src/primitive.cov.cc:  range->min[CES_LAMBDA] = 0.0;
RandomFields/src/primitive.cov.cc:  range->max[CES_LAMBDA] = 2.0;
RandomFields/src/primitive.cov.cc:  range->pmin[CES_LAMBDA] = 1e-3;
RandomFields/src/primitive.cov.cc:  range->pmax[CES_LAMBDA] = 2.0;
RandomFields/src/primitive.cov.cc:  range->openmin[CES_LAMBDA] = true;
RandomFields/src/primitive.cov.cc:  range->openmax[CES_LAMBDA] = false;
RandomFields/src/primitive.cov.cc:    dim = OWNLOGDIM(0),
RandomFields/src/primitive.cov.cc:    rM23, r23,
RandomFields/src/primitive.cov.cc:  assert(dim == VDIM0 && dim == VDIM1);
RandomFields/src/primitive.cov.cc:  rM23 = onethird / r2; // r^-2 /3
RandomFields/src/primitive.cov.cc:      v[d++] -= rM23 * x[i] * x[j];
RandomFields/src/primitive.cov.cc:    if (ANYDIM != 3) SERR1("dim (%d) != 3", ANYDIM);
RandomFields/src/primitive.cov.cc:  range->max[LGD_ALPHA] = (OWNLOGDIM(0)==2) ? 0.5 : 1.0;
RandomFields/src/primitive.cov.cc:#define MULTIQUAD_DELTA 0
RandomFields/src/primitive.cov.cc:#define MULTIQUAD_TAU 1
RandomFields/src/primitive.cov.cc:#define MULTIQUAD_EPS 1e-7
RandomFields/src/primitive.cov.cc:  double delta = P0(MULTIQUAD_DELTA), // Auslesen der Parameter aus cov
RandomFields/src/primitive.cov.cc:    deltaM1 = delta - 1.0,
RandomFields/src/primitive.cov.cc:    tau = P0(MULTIQUAD_TAU); 
RandomFields/src/primitive.cov.cc:  *v = POW( deltaM1 * deltaM1 / (1.0 + delta * (delta - 2.0 * COS(y))), tau);
RandomFields/src/primitive.cov.cc:  range->min[MULTIQUAD_DELTA] = 0.0;  // true range
RandomFields/src/primitive.cov.cc:  range->max[MULTIQUAD_DELTA] = 1.0;   
RandomFields/src/primitive.cov.cc:  range->pmin[MULTIQUAD_DELTA] = MULTIQUAD_EPS; // practical range (assumed)
RandomFields/src/primitive.cov.cc:  range->pmax[MULTIQUAD_DELTA] = 1.0 - MULTIQUAD_EPS; 
RandomFields/src/primitive.cov.cc:  range->openmin[MULTIQUAD_DELTA] = true;  // lower endpoint included 
RandomFields/src/primitive.cov.cc:  range->openmax[MULTIQUAD_DELTA] = true; // upper endpoint excluded 
RandomFields/src/primitive.cov.cc:  range->min[MULTIQUAD_TAU] = 0;  // true range
RandomFields/src/primitive.cov.cc:  range->max[MULTIQUAD_TAU] = RF_INF;   
RandomFields/src/primitive.cov.cc:  range->pmin[MULTIQUAD_TAU] = 0.0001; // practical range (assumed)
RandomFields/src/primitive.cov.cc:  range->pmax[MULTIQUAD_TAU] = 500; 
RandomFields/src/primitive.cov.cc:  range->openmin[MULTIQUAD_TAU] = true;  // lower endpoint included 
RandomFields/src/primitive.cov.cc:  range->openmax[MULTIQUAD_TAU] = true; // upper endpoint excluded  
RandomFields/src/primitive.cov.cc:void TBM2power(double *x, INFO, model *cov, double *v){
RandomFields/src/primitive.cov.cc:  if (P0(POW_ALPHA) != 2.0) ERR("TBM2 of power only allowed for alpha=2");
RandomFields/src/primitive.cov.cc:  set_maxdim(OWN, 0, ISNAN(dim) || dim >= INFDIM ? INFDIM-1 : (int) dim);
RandomFields/src/primitive.cov.cc:  cov->monotone = alpha >= (double) ((OWNLOGDIM(0) / 2) + 1)
RandomFields/src/primitive.cov.cc:    ? COMPLETELY_MON : NORMAL_MIXTURE;
RandomFields/src/primitive.cov.cc:  if (OWNLOGDIM(0) == 1 && P0(POW_ALPHA) == 1)
RandomFields/src/primitive.cov.cc:      cov->mpp.mM[i] = cov->mpp.mMplus[i] = EXP(logB(x, y));
RandomFields/src/primitive.cov.cc:  else ERR1("'%.50s' isn't defined in required frame", NAME(cov));
RandomFields/src/primitive.cov.cc:  int dim = OWNLOGDIM(0);
RandomFields/src/primitive.cov.cc:void TBM2spherical(double *x, INFO, model VARIABLE_IS_NOT_USED *cov, double *v){
RandomFields/src/primitive.cov.cc:  int  dim = OWNLOGDIM(0);
RandomFields/src/primitive.cov.cc:      cov->mpp.mM[1] = cov->mpp.mMplus[1] =  
RandomFields/src/primitive.cov.cc:  else ILLEGAL_FRAME;
RandomFields/src/primitive.cov.cc:  *nr = (i == STEIN_NU) ? 1 : (i==STEIN_Z) ? OWNLOGDIM(0) - 1 : -1;
RandomFields/src/primitive.cov.cc:   dim = OWNLOGDIM(0),
RandomFields/src/primitive.cov.cc:    double bk[MATERN_NU_THRES];
RandomFields/src/primitive.cov.cc:    spatialdim=OWNLOGDIM(0) - 1;
RandomFields/src/primitive.cov.cc:  if (nu > MATERN_NU_THRES) SERR1("'nu'>%d is too large for precise returns",
RandomFields/src/primitive.cov.cc:				  MATERN_NU_THRES)
RandomFields/src/primitive.cov.cc:    SERR("currently, components of z cannot be estimated by MLE, so NA's are not allowed");
RandomFields/src/primitive.cov.cc:  double x2, wz, dWM, nu = P0(STEIN_NU), 
RandomFields/src/primitive.cov.cc:    dim = PREVLOGDIM(0),
RandomFields/src/primitive.cov.cc:  dWM = EXP(QVALUE2 - QVALUE3 * LOG(x2 + 1.0));
RandomFields/src/primitive.cov.cc:  return (1.0 + 2.0 * wz * x[spatialdim] + x2) * dWM
RandomFields/src/primitive.cov.cc:  int dim = PREVLOGDIM(0);
RandomFields/src/primitive.cov.cc:  QVALUE2 = QVALUE - lgammafn(nu +  0.5 * dim) - dim * M_LN_SQRT_PI;
RandomFields/src/primitive.cov.cc:  if (HAS_SPECTRAL_FRAME(cov)) {
RandomFields/src/primitive.cov.cc:  if (HAS_SPECTRAL_FRAME(cov)) {
RandomFields/src/primitive.cov.cc:    return (OWNLOGDIM(0) <= 2) ? NOERROR : ERRORFAILED;
RandomFields/src/primitive.cov.cc:  else ILLEGAL_FRAME;
RandomFields/src/primitive.cov.cc:  x = UNIFORM_RANDOM; 
RandomFields/src/primitive.cov.cc:  E12(s, PREVLOGDIM(0), SQRT(1.0 - x * x), e);
RandomFields/src/primitive.cov.cc:#define USER_DOM 1
RandomFields/src/primitive.cov.cc:#define USER_VDIM 3
RandomFields/src/primitive.cov.cc:    vdim = VDIM0 * VDIM1,
RandomFields/src/primitive.cov.cc:    n = OWNXDIM(0);
RandomFields/src/primitive.cov.cc:  if (i == USER_VDIM) *nr = SIZE_NOT_DETERMINED;
RandomFields/src/primitive.cov.cc:  if (i == USER_COORD) *nr=SIZE_NOT_DETERMINED;
RandomFields/src/primitive.cov.cc:  if (i == USER_BETA) *nr=*nc=SIZE_NOT_DETERMINED;
RandomFields/src/primitive.cov.cc:  kdefault(cov, USER_DOM, XONLY);
RandomFields/src/primitive.cov.cc:    else SERR1("type='%.50s' not allowed", TYPE_NAMES[type]);
RandomFields/src/primitive.cov.cc:    *dom = PINT(USER_DOM), 
RandomFields/src/primitive.cov.cc:    *vdim =PINT(USER_VDIM);
RandomFields/src/primitive.cov.cc:  if (OWNDOM(0) != (domain_type) *dom) 
RandomFields/src/primitive.cov.cc:	  DOMAIN_NAMES[OWNDOM(0)], DOMAIN_NAMES[*dom]);
RandomFields/src/primitive.cov.cc:	  ISO_NAMES[OWNISO(0)], ISO_NAMES[*iso]);
RandomFields/src/primitive.cov.cc:    if (vdim == NULL) kdefault(cov, USER_VDIM, nrow[USER_BETA]);
RandomFields/src/primitive.cov.cc:	    KNAME(USER_BETA), nrow[USER_BETA], KNAME(USER_VDIM), *vdim);
RandomFields/src/primitive.cov.cc:    VDIM0 = nrow[USER_BETA];
RandomFields/src/primitive.cov.cc:    VDIM1 = 1;
RandomFields/src/primitive.cov.cc:    if (PisNULL(USER_VDIM)) kdefault(cov, USER_VDIM, 1);  
RandomFields/src/primitive.cov.cc:    VDIM0 = P0INT(USER_VDIM);
RandomFields/src/primitive.cov.cc:    VDIM1 = cov->nrow[USER_VDIM] == 1 ? 1 : PINT(USER_VDIM)[1];
RandomFields/src/primitive.cov.cc:  if (cov->nrow[USER_VDIM] > 2) SERR1("'%.50s' must be a scalar or a vector of length 2", KNAME(USER_VDIM));
RandomFields/src/primitive.cov.cc:  if ((OWNXDIM(0) == 4 && !Loc(cov)->Time) || OWNXDIM(0) > 4)
RandomFields/src/primitive.cov.cc:      pref[TBM] = 5;
RandomFields/src/primitive.cov.cc:		     KNAME(USER_SND), KNAME(USER_FST));
RandomFields/src/primitive.cov.cc:	    KNAME(USER_SND), KNAME(USER_FST), KNAME(USER_FCTN));
RandomFields/src/primitive.cov.cc:  // A  PMI0(cov);
RandomFields/src/primitive.cov.cc:    dom = PisNULL(USER_DOM) ? DOMAIN_MISMATCH : (domain_type) P0INT(USER_DOM);
RandomFields/src/primitive.cov.cc:    iso = PisNULL(USER_ISO) ? ISO_MISMATCH : (isotropy_type) P0INT(USER_ISO);
RandomFields/src/primitive.cov.cc:  //    vdim = PisNULL(USER_VDIM) ? 0 : P0INT(USER_VDIM);
RandomFields/src/primitive.cov.cc:  set_system(OWN, 0, isFixed(previso) ? PREVLOGDIM(0) : xdim /* xdim only dummy! */,
RandomFields/src/primitive.cov.cc:  if (PisNULL(USER_DOM)) return allowedDtrue(cov);
RandomFields/src/primitive.cov.cc:  for (int i=FIRST_DOMAIN; i<LAST_DOMAINUSER; D[i++]=false);
RandomFields/src/primitive.cov.cc:  D[(domain_type) P0INT(USER_DOM)] = true;
RandomFields/src/primitive.cov.cc:  range->min[USER_DOM] = FIRST_DOMAIN;
RandomFields/src/primitive.cov.cc:  range->max[USER_DOM] = LAST_DOMAINUSER;
RandomFields/src/primitive.cov.cc:  range->pmin[USER_DOM] = FIRST_DOMAIN;
RandomFields/src/primitive.cov.cc:  range->pmax[USER_DOM] = LAST_DOMAINUSER;
RandomFields/src/primitive.cov.cc:  range->openmin[USER_DOM] = false;
RandomFields/src/primitive.cov.cc:  range->openmax[USER_DOM] = false;
RandomFields/src/primitive.cov.cc:  range->min[USER_VDIM] = 1;
RandomFields/src/primitive.cov.cc:  range->max[USER_VDIM] = INFDIM;
RandomFields/src/primitive.cov.cc:  range->pmin[USER_VDIM] = 1;
RandomFields/src/primitive.cov.cc:  range->pmax[USER_VDIM] = 10;
RandomFields/src/primitive.cov.cc:  range->openmin[USER_VDIM] = false;
RandomFields/src/primitive.cov.cc:  range->openmax[USER_VDIM] = true;
RandomFields/src/avltr_modified.cc:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
RandomFields/src/avltr_modified.cc:   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
RandomFields/src/avltr_modified.cc:   Internet, or as Ben Pfaff, 12167 Airport Rd, DeWitt MI 48820, USA
RandomFields/src/avltr_modified.cc:/* Martin Schlather: 21 October, 2011,
RandomFields/src/avltr_modified.cc:#define MINUS -1
RandomFields/src/avltr_modified.cc:   is owned by the caller, not by the AVL tree.  CMP is a order
RandomFields/src/avltr_modified.cc:   function for the data to be stored in the tree.  PARAM is arbitrary
RandomFields/src/avltr_modified.cc:      avltr_node *an[AVL_MAX_HEIGHT];	/* Stack A: nodes. */
RandomFields/src/avltr_modified.cc:      char ab[AVL_MAX_HEIGHT];		/* Stack A: bits. */
RandomFields/src/avltr_modified.cc:		  if (p->rtag == MINUS)
RandomFields/src/avltr_modified.cc:	  r->rtag = MINUS;
RandomFields/src/avltr_modified.cc:	  while (p->rtag == MINUS)
RandomFields/src/avltr_modified.cc:  avltr_node *an[AVL_MAX_HEIGHT];	/* Stack A: nodes. */
RandomFields/src/avltr_modified.cc:	/* T4.  Modified to visit HEAD after fully traversing the
RandomFields/src/avltr_modified.cc:	  q->rtag = MINUS;
RandomFields/src/avltr_modified.cc:  avltr_node *an[AVL_MAX_HEIGHT];	/* Stack A: nodes. */
RandomFields/src/avltr_modified.cc:  char ab[AVL_MAX_HEIGHT];		/* Stack A: bits. */
RandomFields/src/avltr_modified.cc:		if (p->rtag == MINUS)
RandomFields/src/avltr_modified.cc:	    if (p->rtag == MINUS)
RandomFields/src/avltr_modified.cc:   PARAM to WALK_FUNC.  */
RandomFields/src/avltr_modified.cc:      if (p->rtag == MINUS)
RandomFields/src/avltr_modified.cc:  if (p->rtag == MINUS)
RandomFields/src/avltr_modified.cc:/* Given ITEM, a pointer to a data item in TREE (or NULL), returns a
RandomFields/src/avltr_modified.cc:   if ITEM is the last item. */
RandomFields/src/avltr_modified.cc:  if (p->rtag == MINUS)
RandomFields/src/avltr_modified.cc:/* Search TREE for an item matching ITEM.  If found, returns a pointer
RandomFields/src/avltr_modified.cc:   to the address of the item.  If none is found, ITEM is inserted
RandomFields/src/avltr_modified.cc:   into the tree, and a pointer to the address of ITEM is returned.
RandomFields/src/avltr_modified.cc:      q->rtag = MINUS;
RandomFields/src/avltr_modified.cc:	      q->rtag = MINUS;
RandomFields/src/avltr_modified.cc:	  if (p->rtag == MINUS)
RandomFields/src/avltr_modified.cc:	  if (r->rtag == MINUS)
RandomFields/src/avltr_modified.cc:	      r->rtag = MINUS;
RandomFields/src/avltr_modified.cc:	      s->rtag = MINUS;
RandomFields/src/avltr_modified.cc:	      s->rtag = MINUS;
RandomFields/src/avltr_modified.cc:/* Search TREE for an item matching ITEM, and return a pointer to it
RandomFields/src/avltr_modified.cc:	  if (p->rtag == MINUS)
RandomFields/src/avltr_modified.cc:/* Search TREE for an item close to the value of ITEM, and return it.
RandomFields/src/avltr_modified.cc:	  if (p->rtag == MINUS)
RandomFields/src/avltr_modified.cc:/* Searches AVL tree TREE for an item matching ITEM.  If found, the
RandomFields/src/avltr_modified.cc:   to the caller.  If no item matching ITEM exists in the tree,
RandomFields/src/avltr_modified.cc:  avltr_node *pa[AVL_MAX_HEIGHT];	/* Stack P: Nodes. */
RandomFields/src/avltr_modified.cc:  unsigned char a[AVL_MAX_HEIGHT];	/* Stack P: Bits. */
RandomFields/src/avltr_modified.cc:    if (t->rtag == MINUS)
RandomFields/src/avltr_modified.cc:	    if (x->rtag == MINUS)
RandomFields/src/avltr_modified.cc:	      pa[k - 1]->rtag = MINUS;
RandomFields/src/avltr_modified.cc:		assert (s->rtag == MINUS);
RandomFields/src/avltr_modified.cc:	  if (s->rtag == MINUS || r->bal == 0)
RandomFields/src/avltr_modified.cc:		s->rtag = MINUS;
RandomFields/src/avltr_modified.cc:		  s->rtag = MINUS;
RandomFields/src/avltr_modified.cc:		r->rtag = MINUS;
RandomFields/src/avltr_modified.cc:	      if (p->rtag == MINUS)
RandomFields/src/avltr_modified.cc:/* Inserts ITEM into TREE.  Returns NULL if the item was inserted,
RandomFields/src/avltr_modified.cc:/* If ITEM does not exist in TREE, inserts it and returns NULL.  If a
RandomFields/src/avltr_modified.cc:   matching item does exist, it is replaced by ITEM and the item
RandomFields/src/avltr_modified.cc:/* Delete ITEM from TREE when you know that ITEM must be in TREE.  For
RandomFields/src/avltr_modified.cc:/* Compare two integers A and B and return a STRCMP()-type result. */
RandomFields/src/avltr_modified.cc:   root of the tree, PARENT should be INT_MIN, otherwise it should be
RandomFields/src/avltr_modified.cc:   it is not used if PARENT is INT_MIN.  Returns the height of the
RandomFields/src/avltr_modified.cc:	      Rprint (" Multiple threads to node %d.\n", d);
RandomFields/src/avltr_modified.cc:      if (parent != INT_MIN)
RandomFields/src/avltr_modified.cc:    recurse_tree (tree, tree->root.link[0], &count, INT_MIN, 0, nodes,
RandomFields/src/avltr_modified.cc:    int last = INT_MIN;
RandomFields/src/avltr_modified.cc:	    Rprint (" Misordered right threads.\n");
RandomFields/src/spectral.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/spectral.cc: Copyright (C) 2000 -- 2017 Martin Schlather, 
RandomFields/src/spectral.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/spectral.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/spectral.cc:#define SPECTRAL_LINES (COMMON_GAUSS + 1)
RandomFields/src/spectral.cc:#define SPECTRAL_GRID (COMMON_GAUSS + 2)
RandomFields/src/spectral.cc:#define SPECTRAL_METRO_FACTOR (COMMON_GAUSS + 3)
RandomFields/src/spectral.cc:#define SPECTRAL_SIGMA (COMMON_GAUSS + 4)
RandomFields/src/spectral.cc:  FRAME_ASSERT_GAUSS_INTERFACE;
RandomFields/src/spectral.cc:  // FRAME_ASSERT(GaussMethod);
RandomFields/src/spectral.cc:  kdefault(cov, SPECTRAL_LINES, gp->lines[OWNXDIM(0)]); // ok
RandomFields/src/spectral.cc:  kdefault(cov, SPECTRAL_METRO_FACTOR, gp->prop_factor);
RandomFields/src/spectral.cc:  kdefault(cov, SPECTRAL_SIGMA, gp->sigma); // ok
RandomFields/src/spectral.cc:  // APMI(cov);
RandomFields/src/spectral.cc:      if ((err2[i] = CHECK(next, OWNLOGDIM(0), OWNXDIM(0), 
RandomFields/src/spectral.cc:			   SUBMODEL_DEP, GaussMethodType)) == NOERROR) break;
RandomFields/src/spectral.cc:      //PMI(cov);    
RandomFields/src/spectral.cc:    if (//!hasGaussMethodFrame(cov) ||
RandomFields/src/spectral.cc:	sub->pref[SpectralTBM] == PREF_NONE) {
RandomFields/src/spectral.cc:      //APMI(cov);
RandomFields/src/spectral.cc:    // eventuell mit dazwischenliegenden RMS's
RandomFields/src/spectral.cc:    //PMI(cov, "here");
RandomFields/src/spectral.cc:    if ((err = CHECK_PASSFRAME(sub, GaussMethodType)) != NOERROR) {
RandomFields/src/spectral.cc:      //		     SUBMODEL_DEP, GaussMethodType)) != NOERROR) {
RandomFields/src/spectral.cc:  // APMI(cov);
RandomFields/src/spectral.cc:  case SPECTRAL_METRO_FACTOR : 
RandomFields/src/spectral.cc:  case SPECTRAL_SIGMA : 
RandomFields/src/spectral.cc:  if (cov->sub[0]->pref[SpectralTBM] == PREF_NONE) {
RandomFields/src/spectral.cc:  //  PMIR(cov);
RandomFields/src/spectral.cc:    dim = ANYDIM;
RandomFields/src/spectral.cc:  cov->method = SpectralTBM;
RandomFields/src/spectral.cc:  if (dim > MAXTBMSPDIM) {
RandomFields/src/spectral.cc:    err=ERRORMAXDIMMETH; goto ErrorHandling;
RandomFields/src/spectral.cc:  S->Sspectral.prop_factor = P0(SPECTRAL_METRO_FACTOR);
RandomFields/src/spectral.cc:  s->sigma = P0(SPECTRAL_SIGMA);
RandomFields/src/spectral.cc:  //  if (key->Time) {err=ERRORTIME NOTALLOWED; goto ErrorHandling;}
RandomFields/src/spectral.cc:    err = ERRORWRONGDIM;
RandomFields/src/spectral.cc:  if (VDIM0 > 1) {
RandomFields/src/spectral.cc:    err = ERRORNOMULTIVARIATE;
RandomFields/src/spectral.cc:  e[0] = A * ((double) (UNIFORM_RANDOM < 0.5) * 2.0 - 1.0);
RandomFields/src/spectral.cc:    phi = TWOPI*UNIFORM_RANDOM;
RandomFields/src/spectral.cc:  phi = TWOPI*UNIFORM_RANDOM;
RandomFields/src/spectral.cc:  psi = PI*UNIFORM_RANDOM;
RandomFields/src/spectral.cc:    nthreshold = (every>0) ? every : MAXINT,
RandomFields/src/spectral.cc:     E[MAXTBMSPDIM], // must always be of full dimension, even 
RandomFields/src/spectral.cc:    oldE[MAXTBMSPDIM] = { 0, 0, 0, 0 },
RandomFields/src/spectral.cc:    inc[MAXTBMSPDIM] = { 0, 0, 0, 0}, 
RandomFields/src/spectral.cc:  s->phi2d = s->phistep2d * UNIFORM_RANDOM;
RandomFields/src/spectral.cc:  for (d=0; d<MAXTBMSPDIM; d++) E[d] = inc[d] = 0.0;
RandomFields/src/spectral.cc:	dim = ANYDIM,
RandomFields/src/spectral.cc:    VV = TWOPI * UNIFORM_RANDOM;
RandomFields/src/spectral.cc:      } else { // ! DECISION_PARAM.exactness
Binary file RandomFields/src/brownresnick.o matches
RandomFields/src/D.H.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/D.H.cc: Copyright (C) 2002 - 2017 Martin Schlather, 
RandomFields/src/D.H.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/D.H.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/D.H.cc:		 SEXP FFTM,  // fftm[0] >=1 not >=1 (R indexing assumed)
RandomFields/src/D.H.cc:  int *fftm = INTEGER(FFTM),
RandomFields/src/D.H.cc:    lenMpart = len - part,
RandomFields/src/D.H.cc:  assert(lenMpart >= 0);
RandomFields/src/D.H.cc:     n_inv = 1.0 / (double) ((int) (1.0 + lenMpart / (double) shift)),
RandomFields/src/D.H.cc:  if ((compl_number = (double*) MALLOC(sizeof(double) * 2 * part))==NULL || 
RandomFields/src/D.H.cc:      (taper = (double*) MALLOC(sizeof(double) * part))==NULL){
RandomFields/src/D.H.cc:    for (seg_dat=0; seg_dat<=lenMpart; seg_dat+=shift) {
RandomFields/src/D.H.cc:    VarMeth_old, VarMeth_mean, VarMeth_var, delta, realnbox, *lvar,
RandomFields/src/D.H.cc:  PROTECT(Lvar = allocMatrix(REALSXP, 2, ldfa * repet));
RandomFields/src/D.H.cc:	VarMeth_mean = dat[ex - 1] / (realnbox);
RandomFields/src/D.H.cc:	VarMeth_old = 0;
RandomFields/src/D.H.cc:	VarMeth_var = 0;
RandomFields/src/D.H.cc:	  delta = (dat[j] - VarMeth_old) - VarMeth_mean;
RandomFields/src/D.H.cc:	  VarMeth_var += delta * delta;
RandomFields/src/D.H.cc:	  VarMeth_old = dat[j];
RandomFields/src/D.H.cc:        lvar[idx] = LOG(VarMeth_var / ((realnbox - 1.0)));
RandomFields/src/D.H.cc:#define FRACT_MAXDIM 10
Binary file RandomFields/src/primitive.bivariate.o matches
RandomFields/src/primitive.bivariate.cc:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/primitive.bivariate.cc:   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/primitive.bivariate.cc:/* Models involving Gauss */
RandomFields/src/primitive.bivariate.cc:  int dim = OWNLOGDIM(0);
RandomFields/src/primitive.bivariate.cc:#define GAUSSGAMMALIKE_M 0
RandomFields/src/primitive.bivariate.cc:  int dim = OWNLOGDIM(0);
RandomFields/src/primitive.bivariate.cc:  int m = P0INT(GAUSSGAMMALIKE_M);
RandomFields/src/primitive.bivariate.cc:  range->min[GAUSSGAMMALIKE_M] = 1;
RandomFields/src/primitive.bivariate.cc:  range->max[GAUSSGAMMALIKE_M] = MAXINT;
RandomFields/src/primitive.bivariate.cc:  range->pmin[GAUSSGAMMALIKE_M] = range->min[GAUSSGAMMALIKE_M];
RandomFields/src/primitive.bivariate.cc:  range->pmax[GAUSSGAMMALIKE_M] =  10;
RandomFields/src/primitive.bivariate.cc:  // TODO ask Martin if this is a good idea
RandomFields/src/primitive.bivariate.cc:  range->openmin[GAUSSGAMMALIKE_M] = false;
RandomFields/src/primitive.bivariate.cc:  range->openmax[GAUSSGAMMALIKE_M] = false;
RandomFields/src/primitive.bivariate.cc:  int dim = OWNLOGDIM(0);
RandomFields/src/primitive.bivariate.cc:  int dim = OWNLOGDIM(0);
RandomFields/src/primitive.bivariate.cc:  int dim = OWNLOGDIM(0);
RandomFields/src/primitive.bivariate.cc:  int dim = OWNLOGDIM(0);
RandomFields/src/primitive.bivariate.cc:  int dim = OWNLOGDIM(0);
RandomFields/src/primitive.bivariate.cc:  int dim = OWNLOGDIM(0);
RandomFields/src/primitive.bivariate.cc:# define LATENTCAUCHY4_GAMMA 2
RandomFields/src/primitive.bivariate.cc:  int dim = OWNLOGDIM(0);
RandomFields/src/primitive.bivariate.cc:         gamma = P0(LATENTCAUCHY4_GAMMA),
RandomFields/src/primitive.bivariate.cc:  range->min[LATENTCAUCHY4_GAMMA] = 0;
RandomFields/src/primitive.bivariate.cc:  range->max[LATENTCAUCHY4_GAMMA] = RF_INF;
RandomFields/src/primitive.bivariate.cc:  range->pmin[LATENTCAUCHY4_GAMMA] = 0;
RandomFields/src/primitive.bivariate.cc:  range->pmax[LATENTCAUCHY4_GAMMA] = 1000;
RandomFields/src/primitive.bivariate.cc:  range->openmin[LATENTCAUCHY4_GAMMA] = true;
RandomFields/src/primitive.bivariate.cc:  range->openmax[LATENTCAUCHY4_GAMMA] = true;
RandomFields/src/primitive.bivariate.cc:/* Miscellaneous models */ 
RandomFields/src/primitive.bivariate.cc:  // TODO make the TBM work... (sorry martin...)
RandomFields/src/primitive.bivariate.cc:  int dim = OWNLOGDIM(0);
RandomFields/src/primitive.bivariate.cc:  *nr = i < DefList[COVNR].kappas ? OWNLOGDIM(0) : 1;
RandomFields/src/primitive.bivariate.cc:  int err, dim = OWNLOGDIM(0);
Binary file RandomFields/src/fftVarioAlt.o matches
Binary file RandomFields/src/bigdata.o matches
RandomFields/src/plusmal.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/plusmal.cc: Copyright (C) 2017 -- 2017 Martin Schlather
RandomFields/src/plusmal.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/plusmal.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/plusmal.cc:#include "QMath.h"
RandomFields/src/plusmal.cc:  //printf("%d %d %d Ecal=%d def=%d %d %s\n", plus, top, trend, hasAnyEvaluationFrame(cov), isNegDef(covtype), isProcess(covtype), TYPE_NAMES[covtype]);
RandomFields/src/plusmal.cc:    last = OWNLASTSYSTEM,
RandomFields/src/plusmal.cc:  //if (PREVISO(0) == SYMMETRIC) APMI(cov);
RandomFields/src/plusmal.cc:  domain_type covdom = trend ? X ONLY : OWNDOM(0);
RandomFields/src/plusmal.cc:  if (trendiso == ISO_MISMATCH) trendiso = OWNISO(0);
RandomFields/src/plusmal.cc:  assert(trendiso != ISO_MISMATCH);
RandomFields/src/plusmal.cc:  //  printf("top = %d %d %d shape=%d %s\n", top, cov->calling == NULL, cov->calling != NULL && !isnowShape(cov->calling), cov->calling != NULL && isnowShape(cov->calling), cov->calling == NULL ? "Niente" : NAME(cov->calling));
RandomFields/src/plusmal.cc:  //  if (OWNDOM(0) == XONLY && OWNISO(0) == EARTH_COORD && OWNTYPE(0) == NegDefType && false) { APMI0(cov);}
RandomFields/src/plusmal.cc:  // PMI0(cov);
RandomFields/src/plusmal.cc:      //  if (top && equalsnowMathDef(sub) && isNegDef(type)) // 16.1.21
RandomFields/src/plusmal.cc:      // wird nie erfuellt, sowie undefiniert da qualsnowMa erst nach
RandomFields/src/plusmal.cc:    //    printf("+ %s %d\n", NAME(sub), possibilities);
RandomFields/src/plusmal.cc:      //      printf("+ %s %d j=%d\n", NAME(sub), possibilities, j); // 2 BUG;
RandomFields/src/plusmal.cc:      //   APMI0(cov);
RandomFields/src/plusmal.cc:      COPYALLSYSTEMS(PREVSYSOF(sub), OWN, false);
RandomFields/src/plusmal.cc:	//	printf("plus %s %d %s j=%d (%d) %d\n", NAME(cov), i, NAME(sub), j, possibilities,  equalsTrend(type));
RandomFields/src/plusmal.cc:	  bool kern = equalsKernel(PREVDOM(s));
RandomFields/src/plusmal.cc:	  set_dom(PREVSYSOF(sub), s, OWNDOM(s));
RandomFields/src/plusmal.cc:      //     A      PMI0(cov);
RandomFields/src/plusmal.cc:      if ((err = CHECK_GEN(sub, SUBMODEL_DEP, SUBMODEL_DEP,
RandomFields/src/plusmal.cc:			   : type == TrendType ? TrendType : frame, //FRAME!!
RandomFields/src/plusmal.cc:      //      printf("err=%d %s\n", err, TYPE_NAMES[type]);      MER R(err);
RandomFields/src/plusmal.cc:      //APMI(cov);
RandomFields/src/plusmal.cc:      //      VDIM0 = sub->vdim[0];
RandomFields/src/plusmal.cc:      // VDIM1 = sub->vdim[1];
RandomFields/src/plusmal.cc:	//	printf("i=%d\n", i);	APMI(cov);
RandomFields/src/plusmal.cc:    if (i == 0) vdim[0] = VDIM0;
RandomFields/src/plusmal.cc:    if (vdim[1] == 1 && VDIM1 != 1) vdim[1] = VDIM1;
RandomFields/src/plusmal.cc:    if (i > 0 && (vdim[0] != VDIM0 ||
RandomFields/src/plusmal.cc:		  (VDIM1 != 1 && VDIM1 != vdim[1])))
RandomFields/src/plusmal.cc:    // printf("i=%d %d %s: %s %s\n",i, conform[i], NAME(sub),
RandomFields/src/plusmal.cc:    //	   TYPE_NAMES[covtype], TYPE_NAMES[SUBTYPE(0)]);
RandomFields/src/plusmal.cc:  VDIM0 = vdim[0];
RandomFields/src/plusmal.cc:  VDIM1 = vdim[1];
RandomFields/src/plusmal.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/plusmal.cc:      vdim = VDIM0,
RandomFields/src/plusmal.cc:  } else StandardCovMatrix(cov, ignore_y, v);
RandomFields/src/plusmal.cc:  ONCE_NEWSTOMODEL;
RandomFields/src/plusmal.cc:  if (OWNDOM(0) == DOMAIN_MISMATCH) RETURN_ERR(ERRORNOVARIOGRAM);
RandomFields/src/plusmal.cc:  if (nsub == 0) cov->pref[SpectralTBM] = PREF_NONE;
RandomFields/src/plusmal.cc:  range->max[SELECT_SUBNR] = MAXSUB-1;
RandomFields/src/plusmal.cc:  range->pmax[SELECT_SUBNR] = MAXSUB-1;
RandomFields/src/plusmal.cc:    vdim = VDIM0,
RandomFields/src/plusmal.cc:      //PMI(cov);
RandomFields/src/plusmal.cc:      //printf("plus i=%d %d %s: %s %s\n",i, conform[i], NAME(sub), TYPE_NAMES[OWNTYPE(0)], TYPE_NAMES[SUBTYPE(0)]);
RandomFields/src/plusmal.cc:      //     PMI(cov);
RandomFields/src/plusmal.cc:      //  printf("i=%d m=%d %.50s %10g %d %d\n", i,  m, NAME(sub), z[0], sub->vdim[0], vsq); 
RandomFields/src/plusmal.cc:    // if (!R_FINITE(v[0]) || !R_FINITE(v[1]) || !R_FINITE(v[2]) || !R_FINITE(v[3])) { PMI(sub); printf("\n\nplus i=%d m=%d x=%10g %10g %10g\n", i, m, x[0], v[0], z[0]);    printf("(%4.3f, %4.3f; %4.3e %4.3e %4.3e %4.3e)\t", x[0], x[1], v[0], v[1], v[2], v[3]);BUG; }
RandomFields/src/plusmal.cc:    //APMI(cov->calling);
RandomFields/src/plusmal.cc:    vsq = VDIM0 * VDIM1;
RandomFields/src/plusmal.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/plusmal.cc:      //printf("nonstat plus i=%d %d %s: %s %s\n",i, conform[i], NAME(sub),
RandomFields/src/plusmal.cc:      //       TYPE_NAMES[OWNTYPE(0)], TYPE_NAMES[SUBTYPE(0)]);
RandomFields/src/plusmal.cc:    vsq = VDIM0 * VDIM1;
RandomFields/src/plusmal.cc:    vsq = VDIM0 * VDIM1;
RandomFields/src/plusmal.cc:  ONCE_NEWSTOMODEL;
RandomFields/src/plusmal.cc:  //PMI0(sub);}
RandomFields/src/plusmal.cc:      (PisNULL(PLUS_TREND) || PARAMisNULL(sub, PLUS_TREND) ||
RandomFields/src/plusmal.cc:       PARAM0INT(sub, PLUS_TREND) ==  P0INT(PLUS_TREND))) {
RandomFields/src/plusmal.cc:    if (!PARAMisNULL(sub, PLUS_TREND))
RandomFields/src/plusmal.cc:      kdefault(cov, PLUS_TREND, PARAM0INT(sub, PLUS_TREND));
RandomFields/src/plusmal.cc:    //PMI(cov);
RandomFields/src/plusmal.cc:  if (OWNDOM(0) == DOMAIN_MISMATCH) RETURN_ERR(ERRORNOVARIOGRAM);
RandomFields/src/plusmal.cc:  if (nsub == 0) cov->pref[SpectralTBM] = PREF_NONE;
RandomFields/src/plusmal.cc:  //assert(COVNR == MULT);
RandomFields/src/plusmal.cc:    GETSTOMODEL;
RandomFields/src/plusmal.cc:    sub = STOMODEL->keys;
RandomFields/src/plusmal.cc:  int nsub = MAXSUB, // cov->nsub,
RandomFields/src/plusmal.cc:    idx = (int) FIRST_DOMAIN;
RandomFields/src/plusmal.cc:  MEMCOPY(D, sub[j]->allowedD, sizeof(allowedD_type));
RandomFields/src/plusmal.cc:  while (idx <= (int) LAST_DOMAINUSER && !D[idx]) idx++;
RandomFields/src/plusmal.cc:  // printf("allowedDPlus idx = %d %d %d\n", idx, LAST_DOMAINUSER, CanHaveBothTrendAndCov(cov));
RandomFields/src/plusmal.cc:  assert(idx <= (int) LAST_DOMAINUSER);
RandomFields/src/plusmal.cc:  if (idx == (int) LAST_DOMAINUSER) return false;
RandomFields/src/plusmal.cc:    int subDidx = FIRST_DOMAIN;
RandomFields/src/plusmal.cc:    while (subDidx <= (int) LAST_DOMAINUSER && !subD[subDidx]) subDidx++;
RandomFields/src/plusmal.cc:    assert(subDidx <= (int) LAST_DOMAINUSER);
RandomFields/src/plusmal.cc:    for (int i = idx; i<=(int) LAST_DOMAINUSER; i++) D[i] |= subD[i];
RandomFields/src/plusmal.cc:    if (idx == (int) LAST_DOMAINUSER) return false;
RandomFields/src/plusmal.cc:  //ssert(COVNR == MULT);
RandomFields/src/plusmal.cc:  model *sub[MAXSUB]; // llowedIsubs schreibt hier hinein!
RandomFields/src/plusmal.cc:    GETSTOMODEL;
RandomFields/src/plusmal.cc:    Sub = STOMODEL->keys;
RandomFields/src/plusmal.cc:    //||required==ProcessType ||required==GaussMethodType; not yet allowed;to do
RandomFields/src/plusmal.cc:  // printf("here %.50s %d\n", NAME(cov), ++Zaehler);
RandomFields/src/plusmal.cc:  if (isManifold(required)) { // nue 6.8.17
RandomFields/src/plusmal.cc:    int last = PREVLASTSYSTEM;
RandomFields/src/plusmal.cc:	//	printf("FAILED! %.50s %d\n", NAME(cov), Zaehler);
RandomFields/src/plusmal.cc:    //   printf("RETURNING %.50s %d\n", NAME(cov), Zaehler);
RandomFields/src/plusmal.cc:    //   print("i=%d %.50s\n", i, NAME(cov->sub[i]));
RandomFields/src/plusmal.cc:  // printf("FAILED %.50s %d\n", NAME(cov), Zaehler);
RandomFields/src/plusmal.cc:  assert(VDIM0 == 1);
RandomFields/src/plusmal.cc:  dummy = UNIFORM_RANDOM * var_cum[nr];
RandomFields/src/plusmal.cc:  case GaussMethodType : {
RandomFields/src/plusmal.cc:    SERR2("frame '%.50s' not allowed for '%.50s'", TYPE_NAMES[cov->frame],
RandomFields/src/plusmal.cc:  GETSTOMODEL;
RandomFields/src/plusmal.cc:    vdim = VDIM0;
RandomFields/src/plusmal.cc:  if (VDIM0 != VDIM1) BUG; // ??
RandomFields/src/plusmal.cc:  int maxv = MIN(vdim, MAXMPPVDIM);
RandomFields/src/plusmal.cc:  if (hasGaussMethodFrame(cov)) {
RandomFields/src/plusmal.cc:    if (VDIM0 == 1) {
RandomFields/src/plusmal.cc:	  ? cov->sub[i] : STOMODEL->keys[i];
RandomFields/src/plusmal.cc:    if (cov->fieldreturn) cov->rf = STOMODEL->keys[0]->rf;
RandomFields/src/plusmal.cc:	? cov->sub[i] : STOMODEL->keys[i];
RandomFields/src/plusmal.cc:      // printf("%s randomkappa=%d moment=%d\n", NAME(sub), sub->randomkappa,cov->mpp.moments);
RandomFields/src/plusmal.cc:  GETSTOMODEL;
RandomFields/src/plusmal.cc:  if (hasGaussMethodFrame(cov) && cov->method==SpectralTBM) {
RandomFields/src/plusmal.cc:      ? STOMODEL->keys[i] : cov->sub[i];
RandomFields/src/plusmal.cc:    } // else assert(Defn[MODELNR(sub)]->Do 
RandomFields/src/plusmal.cc:    vdimtot = totalpoints * VDIM0,
RandomFields/src/plusmal.cc:  StandardCovMatrix(cov, ignore_y, v);
RandomFields/src/plusmal.cc:    vdim = VDIM0,
RandomFields/src/plusmal.cc:  //  assert(x[0] >= 0.0 || OWNXDIM(0) > 1);
RandomFields/src/plusmal.cc:    vdim = VDIM0,
RandomFields/src/plusmal.cc:  assert(VDIM0 == VDIM1); 
RandomFields/src/plusmal.cc:  assert(x[0] >= 0.0 || OWNTOTALXDIM > 1);
RandomFields/src/plusmal.cc:    vdim = VDIM0,
RandomFields/src/plusmal.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/plusmal.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/plusmal.cc:    vdim = VDIM0,
RandomFields/src/plusmal.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/plusmal.cc:    vsq = VDIM0 * VDIM1;
RandomFields/src/plusmal.cc:  bool ok = OWNDOM(0) != DOMAIN_MISMATCH &&
RandomFields/src/plusmal.cc:  if (!ok) RETURN_ERR(ERRORNOVARIOGRAM);
RandomFields/src/plusmal.cc:    if (calling!=NULL && isPlus(calling) &&!PARAMisNULL(calling, PLUS_TREND)) {
RandomFields/src/plusmal.cc:      if (!PARAM0INT(calling, PLUS_TREND)) BUG;
RandomFields/src/plusmal.cc:	int nr = MODELNR(cov->sub[i]);
RandomFields/src/plusmal.cc:  if (OWNTOTALXDIM >= 2) cov->pref[TBM] = PREF_NONE;
RandomFields/src/plusmal.cc:  if (OWNTOTALXDIM==2 && nsub == 2 && 
RandomFields/src/plusmal.cc:    double *aniso1 = PARAM(next1, DANISO),
RandomFields/src/plusmal.cc:      *aniso2 = PARAM(next2, DANISO);
RandomFields/src/plusmal.cc:	cov->pref[TBM] = next2->pref[TBM];
RandomFields/src/plusmal.cc:	cov->pref[TBM] = next1->pref[TBM];
RandomFields/src/plusmal.cc:  //||required==ProcessType ||required==GaussMethodType; not yet allowed;to do
RandomFields/src/plusmal.cc:  case GaussMethodType : RETURN_ERR(ERRORFAILED);
RandomFields/src/plusmal.cc:    SERR2("frame '%.50s' not allowed for '%.50s'", TYPE_NAMES[cov->frame],
RandomFields/src/plusmal.cc:    vdim = VDIM0;
RandomFields/src/plusmal.cc:  if (VDIM0 != VDIM1) BUG; // ??
RandomFields/src/plusmal.cc:  GETSTOMODEL;
RandomFields/src/plusmal.cc:  int maxv = MIN(vdim, MAXMPPVDIM);
RandomFields/src/plusmal.cc:  if (hasGaussMethodFrame(cov)) {
RandomFields/src/plusmal.cc:    if (VDIM0 == 1) {
RandomFields/src/plusmal.cc:	  ? cov->sub[i] : STOMODEL->keys[i];
RandomFields/src/plusmal.cc:	? cov->sub[i] : STOMODEL->keys[i];
RandomFields/src/plusmal.cc:      // printf("%s randomkappa=%d moment=%d\n", NAME(sub), sub->randomkappa,cov->mpp.moments);
RandomFields/src/plusmal.cc:  if (hasGaussMethodFrame(cov) && cov->method==SpectralTBM) {
RandomFields/src/plusmal.cc:  GETSTOMODEL;
RandomFields/src/plusmal.cc:      ? STOMODEL->keys[i] : cov->sub[i];
RandomFields/src/plusmal.cc:    } // else assert(Defn[MODELNR(sub)]->Do 
RandomFields/src/plusmal.cc:      if (cump > 1.0 && i+1<nsub) RETURN_ERR(ERRORATOMP);
RandomFields/src/plusmal.cc:		KNAME(PLUS_P)); 
RandomFields/src/plusmal.cc:	else SERR1("The components of '%.50s' do not sum up to 1.", KNAME(PLUS_P));
RandomFields/src/plusmal.cc:    vdim = VDIM0,
RandomFields/src/plusmal.cc:  ASSERT_ONESYSTEM;
RandomFields/src/plusmal.cc:  SERR("the current version does not support RMmppplus\n");
RandomFields/src/plusmal.cc:  set_maxdim(OWN, 0, MAXMPPDIM);
RandomFields/src/plusmal.cc:  if (!hasMaxStableFrame(cov) && !hasPoissonFrame(cov)) {
RandomFields/src/plusmal.cc:  RETURN_ERR(ERRORNOTPROGRAMMEDYET);
RandomFields/src/plusmal.cc:  // if (nr == MPPPLUS) return S TRUCT(shape, NULL);
RandomFields/src/plusmal.cc:  ASSERT_NEWMODEL_NOT_NULL;
RandomFields/src/plusmal.cc:  NEWSTOMODEL;
RandomFields/src/plusmal.cc:  GETSTOMODEL;
RandomFields/src/plusmal.cc:    if (STOMODEL->keys[i] != NULL) COV_DELETE(STOMODEL->keys + i, cov);    
RandomFields/src/plusmal.cc:    if ((err = covcpy(STOMODEL->keys + i, sub)) != NOERROR) RETURN_ERR(err);
RandomFields/src/plusmal.cc:    if ((err = addShapeFct(STOMODEL->keys + i)) != NOERROR) RETURN_ERR(err);
RandomFields/src/plusmal.cc:    SET_CALLING(STOMODEL->keys[i], cov);
RandomFields/src/plusmal.cc:  double M2[MAXMPPVDIM], M2plus[MAXMPPVDIM], Eplus[MAXMPPVDIM], 
RandomFields/src/plusmal.cc:    maxheight[MAXMPPVDIM];
RandomFields/src/plusmal.cc:    vdim = VDIM0;
RandomFields/src/plusmal.cc:  if (VDIM0 != VDIM1) BUG;
RandomFields/src/plusmal.cc:  if (vdim > MAXMPPVDIM) BUG;
RandomFields/src/plusmal.cc:  int maxv = MIN(vdim, MAXMPPVDIM);
RandomFields/src/plusmal.cc:    M2[i] = M2plus[i] = Eplus[i] = 0.0;
RandomFields/src/plusmal.cc:  GETSTOMODEL;
RandomFields/src/plusmal.cc:  // formerly loggiven got the value SUBMODEL_DEP. Now, it gets the
RandomFields/src/plusmal.cc:      cov->fieldreturn = (ext_bool) SUBMODEL_DEP;
RandomFields/src/plusmal.cc:    // Achtung cov->mpp.mM2 und Eplus koennten nicht direkt gesetzt
RandomFields/src/plusmal.cc:	Eplus[i] += PARAM0(sub, PLUS_P) * sub->mpp.mMplus[idx + 1]; 
RandomFields/src/plusmal.cc:	  M2[i] += PARAM0(sub, PLUS_P)  * sub->mpp.mM[idx + 2];
RandomFields/src/plusmal.cc:	  M2plus[i] += PARAM0(sub, PLUS_P) * sub->mpp.mM[idx + 2];
RandomFields/src/plusmal.cc:      cov->mpp.mMplus[idx + 1] = Eplus[i];
RandomFields/src/plusmal.cc:      cov->mpp.mM[idx + 1] = RF_NA;
RandomFields/src/plusmal.cc:	 cov->mpp.mM[idx + 2] = M2[i];
RandomFields/src/plusmal.cc:	 cov->mpp.mMplus[idx + 2] = M2plus[i];
RandomFields/src/plusmal.cc:  double subselect = UNIFORM_RANDOM;
RandomFields/src/plusmal.cc:    vdim = VDIM0;
RandomFields/src/plusmal.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/plusmal.cc:  for (subnr=0; (subselect -= PARAM0(cov->sub[subnr], PLUS_P)) > 0; subnr++);
RandomFields/src/plusmal.cc:  int maxv = MIN(vdim, MAXMPPVDIM);
RandomFields/src/plusmal.cc:  GETSTOMODEL;
RandomFields/src/plusmal.cc:    sub = STOMODEL->keys[i];
RandomFields/src/plusmal.cc:    if ((err = CHECK_THROUGHOUT(sub, cov, type, KEEPCOPY_DOM, KEEPCOPY_ISO,
RandomFields/src/plusmal.cc:				SUBMODEL_DEP, cov->frame)) != NOERROR) {
RandomFields/src/plusmal.cc:     //   if ((err= CHECK(sub, dim, xdim, type, dom, iso, SUBMODEL_DEP, frame))
RandomFields/src/plusmal.cc:	err = CHECK_THROUGHOUT(sub, cov, type, KEEPCOPY_DOM, 
RandomFields/src/plusmal.cc:			       SUBMODEL_DEP, cov->frame);
RandomFields/src/plusmal.cc:      VDIM0=sub->vdim[0];  // to do: inkonsistent mit vorigen Zeilen !!
RandomFields/src/plusmal.cc:      VDIM1=sub->vdim[1];  // to do: inkonsistent mit vorigen Zeilen !!
RandomFields/src/plusmal.cc:      if (VDIM0 != sub->vdim[0] || VDIM1 != sub->vdim[1]) {
RandomFields/src/plusmal.cc:    dim =  PREVXDIM(0);
RandomFields/src/plusmal.cc:  case GaussMethodType : {
RandomFields/src/plusmal.cc:    ONCE_NEWSTOMODEL;
RandomFields/src/plusmal.cc:    GETSTOMODEL;
RandomFields/src/plusmal.cc:      if (STOMODEL->keys[m] != NULL) COV_DELETE(STOMODEL->keys + m, cov);
RandomFields/src/plusmal.cc:      if ((err =  covcpy(STOMODEL->keys + m, sub)) != NOERROR) {
RandomFields/src/plusmal.cc:      //      PMI(cov);
RandomFields/src/plusmal.cc:      assert(STOMODEL->keys[m] != NULL);
RandomFields/src/plusmal.cc:      assert(STOMODEL->keys[m]->calling == cov);
RandomFields/src/plusmal.cc:      addModelX(STOMODEL->keys + m, trend ? SHAPE_FCT_PROC : GAUSSPROC);
RandomFields/src/plusmal.cc:      //printf("isTrend = %d %s\n", isTrend(sub), NAME(sub));
RandomFields/src/plusmal.cc:      SET_CALLING(STOMODEL->keys[m], cov);
RandomFields/src/plusmal.cc:#if MAXSYSTEMS > 1    
RandomFields/src/plusmal.cc:      COPYALLSYSTEMS(PREVSYSOF(sub), OWN, false);
RandomFields/src/plusmal.cc:      int last = OWNLASTSYSTEM;
RandomFields/src/plusmal.cc:      //PMI0(cov); 
RandomFields/src/plusmal.cc:      if ((err = CHECK(STOMODEL->keys[m], tsdim, tsdim,
RandomFields/src/plusmal.cc:		       GaussMethodType)) != NOERROR) {
RandomFields/src/plusmal.cc:      if ((err = STRUCT(STOMODEL->keys[m], NULL))  > NOERROR) RETURN_ERR(err);
RandomFields/src/plusmal.cc:    SERR2("frame '%.50s' not allowed for '%.50s'", TYPE_NAMES[cov->frame],
RandomFields/src/plusmal.cc:    vdim = VDIM0;
RandomFields/src/plusmal.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/plusmal.cc: GETSTOMODEL;
RandomFields/src/plusmal.cc:  int maxv = MIN(vdim, MAXMPPVDIM);
RandomFields/src/plusmal.cc:  if (hasGaussMethodFrame(cov)) {
RandomFields/src/plusmal.cc:	? STOMODEL->keys[i] : cov->sub[i];
RandomFields/src/plusmal.cc:  GETSTOMODEL;
RandomFields/src/plusmal.cc:  if (hasGaussMethodFrame(cov)) {
RandomFields/src/plusmal.cc:    if (cov->fieldreturn) cov->rf = STOMODEL->keys[0]->rf;
RandomFields/src/plusmal.cc: GETSTOMODEL;
RandomFields/src/plusmal.cc:    total = Loc(cov)->totalpoints * VDIM0;
RandomFields/src/plusmal.cc:  assert(cov->rf == STOMODEL->keys[0]->rf);
RandomFields/src/plusmal.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/plusmal.cc:  if (hasGaussMethodFrame(cov) && cov->method==SpectralTBM) {
RandomFields/src/plusmal.cc:    model *key = STOMODEL->keys[m],
RandomFields/src/plusmal.cc:#define MULTPROC_COPIES 0
RandomFields/src/plusmal.cc:  kdefault(cov, MULTPROC_COPIES, global->special.multcopies);
RandomFields/src/plusmal.cc:  if (hasGaussMethodFrame(cov)) {
RandomFields/src/plusmal.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/plusmal.cc:    vdim = VDIM0,
RandomFields/src/plusmal.cc: GETSTOMODEL;
RandomFields/src/plusmal.cc:  if (hasGaussMethodFrame(cov) && cov->method==SpectralTBM) {
RandomFields/src/plusmal.cc:    int m0 = MODELNR(cov->sub[0]),
RandomFields/src/plusmal.cc:      m1 = MODELNR(cov->sub[1]);      
RandomFields/src/plusmal.cc:      assert(cov->sub[idx]->qlen > PRODPROC_RANDOM);
RandomFields/src/plusmal.cc:      cov->sub[idx]->q[PRODPROC_RANDOM] = (double) false;
RandomFields/src/plusmal.cc:      model *key = STOMODEL->keys[m],
RandomFields/src/plusmal.cc:	  cc = isnowTrend(sub) ? PARAM0(sub, CONST_C) 
RandomFields/src/plusmal.cc:	  : SQRT(PARAM0(sub, CONST_C));
RandomFields/src/plusmal.cc:	    double var = PARAM0(sub, DVAR);
RandomFields/src/plusmal.cc:		TA LLOC_EXTRA2(VarMem, totalvdim);
RandomFields/src/plusmal.cc:		F ct n(NULL, sub->kappasub[DVAR], VarMem);
RandomFields/src/plusmal.cc:	  TA LLOC_EXT RA3(ConstMem, vdimSq);
RandomFields/src/plusmal.cc:  range->min[MULTPROC_COPIES] = 1.0;
RandomFields/src/plusmal.cc:  range->max[MULTPROC_COPIES] = RF_INF;
RandomFields/src/plusmal.cc:  range->pmin[MULTPROC_COPIES] = 1.0;
RandomFields/src/plusmal.cc:  range->pmax[MULTPROC_COPIES] = 1000;
RandomFields/src/plusmal.cc:  range->openmin[MULTPROC_COPIES] = false;
RandomFields/src/plusmal.cc:  range->openmax[MULTPROC_COPIES] = true;
RandomFields/src/plusmal.cc:    vdim = VDIM0,
RandomFields/src/plusmal.cc:    xdimown = OWNXDIM(0);
RandomFields/src/plusmal.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/plusmal.cc:    vdim = VDIM0,
RandomFields/src/plusmal.cc:    xdimown = OWNXDIM(0);
RandomFields/src/plusmal.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/plusmal.cc:    vdim = VDIM0,
RandomFields/src/plusmal.cc: assert(VDIM0 == VDIM1);
RandomFields/src/plusmal.cc:  int dim = PREVTOTALXDIM;
RandomFields/src/plusmal.cc:  if (dim != OWNTOTALXDIM) BUG;
RandomFields/src/plusmal.cc:  if (VDIM0 != 1) SERR("Taylor only known in the unvariate case");
RandomFields/src/plusmal.cc:    dim = OWNLOGDIM(0),
RandomFields/src/plusmal.cc:    xdimown = OWNXDIM(0),
RandomFields/src/plusmal.cc:  ASSERT_ONESYSTEM;
RandomFields/src/plusmal.cc:  if ((err = CHECK(next, dim, xdimNeu, OWNTYPE(0), OWNDOM(0),
RandomFields/src/plusmal.cc:		   OWNISO(0), SUBMODEL_DEP, cov->frame)) != NOERROR) {
RandomFields/src/plusmal.cc:    //||required==ProcessType ||required==GaussMethodType; not yet allowed;to do
RandomFields/src/plusmal.cc:   int dim = OWNLOGDIM(0);
RandomFields/src/plusmal.cc:  assert(!PARAMisNULL(to, LOC_SCALE) && !PARAMisNULL(from, POWSCALE));
RandomFields/src/plusmal.cc:  PARAM(to, LOC_SCALE)[0] = PARAM0(from, POWSCALE);
RandomFields/src/plusmal.cc:  case SmithType :  case GaussMethodType :
RandomFields/src/plusmal.cc:    ASSERT_NEWMODEL_NOT_NULL;
RandomFields/src/plusmal.cc:    addModel(newmodel, POWER_DOLLAR, cov);
RandomFields/src/plusmal.cc:  case BrMethodType : case SchlatherType : {
RandomFields/src/plusmal.cc:    ASSERT_NEWMODEL_NOT_NULL;
RandomFields/src/plusmal.cc:    addModel(newmodel, LOC, cov);
RandomFields/src/plusmal.cc:    addSetDistr(newmodel, scale, PowScaleToLoc, true, MAXINT);
RandomFields/src/plusmal.cc:	  NICK(cov), TYPE_NAMES[cov->frame]);      
RandomFields/src/plusmal.cc:    vdim = VDIM0,
RandomFields/src/plusmal.cc:    maxstable = hasMaxStableFrame(cov);// Realisationsweise 
RandomFields/src/plusmal.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/plusmal.cc:  assert(cov->key == NULL || ({PMI(cov);false;}));//   
RandomFields/src/plusmal.cc:      var[MAXMPPVDIM],  
RandomFields/src/plusmal.cc:      dim = OWNLOGDIM(0);
RandomFields/src/plusmal.cc:    // Achtung I-NIT_RANDOM ueberschreibt mpp.* !!
RandomFields/src/plusmal.cc:      if ((err = INIT_RANDOM(Var, nm_neu, s, P(POWVAR))) != NOERROR) 
RandomFields/src/plusmal.cc:	var[i] = maxstable ? P0(POWVAR) : Var->mpp.mM[idx + 1];
RandomFields/src/plusmal.cc:	     KNAME(POWPOWER));
RandomFields/src/plusmal.cc:      if ((err = INIT_RANDOM(Scale, idx_s, s, P(POWSCALE))) != NOERROR)
RandomFields/src/plusmal.cc:      scale = maxstable ? P0(DSCALE) : Scale->mpp.mM[1];
RandomFields/src/plusmal.cc:      cov->mpp.mM[i] = next->mpp.mM[i];
RandomFields/src/plusmal.cc:      cov->mpp.mMplus[i] = next->mpp.mMplus[i];
RandomFields/src/plusmal.cc:	  cov->mpp.mM[i] *= Var->mpp.mM[idx + i];
RandomFields/src/plusmal.cc:	  cov->mpp.mMplus[i] *= Var->mpp.mMplus[idx + i];
RandomFields/src/plusmal.cc:	  cov->mpp.mM[k] *= pow_var;
RandomFields/src/plusmal.cc:	  cov->mpp.mMplus[k] *= pow_var;
RandomFields/src/plusmal.cc:	cov->mpp.mM[i] *= Scale->mpp.mM[idx];
RandomFields/src/plusmal.cc:	cov->mpp.mMplus[i] *= Scale->mpp.mMplus[idx];
RandomFields/src/plusmal.cc:	  cov->mpp.mM[k] *= pow_scale;
RandomFields/src/plusmal.cc:	  cov->mpp.mMplus[k] *= pow_scale;
RandomFields/src/plusmal.cc:	int maxv = MIN(vdim, MAXMPPVDIM);
RandomFields/src/plusmal.cc:      } else RETURN_ERR(ERRORNOTPROGRAMMEDYET);
RandomFields/src/plusmal.cc:      int maxv = MIN(vdim, MAXMPPVDIM);
RandomFields/src/plusmal.cc:  else if (hasGaussMethodFrame(cov)) {
RandomFields/src/plusmal.cc:  if (hasMaxStableFrame(cov)) {
RandomFields/src/plusmal.cc:    int vdim = VDIM0;
RandomFields/src/plusmal.cc:    assert(VDIM0 == VDIM1);
RandomFields/src/plusmal.cc:    int maxv = MIN(vdim, MAXMPPVDIM);
RandomFields/src/primitive.others.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/primitive.others.cc:Copyright (C) 2017 -- 2018 Martin Schlather
RandomFields/src/primitive.others.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/primitive.others.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/primitive.others.cc:#include "QMath.h"
RandomFields/src/primitive.others.cc:  int dim = OWNXDIM(0);
RandomFields/src/primitive.others.cc:void AngleMatrix(model *cov, double *A) {
RandomFields/src/primitive.others.cc:    dim = OWNXDIM(0) ;
RandomFields/src/primitive.others.cc:    dim = OWNXDIM(0) ;
RandomFields/src/primitive.others.cc:  AngleMatrix(cov, A);
RandomFields/src/primitive.others.cc:      dim = OWNXDIM(0) ;
RandomFields/src/primitive.others.cc:  int dim = OWNXDIM(0);
RandomFields/src/primitive.others.cc:	    KNAME(ANGLE_RATIO), KNAME(ANGLE_DIAG))
RandomFields/src/primitive.others.cc:      SERR1("'%.50s' may be given only if dim=2",  KNAME(ANGLE_RATIO))
RandomFields/src/primitive.others.cc:	    KNAME(ANGLE_RATIO), KNAME(ANGLE_DIAG));
RandomFields/src/primitive.others.cc:  VDIM0 = dim;
RandomFields/src/primitive.others.cc:  VDIM1 = 1;
RandomFields/src/primitive.others.cc:    SYSTEMS(CALLING) == 1 
RandomFields/src/primitive.others.cc:    vdim = VDIM0;
RandomFields/src/primitive.others.cc:  VDIM0 = OWNTOTALXDIM;
RandomFields/src/primitive.others.cc:  VDIM1 = 1;
RandomFields/src/primitive.others.cc:void NullModel(double VARIABLE_IS_NOT_USED *x, INFO, 
RandomFields/src/primitive.others.cc:void logNullModel(double VARIABLE_IS_NOT_USED *x, INFO, 
RandomFields/src/primitive.others.cc:Types TypeNullModel(Types required, model *cov,
RandomFields/src/primitive.others.cc:  return TypeConsistency(isManifold(required) ? PREVTYPE(0) : required,
RandomFields/src/primitive.others.cc:void rangeNullModel(model VARIABLE_IS_NOT_USED *cov, range_type *range){
RandomFields/src/primitive.others.cc:int checkMath(model *cov){
RandomFields/src/primitive.others.cc:    if ((C->cov==MathCos || C->cov==MathSin ||  C->cov==MathTan)) {
RandomFields/src/primitive.others.cc:      bool plus = DefList[SUBNR].cov == Mathplus ||
RandomFields/src/primitive.others.cc:	DefList[SUBNR].cov == Mathminus
RandomFields/src/primitive.others.cc://			OWNDOM(0), OWNISO(0),
RandomFields/src/primitive.others.cc:      if (i==0 || (DefList[COVNR].cov!=Mathplus && 
RandomFields/src/primitive.others.cc:		   DefList[COVNR].cov!=Mathminus && 
RandomFields/src/primitive.others.cc:		   DefList[COVNR].cov!=Mathbind
RandomFields/src/primitive.others.cc:void rangeMath(model VARIABLE_IS_NOT_USED *cov, range_type *range){
RandomFields/src/primitive.others.cc:  set_maxdim(OWN, 0, OWNLOGDIM(0));
RandomFields/src/primitive.others.cc:  assert(MAXDIM(OWN, 0) > 0);
RandomFields/src/primitive.others.cc:void Mathminus(double *x, int *info, model *cov, double *v){
RandomFields/src/primitive.others.cc:  MATH_DEFAULT;
RandomFields/src/primitive.others.cc:  double f = P0(MATH_FACTOR); 
RandomFields/src/primitive.others.cc:void Mathplus(double *x, int *info, model *cov, double *v){
RandomFields/src/primitive.others.cc:  MATH_DEFAULT;
RandomFields/src/primitive.others.cc:  double f = P0(MATH_FACTOR); 
RandomFields/src/primitive.others.cc:void Mathdiv(double *x, int *info, model *cov, double *v){
RandomFields/src/primitive.others.cc:  MATH_DEFAULT;
RandomFields/src/primitive.others.cc:   double f = P0(MATH_FACTOR); 
RandomFields/src/primitive.others.cc:void Mathmult(double *x, int *info, model *cov, double *v){
RandomFields/src/primitive.others.cc:  MATH_DEFAULT;
RandomFields/src/primitive.others.cc:   double f = P0(MATH_FACTOR); 
RandomFields/src/primitive.others.cc:void MathIs(double *x, int *info, model *cov, double *v){
RandomFields/src/primitive.others.cc:void rangeMathIs(model *cov, range_type *range){
RandomFields/src/primitive.others.cc:  rangeMath(cov, range); 
RandomFields/src/primitive.others.cc:void Mathbind(double *x, int *info, model *cov, double *v){
RandomFields/src/primitive.others.cc:  int vdim = VDIM0;
RandomFields/src/primitive.others.cc:  MATH_DEFAULT_0(vdim); 
RandomFields/src/primitive.others.cc:  if ((err = checkMath(cov)) != NOERROR) RETURN_ERR(err);
RandomFields/src/primitive.others.cc:  VDIM0 = variables / ncol;
RandomFields/src/primitive.others.cc:  VDIM1 = ncol;
RandomFields/src/primitive.others.cc:  if (VDIM0 * VDIM1 != variables) 
RandomFields/src/primitive.others.cc:    SERR1("'%.50s' does not fit the number of components given", KNAME(BIND_NCOL));
RandomFields/src/primitive.others.cc:int checkDivMult(model *cov) {   // R.c
RandomFields/src/primitive.others.cc:  if ((err = checkMath(cov)) != NOERROR) RETURN_ERR(err);
RandomFields/src/primitive.others.cc:      cov->ptwise_definite = MODELNR(cov) == MATHDIV ? pt_mismatch : pt_zero;
RandomFields/src/primitive.others.cc:    for (int j=(int) FIRST_DOMAIN; j<=(int) LAST_DOMAINUSER; D[j++] = false);
RandomFields/src/primitive.others.cc:	for (int j=(int) FIRST_DOMAIN; j<=(int) LAST_DOMAINUSER; j++)
RandomFields/src/primitive.others.cc:  //  printf("c:%s %d %d %d %d \n", TYPE_NAMES[required], !isNegDef(required),
RandomFields/src/primitive.others.cc:  //  PMI(cov);
RandomFields/src/primitive.others.cc:void Mathc(double VARIABLE_IS_NOT_USED *x, INFO,model *cov, double *v) {
RandomFields/src/primitive.others.cc:    // For spatially constant covariance functions, see RMconstant      
RandomFields/src/primitive.others.cc:  if (tcf) MEMCOPY(cov->pref, PREF_ALL, sizeof(pref_shorttype));
RandomFields/src/primitive.others.cc:    case SYMMETRIC : case EARTH_SYMMETRIC: case SPHERICAL_SYMMETRIC :
RandomFields/src/primitive.others.cc:    case GNOMONIC_PROJ  : case ORTHOGRAPHIC_PROJ : 
RandomFields/src/primitive.others.cc:      ERR("Do not use projection in 'R,p', but use 'RMtrafo' instead.");
RandomFields/src/primitive.others.cc:    default : ERR2("'%.50s' not allowed for '%.50s'", ISO_NAMES[iso],KNAME(PROJ_ISO));
RandomFields/src/primitive.others.cc:  if (p == PROJ_TIME) *v = x[OWNTOTALXDIM - 1] * f;
RandomFields/src/primitive.others.cc:    int spdim = OWNTOTALXDIM - 1;
RandomFields/src/primitive.others.cc:  domain_type dom = PREVDOM(0);
RandomFields/src/primitive.others.cc:#if MAXSYSTEMS == 1
RandomFields/src/primitive.others.cc:      set_system(OWN, 0, PREVLOGDIM(0), MAXINT, 2, type, dom, iso);
RandomFields/src/primitive.others.cc:      set_system(OWN, 0, totlogicaldim - 1, MAXINT, 1, type, dom, ISOTROPIC);
RandomFields/src/primitive.others.cc:      set_system(OWN, 1, 1, 1, 1, OWNTYPE(1), OWNDOM(1), ISOTROPIC);
RandomFields/src/primitive.others.cc:#if MAXSYSTEMS == 1
RandomFields/src/primitive.others.cc:    set_system(OWN, s, PREVLOGDIM(s), MAXINT,	 PREVLOGDIM(s), PREVTYPE(s),
RandomFields/src/primitive.others.cc:	       PREVDOM(s), CoordinateSystemOf(PREVISO(s)));    
RandomFields/src/primitive.others.cc:    int last = PREVLASTSYSTEM;
RandomFields/src/primitive.others.cc:      set_system(OWN, s, PREVLOGDIM(s), MAXINT,	 PREVLOGDIM(s), PREVTYPE(s),
RandomFields/src/primitive.others.cc:		 PREVDOM(s), CoordinateSystemOf(PREVISO(s)));
RandomFields/src/primitive.others.cc:     if (fixed) set_system(OWN, 0, PREVLOGDIM(0), MAXINT, 1, type, dom, iso);
RandomFields/src/primitive.others.cc:  //	  ISO_NAMES[isoown], ISO_NAMES[iso]);
RandomFields/src/primitive.others.cc:	  PROJECTION_NAMES[0], PROJECTION_NAMES[1]);
RandomFields/src/primitive.others.cc:  range->max[PROJ_PROJ] = OWNXDIM(0);
RandomFields/src/primitive.others.cc:  range->pmax[PROJ_PROJ] = OWNXDIM(0);
RandomFields/src/primitive.others.cc:  *nr = i >= DefList[COVNR].kappas? -1 : SIZE_NOT_DETERMINED;
RandomFields/src/primitive.others.cc:  *nc = SIZE_NOT_DETERMINED;
RandomFields/src/primitive.others.cc:  int vdimSq = VDIM0 * VDIM1;
RandomFields/src/primitive.others.cc:  int vdimSq = VDIM0 * VDIM1;
RandomFields/src/primitive.others.cc:  VDIM0 = VDIM1 = v;
Binary file RandomFields/src/fftVario.o matches
Binary file RandomFields/src/trend.o matches
RandomFields/src/Huetchen.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/Huetchen.cc: Copyright (C) 2001 -- 2017 Martin Schlather, 
RandomFields/src/Huetchen.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURSE.  See the
RandomFields/src/Huetchen.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/Huetchen.cc:#define RANDOMCOIN_INTENSITY (COMMON_GAUSS + 1) 
RandomFields/src/Huetchen.cc:  int dimP1 = OWNXDIM(0) + 1;
RandomFields/src/Huetchen.cc:  NEWSTOMODEL;
RandomFields/src/Huetchen.cc:    RETURN_ERR(ERRORMEMORYALLOCATION);
RandomFields/src/Huetchen.cc:  int dim = OWNXDIM(0);  
RandomFields/src/Huetchen.cc:  TALLOC_X1(delta, OWNXDIM(0));
RandomFields/src/Huetchen.cc: // PMI(cov);
RandomFields/src/Huetchen.cc:  TALLOC_X1(delta, OWNXDIM(0));
RandomFields/src/Huetchen.cc:  ASSERT_ONESYSTEM;
RandomFields/src/Huetchen.cc:    dim = OWNLOGDIM(0);
RandomFields/src/Huetchen.cc:  kdefault(cov, ZHOU_INFTY_SMALL, P0INT(ZHOU_FLATHULL) != (int) False);
RandomFields/src/Huetchen.cc:  kdefault(cov, ZHOU_NORMED, true);
RandomFields/src/Huetchen.cc:  //if (shape->randomkappa) RETURN_ERR(ERRORNOTPROGRAMMED); // Dichte muss nicht normiert sein und stattdessen durch das mittlere Volumen dividiert werden.
RandomFields/src/Huetchen.cc:  ASSERT_NEWMODEL_NULL;
RandomFields/src/Huetchen.cc:    DELSTOMODEL;
RandomFields/src/Huetchen.cc:  if (!hasSmithFrame(shape)) ILLEGAL_FRAME;
RandomFields/src/Huetchen.cc:    dim = OWNLOGDIM(0);
RandomFields/src/Huetchen.cc:  //  PMI(cov, "calculate max");
RandomFields/src/Huetchen.cc:  //  printf("%.50s %d %d %10g\n",NICK(cov), ZHOU_FLATHULL, P0INT(ZHOU_FLATHULL), value_orig );// APMI(cov); assert(false);
RandomFields/src/Huetchen.cc:    if (P0INT(ZHOU_INFTY_SMALL)) {
RandomFields/src/Huetchen.cc:	    KNAME(ZHOU_FLATHULL), KNAME(ZHOU_INFTY_SMALL));
RandomFields/src/Huetchen.cc:    //    APMI(cov);
RandomFields/src/Huetchen.cc:  //  printf("%d %10g\n", !P0INT(ZHOU_NORMED), single[ZHOU_CORNER]);
RandomFields/src/Huetchen.cc:  assert(!P0INT(ZHOU_NORMED) || single[ZHOU_CORNER] == 1.0); // nur wenn normiert
RandomFields/src/Huetchen.cc:      //PMI(cov);
RandomFields/src/Huetchen.cc:  ASSERT_ONESYSTEM;
RandomFields/src/Huetchen.cc:  if ((err = CHECK(*newmodel, OWNLOGDIM(0), PREVXDIM(0), OWNTYPE(0),
RandomFields/src/Huetchen.cc:		   PREVDOM(0), PREVISO(0), cov->vdim, frame))
RandomFields/src/Huetchen.cc:   if ((err =  CHECK(*newmodel, OWNLOGDIM(0), PREVXDIM(0), OWNTYPE(0), 
RandomFields/src/Huetchen.cc:		      PREVDOM(0), PREVISO(0), cov->vdim, frame)) 
RandomFields/src/Huetchen.cc:   //APMI(*newmodel);
RandomFields/src/Huetchen.cc:      //APMI(covIn); // !!! ?? hier weitermachen
RandomFields/src/Huetchen.cc:  ASSERT_ONESYSTEM;
RandomFields/src/Huetchen.cc:  defn *Cshape = DefList + MODELNR(shape);
RandomFields/src/Huetchen.cc:    dim = XDIM(PREVSYSOF(shape), 0);
RandomFields/src/Huetchen.cc:  assert(dim == XDIM(PREVSYSOF(cov->sub[PGS_LOC]), 0));
RandomFields/src/Huetchen.cc:	) RETURN_ERR(ERRORMEMORYALLOCATION);
RandomFields/src/Huetchen.cc:  GETSTOMODEL;
RandomFields/src/Huetchen.cc:  //  PMI(shape);
RandomFields/src/Huetchen.cc:    RETURN_ERR(ERRORMEMORYALLOCATION);
RandomFields/src/Huetchen.cc:  if (P0INT(ZHOU_NORMED)) {
RandomFields/src/Huetchen.cc:      //      printf("masses shape=%10g pts=%10g\n", shape->mpp.mMplus[1], pts->mpp.unnormedmass);
RandomFields/src/Huetchen.cc:      //APMI(cov);
RandomFields/src/Huetchen.cc:      pts->mpp.unnormedmass = shape->mpp.mMplus[1];
RandomFields/src/Huetchen.cc:  //  APMI(cov);
RandomFields/src/Huetchen.cc:  assert(cov->randomkappa || P0INT(ZHOU_NORMED));
RandomFields/src/Huetchen.cc:    if (STOMODEL->cov == NULL) {
RandomFields/src/Huetchen.cc:      //  APMI(start);
RandomFields/src/Huetchen.cc:      while (start->calling != NULL && MODELNR(start) != ZHOU)
RandomFields/src/Huetchen.cc:      if (MODELNR(start) != ZHOU) {
RandomFields/src/Huetchen.cc:	if ((err=complete_copy(&(STOMODEL->cov), cov)) != NOERROR) RETURN_ERR(err);
RandomFields/src/Huetchen.cc:	SET_CALLING(STOMODEL->cov, cov->calling);
RandomFields/src/Huetchen.cc:	assert(STOMODEL->cov->Smodel != NULL);
RandomFields/src/Huetchen.cc:	STOMODEL->cov->Smodel->cov = cov;
RandomFields/src/Huetchen.cc:      pts->mpp.unnormedmass * pgs->totalmass / shape->mpp.mMplus[1];
RandomFields/src/Huetchen.cc:    //     printf("%10g %10g %10g %10g\n", pgs->zhou_c, pts->mpp.unnormedmass, pgs->totalmass, shape->mpp.mMplus[1]);assert(false);
RandomFields/src/Huetchen.cc:  if (DefList[MODELNR(shape)].inverse_nonstat == inversenonstatErr) {
RandomFields/src/Huetchen.cc:    if (MODELNR(pts) != RECTANGULAR) {
RandomFields/src/Huetchen.cc:      //       PMI(pts);
RandomFields/src/Huetchen.cc:      // APMI(shape);
RandomFields/src/Huetchen.cc:    cov->mpp.mM[i] = shape->mpp.mM[i] * pts->mpp.mMplus[0];
RandomFields/src/Huetchen.cc:    cov->mpp.mMplus[i] = shape->mpp.mMplus[i] * pts->mpp.mMplus[0];
RandomFields/src/Huetchen.cc:  mass = UNIFORM_RANDOM * total[size - 1];
RandomFields/src/Huetchen.cc:  dim = XDIM(PREVSYSOF(shape), 0);		 \
RandomFields/src/Huetchen.cc:	 (STOMODEL->cov!=NULL && STOMODEL->cov->Spgs!=NULL \
RandomFields/src/Huetchen.cc:	  && STOMODEL->cov->Smodel->cov==cov));
RandomFields/src/Huetchen.cc:  GETSTOMODEL;
RandomFields/src/Huetchen.cc:    // assert(PARAM0(shape->sub[0], POWSCALE) == PARAM0(pts, LOC_SCALE));
RandomFields/src/Huetchen.cc:      cmaxDmu = pgs->totalmass / shape->mpp.mMplus[1];
RandomFields/src/Huetchen.cc:	     cmaxDmu, (double) pgs->totalmass, shape->mpp.mMplus[1], 
RandomFields/src/Huetchen.cc:	     PARAM0(shape->sub[0], 0), 
RandomFields/src/Huetchen.cc:      //    if (!(shape->mpp.mMplus[1] > 0.0001 || pgs->totalmass < 100)) APMI(cov);
RandomFields/src/Huetchen.cc:      //PMI(cov);
RandomFields/src/Huetchen.cc:      //assert( shape->sub[0]->Spolygon->P->box0[0] == PARAM(pts, 0)[0]);
RandomFields/src/Huetchen.cc:      double old_zhou = STOMODEL->cov->Spgs->old_zhou;
RandomFields/src/Huetchen.cc:      if (old_zhou < cmaxDmu || UNIFORM_RANDOM * old_zhou < cmaxDmu) {
RandomFields/src/Huetchen.cc:    //PMI(pts);
RandomFields/src/Huetchen.cc:    // printf("%10g %10g\n", PARAM(pts, 1)[0] *PARAM(pts, 1)[1] * 4 , pts->mpp.mMplus[0]);
RandomFields/src/Huetchen.cc:    //assert(FABS(PARAM(pts, 1)[0] *PARAM(pts, 1)[1] * 4 - pts->mpp.mMplus[0]) < 1e-14 *  pts->mpp.mMplus[0]);
RandomFields/src/Huetchen.cc:    //   PMI(save_pts);
RandomFields/src/Huetchen.cc:    //APMI(pts);
RandomFields/src/Huetchen.cc:    DORANDOM(pts, cov->q); // cov->q ist hier nur dummy    
RandomFields/src/Huetchen.cc:    //printf("old %10g %10g %10g\n", (double) pgs->old_zhou, (double) pgs->totalmass, PARAM0(shape->sub[0], POWSCALE));
RandomFields/src/Huetchen.cc:    // if (pgs->old_zhou > 1e6 && PARAM0(shape->sub[0], POWSCALE)>1) APMI(cov);  //    assert(shape->sub[0]->nr == POWER_DOLLAR && pts->nr == LOC);
RandomFields/src/Huetchen.cc:    // assert(PARAM0(shape->sub[0], POWSCALE) == PARAM0(pts, LOC_SCALE));
RandomFields/src/Huetchen.cc:	     NICK(shape->sub[0]), PARAM0(shape->sub[0], POWSCALE)
RandomFields/src/Huetchen.cc:  //APMI(cov);
RandomFields/src/Huetchen.cc:    // Bsp das nicht funktioniert fuer flathull=FLATHULL_UNDETERMINED
RandomFields/src/Huetchen.cc:    //      z _ RFsimulate(RPsmith(RMgauss(), xi=0), x, x, grid=T, print=20)
RandomFields/src/Huetchen.cc:	v[d] = gr[d][XSTEP] * UNIFORM_RANDOM - halfstepvector[d];
RandomFields/src/Huetchen.cc:  // v[0] = (2 * UNIFORM_RANDOM - 1) * PARAM0(shape->sub[0], POWSCALE) ;
RandomFields/src/Huetchen.cc:  //  v[1] = (2 * UNIFORM_RANDOM - 1) * PARAM0(shape->sub[0], POWSCALE);
RandomFields/src/Huetchen.cc:  // v[2] = (2 * UNIFORM_RANDOM - 1) * PARAM0(shape->sub[0], POWSCALE);
RandomFields/src/Huetchen.cc:      // versetzt wieder zusammengesetzt werden, so dass in der Mitte i.a.
RandomFields/src/Huetchen.cc:    dim = XDIM(PREVSYSOF(shape), 0);
RandomFields/src/Huetchen.cc:  //  printf("%d %f %f--%f %s\n",cov->loggiven, eps, x[0], y[0], NAME(shape));
RandomFields/src/Huetchen.cc:  booleanRange(ZHOU_INFTY_SMALL);
RandomFields/src/Huetchen.cc:  booleanRange(ZHOU_NORMED);
RandomFields/src/Huetchen.cc:  //  APMI(cov);
RandomFields/src/Huetchen.cc:    dim = OWNLOGDIM(0); 
RandomFields/src/Huetchen.cc:  ASSERT_NEWMODEL_NULL;
RandomFields/src/Huetchen.cc:  if (!hasPoissonFrame(shape) && !hasSchlatherFrame(shape)) ILLEGAL_FRAME;
RandomFields/src/Huetchen.cc:  ASSERT_ONESYSTEM;
RandomFields/src/Huetchen.cc:    dim = XDIM(PREVSYSOF(shape), 0);
RandomFields/src/Huetchen.cc:      cov->mpp.mM[i] = shape->mpp.mM[i];
RandomFields/src/Huetchen.cc:      cov->mpp.mMplus[i] = shape->mpp.mMplus[i];
RandomFields/src/Huetchen.cc:    pgs->zhou_c = 1.0 / cov->mpp.mMplus[1]; // passt fuer binary, und auch fuer 
RandomFields/src/Huetchen.cc:// APMI0(cov);
RandomFields/src/Huetchen.cc://  PMI(cov);
RandomFields/src/Huetchen.cc:    dim =  OWNXDIM(0);
RandomFields/src/Huetchen.cc:     ILLEGAL_FRAME;
RandomFields/src/Huetchen.cc:      (MODELNR(shape)!= TRUNCSUPPORT || cov->kappasub[TRUNC_RADIUS] != NULL))
RandomFields/src/Huetchen.cc:  ASSERT_NEWMODEL_NULL;
RandomFields/src/Huetchen.cc:  if (!hasAnyPoissonFrame(shape) && !hasSmithFrame(shape)) ILLEGAL_FRAME;
RandomFields/src/Huetchen.cc:  ASSERT_ONESYSTEM;
RandomFields/src/Huetchen.cc:    dim = XDIM(PREVSYSOF(shape), 0),
RandomFields/src/Huetchen.cc:  assert(XDIM(PREVSYSOF(shape), 0) == Loc(cov)->timespacedim);
RandomFields/src/Huetchen.cc:      RETURN_ERR(ERRORMEMORYALLOCATION);
RandomFields/src/Huetchen.cc:  // FRAME_ASSE RT(Poisson || cov->frame = = M axStableType);
RandomFields/src/Huetchen.cc:  //  PMI(cov->calling);
RandomFields/src/Huetchen.cc:  //A  PMI(cov); printf("%d\n", PGS_LOC);
RandomFields/src/Huetchen.cc:  assert(MODELNR(u) == UNIF);
RandomFields/src/Huetchen.cc:    *min = PARAM(u, UNIF_MIN),
RandomFields/src/Huetchen.cc:    *max = PARAM(u, UNIF_MAX),
RandomFields/src/Huetchen.cc:  } else if (hasMaxStableFrame(cov)){    
RandomFields/src/Huetchen.cc:    pgs->zhou_c = pgs->totalmass / shape->mpp.mMplus[1];
RandomFields/src/Huetchen.cc:    dim = XDIM(PREVSYSOF(shape), 0);
RandomFields/src/Huetchen.cc:  DORANDOM(pts, cov->q);
RandomFields/src/Huetchen.cc:  //PMI(shape, "standard");
RandomFields/src/Huetchen.cc:    //    APMI(pts);
RandomFields/src/Huetchen.cc:    dim = OWNLOGDIM(0);
RandomFields/src/Huetchen.cc:  kdefault(cov, ZHOU_INFTY_SMALL, P0INT(ZHOU_FLATHULL) != (int) False);
RandomFields/src/Huetchen.cc:  kdefault(cov, ZHOU_NORMED, true);
RandomFields/src/Huetchen.cc:  if (hasGaussMethodFrame(cov))
RandomFields/src/Huetchen.cc:    frame = isGaussMethod(shape) || equalsBernoulliProcess(shape)
RandomFields/src/Huetchen.cc:      ? GaussMethodType : cov->frame ; 
RandomFields/src/Huetchen.cc:  //  else if (hasMaxStableFrame(cov)) frame = cov->frame;
RandomFields/src/Huetchen.cc:  else ILLEGAL_FRAME;
RandomFields/src/Huetchen.cc:  // PMI(shape);
RandomFields/src/Huetchen.cc:  //if (shape->randomkappa) RETURN_ERR(ERRORNOTPROGRAMMED); // Dichte muss nicht normiert sein und stattdessen durch das mittlere Volumen dividiert werden.
RandomFields/src/Huetchen.cc:  ASSERT_NEWMODEL_NULL;
RandomFields/src/Huetchen.cc:  ASSERT_ONESYSTEM;
RandomFields/src/Huetchen.cc:    cov->mpp.mM[i] = shape->mpp.mM[i] * pts->mpp.mMplus[0];
RandomFields/src/Huetchen.cc:    cov->mpp.mMplus[i] = shape->mpp.mMplus[i] * pts->mpp.mMplus[0];
RandomFields/src/Huetchen.cc:  booleanRange(ZHOU_INFTY_SMALL);
RandomFields/src/Huetchen.cc:  booleanRange(ZHOU_NORMED);
RandomFields/src/Huetchen.cc:     (a) die Massen um die Punkte am naechsten zum Zentrum 
RandomFields/src/Huetchen.cc:     (b) die Massen ueberlappen sich nicht genug. Dann werden 
RandomFields/src/Huetchen.cc:         2^d -1 Moeglichkeiten einzeln, ob die Punkte dem Zentrum
RandomFields/src/Huetchen.cc:    dim = OWNLOGDIM(0);
RandomFields/src/Huetchen.cc:    //    PMI(shape);    printf("%10g %10g\n", v[0], x[0]);
RandomFields/src/Huetchen.cc:	  MEMCOPYX(xgr[d], gr[d], 3 * sizeof(double));
RandomFields/src/Huetchen.cc:    dim = XDIM(PREVSYSOF(shape), 0);
RandomFields/src/Huetchen.cc:    DORANDOM(pts, cov->q);  // cov->q nur dummy. Wird ueberschrieben
RandomFields/src/Huetchen.cc:  //  APMI(pts);
RandomFields/src/Huetchen.cc:  i = UNIFORM_RANDOM * pgs->totalmass;
RandomFields/src/Huetchen.cc:  //  TALLOC_X1(delta, OWNXDIM(0));
RandomFields/src/Huetchen.cc:  RETURN_ERR(ERRORNOTPROGRAMMEDYET); // the paper to write
RandomFields/src/Huetchen.cc:  ASSERT_ONESYSTEM;
RandomFields/src/Huetchen.cc:    dim = OWNLOGDIM(0);
RandomFields/src/Huetchen.cc:  //  kdefault(cov, ZHOU_INFTY_SMALL, P0INT(ZHOU_FLATHULL) != (int) False);
RandomFields/src/Huetchen.cc:  //  kdefault(cov, ZHOU_NORMED, true);
RandomFields/src/Huetchen.cc:  //if (shape->randomkappa) RETURN_ERR(ERRORNOTPROGRAMMED); // Dichte muss nicht normiert sein und stattdessen durch das mittlere Volumen dividiert werden.
RandomFields/src/Huetchen.cc:  RETURN_ERR(ERRORNOTPROGRAMMEDYET);
RandomFields/src/Huetchen.cc:  ASSERT_NEWMODEL_NULL;
RandomFields/src/Huetchen.cc:    DELSTOMODEL;
RandomFields/src/Huetchen.cc:  if (!hasPoissonGaussFrame(shape)) ILLEGAL_FRAME;
RandomFields/src/Huetchen.cc:  RETURN_ERR(ERRORNOTPROGRAMMEDYET);
RandomFields/src/Huetchen.cc:  ASSERT_ONESYSTEM;
RandomFields/src/Huetchen.cc:  defn *Cshape = DefList + MODELNR(shape);
RandomFields/src/Huetchen.cc:     dim = XDIM(PREVSYSOF(shape), 0);
RandomFields/src/Huetchen.cc:  assert(dim == XDIM(PREVSYSOF(cov->sub[PGS_LOC]), 0));
RandomFields/src/Huetchen.cc:	) RETURN_ERR(ERRORMEMORYALLOCATION);
RandomFields/src/Huetchen.cc:       )) RETURN_ERR(ERRORMEMORYALLOCATION);
RandomFields/src/Huetchen.cc:  if (DefList[MODELNR(shape)].inverse_nonstat == inversenonstatErr) {
RandomFields/src/Huetchen.cc:    if (MODELNR(pts) != RECTANGULAR) {
RandomFields/src/Huetchen.cc:      //       PMI(pts);
RandomFields/src/Huetchen.cc:      // APMI(shape);
RandomFields/src/Huetchen.cc:    cov->mpp.mM[i] = shape->mpp.mM[i] * pts->mpp.mMplus[0];
RandomFields/src/Huetchen.cc:    cov->mpp.mMplus[i] = shape->mpp.mMplus[i] * pts->mpp.mMplus[0];
RandomFields/src/Huetchen.cc:    dim = XDIM(PREVSYSOF(shape), 0);
RandomFields/src/Options.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/Options.h: Copyright (C) 2017 -- 2017 Martin Schlather
RandomFields/src/Options.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/Options.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/Options.h:#define MAX_CE_MEM 16777216
RandomFields/src/Options.h:// IMPORTANT: all names of general must have at least 3 letters !!!
RandomFields/src/Options.h:#define GENERAL_MODUS 0 
RandomFields/src/Options.h:	 In case, only MAXFIELDS different parameter sets are used, but after each 
RandomFields/src/Options.h:   has an effect only if cov (and not only cov.local, e.g. Brownian Motion) is 
RandomFields/src/Options.h:   3 : MLE (special needs taken into account, Long memory covariance functions
RandomFields/src/Options.h:  {pch[NM],								\
RandomFields/src/Options.h:      1e-6, exactness[NM]						\
RandomFields/src/Options.h:    boxcox[2 * MAXBOXCOXVDIM];
RandomFields/src/Options.h:#define MINSPLITN(locmaxn) ((locmaxn) / 40)
RandomFields/src/Options.h:#define MEDSPLITN(locmaxn) ((locmaxn) / 8)
RandomFields/src/Options.h:#define MAXSPLITN(locmaxn) (((locmaxn) * 5) / 8)
RandomFields/src/Options.h:      locmaxn[NM],							\
RandomFields/src/Options.h:      {MINSPLITN(locmaxn[NM]), MEDSPLITN(locmaxn[NM]), MAXSPLITN(locmaxn[NM])},\
RandomFields/src/Options.h:     tol_re, tol_im, mmin[MAXCEDIM],
RandomFields/src/Options.h:  {ce_force[NM], true, ce_dependent[NM],	\
RandomFields/src/Options.h:      3, MAX_CE_MEM, MAXINT,						\
RandomFields/src/Options.h:      1, ce_tolRe[NM], ce_tolIm[NM], {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, \
RandomFields/src/Options.h:      ce_approx_step[NM]}
RandomFields/src/Options.h:  int lines[MAXTBMSPDIM];
RandomFields/src/Options.h:#define spectral_START {sp_grid[NM], 50, 0.0, {2500, 2500, 2500, 2500}}
RandomFields/src/Options.h:#define pTBMN 9
RandomFields/src/Options.h:extern const char * pTBM[pTBMN];
RandomFields/src/Options.h:    lines[MAXTBMSPDIM];          // number of lines simulated
RandomFields/src/Options.h:    center[MAXTBMSPDIM];
RandomFields/src/Options.h:  {sp_grid[NM], -2, 3, 0, {1, 60, 500}, Nan, tbm_linefactor[NM], 0.0, \
RandomFields/src/Options.h:#define MAX_DIRECT_MAXVAR 30000
RandomFields/src/Options.h:#define DIRECT_ORIG_MAXVAR 12000
RandomFields/src/Options.h:#define DIRECT_MAXVAR_PARAM 0
RandomFields/src/Options.h:#define direct_START  { DIRECT_ORIG_MAXVAR }
RandomFields/src/Options.h:#define nugget_START {nugget_tol[NM]}
RandomFields/src/Options.h:    scatter_max[MAXMPPDIM];
RandomFields/src/Options.h:  double intensity[MAXMPPDIM], // intensity factor for e.g. unif_initu
RandomFields/src/Options.h:    scatter_step[MAXMPPDIM];
RandomFields/src/Options.h:   {mpp_intensity[NM], mpp_intensity[NM], mpp_intensity[NM],mpp_intensity[NM]},\
RandomFields/src/Options.h:     mpp_zero[NM], /* about zero */					\
RandomFields/src/Options.h:#define HYPER_UNIFORM  0
RandomFields/src/Options.h:#define hyper_START {700, 1000, HYPER_UNIFORM, RF_NA}
RandomFields/src/Options.h:#define EXTREME_FLAT 5
RandomFields/src/Options.h:  {False, MAXINT, 30,			\
RandomFields/src/Options.h:      max_max_gauss[NM],			\
RandomFields/src/Options.h:  int BRmaxmem, BRvertnumber, BRoptim, deltaAM;
RandomFields/src/Options.h:      DISTMAXSTEPS, 8, 20, 15, 1000}  // distr (rectangular) // todo should be 500 and better algorithm for approximation!
RandomFields/src/Options.h:#define MINCLIQUE(locmaxn) ((locmaxn) / 25)
RandomFields/src/Options.h:#define MEDCLIQUE(locmaxn) ((locmaxn) / 5)
RandomFields/src/Options.h:#define MAXCLIQUE(locmaxn) (((locmaxn) * 3) / 5)
RandomFields/src/Options.h:#define FLAT_UNDETERMINED -1
RandomFields/src/Options.h:#define FIT_MAXNEIGHBOUR 19
RandomFields/src/Options.h:    BC_lambdaLB[2 * MAXBOXCOXVDIM],
RandomFields/src/Options.h:    BC_lambdaUB[2 * MAXBOXCOXVDIM],
RandomFields/src/Options.h:    0.1, 1e-7, fit_pgtol[NM], fit_pgtol_recall[NM], /* */		\
RandomFields/src/Options.h:    fit_factr[NM], fit_factr_recall[NM], PSEUDO,			\
RandomFields/src/Options.h:    5 /* ncrit */ , maxclique[NM],					\
RandomFields/src/Options.h:	    {MINCLIQUE(maxclique[NM]), MEDCLIQUE(maxclique[NM]),	\
RandomFields/src/Options.h:		MAXCLIQUE(maxclique[NM]) }, 2, 2000 /* small */,  /* 11 */ \
RandomFields/src/Options.h:    0, 0, 0 /* UNSET algorithm */, 0, fit_split[NM], 1, 0, /*  */	\
RandomFields/src/Options.h:	  /* bool */ false, false, fit_reoptimise[NM],  /* 5 */ \
RandomFields/src/Options.h:    fit_ratiotest_approx[NM], true, fit_cross_refit[NM], false, true,	\
RandomFields/src/Options.h:#define MAXBINS 50
RandomFields/src/Options.h:    bins[MAXBINS], deltaT[2];
RandomFields/src/Options.h:#define register_START {0, MODEL_PREDICT, MODEL_USER}
RandomFields/src/Options.h:#define MESSAGES_NEWANISO 2
RandomFields/src/Options.h:#define MESSAGES_ONGRID 8
RandomFields/src/Options.h:#define MESSAGES_COORD_CHANGE 11
RandomFields/src/Options.h:#define MESSAGES_ZENIT 13
RandomFields/src/Options.h:#define MESSAGES_PARALLEL 18
RandomFields/src/Options.h:#define MESSAGES_RAW 24
RandomFields/src/Options.h:#define COORDS_DATANAMES 6
RandomFields/src/Options.h:#define COORDS_XNAMES 8
RandomFields/src/Options.h:     newunits[MAXCOORDNAMES][MAXUNITSCHAR], // 2; only to read
RandomFields/src/Options.h:    curunits[MAXCOORDNAMES][MAXUNITSCHAR], // 3
RandomFields/src/Options.h:    varunits[MAXDATANAMES][MAXUNITSCHAR], // 4
RandomFields/src/Options.h:    data_names[MAXDATANAMES][MAXCHAR],// (5C)
RandomFields/src/Options.h:    x_names[MAXCOORDNAMES][MAXCHAR], // (6 C)
RandomFields/src/Options.h:    data_col_initial[MAXCHAR],
RandomFields/src/Options.h:    coord_initial[MAXCHAR],
RandomFields/src/Options.h:    cartesian_names[4][MAXCHAR],
RandomFields/src/Options.h:    earthcoord_names[4][MAXCHAR];
RandomFields/src/families.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/families.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/src/families.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/families.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/families.h:#define DISTR_NAME 0
RandomFields/src/families.h:#define SPHERIC_SPACEDIM 0
RandomFields/src/families.h:#define SPHERIC_BALLDIM 1
RandomFields/src/families.h:#define GAUSS_DISTR_MEAN 0
RandomFields/src/families.h:#define RECT_MINSTEPLENGTH 1
RandomFields/src/families.h:#define RECT_MAXSTEPS 2
RandomFields/src/families.h:#define RECT_MAXIT 4
RandomFields/src/families.h:#define RECT_INNERMIN 5
RandomFields/src/families.h:#define RECT_OUTERMAX 6
RandomFields/src/families.h:#define RECT_MCMC_N 7
RandomFields/src/families.h:#define RECT_NORMED 8 // unsused
RandomFields/src/families.h:#define SETPARAM_LOCAL 0
RandomFields/src/families.h:#define SET_PERFORMDO 0
RandomFields/src/families.h://#define SETPARAM_VARIANT 1
RandomFields/src/families.h://#define SETPARAM_FROM 1
RandomFields/src/families.h://#define SETPARAM_SET 2
RandomFields/src/families.h:#define UNIF_MIN 0
RandomFields/src/families.h:#define UNIF_MAX 1
RandomFields/src/families.h:#define UNIF_NORMED 2
Binary file RandomFields/src/zzz.o matches
Binary file RandomFields/src/Coordinate_systems.o matches
Binary file RandomFields/src/KeyInfo.o matches
RandomFields/src/startGetNset.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/startGetNset.cc: Copyright (C) 2001 -- 2017 Martin Schlather, 
RandomFields/src/startGetNset.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/startGetNset.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/startGetNset.cc:#include "QMath.h"
RandomFields/src/startGetNset.cc:int checkMissing(model *cov){
RandomFields/src/startGetNset.cc:  //  printf("%s%d\n", n, STRCMP(n, ADD_NA));
RandomFields/src/startGetNset.cc:	 STRCMP(n, ADD_NA) != 0 && // reserved word in convert.R 8.Okt.19
RandomFields/src/startGetNset.cc:	 (n[0] != ONEARGUMENT_NAME || n[1] != '\0') // reserved for standard parameter names
RandomFields/src/startGetNset.cc:	 && (n[0] != DEFAULT_SUBNAME || 
RandomFields/src/startGetNset.cc:  // assert(STRCMP(n, ELEMENT) || C->check == checkfix || C->check == checkmixed);
RandomFields/src/startGetNset.cc:  strcopyN(C->kappanames[i], n, PARAMMAXCHAR);
RandomFields/src/startGetNset.cc:  assert(STRCMP(n, FREEVARIABLE) || C->internal);
RandomFields/src/startGetNset.cc:  // if (t >= LISTOF) assert(STRCMP(C->kappanames[0], ELEMENT) == 0 
RandomFields/src/startGetNset.cc:	 type == MixedInputType ||
RandomFields/src/startGetNset.cc:  assert(type != MixedInputType);
RandomFields/src/startGetNset.cc:  assert(n[0] != ONEARGUMENT_NAME && n[0] != DEFAULT_SUBNAME);
RandomFields/src/startGetNset.cc:  assert(i < MAXSUB);
RandomFields/src/startGetNset.cc:  strcopyN(C->subnames[i], n, PARAMMAXCHAR);
RandomFields/src/startGetNset.cc:    if ((C->subintern[i] = STRCMP(C->kappanames[j], C->subnames[i]) == 0))
RandomFields/src/startGetNset.cc:    PMI(cov);//
RandomFields/src/startGetNset.cc:    PMI(cov);//
RandomFields/src/startGetNset.cc:    PMI(cov->calling); //
RandomFields/src/startGetNset.cc:    PMI(cov->calling);//
RandomFields/src/startGetNset.cc:#ifdef SCHLATHERS_MACHINE
RandomFields/src/startGetNset.cc:	 NAME(cov), COVNR, (Long) C->spectral , (Long) Errspectral);
RandomFields/src/startGetNset.cc:    PMI(cov->calling);//
RandomFields/src/startGetNset.cc:    PMI(cov->calling); //
RandomFields/src/startGetNset.cc:  ASSERT_NEWMODEL_NOT_NULL;
RandomFields/src/startGetNset.cc:      vdim = VDIM0;
RandomFields/src/startGetNset.cc:    int maxv = MIN(vdim, MAXMPPVDIM);
RandomFields/src/startGetNset.cc:      return addUnifModel(cov, 1.0, newmodel);
RandomFields/src/startGetNset.cc:  } else ILLEGAL_FRAME_STRUCT;
RandomFields/src/startGetNset.cc:  //  PMI(cov);
RandomFields/src/startGetNset.cc:	TRAFONR == MISMATCH || TRAFONR == UNSET ? "" : 
RandomFields/src/startGetNset.cc:	"NOTE THAT THE ERROR CAN ALSO BE CAUSED BY COORDINATE TRANSFORMATION\n"
RandomFields/src/startGetNset.cc:  SERR2("'%.50s' cannot be initialised (frame=%50s)", NAME(cov),
RandomFields/src/startGetNset.cc:	TYPE_NAMES[cov->frame]);
RandomFields/src/startGetNset.cc:  // SERR1("Init failed. Compound Poisson fields are essentially only programmed for simple and isotropic shape functions (not kernels). Error occurred in '%.50s'", NAME(cov));
RandomFields/src/startGetNset.cc:  //  PMI(cov);
RandomFields/src/startGetNset.cc:  SERR1("Call of init: Compound Poisson fields are essentially only programmed for domain and isotropic functions. Error occurred in '%.50s'", NAME(cov));
RandomFields/src/startGetNset.cc:      DORANDOM(sub, P(i));
RandomFields/src/startGetNset.cc:      XERR(ERRORNOTPROGRAMMEDYET);
RandomFields/src/startGetNset.cc:  if (PL >= PL_ERRORS) {PRINTF("do failed for %s:\n", NAME(cov));}
RandomFields/src/startGetNset.cc:  ERR1("call of do: compound Poisson fields are essentially only programmed for isotropic shape functions (not kernels). Error occurred in '%.10s'", NAME(cov));
RandomFields/src/startGetNset.cc:  if (PL >= PL_ERRORS) {PRINTF("do_random failed for %s:\n", NAME(cov));}
RandomFields/src/startGetNset.cc:  ERR1("Call of do: Compound Poisson fields are essentially only programmed for isotropic shape functions (not kernels). Error occurred in '%.10s'", NAME(cov));
RandomFields/src/startGetNset.cc:  if (hasPoissonFrame(cov) || hasMaxStableFrame(cov)) return;
RandomFields/src/startGetNset.cc:    // PMI(cov);
RandomFields/src/startGetNset.cc:				NICK(cov), TYPE_NAMES[cov->frame]);
RandomFields/src/startGetNset.cc:  char dummy[MAXCHAR];
RandomFields/src/startGetNset.cc:  int sl = STRLEN(CAT_TYPE_NAMES[type]);  
RandomFields/src/startGetNset.cc:  strcopyN(dummy, name, MAXCHAR-sl);
RandomFields/src/startGetNset.cc:  //printf("%s %s\n",  CAT_TYPE_NAMES[type], dummy);
RandomFields/src/startGetNset.cc:  SPRINTF(C->nick, "%.3s%.*s", CAT_TYPE_NAMES[type], MAXCHAR-4, dummy);
RandomFields/src/startGetNset.cc:#ifdef SCHLATHERS_MACHINE
RandomFields/src/startGetNset.cc:  if ((int) STRLEN(name) >= (int) MAXCHAR - sl) {
RandomFields/src/startGetNset.cc:  char dummy[MAXCHAR];
RandomFields/src/startGetNset.cc:  strcopyN(dummy, name, MAXCHAR);
RandomFields/src/startGetNset.cc:  if (STRLEN(name)>=MAXCHAR) {
RandomFields/src/startGetNset.cc:  assert(STRCMP(InternalName, name));
RandomFields/src/startGetNset.cc:void StandardCovMatrix(model *cov, bool ignore_y, double *v) { 
RandomFields/src/startGetNset.cc:    vdim = VDIM0;
RandomFields/src/startGetNset.cc:    XERR(ERRORMEMORYALLOCATION);
RandomFields/src/startGetNset.cc:   CovarianceMatrix(cov, ignore_y, v); 
RandomFields/src/startGetNset.cc://void StandardInverseCovMatrix(model *cov, double *inverse, double *det) { 
RandomFields/src/startGetNset.cc://  InverseCovMatrix(cov, inverse, det); 
RandomFields/src/startGetNset.cc:    dim = PREVLOGDIM(0); // !!und nicht OWNXDIM, xdimprev !!
RandomFields/src/startGetNset.cc:    dim = PREVLOGDIM(0); // !!und nicht OWNXDIM, xdimprev !!
RandomFields/src/startGetNset.cc:  if (VDIM0 != VDIM1 || OWNLASTSYSTEM != 0) BUG;
RandomFields/src/startGetNset.cc:  int vdim = VDIM0,
RandomFields/src/startGetNset.cc:    *v = (double*) MALLOC(bytes),
RandomFields/src/startGetNset.cc:    *wert = (double*) MALLOC(bytes);
RandomFields/src/startGetNset.cc:void InverseIsoMon(double VARIABLE_IS_NOT_USED *x, model *cov, double VARIABLE_IS_NOT_USED *v){
RandomFields/src/startGetNset.cc:  MEMCOPY(cov->allowedD, sub->allowedD, sizeof(allowedD_type));
RandomFields/src/startGetNset.cc:  MEMCOPY(cov->allowedI, sub->allowedI, sizeof(allowedI_type));
RandomFields/src/startGetNset.cc:bool allowedPrevModelI(model *cov) {
RandomFields/src/startGetNset.cc:  model *sub[MAXPARAM + MAXSUB];
RandomFields/src/startGetNset.cc:  if (isMathDef(C) && (C->cov==MathCos || C->cov==MathSin ||  C->cov==MathTan)
RandomFields/src/startGetNset.cc:  } // else printf("not ok: %s\n", NAME(cov));
RandomFields/src/startGetNset.cc:  assert(currentNrCov < MAXNRCOVFCTS);
RandomFields/src/startGetNset.cc:    // ERR1("maximum number of covariance models reached. Last included  model is '%.50s'.", DefList[MAXNRCOVFCTS-1].name);
RandomFields/src/startGetNset.cc:  assert((isotropy >= 0 && (isotropy != ISO_MISMATCH || equalsRandom(type))) 
RandomFields/src/startGetNset.cc:	 || isMathDef(type));
RandomFields/src/startGetNset.cc:  for (int i=0; i<MAXVARIANTS; i++) SYSTEM_NULL(C->systems[i], MAXSYSTEMS);
RandomFields/src/startGetNset.cc:  assert(maxdim >= SUBMODEL_DEP);
RandomFields/src/startGetNset.cc:#if MAXSYSTEMS == 1
RandomFields/src/startGetNset.cc:      monotone == COMPLETELY_MON) {
RandomFields/src/startGetNset.cc:    assert(LASTSYSTEM(C->systems[0]) == 0);
RandomFields/src/startGetNset.cc:    //   printf("name %s\n", name); PSYS(C->systems[C->variants]);  assert(STRCMP(C->name, "exp") != 0);
RandomFields/src/startGetNset.cc:  C->Dallowed = isSubModelD(domain) ? allowedDstandard : NULL;
RandomFields/src/startGetNset.cc:  C->Iallowed = isSubModelI(isotropy) ? allowedIstandard :
RandomFields/src/startGetNset.cc:    equalsPrevModelI(isotropy) ? allowedPrevModelI : NULL;
RandomFields/src/startGetNset.cc:  //if (domain == PARAM_DEP) printf("%s\n", C->nick);
RandomFields/src/startGetNset.cc:  assert(kappas >= 0 && kappas <= MAXPARAM);
RandomFields/src/startGetNset.cc:  assert(vdim >= SUBMODEL_DEP);
RandomFields/src/startGetNset.cc:  C->maxmoments = isShape(type) ? 0 : MISMATCH;
RandomFields/src/startGetNset.cc:    SPRINTF(C->kappanames[i], "%c%d", ONEARGUMENT_NAME, i); // default (repeated twice)
RandomFields/src/startGetNset.cc:    // UNBEDEINGT BIS ZUM SCHLUSS LAUFEN LASSEN, DA VERDECKTE PARAMTER
RandomFields/src/startGetNset.cc:    for (int i=0; i<MAXPARAM; i++) C->sortof_tab[i] = FORBIDDENPARAM;
RandomFields/src/startGetNset.cc:    for (int i=0; i<MAXPARAM; i++) C->sortof_tab[i] = ANYPARAM;
RandomFields/src/startGetNset.cc:  if (isMathDef(type)) {
RandomFields/src/startGetNset.cc:    for (int i=0; i<MAXPARAM; i++) {
RandomFields/src/startGetNset.cc:    for (int i=0; i<MAXPARAM; i++) {
RandomFields/src/startGetNset.cc:  for (int i=0; i<Forbidden; C->implemented[i++] = NOT_IMPLEMENTED);
RandomFields/src/startGetNset.cc:  C->Specific = isProcess(type) || isInterface(type) ? MISMATCH : UNSET;
RandomFields/src/startGetNset.cc:  assert(monotone != MON_MISMATCH || 
RandomFields/src/startGetNset.cc:	 (monotone == MON_MISMATCH && (type==RandomType || type== PointShapeType
RandomFields/src/startGetNset.cc:  // assert(monotone != PARAM_DEP);
RandomFields/src/startGetNset.cc:  C->Monotone = monotone;
RandomFields/src/startGetNset.cc:  C->ptwise_definite = !isShape(type) && type != MathDefType ? pt_mismatch
RandomFields/src/startGetNset.cc:    (isVariogram(type) && C->vdim == 1) // see also IncludeModel!
RandomFields/src/startGetNset.cc:  MEMCOPY(C->pref, pref, sizeof(pref_shorttype));
RandomFields/src/startGetNset.cc:  //C->density = MISMATCH;
RandomFields/src/startGetNset.cc:    isInterface(type) ? MISMATCH : UNSET;
RandomFields/src/startGetNset.cc:  //    type == MathDefType) C->logD = standard_likelihood;
RandomFields/src/startGetNset.cc:  if (LASTSYSTEM(C->systems[0]) == 0) {
RandomFields/src/startGetNset.cc:  C->covmatrix = StandardCovMatrix;
RandomFields/src/startGetNset.cc:  //  C->inversecovmatrix = StandardInverseCovMatrix;
RandomFields/src/startGetNset.cc:  C->TaylorN = C->TailN = isShape(type) ? UNSET : MISMATCH;
RandomFields/src/startGetNset.cc:int CopyModel(const char *name, int which) {
RandomFields/src/startGetNset.cc:  MEMCOPYX(DefList + currentNrCov, DefList + which, sizeof(defn)); 
RandomFields/src/startGetNset.cc:int CopyModel(const char *name, int which, Types type) {
RandomFields/src/startGetNset.cc:  CopyModel(name, which);
RandomFields/src/startGetNset.cc:int CopyModel(const char *name, int which, checkfct check) {  
RandomFields/src/startGetNset.cc:  CopyModel(name, which);
RandomFields/src/startGetNset.cc:  int CopyModel(const char *name, int which, checkfct check) {
RandomFields/src/startGetNset.cc:  CopyModel(name, which);
RandomFields/src/startGetNset.cc:  assert(type <= MathDefType);
RandomFields/src/startGetNset.cc:int IncludeModel(const char *name, Types type, int minsub, int maxsub,
RandomFields/src/startGetNset.cc:  assert(!isPrevModelI(isotropy) || maxsub != 0 || isMathDef(type)
RandomFields/src/startGetNset.cc:	 || STRCMP("shape", name) == 0
RandomFields/src/startGetNset.cc:	 || STRCMP("U", name) == 0 
RandomFields/src/startGetNset.cc:	 || STRCMP("declare", name) == 0 
RandomFields/src/startGetNset.cc:	 || STRCMP("whittle", name) == 0 
RandomFields/src/startGetNset.cc:	 || STRCMP("matern", name) == 0 
RandomFields/src/startGetNset.cc:	 || STRCMP("idcoord", name) == 0
RandomFields/src/startGetNset.cc:	 || STRCMP("constant", name) == 0);
RandomFields/src/startGetNset.cc:  assert(maxsub >= minsub && maxsub <= MAXSUB);
RandomFields/src/startGetNset.cc:    not primitive: biWM 
RandomFields/src/startGetNset.cc:int IncludeModel(const char *name, Types type, int minsub, int maxsub,
RandomFields/src/startGetNset.cc:  return IncludeModel(name, type, minsub, maxsub, kappas, kappasize,
RandomFields/src/startGetNset.cc:int IncludeModelR(const char *name, Types type, int minsub, int maxsub,
RandomFields/src/startGetNset.cc:  return IncludeModel(name, type, minsub, maxsub, kappas, kappasize,
RandomFields/src/startGetNset.cc:    IncludeModel(name, type, minsub, maxsub, kappas,
RandomFields/src/startGetNset.cc:   if (isManifold(SYSTYPE(C->systems[0], 0))) return false;
RandomFields/src/startGetNset.cc:  if (C->variants >= MAXVARIANTS) return false;
RandomFields/src/startGetNset.cc:  if (nr != BIND && isSubModelD(DOM(C->systems[0], 0))) return false;
RandomFields/src/startGetNset.cc:  if (LASTSYSTEM(C->systems[0]) > 0) BUG;
RandomFields/src/startGetNset.cc:   if (isPrevModelI(C) || isPrevModelI(iso)) {
RandomFields/src/startGetNset.cc:	SYSTYPE(C->systems[0], 0) != MathDefType &&
RandomFields/src/startGetNset.cc:	C->check != checkMatern &&
RandomFields/src/startGetNset.cc:	C->check != checkWM &&
RandomFields/src/startGetNset.cc:  int n = SYSTEMS(C->systems[C->variants - 1]);
RandomFields/src/startGetNset.cc:     !isMathDef(C)) 
RandomFields/src/startGetNset.cc:       || C->Monotone == COMPLETELY_MON)) return false;
RandomFields/src/startGetNset.cc:	     LOGDIM(C->systems[0], 0),
RandomFields/src/startGetNset.cc:	     MAXDIM(C->systems[0], 0),
RandomFields/src/startGetNset.cc:	     XDIM(C->systems[0], 0),
RandomFields/src/startGetNset.cc:	     DOM(C->systems[0], 0),
RandomFields/src/startGetNset.cc:  // PSYS(C->systems[C->variants]);  assert(STRCMP(C->name, "exp") != 0);
RandomFields/src/startGetNset.cc:#define IMPLEMENTED_CE							\
RandomFields/src/startGetNset.cc:  ( (anyVariant(isPosDef, C) || anyVariant(isManifold, C)) &&		\
RandomFields/src/startGetNset.cc:    !equalsKernel(DOM(C->systems[0], 0)) )
RandomFields/src/startGetNset.cc:#define IMPLEMENTED_SEQUENTIAL (C->vdim <= 1 &&	IMPLEMENTED_CE)
RandomFields/src/startGetNset.cc:  C->implemented[CircEmbed] = IMPLEMENTED_CE;
RandomFields/src/startGetNset.cc:  C->implemented[Sequential] = IMPLEMENTED_SEQUENTIAL;
RandomFields/src/startGetNset.cc:    assert(isSpaceIsotropic(C->systems[0])|| isSubModelI(C) ||
RandomFields/src/startGetNset.cc:	   isPrevModelI(C) || isParamDepI(C));
RandomFields/src/startGetNset.cc:    // C->implemented[TBM2] = NUM_APPROX;
RandomFields/src/startGetNset.cc:    C->implemented[TBM] = true; 
RandomFields/src/startGetNset.cc:  else if (isMonotone(C->Monotone) && isIsotropic(C->systems[0]) && 
RandomFields/src/startGetNset.cc:    C->inverse = InverseIsoMon;
RandomFields/src/startGetNset.cc:  //  printf("here %s posdef=%d mani=%d xonly=%d prevD=%d\n", C->name, anyVariant(isPosDef, C), anyVariant(isManifold, C),  isXonly(DOM(C->systems[0], 0)), isPrevModelD(DOM(C->systems[0], 0)) );
RandomFields/src/startGetNset.cc:  C->implemented[CircEmbed] = cf != NULL && IMPLEMENTED_CE;
RandomFields/src/startGetNset.cc:  C->implemented[Sequential] = IMPLEMENTED_SEQUENTIAL;
RandomFields/src/startGetNset.cc:  assert(equalsDomMismatch(DOM(C->systems[0], 0)));
RandomFields/src/startGetNset.cc:  assert(equalsIsoMismatch(ISO(C->systems[0], 0)));
RandomFields/src/startGetNset.cc:    set_dom(C->systems[0], 0, PREVMODEL_D);
RandomFields/src/startGetNset.cc:  assert(equalsXonly(DOM(C->systems[0], 0)));
RandomFields/src/startGetNset.cc:  MEMCOPY(C, C - 1, sizeof(defn));
RandomFields/src/startGetNset.cc:  strcopyN(CovNames[currentNrCov], InternalName, MAXCHAR);
RandomFields/src/startGetNset.cc:  strcopyN(C->name + 1, DefList[currentNrCov-1].name, MAXCHAR - 1);
RandomFields/src/startGetNset.cc:  C->RS_derivs = MISMATCH;
RandomFields/src/startGetNset.cc:  C->internal = true; // addCov is used without previous call of IncludeModel
RandomFields/src/startGetNset.cc:  MEMCOPY(C, C - 1, sizeof(defn));
RandomFields/src/startGetNset.cc:  assert(C->vdim == SCALAR || C->vdim == SUBMODEL_DEP ||
RandomFields/src/startGetNset.cc:	 C->vdim == PARAM_DEP || D == NULL);
RandomFields/src/startGetNset.cc:  strcopyN(CovNames[currentNrCov], InternalName, MAXCHAR);
RandomFields/src/startGetNset.cc:  strcopyN(C->name + 1, DefList[currentNrCov-1].name, MAXCHAR - 1);
RandomFields/src/startGetNset.cc:    assert(isSpaceIsotropic(C->systems[0]) || isPrevModelI(C) ||isSubModelI(C));
RandomFields/src/startGetNset.cc:    //C->implemented[TBM2] = NUM_APPROX;
RandomFields/src/startGetNset.cc:    C->implemented[TBM] = IMPLEMENTED; 
RandomFields/src/startGetNset.cc:  C->internal = true; // addCov is used without previous call of IncludeModel
RandomFields/src/startGetNset.cc:void Implemented(Methods Meth) {
RandomFields/src/startGetNset.cc:  C->implemented[Meth] = true;
RandomFields/src/startGetNset.cc:  assert(C->vdim == SCALAR || C->vdim == SUBMODEL_DEP || 
RandomFields/src/startGetNset.cc:	 C->vdim == PARAM_DEP || nabla==NULL);
RandomFields/src/startGetNset.cc:#define ASSERT_TBM  \
RandomFields/src/startGetNset.cc:  /* // printf("assert_tbm %s %d %d %d %d\n", C->name, isPrevModelD(DOM(C->systems[0], 0)), anyVariant(isPosDef, C), anyVariant(isManifold, C), isXonly(DOM(C->systems[0], 0))); */ \
RandomFields/src/startGetNset.cc:  assert(equalsPrevModelD(DOM(C->systems[0], 0)) ||			\
RandomFields/src/startGetNset.cc:	 isSubModelD(DOM(C->systems[0], 0)) ||				\
RandomFields/src/startGetNset.cc:	 equalsParamDepD(DOM(C->systems[0], 0)) ||			\
RandomFields/src/startGetNset.cc: 	 ((anyVariant(isPosDef, C) || anyVariant(isManifold, C))	\
RandomFields/src/startGetNset.cc:	  && equalsXonly(DOM(C->systems[0], 0))));			\
RandomFields/src/startGetNset.cc:  /* // printf("%d %d %d\n", C->vdim == SCALAR, C->vdim == SUBMODEL_DEP,	C->vdim == PARAM_DEP) ;	*/ \
RandomFields/src/startGetNset.cc:  assert(C->vdim == SCALAR || C->vdim == SUBMODEL_DEP ||		\
RandomFields/src/startGetNset.cc:	 C->vdim == PARAM_DEP)					
RandomFields/src/startGetNset.cc:int addTBM(covfct tbm2) { 
RandomFields/src/startGetNset.cc:  ASSERT_TBM; 
RandomFields/src/startGetNset.cc:    // addTBM is called from the other addTBM's -- so tbm2 might
RandomFields/src/startGetNset.cc:    assert(isSpaceIsotropic(C->systems[0]) ||isPrevModelI(C) || isSubModelI(C));
RandomFields/src/startGetNset.cc:    C->implemented[TBM] = IMPLEMENTED;
RandomFields/src/startGetNset.cc:    if (C->pref[TBM] == PREF_NONE) C->pref[TBM] = PREF_BEST;
RandomFields/src/startGetNset.cc:  // IMPLEMENTED must imply the NUM_APPROX to simplify the choice
RandomFields/src/startGetNset.cc:  // between TBM2 and Tbm2Num
RandomFields/src/startGetNset.cc:void addTBM(covfct tbm2, initfct Init, spectral_do spectralDo) {
RandomFields/src/startGetNset.cc:  int nr = addTBM(tbm2);
RandomFields/src/startGetNset.cc:  ASSERT_TBM;
RandomFields/src/startGetNset.cc:  C->implemented[SpectralTBM] = true;
RandomFields/src/startGetNset.cc:  if (C->pref[SpectralTBM] == PREF_NONE) C->pref[SpectralTBM] = PREF_BEST;
RandomFields/src/startGetNset.cc:void addTBM(int maxmoments, covfct tbm2, initfct Init, spectral_do spectralDo) {
RandomFields/src/startGetNset.cc:  int nr = addTBM(tbm2);
RandomFields/src/startGetNset.cc:  addTBM(tbm2, Init, spectralDo);
RandomFields/src/startGetNset.cc:  assert(maxmoments >= SUBMODEL_DEP);
RandomFields/src/startGetNset.cc:void addTBM(initfct Init, spectral_do spectralDo) {
RandomFields/src/startGetNset.cc:  addTBM((covfct) NULL, Init, spectralDo);
RandomFields/src/startGetNset.cc:  nickname(X->nick + STRLEN(CAT_TYPE_NAMES[SYSTYPE(X->systems[0], 0)]));
RandomFields/src/startGetNset.cc:    assert(X->Specific == MISMATCH ||X->Specific == UNSET || X->Specific == nr);
RandomFields/src/startGetNset.cc:    X->implemented[Specific] = IMPLEMENTED;
RandomFields/src/startGetNset.cc://void addSpecialMeth(initstandard initspecial, dometh special)  {
RandomFields/src/startGetNset.cc:  assert(maxmoments >= SUBMODEL_DEP || maxmoments == UNSET);
RandomFields/src/startGetNset.cc:    if (C->Specific == MISMATCH ||  C->Specific == UNSET) C->Specific = nr;
RandomFields/src/startGetNset.cc:    C->Specific = isProcess(type) || isInterface(type) ? MISMATCH : UNSET;
RandomFields/src/startGetNset.cc:  RandomShape(PARAM_DEP, Struct, initOK, doOK,  do_random_failed, 
RandomFields/src/startGetNset.cc:  RandomShape(PARAM_DEP, Struct, initOK, doOK, do_random_failed,
RandomFields/src/startGetNset.cc:void addGaussMixture(draw_random drawmix,
RandomFields/src/startGetNset.cc:void addReturns(return_covmat CovMatrix, ext_bool_ret_fct isCovMatrix) {
RandomFields/src/startGetNset.cc:  if (CovMatrix!=NULL) {
RandomFields/src/startGetNset.cc:    C->covmatrix=CovMatrix;
RandomFields/src/startGetNset.cc:    C->is_covmatrix = isCovMatrix==NULL ? isFalse : isCovMatrix;
RandomFields/src/startGetNset.cc:  } else assert(isCovMatrix==NULL);
RandomFields/src/startGetNset.cc:  assert(C->TailN <= MAXTAYLOR);
RandomFields/src/startGetNset.cc:  if (isPosDef(type) || isManifold(type)) {
RandomFields/src/startGetNset.cc:  assert(C->TaylorN <= MAXTAYLOR);
RandomFields/src/startGetNset.cc:  assert(C->TaylorN <= MAXTAYLOR);
RandomFields/src/startGetNset.cc:  assert(C->TaylorN <= MAXTAYLOR);
RandomFields/src/startGetNset.cc:	 DefList[nr].Iallowed == allowedPrevModelI);
RandomFields/src/startGetNset.cc:  MEMSET(I, 0, sizeof(allowedI_type)); // default is false
RandomFields/src/startGetNset.cc:	    : ISO_MISMATCH);
RandomFields/src/startGetNset.cc:	    : ISO_MISMATCH);
RandomFields/src/startGetNset.cc:    set_xdim(OWN, 0, PREVXDIM(0));
RandomFields/src/startGetNset.cc:Types TypeGaussMethod(Types required, model VARIABLE_IS_NOT_USED *cov,
RandomFields/src/startGetNset.cc:  return equalsProcess(required) || equalsGaussMethod(required) ?
RandomFields/src/startGetNset.cc:    GaussMethodType : BadType;
RandomFields/src/AutoRandomFields.h:#define MAXCHAR_RF MAXCHAR // max number of characters for (covariance) names  
RandomFields/src/AutoRandomFields.h:#define METHODMAXCHAR MAXCHAR // max number of character to describe a Method (including \0)
RandomFields/src/AutoRandomFields.h:#define MAXPARAM 20
RandomFields/src/AutoRandomFields.h:#define MAXSUB 10
RandomFields/src/AutoRandomFields.h:#define MAXCEDIM 13
RandomFields/src/AutoRandomFields.h:#define MAXTBMSPDIM 4
RandomFields/src/AutoRandomFields.h:#define MAXMPPDIM 4
RandomFields/src/AutoRandomFields.h:#define MAXBOXCOXVDIM 10  // immer >= 1 
RandomFields/src/AutoRandomFields.h:#define MAXHYPERDIM 4
RandomFields/src/AutoRandomFields.h:#define MAXVARIODIM 20
RandomFields/src/AutoRandomFields.h:#define MAXACCEPTED 1e300
RandomFields/src/AutoRandomFields.h:#define MAXVARIANTS 6
RandomFields/src/AutoRandomFields.h:#define MAXSYSTEMS 1
RandomFields/src/AutoRandomFields.h:#define MAXDATANAMES 5
RandomFields/src/AutoRandomFields.h:#define MAXMPPVDIM 9 // just to distinguish, 9 has no meaning
RandomFields/src/AutoRandomFields.h:#define MAXCOORDNAMES 4
RandomFields/src/AutoRandomFields.h:// ignoreValues: keine Auswertung -- darf bei RMfix nur zur Auswertungszeit
RandomFields/src/AutoRandomFields.h:#define PARAM_DEP -1 // parameter dependent fuer vdim, finiterange, etc; for DefList only, falls von submodel und param abhaengig, so submodel_dep 
RandomFields/src/AutoRandomFields.h:#define PREVMODEL_DEP -2 // NIE AENDERN!
RandomFields/src/AutoRandomFields.h:#define SUBMODEL_DEP -3  // // NIE AENDERN! immer, wenn zumindest submodel dependence
RandomFields/src/AutoRandomFields.h:#define MISMATCH -4 // NIE AENDERN!
RandomFields/src/AutoRandomFields.h:typedef enum domain_type { // IF CHANGED CHANGE ALSO RFgetModelNames
RandomFields/src/AutoRandomFields.h:  XONLY, KERNEL, PREVMODEL_D, SUBMODEL_D, PREV_SUB_D, PARAMDEP_D, KEEPCOPY_DOM, 
RandomFields/src/AutoRandomFields.h:  DOMAIN_MISMATCH // always last ! 
RandomFields/src/AutoRandomFields.h:#define FIRST_DOMAIN XONLY
RandomFields/src/AutoRandomFields.h:#define LAST_DOMAINUSER KERNEL
RandomFields/src/AutoRandomFields.h:#define LAST_DOMAIN DOMAIN_MISMATCH
RandomFields/src/AutoRandomFields.h:  SYMMETRIC , //"stationary" only if XONLY; in the covariance sense if multivariate!
RandomFields/src/AutoRandomFields.h:  GNOMONIC_PROJ ,   // RC 5, projection on the plane
RandomFields/src/AutoRandomFields.h:  SPHERICAL_SYMMETRIC , 
RandomFields/src/AutoRandomFields.h:  EARTH_SYMMETRIC  ,
RandomFields/src/AutoRandomFields.h:  //  LOGCART_SYMMETRIC,
RandomFields/src/AutoRandomFields.h:  PREVMODEL_I ,  // 15, type taken from submodels
RandomFields/src/AutoRandomFields.h:  SUBMODEL_I, // if model is both, submodel_dep and param_dep set submodel_i;
RandomFields/src/AutoRandomFields.h:              // if both PREV_MODEL_I and SUBMODEL_I, submodel_dep has
RandomFields/src/AutoRandomFields.h:  PARAMDEP_I, // purely paramdep, not submodel_dep
RandomFields/src/AutoRandomFields.h:  ISO_MISMATCH // always last ! 
RandomFields/src/AutoRandomFields.h:#define LAST_REDUCEDXDIM_CART DOUBLEISOTROPIC
RandomFields/src/AutoRandomFields.h:#define FIRST_PROJECTION GNOMONIC_PROJ
RandomFields/src/AutoRandomFields.h:#define LAST_PROJECTION ORTHOGRAPHIC_PROJ // danach MUSS sphaerisch kommen!!
RandomFields/src/AutoRandomFields.h:#define LAST_CARTESIAN LAST_PROJECTION // danach MUSS sphaerisch kommen!!
RandomFields/src/AutoRandomFields.h://#define FIRST_LOGCART LOGCART_SYMMETRIC
RandomFields/src/AutoRandomFields.h:#define LAST_ISO ISO_MISMATCH
RandomFields/src/AutoRandomFields.h:  MON_UNSET = UNSET,
RandomFields/src/AutoRandomFields.h:  MON_MISMATCH = MISMATCH,
RandomFields/src/AutoRandomFields.h:  MON_SUB_DEP = SUBMODEL_DEP,
RandomFields/src/AutoRandomFields.h:  MON_PREV_DEP = PREVMODEL_DEP,
RandomFields/src/AutoRandomFields.h:  MON_PARAMETER = PARAM_DEP,
RandomFields/src/AutoRandomFields.h:  NOT_MONOTONE = 0,
RandomFields/src/AutoRandomFields.h:  MONOTONE = 1,
RandomFields/src/AutoRandomFields.h:  GNEITING_MON = 2, // Euclid's hat, Gneiting, J.Mult.Anal. 69, 1999
RandomFields/src/AutoRandomFields.h:  NORMAL_MIXTURE = 3,
RandomFields/src/AutoRandomFields.h:  COMPLETELY_MON = 4,
RandomFields/src/AutoRandomFields.h:#define MONOTONE_TOTAL (BERNSTEIN - MON_UNSET + 1)
RandomFields/src/AutoRandomFields.h:#define MAXFIELDS 10
RandomFields/src/AutoRandomFields.h:#define MODEL_USER (MAXFIELDS + 0)  // for user call of Covariance etc.
RandomFields/src/AutoRandomFields.h:#define MODEL_COV (MAXFIELDS + 1)
RandomFields/src/AutoRandomFields.h:#define MODEL_COVMATRIX (MAXFIELDS + 2)
RandomFields/src/AutoRandomFields.h:#define MODEL_VARIOGRAM (MAXFIELDS + 3)
RandomFields/src/AutoRandomFields.h:#define MODEL_PSEUDO (MAXFIELDS + 4)
RandomFields/src/AutoRandomFields.h:#define MODEL_FCTN (MAXFIELDS + 5)
RandomFields/src/AutoRandomFields.h:#define MODEL_DISTR (MAXFIELDS + 6)
RandomFields/src/AutoRandomFields.h:#define MODEL_CALC (MAXFIELDS + 7)
RandomFields/src/AutoRandomFields.h:#define LAST_MODEL_USER (MAXFIELDS + 9)
RandomFields/src/AutoRandomFields.h:#define FIRST_INTERNAL (LAST_MODEL_USER + 1)
RandomFields/src/AutoRandomFields.h:#define MODEL_AUX  (FIRST_INTERNAL + 0)  // auxiliary in fitgauss.R & plot
RandomFields/src/AutoRandomFields.h:#define MODEL_INTERN (FIRST_INTERNAL+1)//for kriging, etc; internal call of cov 
RandomFields/src/AutoRandomFields.h:#define MODEL_SPLIT (FIRST_INTERNAL + 2)// split cov model & other aux methods 
RandomFields/src/AutoRandomFields.h:#define MODEL_GUI (FIRST_INTERNAL + 3)   // RFgui 
RandomFields/src/AutoRandomFields.h:#define MODEL_MLE (FIRST_INTERNAL + 4) // mle covariance model 
RandomFields/src/AutoRandomFields.h:#define MODEL_MLESPLIT (FIRST_INTERNAL + 5)  // ="= 
RandomFields/src/AutoRandomFields.h:#define MODEL_LSQ (FIRST_INTERNAL + 6)  // used in fitgauss for variogram calc
RandomFields/src/AutoRandomFields.h:#define MODEL_BOUNDS (FIRST_INTERNAL + 7)  // MLE, lower, upper 
RandomFields/src/AutoRandomFields.h:#define MODEL_PREDICT (FIRST_INTERNAL + 8)
RandomFields/src/AutoRandomFields.h:#define MODEL_ERR (FIRST_INTERNAL + 10)
RandomFields/src/AutoRandomFields.h:#define MODEL_MAX MODEL_ERR  
RandomFields/src/AutoRandomFields.h:typedef enum Types { // IF CHANGED, CHANGE RFgetModelNames!
RandomFields/src/AutoRandomFields.h:  ManifoldType, // Bedeutung: C->Type:TypeFct existiert; cov->typus:ungesetzt
RandomFields/src/AutoRandomFields.h:  ProcessType, GaussMethodType, // # 10
RandomFields/src/AutoRandomFields.h:  BrMethodType, // change also rf_globals.R if deleted
RandomFields/src/AutoRandomFields.h:  MathDefType, // 19
RandomFields/src/AutoRandomFields.h:  MixedInputType, // 28.4.2019 likely obsolete
RandomFields/src/AutoRandomFields.h:  NN3, NN4 // 30, for use in generateMmodels only
RandomFields/src/AutoRandomFields.h:/* FRAMES: calls from within the respective processes
RandomFields/src/AutoRandomFields.h:  ProcessType, GaussMethodType, // 
RandomFields/src/AutoRandomFields.h:  BrMethodType, // 
RandomFields/src/AutoRandomFields.h:#define nVAR2COV_METHODS 4
RandomFields/src/AutoRandomFields.h:  VARPARAM,  // 0
RandomFields/src/AutoRandomFields.h:  SIGNEDVARPARAM, //1
RandomFields/src/AutoRandomFields.h:  SDPARAM, //2
RandomFields/src/AutoRandomFields.h:  SIGNEDSDPARAM, // 0..3
RandomFields/src/AutoRandomFields.h:  SCALEPARAM, //4
RandomFields/src/AutoRandomFields.h:  DIAGPARAM, // 5
RandomFields/src/AutoRandomFields.h:  ANISOPARAM, // 4..6
RandomFields/src/AutoRandomFields.h:  INTEGERPARAM,//7
RandomFields/src/AutoRandomFields.h:  ANYPARAM, //8
RandomFields/src/AutoRandomFields.h:  TRENDPARAM, 
RandomFields/src/AutoRandomFields.h:  CRITICALPARAM, 
RandomFields/src/AutoRandomFields.h:  DONOTVERIFYPARAM,  // lists arguments and worse; not used in MLE!
RandomFields/src/AutoRandomFields.h:  FORBIDDENPARAM, // still a possible user input!! just estimation is forbidden
RandomFields/src/AutoRandomFields.h:  UNKNOWNPARAM,
RandomFields/src/AutoRandomFields.h:  VARONLYMLE, // same as VARPARAM, but not returned
RandomFields/src/AutoRandomFields.h:  CRITONLYMLE, // same as CRITICAL, but not returned
RandomFields/src/AutoRandomFields.h:  ONLYMLE, // not returned  -- never delete this value from the list
RandomFields/src/AutoRandomFields.h:  IGNOREPARAM, // neither recognised in MLE nor returned by key
RandomFields/src/AutoRandomFields.h:  INCLUDENOTRETURN, // STANDARD + those marked with IGNOREPARAM
RandomFields/src/AutoRandomFields.h:  INTERNALPARAMETERS, //only those that have the INTERNAL_PARAM name
RandomFields/src/AutoRandomFields.h:  ALLPARAMETERS, //really all parameters
RandomFields/src/AutoRandomFields.h:  NOPARAMETERS // no parameter at all
RandomFields/src/AutoRandomFields.h:#define LASTRETURNED FORBIDDENPARAM
RandomFields/src/AutoRandomFields.h:#define FIRSTONLYMLE VARONLYMLE
RandomFields/src/AutoRandomFields.h:#define LASTONLYMLE ONLYMLE
RandomFields/src/AutoRandomFields.h:#define LASTUSERSORTOF FORBIDDENPARAM
RandomFields/src/AutoRandomFields.h:#define LASTSORTOF NOPARAMETERS
RandomFields/src/AutoRandomFields.h:typedef enum Methods {
RandomFields/src/AutoRandomFields.h:  TBM,           // Turning Bands, performed in 2 or 3 dimensions 
RandomFields/src/AutoRandomFields.h:  SpectralTBM,   // Spectral turning bands, only 2 dimensional
RandomFields/src/AutoRandomFields.h:  RandomCoin,    // "additive MPP (random coins)"  // 10
RandomFields/src/AutoRandomFields.h:  Specific,      // Specific Methods 
RandomFields/src/AutoRandomFields.h:  Nothing,       // (*) erstes nach den echten Methoden !!!
RandomFields/src/AutoRandomFields.h:} Methods;
RandomFields/src/AutoRandomFields.h://                    (3) method is not shown, if ErrorMessage is called with
RandomFields/src/AutoRandomFields.h:  original_model, // only one used in ML estimation
RandomFields/src/AutoRandomFields.h:#define INTERNAL_PARAM "internal" // in particular to use
RandomFields/src/AutoRandomFields.h:#define GETMODEL_AS_SAVED 0    
RandomFields/src/AutoRandomFields.h:#define GETMODEL_DEL_NATSC 1   
RandomFields/src/AutoRandomFields.h:#define GETMODEL_SOLVE_NATSC 2
RandomFields/src/AutoRandomFields.h:#define GETMODEL_DEL_MLE 3
RandomFields/src/AutoRandomFields.h:#define GETMODEL_SOLVE_MLE 4
RandomFields/src/AutoRandomFields.h:#define MIXED_X_NAME "X"
RandomFields/src/AutoRandomFields.h:#define MIXED_BETA_NAME "beta"
RandomFields/src/AutoRandomFields.h:#define COVARIATE_C_NAME "data"
RandomFields/src/AutoRandomFields.h:#define COVARIATE_X_NAME "x"
RandomFields/src/AutoRandomFields.h:#define COVARIATE_RAW_NAME "raw"
RandomFields/src/AutoRandomFields.h:#define COVARIATE_EXTRA_DATA_NAME "extra_data"
RandomFields/src/AutoRandomFields.h:#define COVARIATE_ADDNA_NAME "addNA"
RandomFields/src/AutoRandomFields.h:#define COVARIATE_NAME_NAME "name"
RandomFields/src/AutoRandomFields.h:#define COVARIATE_DATA_NAME "data"
RandomFields/src/AutoRandomFields.h:#define CONST_A_NAME "x"
RandomFields/src/AutoRandomFields.h:#define MINMAX_PMIN 1 // already in R coding
RandomFields/src/AutoRandomFields.h:#define MINMAX_PMAX 2
RandomFields/src/AutoRandomFields.h:#define MINMAX_TYPE 3
RandomFields/src/AutoRandomFields.h:#define MINMAX_NAN 4
RandomFields/src/AutoRandomFields.h:#define MINMAX_MIN 5
RandomFields/src/AutoRandomFields.h:#define MINMAX_MAX 6
RandomFields/src/AutoRandomFields.h:#define MINMAX_OMIN 7
RandomFields/src/AutoRandomFields.h:#define MINMAX_OMAX 8
RandomFields/src/AutoRandomFields.h:#define MINMAX_ROWS 9
RandomFields/src/AutoRandomFields.h:#define MINMAX_COLS 10
RandomFields/src/AutoRandomFields.h:#define MINMAX_BAYES 11
RandomFields/src/AutoRandomFields.h:#define MINMAX_COORD 12
RandomFields/src/AutoRandomFields.h:#define MINMAX_ENTRIES MINMAX_COORD
RandomFields/src/AutoRandomFields.h:#define XLIST_SPATIALDIM 3
RandomFields/src/AutoRandomFields.h:#define XLIST_TIME 4
RandomFields/src/AutoRandomFields.h:#define XLIST_RELEVANT_ELMTS (XLIST_GRIDY + 1)
RandomFields/src/AutoRandomFields.h:#define PROJ_TIME -2
RandomFields/src/AutoRandomFields.h:#define VAR2COV_EXTREMAL -1
RandomFields/src/AutoRandomFields.h:#define VAR2COV_METHODS 3
RandomFields/src/AutoRandomFields.h:#define VARIOGRAM -2// RC NEVER change ordering nor values!! 
RandomFields/src/AutoRandomFields.h:#define MADOGRAM -1// RC 
RandomFields/src/AutoRandomFields.h:#define PSEUDOMADOGRAM 1 // RC NEVER change ordering nor values!! 
RandomFields/src/AutoRandomFields.h:#define ALPHAPSEUDOMADOGRAM 3// for internal purposes only
RandomFields/src/AutoRandomFields.h://#define RMCOV_X 0
RandomFields/src/AutoRandomFields.h://#define RMCOV_A 1
RandomFields/src/AutoRandomFields.h:#define POISSON_SCATTER_OPTIM 0
RandomFields/src/AutoRandomFields.h:#define nEQ_NAMES 6
RandomFields/src/AutoRandomFields.h:extern const char *ISO_NAMES[LAST_ISO + 1],
RandomFields/src/AutoRandomFields.h:  *EQ_NAMES[nEQ_NAMES],
RandomFields/src/AutoRandomFields.h:  *OPTIMISER_NAMES[nOptimiser], *NLOPTR_NAMES[nNLOPTR],
RandomFields/src/AutoRandomFields.h:  *LIKELIHOOD_NAMES[nLikelihood],
RandomFields/src/AutoRandomFields.h:  *DUPLICATEDLOC_NAMES[nDuplicatedloc],
RandomFields/src/AutoRandomFields.h:  *DOMAIN_NAMES[LAST_DOMAIN + 1],
RandomFields/src/AutoRandomFields.h:  *TYPE_NAMES[LASTTYPE + 1],
RandomFields/src/AutoRandomFields.h:  *MONOTONE_NAMES[MONOTONE_TOTAL] ,
RandomFields/src/AutoRandomFields.h:  *MODE_NAMES[nr_modes], *OUTPUTMODE_NAMES[nr_output_modes], 
RandomFields/src/AutoRandomFields.h:  *ANGLE_NAMES[last_angle_mode + 1],
RandomFields/src/AutoRandomFields.h:  *REPORTCOORD_NAMES[nr_reportcoord_modes],
RandomFields/src/AutoRandomFields.h:  *UNITS_NAMES[nr_units], 
RandomFields/src/AutoRandomFields.h:  *COORD_SYS_NAMES[nr_coord_sys],
RandomFields/src/AutoRandomFields.h:  *CARTESIAN_SYS_NAMES[3],
RandomFields/src/AutoRandomFields.h:  *PROJECTION_NAMES[nProjections],
RandomFields/src/AutoRandomFields.h:  *TYPEOF_PARAM_NAMES[LASTSORTOF + 1],
RandomFields/src/AutoRandomFields.h:  *NAMES_OF_NAMES[nNamesOfNames],
RandomFields/src/AutoRandomFields.h:  *RMCOV_X[nVAR2COV_METHODS],
RandomFields/src/AutoRandomFields.h:  *FCTN_TYPE_NAMES[TOTAL_FCTN_TYPE],
RandomFields/src/AutoRandomFields.h:  *POISSON_SCATTER_NAMES[nPOISSON_SCATTER];
RandomFields/src/AutoRandomFields.h:#define NEIGHB_MIN 0
RandomFields/src/AutoRandomFields.h:#define NEIGHB_MED NEIGHB_SPLIT
RandomFields/src/AutoRandomFields.h:#define NEIGHB_MAX 2
RandomFields/src/AutoRandomFields.h:#define BR_NAME "brownresnick"
RandomFields/src/AutoRandomFields.h:#define EG_NAME "schlather"
RandomFields/src/AutoRandomFields.h:#define OPITZ_NAME "opitz"
RandomFields/src/AutoRandomFields.h:#define SMITH_NAME "smith"
RandomFields/src/AutoRandomFields.h:#define MAX_NA 100
RandomFields/src/shape.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/shape.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/src/shape.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/shape.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/shape.h:// MPP operator 
RandomFields/src/shape.h:#define ZHOU_INFTY_SMALL 2
RandomFields/src/shape.h:#define ZHOU_NORMED 3
RandomFields/src/shape.h:#define SHAPE_FCT_MEAN 0
RandomFields/src/shape.h:#define COVARIATE_NAME 6
RandomFields/src/shape.h:#define FIXCOV_M COVARIATE_C // never change
RandomFields/src/zzz.c: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/zzz.c: Copyright (C) 2015 -- 2017 Martin Schlather, Reinhard Furrer
RandomFields/src/zzz.c:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/zzz.c:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/zzz.c:static const R_CMethodDef cMethods[]  = {  
RandomFields/src/zzz.c:  CDEF(GetModelName, 3, inttwochar),
RandomFields/src/zzz.c:  CDEF(GetModelNr, 2, charint),
RandomFields/src/zzz.c:  CDEF(GetCurrentNrOfModels, 1, one_int),
RandomFields/src/zzz.c:  CDEF(PrintModelList, 3, three_int),
RandomFields/src/zzz.c:  CDEF(expliciteDollarMLE, 2, intdouble),
RandomFields/src/zzz.c:  CDEF(MultiDimRange, 3, intintdouble),
RandomFields/src/zzz.c:  CDEF(GetModelRegister, 2, charint),
RandomFields/src/zzz.c:static R_CallMethodDef callMethods[]  = {
RandomFields/src/zzz.c:  CALLDEF_DO(GetAllModelNames, 1),
RandomFields/src/zzz.c:  CALLDEF_DO(GetModelInfo, 5),
RandomFields/src/zzz.c:  CALLDEF_DO(GetModel, 7),
RandomFields/src/zzz.c:  CALLDEF_DO(EvaluateModel, 3),
RandomFields/src/zzz.c:  //  CALLDEF_DO(EvaluateModelXX, 0),
RandomFields/src/zzz.c:  CALLDEF_DO(MomentsIntern, 2),
RandomFields/src/zzz.c:  CALLDEF_DO(SetAndGetModelFacts, 10),   
RandomFields/src/zzz.c:  CALLDEF_DO(SetAndGetModelLikelihood, 5), 
RandomFields/src/zzz.c:  R_registerRoutines(dll, cMethods, callMethods, NULL, // .Fortran
RandomFields/src/variogramAndCo.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/variogramAndCo.h: Copyright (C) 2015 -- 2017  Martin Schlather
RandomFields/src/variogramAndCo.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/variogramAndCo.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/variogramAndCo.h:  if (fctn == NULL) { /* // PMI0(whereSfctn);printf("\n\n\n\n");PMI0(whereVdim); printf("fctn=NULL\n"); */ BUG;} \
RandomFields/src/variogramAndCo.h:    tsxdim = PREVTOTALXDIM,						\
RandomFields/src/variogramAndCo.h:    VARIABLE_IS_NOT_USED VDIM_0, VARIABLE_IS_NOT_USED NEND,		\
RandomFields/src/variogramAndCo.h:    VARIABLE_IS_NOT_USED  NINCR, VARIABLE_IS_NOT_USED  MINCR,		\
RandomFields/src/variogramAndCo.h:    VARIABLE_IS_NOT_USED VDIMtotX,					\
RandomFields/src/variogramAndCo.h:    VDIM_0 = vdim0;							\
RandomFields/src/variogramAndCo.h:    VDIMtotX = vdimSqtotX;						\
RandomFields/src/variogramAndCo.h:    MINCR = 1;								\
RandomFields/src/variogramAndCo.h:    /* default in global->CovMatrixMulti */				\
RandomFields/src/variogramAndCo.h:    VDIM_0 = 1;								\
RandomFields/src/variogramAndCo.h:    VDIMtotX = vdim0totX;						\
RandomFields/src/variogramAndCo.h:    MINCR = totX;							\
RandomFields/src/variogramAndCo.h:  /*  PMI1(whereSfctn);	 PMIR(whereVdim); */				\
RandomFields/src/variogramAndCo.h:#define STANDARDINKREMENT_X	\
RandomFields/src/variogramAndCo.h:// ny wird nur inv CovMatrix verwendet!
RandomFields/src/variogramAndCo.h:#define STANDARDINKREMENT_Y			\
RandomFields/src/variogramAndCo.h:#define GRIDCYCLES(SOME_FCTN)				\
RandomFields/src/variogramAndCo.h:    SOME_FCTN;						\
RandomFields/src/variogramAndCo.h:    if (gridY) { STANDARDINKREMENT_Y; RECYCLE_Y;}	\
RandomFields/src/variogramAndCo.h:    STANDARDINKREMENT_X;				\
RandomFields/src/variogramAndCo.h:#define GRIDCYCLE_X(SOME_FCTN)			\
RandomFields/src/variogramAndCo.h:    SOME_FCTN;					\
RandomFields/src/variogramAndCo.h:    STANDARDINKREMENT_X;			\
RandomFields/src/variogramAndCo.h:#define DO_INCREMENTY ,  i_col++, y+=tsxdim
RandomFields/src/variogramAndCo.h:#define EMPTY 
RandomFields/src/variogramAndCo.h:#define NONGRIDCYCLE(INCREMENT, PREPARE, FCTN1, FCTN2)			\
RandomFields/src/variogramAndCo.h:    for (; i_row<totX; i_row++, x+=tsxdim INCREMENT){			\
RandomFields/src/variogramAndCo.h:    for (; i_row<totX; i_row++, x+=tsxdim INCREMENT){			\
RandomFields/src/variogramAndCo.h:#define PERFORM_PREPARE						\
RandomFields/src/variogramAndCo.h:#define PERFORM(UNIVAR_FCTN_X, MULTIVAR_FCTN_X, UNIVAR_KERNEL,		\
RandomFields/src/variogramAndCo.h:		MULTIVAR_KERNEL)					\
RandomFields/src/variogramAndCo.h:	if (gridY) { GRIDCYCLES(MULTIVAR_KERNEL); }			\
RandomFields/src/variogramAndCo.h:      } else {GRIDCYCLE_X(MULTIVAR_FCTN_X); }				\
RandomFields/src/variogramAndCo.h:	NONGRIDCYCLE(DO_INCREMENTY, PREPAREY,				\
RandomFields/src/variogramAndCo.h:		     UNIVAR_KERNEL; v+=vdimSq, MULTIVAR_KERNEL);	\
RandomFields/src/variogramAndCo.h:	NONGRIDCYCLE(EMPTY, PREPAREX, UNIVAR_FCTN_X; v+=vdimSq,	\
RandomFields/src/variogramAndCo.h:		     MULTIVAR_FCTN_X);					\
RandomFields/src/variogramAndCo.h:#define VDIM_LOOP(DO)							\
RandomFields/src/variogramAndCo.h:   double *C = v + VDIM_0 * i_row + i_col * VDIMtotX;			\
RandomFields/src/variogramAndCo.h:    int w = m; /* index der (virtuell) transponierten cross Matrix */	\
RandomFields/src/variogramAndCo.h:    for (Long m1=n1; w<vdimSq; m1+=MINCR) { /* zeilenschleife */	\
RandomFields/src/variogramAndCo.h:      /* printf("%d %d; %d %d; row=%d, col%d\n", m1, VDIM_0 * i_row + i_col * VDIMtotX + m1, totX, totY,  i_row, i_col); assert( VDIM_0 * i_row + i_col * VDIMtotX + m1< 400); //*/ \
RandomFields/src/variogramAndCo.h:void CovarianceMatrix(model *cov, bool ignore_y, double *v);
RandomFields/src/variogramAndCo.h:void CovarianceMatrix(model *Cov, bool ignore_y, int *idx, int Nidx,
RandomFields/src/variogramAndCo.h:void CovarianceMatrixCols(model *Cov, bool ignore_y, int row, double *v);
RandomFields/src/variogramAndCo.h:void StandardCovMatrix(model *cov, bool ignore_y, double *v);
RandomFields/src/variogramAndCo.h://void InverseCovMatrix(model *cov, double *v, double *det);
RandomFields/src/variogramAndCo.h://void StandardInverseCovMatrix(model *cov, double *inverse, double *det);
RandomFields/src/empvario.cc:  Authors  Martin Schlather, schlather@math.uni-mannheim.de 
RandomFields/src/empvario.cc:  Copyright (C) 2002 - 2020 Martin Schlather, 
RandomFields/src/empvario.cc:  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/empvario.cc:  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111 - 1307, USA.
RandomFields/src/empvario.cc:  case PSEUDO: case VARIOGRAM:
RandomFields/src/empvario.cc:  case PSEUDOMADOGRAM: case ALPHAPSEUDOMADOGRAM:
RandomFields/src/empvario.cc:    XERR(TOOLS_METHOD);
RandomFields/src/empvario.cc:    method = ALPHAPSEUDOMADOGRAM;
RandomFields/src/empvario.cc:  int halfnbin, gridpoints[MAXVARIODIM], dimM1, 
RandomFields/src/empvario.cc:  double  * xx[MAXVARIODIM], // maxdist[MAXVARIODIM],// dd, 
RandomFields/src/empvario.cc:  PROTECT(Res = allocMatrix(REALSXP, totaln, 3));
RandomFields/src/empvario.cc:  if ( dim > MAXVARIODIM || dim <= 0) {err = TOOLS_DIM; goto ErrorHandling; }
RandomFields/src/empvario.cc:  // (2,4] : Matheron true alpha: alpha - 2.0
RandomFields/src/empvario.cc:      if (alpha == VARIOGRAM) method = VARIOGRAM;
RandomFields/src/empvario.cc:      method = (alpha == 1 || alpha == 2) ? (int) alpha : ALPHAPSEUDOMADOGRAM;
RandomFields/src/empvario.cc:  dimM1 =  dim - 1; 
RandomFields/src/empvario.cc:  if ((BinSq = (double  * ) MALLOC(sizeof(double) * (nbin + 1)))==NULL) {
RandomFields/src/empvario.cc:    err = ERRORMEMORYALLOCATION; goto ErrorHandling; 
RandomFields/src/empvario.cc:      err = ERRORMEMORYALLOCATION; goto ErrorHandling;
RandomFields/src/empvario.cc:      err = ERRORMEMORYALLOCATION; goto ErrorHandling;
RandomFields/src/empvario.cc:    double p1[MAXVARIODIM], p2[MAXVARIODIM], dx[MAXVARIODIM]; 
RandomFields/src/empvario.cc:    Long indextail[MAXVARIODIM], indexhead[MAXVARIODIM];
RandomFields/src/empvario.cc:      //   segmentbase[MAXVARIODIM]; //SegmentbaseTwo[MAXVARIODIM],
RandomFields/src/empvario.cc:      //SegmentbaseFour[MAXVARIODIM];
RandomFields/src/empvario.cc:    for (int i = 0; i <= dimM1; i++) {
RandomFields/src/empvario.cc:    for (int i = 0; i <= dimM1; i++) { dx[i] = xx[i][XSTEP] * 0.99999999; }
RandomFields/src/empvario.cc:    for (int i = 0; i <= dimM1; i++) {indexhead[i] = 0; p1[i] = 0.0; }
RandomFields/src/empvario.cc:      for (int i = 0; i <= dimM1; i++) {				\
RandomFields/src/empvario.cc:	double dx2 = p1[dimM1] - p2[dimM1];				\
RandomFields/src/empvario.cc:	  while(d < dimM1 && p1[d] == p2[d]) d++;			\
RandomFields/src/empvario.cc:	  if (d < dimM1 && p1[d] < p2[d]) {tail++; continue;}		\
RandomFields/src/empvario.cc:	for ( ; d < dimM1; d++) {					\
RandomFields/src/empvario.cc:	  d2 = dimM1;							\
RandomFields/src/empvario.cc:	d1 = dimM1;							\
RandomFields/src/empvario.cc:    //printf("%d meth=%d %d %f\n", method, PSEUDOMADOGRAM, VARIOGRAM, alpha);
RandomFields/src/empvario.cc:    //assert(method == VARIOGRAM);
RandomFields/src/empvario.cc:    case VARIOGRAM:  // cross variogram
RandomFields/src/empvario.cc:    case PSEUDOMADOGRAM:      // pseudo madogram
RandomFields/src/empvario.cc:    case ALPHAPSEUDOMADOGRAM:      // alpha pseudo madogram
RandomFields/src/empvario.cc:      err = TOOLS_METHOD; goto ErrorHandling;
RandomFields/src/empvario.cc:	  double dx=xx[dimM1][head] - xx[dimM1][tail];			\
RandomFields/src/empvario.cc:	    while(d < dimM1 && xx[d][head] == xx[d][tail]) d++;		\
RandomFields/src/empvario.cc:	    if (d < dimM1 && xx[d][head] < xx[d][tail]) {tail++; continue;} \
RandomFields/src/empvario.cc:	  for ( ; d<dimM1; d++) {					\
RandomFields/src/empvario.cc:    case VARIOGRAM:
RandomFields/src/empvario.cc:    case PSEUDOMADOGRAM:
RandomFields/src/empvario.cc:    case ALPHAPSEUDOMADOGRAM:
RandomFields/src/empvario.cc:      err = TOOLS_METHOD; goto ErrorHandling;
RandomFields/src/empvario.cc: *    Method : 0 cross-variogram, 1 pseudo-variogram, 2 covariance
RandomFields/src/empvario.cc:    method = ALPHAPSEUDOMADOGRAM,
RandomFields/src/empvario.cc:  // (2,4] : Matheron true alpha: alpha - 2.0
RandomFields/src/empvario.cc:	if (alpha == VARIOGRAM) method = VARIOGRAM;
RandomFields/src/empvario.cc:      } else if (alpha < VARIOGRAM) alpha -= PSEUDO;
RandomFields/src/empvario.cc:    if (method != VARIOGRAM) {
RandomFields/src/empvario.cc:  PROTECT(Res = allocMatrix(REALSXP, totaln, 3));
RandomFields/src/empvario.cc:  if ((BinSq = (double *) MALLOC(sizeof(double)* (nbin + 1)))==NULL) {
RandomFields/src/empvario.cc:    err=ERRORMEMORYALLOCATION; goto ErrorHandling; 
RandomFields/src/empvario.cc:      err = ERRORMEMORYALLOCATION; goto ErrorHandling;
RandomFields/src/empvario.cc:      err = ERRORMEMORYALLOCATION; goto ErrorHandling;
RandomFields/src/empvario.cc:      gridpoints[i] = MAX(1, (int) xx[i][XLENGTH]);
RandomFields/src/empvario.cc:	phidata = Mod(phidata, TWOPI);					\
RandomFields/src/empvario.cc:	  thetadata = Mod(thetadata, PI);				\
RandomFields/src/empvario.cc:    case VARIOGRAM:
RandomFields/src/empvario.cc:    case PSEUDOMADOGRAM:
RandomFields/src/empvario.cc:    case ALPHAPSEUDOMADOGRAM:
RandomFields/src/empvario.cc:      err = TOOLS_METHOD; goto ErrorHandling;
RandomFields/src/empvario.cc:	    int mn = MIN(i, j), mx=MAX(i, j);				\
RandomFields/src/empvario.cc:	  phidata = Mod(phidata, TWOPI);				\
RandomFields/src/empvario.cc:	  thetadata = Mod(thetadata, PI);				\
RandomFields/src/empvario.cc:    case VARIOGRAM:
RandomFields/src/empvario.cc:    case PSEUDOMADOGRAM:
RandomFields/src/empvario.cc:      case ALPHAPSEUDOMADOGRAM:
RandomFields/src/empvario.cc:      err = TOOLS_METHOD; goto ErrorHandling;
Binary file RandomFields/src/Brown.o matches
RandomFields/src/QMath.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/QMath.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/src/QMath.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/QMath.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/QMath.h:#ifndef RFQMath_H
RandomFields/src/QMath.h:#define RFQMath_H 1
RandomFields/src/QMath.h:void MathCos(double *x, int *, model *cov, double *v);
RandomFields/src/QMath.h:void MathSin(double *x, int *, model *cov, double *v);
RandomFields/src/QMath.h:void MathTan(double *x, int *, model *cov, double *v);
RandomFields/src/QMath.h:#define MATH_FACTOR 2
RandomFields/src/QMath.h:#define CONST_NAME 1
RandomFields/src/QMath.h:void Mathminus(double *x, int *, model *cov, double *v);
RandomFields/src/QMath.h:void Mathplus(double *x, int *, model *cov, double *v);
RandomFields/src/QMath.h:void Mathmult(double *x, int *, model *cov, double *v);
RandomFields/src/QMath.h:void Mathdiv(double *x, int *, model *cov, double *v);
RandomFields/src/QMath.h:void Mathc(double *x, int *, model *cov, double *v);
RandomFields/src/QMath.h:void MathIs(double *x, int*, model *cov, double *v);
RandomFields/src/QMath.h:void rangeMathIs(model *cov, range_type *range);
RandomFields/src/QMath.h:void Mathbind(double *x, int *, model *cov, double *v);
RandomFields/src/QMath.h:int checkDivMult(model *cov);
RandomFields/src/QMath.h:#define PROJ_NAME 3
RandomFields/src/QMath.h:int checkMath(model *cov);
RandomFields/src/QMath.h:void rangeMath(model *cov, range_type *range);
RandomFields/src/QMath.h:#define MATH_DEFAULT_0(VARIAB)						\
RandomFields/src/QMath.h:  double w[MAXPARAM];							\
RandomFields/src/QMath.h:#define MATH_DEFAULT MATH_DEFAULT_0(DefList[COVNR].kappas)
RandomFields/src/QMath.cc:// This file has been created automatically by 'rfGenerateMaths'
RandomFields/src/QMath.cc:#include "QMath.h"
RandomFields/src/QMath.cc:void MathACos(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathASin(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathATan(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathAtan2(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathCos(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathSin(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathTan(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathAcosh(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:#if defined _GLIBCXX_CMATH
RandomFields/src/QMath.cc:void MathAsinh(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:#if defined _GLIBCXX_CMATH
RandomFields/src/QMath.cc:void MathAtanh(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:#if defined _GLIBCXX_CMATH
RandomFields/src/QMath.cc:void MathCosh(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathSinh(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathTanh(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathExp(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathLog(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathExpm1(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT 
RandomFields/src/QMath.cc:#if defined _GLIBCXX_CMATH 
RandomFields/src/QMath.cc:  *v = EXPM1(w[0]);
RandomFields/src/QMath.cc:void MathLog1p(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:#if defined _GLIBCXX_CMATH 
RandomFields/src/QMath.cc://void MathLogb(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc://MATH_DEFAULT
RandomFields/src/QMath.cc:void MathExp2(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathLog2(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathPow(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:  if (sub != NULL && MODELNR(sub) == CONST && !PARAMisNULL(sub, CONST_C)) {
RandomFields/src/QMath.cc:    double p = PARAM0(sub, CONST_C);
RandomFields/src/QMath.cc:    if (sub != NULL && MODELNR(sub) == CONST && !PARAMisNULL(sub, CONST_C)) {
RandomFields/src/QMath.cc:      double p = PARAM0(sub, CONST_C);
RandomFields/src/QMath.cc:  RETURN_ERR(checkMath(cov));
RandomFields/src/QMath.cc:void MathSqrt(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathHypot(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:#if defined _GLIBCXX_CMATH
RandomFields/src/QMath.cc:void MathCbrt(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathCeil(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathFABS(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathFloor(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathFmod(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:  *v = FMOD(w[0], w[1]); 
RandomFields/src/QMath.cc://printf("e %10g\t%10g\n", *v, FMOD(w[0], w[1]));
RandomFields/src/QMath.cc:void MathRound(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathTrunc(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void Mathnearbyint(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathLrint(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathLlrint(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathLRound(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:  MATH_DEFAULT
RandomFields/src/QMath.cc:void MathLLRound(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathCopysign(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathRint(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathNextafter(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathNexttoward(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathErf(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathErfc(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathGGamma(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathGamma(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:  MathGGamma(x, info, cov, v);
RandomFields/src/QMath.cc:void MathLgamma(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:void MathRemainder(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:*v = REMAINDER(w[0], w[1]);
RandomFields/src/QMath.cc:// printf("e %10g\t%10g\t%10g\n", *v, REMAINDER(w[0], w[1]), fr ound(w[1], 0));
RandomFields/src/QMath.cc:void MathFdim(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:  *v = FDIM(w[0], w[1]);
RandomFields/src/QMath.cc:void MathFmax(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:*v = FMAX(w[0], w[1]);
RandomFields/src/QMath.cc:    if (sub != NULL && MODELNR(sub) == CONST &&!PARAMisNULL(sub, CONST_C)) {
RandomFields/src/QMath.cc:      double p = PARAM0(sub, CONST_C);
RandomFields/src/QMath.cc:  RETURN_ERR(checkMath(cov));
RandomFields/src/QMath.cc:void MathFmin(double *x, int *info, model *cov, double *v){
RandomFields/src/QMath.cc:MATH_DEFAULT
RandomFields/src/QMath.cc:*v = FMIN(w[0], w[1]); 
RandomFields/src/QMath.cc:    if (sub != NULL && MODELNR(sub) == CONST &&!PARAMisNULL(sub, CONST_C)) {
RandomFields/src/QMath.cc:      double p = PARAM0(sub, CONST_C);
RandomFields/src/QMath.cc:  RETURN_ERR(checkMath(cov));
RandomFields/src/QMath.cc:  model *sub[MAXSUB];
RandomFields/src/QMath.cc:  AddVariant(TrendType, PREVMODEL_I);		\
RandomFields/src/QMath.cc:void includeStandardMath() {
RandomFields/src/QMath.cc:IncludeModel(".asin", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathASin);
RandomFields/src/QMath.cc:IncludeModel(".atan", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathATan);
RandomFields/src/QMath.cc:IncludeModel(".atan2", MathDefType, 0, 0, 2, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathAtan2);
RandomFields/src/QMath.cc:IncludeModel(".cos", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathCos);
RandomFields/src/QMath.cc:IncludeModel(".sin", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathSin);
RandomFields/src/QMath.cc:IncludeModel(".tan", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathTan);
RandomFields/src/QMath.cc:IncludeModel(".asinh", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathAsinh);
RandomFields/src/QMath.cc:IncludeModel(".atanh", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathAtanh);
RandomFields/src/QMath.cc:IncludeModel(".cosh", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathCosh);
RandomFields/src/QMath.cc:IncludeModel(".sinh", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathSinh);
RandomFields/src/QMath.cc:IncludeModel(".tanh", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathTanh);
RandomFields/src/QMath.cc:IncludeModel(".log", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathLog);
RandomFields/src/QMath.cc:IncludeModel(".expm1", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathExpm1);
RandomFields/src/QMath.cc:IncludeModel(".log1p", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathLog1p);
RandomFields/src/QMath.cc:IncludeModel(".logb", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	     SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathLogb);
RandomFields/src/QMath.cc:IncludeModel(".exp2", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathExp2);
RandomFields/src/QMath.cc:IncludeModel(".log2", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathLog2);
RandomFields/src/QMath.cc:IncludeModel(".hypot", MathDefType, 0, 0, 2, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathHypot);
RandomFields/src/QMath.cc:IncludeModel(".cbrt", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathCbrt);
RandomFields/src/QMath.cc:IncludeModel(".ceil", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathCeil);
RandomFields/src/QMath.cc:IncludeModel(".floor", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathFloor);
RandomFields/src/QMath.cc:IncludeModel(".fmod", MathDefType, 0, 0, 2, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathFmod);
RandomFields/src/QMath.cc:IncludeModel(".round", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathRound);
RandomFields/src/QMath.cc:IncludeModel(".trunc", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathTrunc);
RandomFields/src/QMath.cc:IncludeModel(".nearbyint", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, false, NOT_MONTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathNearbyint);
RandomFields/src/QMath.cc:IncludeModel(".lrint", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(Mathlrint);
RandomFields/src/QMath.cc:IncludeModel(".llrint", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathLlrint);
RandomFields/src/QMath.cc:IncludeModel(".lround", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathLRound);
RandomFields/src/QMath.cc:IncludeModel(".llround", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathLLRound);
RandomFields/src/QMath.cc:IncludeModel(".copysign", MathDefType, 0, 0, 2, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, false, NOT_MONTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathCopysign);
RandomFields/src/QMath.cc:IncludeModel(".rint", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, false, NOT_MONTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathRint);
RandomFields/src/QMath.cc:IncludeModel(".nextafter", MathDefType, 0, 0, 2, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, false, NOT_MONTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathNextafter);
RandomFields/src/QMath.cc:IncludeModel(".nexttoward", MathDefType, 0, 0, 2, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, false, NOT_MONTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathNexttoward);
RandomFields/src/QMath.cc:IncludeModel(".erfc", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	     PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	     false, SCALAR, PREVMODEL_DEP, falsch, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathErfc);
RandomFields/src/QMath.cc:IncludeModel(".lgamma", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, falsch, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathLgamma);
RandomFields/src/QMath.cc:IncludeModel(".remainder", MathDefType, 0, 0, 2, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, falsch, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathRemainder);
RandomFields/src/QMath.cc:IncludeModel(".fdim", MathDefType, 0, 0, 2, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, falsch, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathFdim);
RandomFields/src/QMath.cc:IncludeModel(".fmax", MathDefType, 0, 0, 2, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,check_Fmax,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, falsch, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathFmax);
RandomFields/src/QMath.cc:IncludeModel(".fmin", MathDefType, 0, 0, 2, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,check_Fmin,rangeMath, PREF_TREND,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, falsch, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathFmin);
RandomFields/src/QMath.cc:  assert(isMathDef(DefList + nr));
RandomFields/src/QMath.cc:IncludeModel(".gamma", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_MATHDEF,
RandomFields/src/QMath.cc:	     false, SCALAR, PREVMODEL_DEP, falsch, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathGamma);
RandomFields/src/QMath.cc:IncludeModel(".ggamma", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_MATHDEF,
RandomFields/src/QMath.cc:	     false, SCALAR, PREVMODEL_DEP, falsch, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathGGamma);
RandomFields/src/QMath.cc:IncludeModel(".exp", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_MATHDEF,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathExp);
RandomFields/src/QMath.cc:IncludeModel(".erf", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_MATHDEF,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, falsch, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathErf);
RandomFields/src/QMath.cc:IncludeModel(".fabs", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_MATHDEF,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathFABS);
RandomFields/src/QMath.cc:IncludeModel(".acos", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	     PREVMODEL_I,checkMath,rangeMath, PREF_MATHDEF,
RandomFields/src/QMath.cc:	     false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathACos);
RandomFields/src/QMath.cc:IncludeModel(".acosh", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_MATHDEF,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathAcosh);
RandomFields/src/QMath.cc:IncludeModel(".pow", MathDefType, 0, 0, 2, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,check_Pow,rangeMath, PREF_MATHDEF,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathPow);
RandomFields/src/QMath.cc:IncludeModel(".sqrt", MathDefType, 0, 0, 1, NULL, XONLY,
RandomFields/src/QMath.cc:	 PREVMODEL_I,checkMath,rangeMath, PREF_MATHDEF,
RandomFields/src/QMath.cc:	false, SCALAR, PREVMODEL_DEP, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/QMath.cc:ADDCOV(MathSqrt);
RandomFields/src/primitive.bivariate.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/primitive.bivariate.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
Binary file RandomFields/src/sequential.o matches
RandomFields/src/avltr.h:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
RandomFields/src/avltr.h:   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
RandomFields/src/avltr.h:   Internet, or as Ben Pfaff, 12167 Airport Rd, DeWitt MI 48820, USA
RandomFields/src/avltr.h:#ifndef AVL_MAX_HEIGHT
RandomFields/src/avltr.h:#define AVL_MAX_HEIGHT	32
Binary file RandomFields/src/avltr_modified.o matches
Binary file RandomFields/src/init.general.o matches
RandomFields/src/RF.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/RF.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/src/RF.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/RF.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/RF.h:// in /home/schlather/TMP/RandomFieldsUtils/include/utils.h:
RandomFields/src/RF.h:// #define MEMCOPY(A,B,C) memory_copy(A, B, C)
RandomFields/src/RF.h:// M-x replace-regexp RET c[ad]+r RET \&-safe RET
RandomFields/src/RF.h:#define MAX_LEN_EXAMPLES 4
RandomFields/src/RF.h:// BASIC DIMENSIONS AND VARIABLES
RandomFields/src/RF.h:#define PARAMMAXCHAR MAXCHAR
RandomFields/src/RF.h:#define MAXLONGCHAR 40 // for RFoptions that are string
RandomFields/src/RF.h://#define MAX_MLE_ELMNTS 10
RandomFields/src/RF.h:/* max number of submodels -- NEVER MORE THAN 255 */
RandomFields/src/RF.h:#define MAXTBMDIM 3
RandomFields/src/RF.h:#define MAXTAYLOR 3
RandomFields/src/RF.h:   2 dim: CircEmbed, TBM, spectralTBM, 
RandomFields/src/RF.h:   AdditiveMpp, Direct
RandomFields/src/RF.h:   3 dim: CircEmbed, TBM, Direct
RandomFields/src/RF.h:#define MAXLILIGRIDDIM 10
RandomFields/src/RF.h:#define NATSCALE_ORNUMERIC 2
RandomFields/src/RF.h:#define NATSCALE_MLE 3 /* check fitvario when changing; best NOT to change !! */
RandomFields/src/RF.h:#define ONEARGUMENT_NAME 'k'
RandomFields/src/RF.h:#define DEFAULT_SUBNAME 'C'
RandomFields/src/RF.h:#define SIZE_NOT_DETERMINED 0 // don't change the value !
RandomFields/src/RF.h:#ifndef PL_IMPORTANT // SEE utils.h in RandomFieldsUtils
RandomFields/src/RF.h:#define PL_IMPORTANT 1 // crucial messages
RandomFields/src/RF.h:#define PL_STRUCTURE 5 // see also initNerror.ERROROUTOFMETHOD
RandomFields/src/RF.h:#define NOT_IMPLEMENTED 0 /* don't change this val_ue except to false */
RandomFields/src/RF.h:#define IMPLEMENTED 1     /* don't change this value except to true */
RandomFields/src/RF.h:#define NUM_APPROX 2 
RandomFields/src/RF.h:#define GIVEN_METH_IGNORED 3
RandomFields/src/RF.h:#define HYPERIMPLEMENTED 4
RandomFields/src/RF.h:		       Paramdep=PARAM_DEP,  // necessarily negative !!
RandomFields/src/RF.h:		       Submodeldep=SUBMODEL_DEP, // necessarily negative !!
RandomFields/src/RF.h:  //length[M A XS IMUDIM], /* grid==true: number of pixels of each direction 
RandomFields/src/RF.h:    delete_x, delete_y,  /* is loc->x only a reference? -- used in MLE */
RandomFields/src/RF.h:// GENERAL PARAMETERS FOR THE SIMULAIONMETHODS
RandomFields/src/RF.h:typedef enum matrix_type {//TypeMid,
RandomFields/src/RF.h:                          TypeMiso, TypeMdiag, 
RandomFields/src/RF.h:			  TypeMtimesepproj, // TypeMtimesep and TypeMproj
RandomFields/src/RF.h:			  TypeMtimesep, // last column is zero, but last entry
RandomFields/src/RF.h:			  TypeMproj, // including scale: values need not be 1 
RandomFields/src/RF.h:			  TypeMany} matrix_type;
RandomFields/src/RF.h:  double min[MAXPARAM];
RandomFields/src/RF.h:  double max[MAXPARAM];
RandomFields/src/RF.h:  bool openmin[MAXPARAM];
RandomFields/src/RF.h:  bool openmax[MAXPARAM];
RandomFields/src/RF.h:  double pmin[MAXPARAM];
RandomFields/src/RF.h:  double pmax[MAXPARAM];
RandomFields/src/RF.h:typedef double *param_type[MAXPARAM];
RandomFields/src/RF.h:typedef double *naptr_type[MAX_NA];
RandomFields/src/RF.h:typedef model *covptr_type[MAX_NA];
RandomFields/src/RF.h://typedef int *elptr_type[MAX_MLE_ELMNTS];
RandomFields/src/RF.h:// typedef double *internal_type[MAXINTERNALPARAM];
RandomFields/src/RF.h:  naptr_type MEMORY;
RandomFields/src/RF.h:  covptr_type COVMODELS;
RandomFields/src/RF.h:#define MAXLOCALINSTANCES 3
RandomFields/src/RF.h:  int msg[MAXLOCALINSTANCES];
RandomFields/src/RF.h:  double value[MAXLOCALINSTANCES];
RandomFields/src/RF.h:typedef bool allowedD_type[LAST_DOMAINUSER + 1];
RandomFields/src/RF.h:					     PREVDOM should be instead.
RandomFields/src/RF.h:typedef system_type Systems_type[MAXSYSTEMS];
RandomFields/src/RF.h:  char name[MAXCHAR], nick[MAXCHAR],
RandomFields/src/RF.h:    kappanames[MAXPARAM][PARAMMAXCHAR],
RandomFields/src/RF.h:    subnames[MAXSUB][PARAMMAXCHAR];
RandomFields/src/RF.h:  monotone_type Monotone;
RandomFields/src/RF.h:    subintern[MAXSUB]; // do any subnames match exactly a parameter name?
RandomFields/src/RF.h:  Systems_type systems[MAXVARIANTS];
RandomFields/src/RF.h:  SEXPTYPE kappatype[MAXPARAM]; // REALSXP, VECSXP, etc, what is expected
RandomFields/src/RF.h:  Types kappaParamType[MAXPARAM];//
RandomFields/src/RF.h:  const char **kappaParamTypeNames[MAXPARAM];
RandomFields/src/RF.h:  sortsofparam sortof_tab[MAXPARAM]; // the constants used by the
RandomFields/src/RF.h:  sortof_fct sortof; // particularly for MLE, function returning
RandomFields/src/RF.h:  //                                   VARPARAM : ANYPARAM,
RandomFields/src/RF.h:  //                          but also FORBIDDENPARAM, 
RandomFields/src/RF.h:  double Taylor[MAXTAYLOR][TaylorPow + 1], 
RandomFields/src/RF.h:    Tail[MAXTAYLOR][TaylorExpPow + 1]; 
RandomFields/src/RF.h:// STORAGES FOR SPECIFIC MODELS
RandomFields/src/RF.h:  int *iwork, nseg, maxf[MAXCEDIM], kt[MAXCEDIM], m_fac[MAXCEDIM],
RandomFields/src/RF.h:    NFAC[MAXCEDIM][21];
RandomFields/src/RF.h:  int m[MAXCEDIM], trials,
RandomFields/src/RF.h:    halfm[MAXCEDIM], nn[MAXCEDIM], cumm[MAXCEDIM+1], 
RandomFields/src/RF.h:    cur_square[MAXCEDIM], max_squares[MAXCEDIM], /* !!!! **** */ 
RandomFields/src/RF.h:    vdim; //  added by PM 12/08
RandomFields/src/RF.h:  Long mtot, square_seg[MAXCEDIM];
RandomFields/src/RF.h:#define LOCALCE_MAXVDIM 2
RandomFields/src/RF.h:struct union_cube { double constant, R, A, B, C, N, M, L; };
RandomFields/src/RF.h:struct union_intrinsic { double A0, A2, B, MAX; };
RandomFields/src/RF.h:typedef localvariab localvariabArray[LOCALCE_MAXVDIM * LOCALCE_MAXVDIM];
RandomFields/src/RF.h:  double correction[MAXCEDIM * MAXCEDIM];
RandomFields/src/RF.h:  // bool genuine_dim[MAX362DIM];
RandomFields/src/RF.h:  double center[MAXTBMSPDIM],  
RandomFields/src/RF.h:  double *U11, *U22, *MuT,  *G,   *Cov21, *Inv22;
RandomFields/src/RF.h:  double rx[MAXHYPERDIM], center[MAXHYPERDIM], radius;
RandomFields/src/RF.h:  bool keys_given, conform[MAXSUB];
RandomFields/src/RF.h:  model *sub[MAXSUB];
RandomFields/src/RF.h:  // Modelle nur hier, da diese rueckverfolgt werden muessen,
RandomFields/src/RF.h:    *keys[MAXSUB];
RandomFields/src/RF.h:#define MAX_LIN_COMP (MAXSUB * MAXSUB)
RandomFields/src/RF.h:typedef char NAname_type[MAX_NA][255];
RandomFields/src/RF.h:  int varmodel, NAs, nas[MAX_LIN_COMP],
RandomFields/src/RF.h:    effect[MAX_LIN_COMP];
RandomFields/src/RF.h:  double *Matrix, 
RandomFields/src/RF.h:    cum_n_betas[MAX_LIN_COMP + 1], nas[MAX_LIN_COMP], nas_det[MAX_LIN_COMP], 
RandomFields/src/RF.h:    nas_fixed[MAX_LIN_COMP], // # of additional NAs in a fixed effect
RandomFields/src/RF.h:    nas_random[MAX_LIN_COMP],// # of additional NAs in a random effect
RandomFields/src/RF.h:  char *betanames[MAX_LIN_COMP];
RandomFields/src/RF.h:  model *fixed_effect[MAX_LIN_COMP], *det_effect[MAX_LIN_COMP], *rand_effect[MAX_LIN_COMP];
RandomFields/src/RF.h:#define MAXDIM_POLY 2
RandomFields/src/RF.h:  double sigma, E[MAXTBMSPDIM];
RandomFields/src/RF.h:  double sub_var_cum[MAXSUB];
RandomFields/src/RF.h:  //        unnormedmass * maxheight(of normed fctn) = mM[0]
RandomFields/src/RF.h:  // frequently holds (in particular if mM[0]=1), but not always
RandomFields/src/RF.h:    maxheights[MAXMPPVDIM], // maximum of f resp. of \d F // maxv=min(vdim, max)
RandomFields/src/RF.h:    *mM, *mMplus // = int f^k \D \lambda, falls keine Verteilungsfamilie
RandomFields/src/RF.h:  bool check, dosimulate; // used in biWM, BiGneiting
RandomFields/src/RF.h:  model *KEY[MODEL_MAX + 1];
RandomFields/src/RF.h:#define PIDMODULUS 1000
RandomFields/src/RF.h:extern KEY_type *PIDKEY[PIDMODULUS];
RandomFields/src/RF.h:// MLE.cc, gausdlikeli.cc
RandomFields/src/RF.h:  (STRCMP(C->kappanames[i], FREEVARIABLE) ? C->kappanames[i]		\
RandomFields/src/RF.h:void InitModelList();   
RandomFields/src/RF.h:// Brown.cc, extremes.cc, nugget.cc, operator.cc, RMS.cc, tbm.cc, 
RandomFields/src/RF.h:// used by RMS
RandomFields/src/RF.h:void CheckModel(SEXP Model, double *x, double *y, double *T,  double *Ty,
RandomFields/src/RF.h:void addModelX(model **pcov, int covnr);
RandomFields/src/RF.h:void addModel(model *pcov, int subnr, int covnr);
RandomFields/src/RF.h:void addModelKey(model *cov, int covnr);
RandomFields/src/RF.h:void addModelKappa(model *pcov, int subnr, int covnr);
RandomFields/src/RF.h:void addModel(model **pcov, int covnr, model *calling);
RandomFields/src/RF.h:void addModel(model **pcov, int covnr, model *calling, bool nullOK); 
RandomFields/src/RF.h:int addUnifModel(model *cov, double radius, model **newmodel);
RandomFields/src/RF.h:#define CHECK_NOPASS(C) check2passframe(C, OWN, VDIM0, VDIM1, cov->frame)
RandomFields/src/RF.h:#define CHECK_PASSFRAME(C,F) check2passframe(C, OWN, VDIM0, VDIM1, F)
RandomFields/src/RF.h:#define CHECK_PASSTYPE(C,T) check2passtype(C, OWN, T, VDIM0, VDIM1, cov->frame)
RandomFields/src/RF.h:#define CHECK_VDIM(C,T,X,type,D,I,V0,V1,F) check2X(C,T,X,type,D,I,V0,V1,F,true)
RandomFields/src/RF.h:  CHECK_VDIM(C, vdim, vdim, RandomType, KERNEL, CARTESIAN_COORD, \
RandomFields/src/RF.h:int INIT_RANDOM_intern(model *M, int moments, gen_storage *s, double *p);
RandomFields/src/RF.h:int INIT_intern(model *M, int moments, gen_storage *s);
RandomFields/src/RF.h:int REINIT_intern(model *M, int moments, gen_storage *s);
RandomFields/src/RF.h:void iexplDollar(model *cov, bool MLEnatsc_only);
RandomFields/src/RF.h:int alloc_mpp_M(model *cov, int moments);
RandomFields/src/RF.h:void free_mpp_M(model *cov);
RandomFields/src/RF.h:double *getAnisoMatrix(model *cov, int *nrow, int *ncol);
RandomFields/src/RF.h:double *getAnisoMatrix(model *cov, bool null_if_id, int *nrow, int *ncol);
RandomFields/src/RF.h:// UNAUFGERAEUMT:
RandomFields/src/RF.h:#define MAXDEFMATRIX 3
RandomFields/src/RF.h:#define AveMaxDim 10 
RandomFields/src/RF.h:#define CoxMaxDim 3 
RandomFields/src/RF.h:#define StpMaxDim 10 
RandomFields/src/RF.h:#define EaxxaMaxDim 10  
RandomFields/src/RF.h:#define ShiftMaxDim 10  
RandomFields/src/RF.h:#define ParsWMMaxVDim 10 
RandomFields/src/RF.h:  int nrow[MAXPARAM], // 24 bytes
RandomFields/src/RF.h:    ncol[MAXPARAM];   // 24 bytes
RandomFields/src/RF.h:  model *sub[MAXSUB], *kappasub[MAXPARAM], *calling, *root, *key; 
RandomFields/src/RF.h:     monotone;/* for simple model: normal mix model iff maxdim = INFDIM
RandomFields/src/RF.h:  //               an enormous amount of memory in case of M3 processes)
RandomFields/src/RF.h:  double taylor[MAXTAYLOR][TaylorPow + 1], 
RandomFields/src/RF.h:    tail[MAXTAYLOR][TaylorExpPow + 1]; 
RandomFields/src/RF.h:  Methods method; /* the current method (out of SimulationsMeth) which 
RandomFields/src/RF.h:void SYSTEM_NULL(system_type *sys, int len);
RandomFields/src/RF.h:#define Nick(Cov) (DefList[MODELNR(Cov)].nick)
RandomFields/src/RF.h://#define NICK(Cov) (isDollar(Cov) ? Nick((Cov)->sub[0]) : isPlusMal(Cov)  ? NAME(Cov) : Nick(Cov))
RandomFields/src/RF.h:#define NAME(Cov) DefList[MODELNR(Cov)].name
RandomFields/src/RF.h:#define KNAME(NAME) DefList[COVNR].kappanames[NAME]
RandomFields/src/RF.h:#define SNAME(NAME) DefList[COVNR].subnames[NAME]
RandomFields/src/RF.h:// DEDUGGING INFORMATION
RandomFields/src/RF.h:#define INIT(Cov, Moments, S) INIT_intern(Cov, Moments, S)
RandomFields/src/RF.h:#define REINIT(Cov, Moments, S) REINIT_intern(Cov, Moments, S)
RandomFields/src/RF.h:#define INIT_RANDOM(Cov, Moments, S, P) INIT_RANDOM_intern(Cov, Moments, S, P)
RandomFields/src/RF.h:#define DORANDOM(Cov, S) {						\
RandomFields/src/RF.h:    ASSERT_CHECKED(Cov); DefList[MODELNR(Cov)].D(X, Info, Cov, V);}//kein gatter notw.
RandomFields/src/RF.h:    ASSERT_CHECKED(Cov); DefList[MODELNR(Cov)].logD(X, Info, Cov, V);}
RandomFields/src/RF.h:    ASSERT_CHECKED(Cov); DefList[MODELNR(Cov)].cov(X, Info, Cov, V);} 
RandomFields/src/RF.h:    ASSERT_CHECKED(Cov); DefList[MODELNR(Cov)].nonstat_cov(X, Y, Info, Cov, V);} 
RandomFields/src/RF.h:    ASSERT_CHECKED(Cov); DefList[MODELNR(Cov)].inverse(V, Cov, X);}
RandomFields/src/RF.h:    ASSERT_CHECKED(Cov); DefList[MODELNR(Cov)].random(X, Info, Cov, V);} /* dito */
RandomFields/src/RF.h:    ASSERT_CHECKED(Cov); DefList[MODELNR(Cov)].nonstat_random(X, Y, Info, Cov, V);}
RandomFields/src/RF.h:  { ASSERT_CHECKED(Cov); DefList[MODELNR(Cov)].inverse_nonstat_D(V, Cov, X, Y);}
RandomFields/src/RF.h:    ASSERT_GATTER(Cov); DefList[MODELNR(Cov)].spectral(Cov, S,E);}/*not gatter*/
RandomFields/src/RF.h:#define TBM2CALL(X, Info, Cov, V) {ASSERT_KERNEL(Cov);			\
RandomFields/src/RF.h:    ASSERT_GATTER(Cov); assert(DefList[MODELNR(Cov)].tbm2 != NULL);	\
RandomFields/src/RF.h:    DefList[MODELNR(Cov)].tbm2(X, Info, Cov, V);}
RandomFields/src/RF.h:    ASSERT_GATTER(Cov);DefList[MODELNR(Cov)].hess(X, Info, Cov, V);}
RandomFields/src/RF.h:    ASSERT_GATTER(Cov);DefList[MODELNR(Cov)].nabla(X, Info, Cov, V);}
RandomFields/src/RF.h://#define FRAME_ASSERT(F)				\
RandomFields/src/RF.h://    assert(({PMI(cov) ; true;}));					\
RandomFields/src/RF.h://	  TYPE_NAMES[cov->frame], NICK(cov));				\
RandomFields/src/RF.h:#define ILLEGAL_FRAME							\
RandomFields/src/RF.h:  NERR4(ERRORILLEGALFRAME, "cannot initiate '%.50s' within frame '%.50s' [debug info: '%.50s' at line %d]", \
RandomFields/src/RF.h:	NICK(cov), TYPE_NAMES[cov->frame], __FILE__, __LINE__)
RandomFields/src/RF.h:#define ILLEGAL_FRAME_STRUCT \
RandomFields/src/RF.h:  NERR2(ERRORILLEGALFRAME, "cannot restructure '%.50s' by frame '%.50s'",\
RandomFields/src/RF.h:	NICK(cov), TYPE_NAMES[cov->frame])
RandomFields/src/RF.h:#define ASSERT_NEWMODEL_NOT_NULL\
RandomFields/src/RF.h:    SERR1("unexpected call of struct_%.50s", NAME(cov));	       
RandomFields/src/RF.h:#define ASSERT_NEWMODEL_NULL\
RandomFields/src/RF.h:    SERR1("Unexpected call of struct_%.50s", NAME(cov));
RandomFields/src/RF.h:#define ASSERT_ONE_SUBMODEL(Cov) {					\
RandomFields/src/RF.h:      defn *C = DefList + MODELNR(Cov);					\
RandomFields/src/RF.h:#define ASSERT_FRAME_DEFINED(Cov) { \
RandomFields/src/RF.h:    (cov)->S##new = (new##_storage *) MALLOC(sizeof(new##_storage));	\
RandomFields/src/RF.h:    (cov)->S##new = (new##_storage *) MALLOC(sizeof(new##_storage));	\
RandomFields/src/RF.h:    (cov)->S##new = (new##_storage *) MALLOC(sizeof(new##_storage));	\
RandomFields/src/RF.h:    (cov)->S##new = (new##_storage *) MALLOC(sizeof(new##_storage));	\
RandomFields/src/RF.h:    (cov)->S##new = (new##_storage *) MALLOC(sizeof(new##_storage));	\
RandomFields/src/RF.h:   cov->S##new = (new##_storage *) MALLOC(sizeof(new##_storage));	\
RandomFields/src/RF.h:    (Z) = (cov)->Snew->WHAT = (double*) MALLOC(sizeof(double) * (SIZE)) 
RandomFields/src/RF.h:    Z = cov->Snew->WHAT = (int*) MALLOC(sizeof(int) * (SIZE))
RandomFields/src/RF.h:#define DISTMAXSTEPS 1000
RandomFields/src/RF.h:#define XXXSIZE 1116 // >= DISTAMAXSTEPS + 2 *dim
RandomFields/src/RF.h:#if (XXSIZE < 1L + MATERN_NU_THRES)
RandomFields/src/RF.h:    WHAT##__Y = (double*) MALLOC(sizeof(double)*(SIZE));		\
RandomFields/src/RF.h:    Z##__Y=(double*) MALLOC(sizeof(double)*(SIZE));			\
RandomFields/src/RF.h:    WHAT##__Y =(int*) MALLOC(sizeof(int)*(SIZE));			\
RandomFields/src/RF.h:// MALLOC ?
RandomFields/src/RF.h:// MALLOC :
RandomFields/src/RF.h:    (Z) = (cov)->Snew->WHAT = (double*) MALLOC(sizeof(double) * (SIZE)) 
RandomFields/src/RF.h:    (Z) = (cov)->Snew->WHAT = (double*) MALLOC(sizeof(double) * (SIZE)) 
RandomFields/src/RF.h:    Z = cov->Snew->WHAT = (int*) MALLOC(sizeof(int) * (SIZE)) 
RandomFields/src/RF.h:#include "Machine.h"
RandomFields/src/RF.h:#ifdef SCHLATHERS_MACHINE
RandomFields/src/RF.h:#include "MachineSchlather.h"
RandomFields/src/RF.h:#include "MachineOthers.h"
RandomFields/src/RF.h:#ifdef RANDOMFIELDS_DEBUGGING
RandomFields/src/RF.h:#include "MachineDebugging.h"
RandomFields/src/RF.h:#define PMIL(Cov, ML) {				\
RandomFields/src/RF.h:    PRINTF("\n(PMI '%s', line %d)", __FILE__, (int) __LINE__);	\
RandomFields/src/RF.h:  pmi(Cov, ML);							\
RandomFields/src/RF.h:#define PMI(Cov) PMIL(Cov, 999999)    
RandomFields/src/RF.h:#define PMI0(Cov) PMIL(Cov, 0)
RandomFields/src/RF.h:#define PMI1(Cov) PMIL(Cov, 1)
RandomFields/src/RF.h:#define PMI2(Cov) PMIL(Cov, 2)
RandomFields/src/RF.h:#define APMIL(Cov, ML) { PMIL(Cov, ML); assert(false); }	  
RandomFields/src/RF.h:#define APMI(Cov)  APMIL(Cov, 999999)
RandomFields/src/RF.h:#define APMI0(Cov) APMIL(Cov, 0)
RandomFields/src/RF.h:#define PMIR(Cov) {						\
RandomFields/src/RF.h:  PRINTF("\n(PMI '%s', line %d)", __FILE__, __LINE__);		\
RandomFields/src/RF.h:#define PMIE(Cov) {					\
RandomFields/src/RF.h:  PRINTF("\n\nPMIE '%s', line %d", __FILE__, __LINE__);	\
RandomFields/src/RF.h:  PRINTF("\n%s level=%d err=%d (%s)\n\n", NAME(Cov), Cov->err_level, Cov->err, Cov->err_msg); \
RandomFields/src/RF.h:  CovNames[MAXNRCOVFCTS][MAXCHAR],
RandomFields/src/RF.h:  CovNickNames[MAXNRCOVFCTS][MAXCHAR];
RandomFields/src/RF.h:#define SPLIT(I, MM, DIM, INDEX)			\
RandomFields/src/RF.h:  for (int k__=0; k__<DIM##M1; k__++) {			\
RandomFields/src/RF.h:    int j__ = ii__ / MM[k__];				\
RandomFields/src/RF.h:    INDEX[k__] = ii__ % MM[k__];		      	\
RandomFields/src/RF.h:  INDEX[DIM##M1] = ii__
RandomFields/src/RF.h:    (which)->calling = to; /*if anything change, change also within CMbuild*/ \
RandomFields/src/RF.h:#ifdef SCHLATHERS_MACHINE
RandomFields/src/RF.h:#define STOMODEL stoModel
RandomFields/src/RF.h:#define GETSTOMODEL getStorage(STOMODEL, model)
RandomFields/src/RF.h:#define DELSTOMODEL model_DELETE(&(cov->Smodel), cov);    
RandomFields/src/RF.h:#define NEWSTOMODEL NEW_COV_STORAGE_SAVE(cov, model)
RandomFields/src/RF.h:#define ONCE_NEWSTOMODEL ONCE_NEW_STORAGE(model)
Binary file RandomFields/src/kleinkram.o matches
Binary file RandomFields/src/gauss.o matches
Binary file RandomFields/src/getNset.o matches
Binary file RandomFields/src/questions.o matches
RandomFields/src/Gneiting.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/Gneiting.cc: Copyright (C) 2006 -- 2017 Martin Schlather
RandomFields/src/Gneiting.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/Gneiting.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/Gneiting.cc:#define LOG2 M_LN2
RandomFields/src/Gneiting.cc:#define AVESTP_MINEIGEN 2
RandomFields/src/Gneiting.cc:#define AVESTP_LOGMIXDENS 6 
RandomFields/src/Gneiting.cc:#define TOTALAVESTP (AVESTP_LOGMIXDENS + 1)
RandomFields/src/Gneiting.cc:#define AVE_SPACETIME 2
RandomFields/src/Gneiting.cc:    spacetime = (bool) (PisNULL(AVE_SPACETIME) || P0INT(AVE_SPACETIME));
RandomFields/src/Gneiting.cc: int dim = OWNLOGDIM(0);
RandomFields/src/Gneiting.cc:    spacetime = (bool) (PisNULL(AVE_SPACETIME) || P0INT(AVE_SPACETIME));
RandomFields/src/Gneiting.cc:    dim = OWNLOGDIM(0);
RandomFields/src/Gneiting.cc:  double Ah[AveMaxDim], Eplus2B[AveMaxDim], 
RandomFields/src/Gneiting.cc:    spacetime = (bool) (PisNULL(AVE_SPACETIME) || P0INT(AVE_SPACETIME));
RandomFields/src/Gneiting.cc:   dim =  OWNLOGDIM(0),
RandomFields/src/Gneiting.cc:  if (OWNTOTALXDIM < 2) SERR("The spatial dimension must be at least 2.");
RandomFields/src/Gneiting.cc:  if (dim > AveMaxDim)
RandomFields/src/Gneiting.cc:	  AveMaxDim, dim);
RandomFields/src/Gneiting.cc:  kdefault(cov, AVE_SPACETIME, true);
RandomFields/src/Gneiting.cc:  if (!isNormalMixture(next->monotone)) RETURN_ERR(ERRORNORMALMIXTURE);
RandomFields/src/Gneiting.cc:  if (next->pref[SpectralTBM] == PREF_NONE) 
RandomFields/src/Gneiting.cc:			   2 * x2); // proportional zum dritten Moment !
RandomFields/src/Gneiting.cc:	  -  q[AVESTP_LOGMIXDENS]
RandomFields/src/Gneiting.cc:	  ) / ( - q[AVESTP_MINEIGEN] * q[AVESTP_V]) ); // ???
RandomFields/src/Gneiting.cc:  ASSERT_NEWMODEL_NOT_NULL;
RandomFields/src/Gneiting.cc:  addModel(shape, AVE_GAUSS, GAUSS);
RandomFields/src/Gneiting.cc:  gaussmix->frame = GaussMethodType;
RandomFields/src/Gneiting.cc:  gaussmix->method = SpectralTBM;
RandomFields/src/Gneiting.cc:    spacetime = (bool) (PisNULL(AVE_SPACETIME) || P0INT(AVE_SPACETIME));
RandomFields/src/Gneiting.cc:    dim = OWNLOGDIM(0);
RandomFields/src/Gneiting.cc:#ifdef SCHLATHERS_MACHINE
RandomFields/src/Gneiting.cc:    - 0.5 * (LOG2 - dim * M_LN_SQRT_PId2) - r2
RandomFields/src/Gneiting.cc:  ASSERT_GAUSS_METHOD(Average);
RandomFields/src/Gneiting.cc:    spacetime = (bool) (PisNULL(AVE_SPACETIME) || P0INT(AVE_SPACETIME));
RandomFields/src/Gneiting.cc:   dim = OWNLOGDIM(0);
RandomFields/src/Gneiting.cc:  q[AVESTP_MINEIGEN] = 1.0; 
RandomFields/src/Gneiting.cc:  assert(VDIM0 == 1);  assert(VDIM0 == VDIM1);
RandomFields/src/Gneiting.cc:    cov->mpp.mM[0] = cov->mpp.mMplus[0] = 1.0; 
RandomFields/src/Gneiting.cc:	cov->mpp.mM[2] = 1.0;
RandomFields/src/Gneiting.cc:  double spec_ret[StpMaxDim], sd,
RandomFields/src/Gneiting.cc:    spacetime = (bool) (PisNULL(AVE_SPACETIME) || P0INT(AVE_SPACETIME));
RandomFields/src/Gneiting.cc:    dim = OWNLOGDIM(0);
RandomFields/src/Gneiting.cc:  DefList[MODELNR(phi)].drawmix(phi, q + AVESTP_V); // nicht gatternr
RandomFields/src/Gneiting.cc:  q[AVERAGE_YPHASE] = TWOPI * UNIFORM_RANDOM;
RandomFields/src/Gneiting.cc:// C = 2 (C + 4 M H M), H = h h^t
RandomFields/src/Gneiting.cc:// a = t - h M h - zh
RandomFields/src/Gneiting.cc:// mu = h - 2 a M h
RandomFields/src/Gneiting.cc:#define COX_MU 0
RandomFields/src/Gneiting.cc:      y[CoxMaxDim],
RandomFields/src/Gneiting.cc:      *V = P(COX_MU),
RandomFields/src/Gneiting.cc:	case COX_MU :
RandomFields/src/Gneiting.cc:	    *nr = OWNLOGDIM(0)  - 1;
RandomFields/src/Gneiting.cc:	    *nc = *nr = OWNLOGDIM(0)  - 1;
RandomFields/src/Gneiting.cc: int dim = OWNLOGDIM(0) - 1,
RandomFields/src/Gneiting.cc:  int logicaldim = OWNLOGDIM(0),
RandomFields/src/Gneiting.cc:  double z[CoxMaxDim], det, newx, newxsq, phiD, phiD2;
RandomFields/src/Gneiting.cc:    logicaldim = OWNLOGDIM(0),
RandomFields/src/Gneiting.cc:  double z[CoxMaxDim], det, newx, newxsq, phiD, factor;
RandomFields/src/Gneiting.cc:    logicaldim = OWNLOGDIM(0),
RandomFields/src/Gneiting.cc:  if (OWNTOTALXDIM < 2) SERR("The space-time dimension must be at least 2.");  
RandomFields/src/Gneiting.cc:  if (cov->ncol[COX_MU] != 1 || cov->nrow[COX_MU] != dim) {
RandomFields/src/Gneiting.cc:    if (cov->ncol[COX_MU] == dim && cov->nrow[COX_MU] == 1) {
RandomFields/src/Gneiting.cc:      cov->nrow[COX_MU] = dim;
RandomFields/src/Gneiting.cc:      cov->ncol[COX_MU] = 1; 
RandomFields/src/Gneiting.cc:	    dim, cov->nrow[COX_MU], cov->ncol[COX_MU]);
RandomFields/src/Gneiting.cc:  if (logicaldim != 3)  cov->pref[SpectralTBM] = PREF_NONE;
RandomFields/src/Gneiting.cc:  if (!isNormalMixture(next->monotone)) RETURN_ERR(ERRORNORMALMIXTURE);
RandomFields/src/Gneiting.cc:  if (P0(COX_BETA) != 2.0) cov->pref[SpectralTBM] = 0;
RandomFields/src/Gneiting.cc:  case COX_MU : {
RandomFields/src/Gneiting.cc:  ASSERT_GAUSS_METHOD(SpectralTBM);
RandomFields/src/Gneiting.cc:    logicaldim = OWNLOGDIM(0),
RandomFields/src/Gneiting.cc:  double t, v[CoxMaxDim],
RandomFields/src/Gneiting.cc:    *V = P(COX_MU),
RandomFields/src/Gneiting.cc:  *nc = (i == STP_S || i == STP_M) ? OWNLOGDIM(0) : 1;
RandomFields/src/Gneiting.cc:  *nr = i < DefList[COVNR].kappas ? OWNLOGDIM(0) : -1;
RandomFields/src/Gneiting.cc:    dim =  OWNLOGDIM(0),
RandomFields/src/Gneiting.cc:    xdim = OWNXDIM(0),
RandomFields/src/Gneiting.cc:  double h[StpMaxDim], 
RandomFields/src/Gneiting.cc:    Mh[StpMaxDim], hSx[StpMaxDim],
RandomFields/src/Gneiting.cc:    Syh[StpMaxDim], xi2x, xi2y, 
RandomFields/src/Gneiting.cc:    detA, hMh, cxy, zh, Q, Amux[StpMaxDim], Amuy[StpMaxDim],
RandomFields/src/Gneiting.cc:    *M = P(STP_M),
RandomFields/src/Gneiting.cc:    MEMCOPY(Sx, Sc, bytes);
RandomFields/src/Gneiting.cc:    MEMCOPY(Sy, Sc, bytes);
RandomFields/src/Gneiting.cc:  zh = hMh = 0.0;
RandomFields/src/Gneiting.cc:    Mh[d] = hSx[d] = Syh[d] = 0.0;
RandomFields/src/Gneiting.cc:     Mh[d] += h[j] * M[k];
RandomFields/src/Gneiting.cc:    hMh += Mh[d] * h[d];
RandomFields/src/Gneiting.cc:      A[k] = Sx[k] + Sy[k] + 4.0 * Mh[d] * Mh[j];
RandomFields/src/Gneiting.cc:    Amux[d] = hSx[d] + 2.0 * (hMh + cxy) * Mh[d]; // uses that M is symmetric
RandomFields/src/Gneiting.cc:    Amuy[d] = Syh[d] + 2.0 * (hMh - cxy) * Mh[d];
RandomFields/src/Gneiting.cc:  Q = cxy * cxy - hMh * hMh + muxAmuy;
RandomFields/src/Gneiting.cc:    PRINTF("cxy=%4f hMh=%10g Amux=%10g Amuy=%10g\ndim=%d h=%10g,%10g hSx=%10g,%10g, Q=%10g\n", 
RandomFields/src/Gneiting.cc:	   cxy, hMh, Amux[0], Amuy[0], 
RandomFields/src/Gneiting.cc:    dim = OWNLOGDIM(0);
RandomFields/src/Gneiting.cc:  if (dim > StpMaxDim)
RandomFields/src/Gneiting.cc:	  StpMaxDim, GATTERXDIM(0));
RandomFields/src/Gneiting.cc:   if ((cov->px[STP_S] = EinheitsMatrix(dim)) == NULL) 
RandomFields/src/Gneiting.cc:     RETURN_ERR(ERRORMEMORYALLOCATION);
RandomFields/src/Gneiting.cc: if (PisNULL(STP_M)) { // M
RandomFields/src/Gneiting.cc:   if ((cov->px[STP_M] = EinheitsMatrix(dim)) == NULL)
RandomFields/src/Gneiting.cc:     RETURN_ERR(ERRORMEMORYALLOCATION);
RandomFields/src/Gneiting.cc:    cov->ncol[STP_M] = cov->nrow[STP_M] = dim;
RandomFields/src/Gneiting.cc:  if (!isNormalMixture(phi->monotone)) RETURN_ERR(ERRORNORMALMIXTURE);
RandomFields/src/Gneiting.cc:  for (i=0; i<=2; i++) { /* S, M, z */
RandomFields/src/Gneiting.cc:  ASSERT_NEWMODEL_NOT_NULL;
RandomFields/src/Gneiting.cc:  addModel(shape, STP_GAUSS, GAUSS);
RandomFields/src/Gneiting.cc:  // jedoch sehr Speicherintensiv. MEMCOPY braucht man auch nicht
RandomFields/src/Gneiting.cc:    dim= OWNXDIM(0),
RandomFields/src/Gneiting.cc:  double h[StpMaxDim], hSxh, hSx, xi, Mhd, 
RandomFields/src/Gneiting.cc:    *M = P(STP_M),
RandomFields/src/Gneiting.cc:    MEMCOPY(Sx, Sc, bytes);
RandomFields/src/Gneiting.cc:    Mhd = hSx = 0.0;
RandomFields/src/Gneiting.cc:     Mhd += h[j] * M[k];
RandomFields/src/Gneiting.cc:    xi += Mhd * h[d] + z[d] * h[d];
RandomFields/src/Gneiting.cc:    0.25 * dim * (// M_LN2 +  ??? !!! Rechnung!!! 
RandomFields/src/Gneiting.cc:		  q[AVESTP_LOGV] - 2.0 * M_LN_SQRT_PI) // (2V/pi)^{d/4}
RandomFields/src/Gneiting.cc:          0.25 * dim * (// M_LN2 +  ??? !!! Rechnung!!! 
RandomFields/src/Gneiting.cc:			q[AVESTP_LOGV] - 2.0 * M_LN_SQRT_PI) // (2V/pi)^{d/4}
RandomFields/src/Gneiting.cc:  ASSERT_GAUSS_METHOD(Average);
RandomFields/src/Gneiting.cc:    assert(DefList[MODELNR(Sf)].minmaxeigenvalue != NULL);
RandomFields/src/Gneiting.cc:    DefList[MODELNR(Sf)].minmaxeigenvalue(Sf, minmax);
RandomFields/src/Gneiting.cc:    q[AVESTP_MINEIGEN] = minmax[0];
RandomFields/src/Gneiting.cc:      OWNXDIM(0) * LOG(minmax[1]);
RandomFields/src/Gneiting.cc:#define dummyN (5 * StpMaxDim)
RandomFields/src/Gneiting.cc:    double value[StpMaxDim], ivalue[StpMaxDim], dummy[dummyN], det,
RandomFields/src/Gneiting.cc:      dim = OWNLOGDIM(0),
RandomFields/src/Gneiting.cc:    F77_NAME(dgeev)("No", "No", &dim, P(STP_S), // SVD
RandomFields/src/Gneiting.cc:    q[AVESTP_MINEIGEN] = min;
RandomFields/src/Gneiting.cc:  q[AVESTP_LOGMIXDENS] = 0.0;
RandomFields/src/Gneiting.cc:  sd_avestp(cov, s, OWNLOGDIM(0), &sd); // sd->gauss
RandomFields/src/Gneiting.cc:  assert(VDIM0 == 1);  assert(VDIM0 == VDIM1);
RandomFields/src/Gneiting.cc:    cov->mpp.mM[0] = cov->mpp.mMplus[0] = 1.0; //// ??? notwendig 
RandomFields/src/Gneiting.cc:      if (cov->mpp.moments >= 2) cov->mpp.mM[2] = 1.0; 
RandomFields/src/Gneiting.cc:  double  spec_ret[StpMaxDim], sd,
RandomFields/src/Gneiting.cc:  DefList[MODELNR(phi)].drawmix(phi, &(q[AVESTP_V]));
RandomFields/src/Gneiting.cc:  sd_avestp(cov, s, OWNLOGDIM(0), &sd); // sd->gauss
RandomFields/src/Gneiting.cc:  q[AVERAGE_YPHASE] = TWOPI * UNIFORM_RANDOM;
RandomFields/src/Gneiting.cc:void TBM2nsst(double *x, int*info, model *cov, double *v) {
RandomFields/src/Gneiting.cc:  TBM2CALL(&y, info, subphi, v);
RandomFields/src/Gneiting.cc:  if (OWNXDIM(0) != 2) SERR("reduced dimension must be 2");
RandomFields/src/Gneiting.cc:  if ((err = CHECK(subphi, OWNLOGDIM(0), 1, PosDefType, XONLY, ISOTROPIC, 
RandomFields/src/Gneiting.cc:  if (!isNormalMixture(subphi->monotone)) return(ERRORNORMALMIXTURE);
RandomFields/src/Gneiting.cc:  range->min[NSST_DELTA] = OWNLOGDIM(0) - 1;
RandomFields/src/Gneiting.cc:  *nc = *nr = i == 0 ? SIZE_NOT_DETERMINED : -1;
RandomFields/src/Gneiting.cc:  int dim = OWNLOGDIM(0);
RandomFields/src/Gneiting.cc:  //  PMI(cov->calling->sub[1]);
RandomFields/src/Gneiting.cc:    dim = OWNXDIM(0);
RandomFields/src/Gneiting.cc:  assert(OWNLOGDIM(0) == OWNXDIM(0));
RandomFields/src/Gneiting.cc:  if ((err = CHECK(next, OWNLOGDIM(0), 1, PosDefType, 
RandomFields/src/Gneiting.cc:  if (!isNormalMixture(next->monotone)) RETURN_ERR(ERRORNORMALMIXTURE);
RandomFields/src/Gneiting.cc:  VDIM0 = VDIM1 = 1;
RandomFields/src/Gneiting.cc:#define GENNSST_DIM_U 0
RandomFields/src/Gneiting.cc:    totaldim = OWNXDIM(0), 
RandomFields/src/Gneiting.cc:    udim = P0INT(GENNSST_DIM_U),
RandomFields/src/Gneiting.cc:  COV(x + hdim, info, subpsi, PARAM(subphi, GENNSST_INTERN_A));
RandomFields/src/Gneiting.cc:    double *p = PARAM(subphi, GENNSST_INTERN_A);
RandomFields/src/Gneiting.cc:    totaldim = OWNXDIM(0), 
RandomFields/src/Gneiting.cc:    udim = P0INT(GENNSST_DIM_U),
RandomFields/src/Gneiting.cc:  NONSTATCOV(x + hdim, y + hdim, info, subpsi, PARAM(subphi, GENNSST_INTERN_A));
RandomFields/src/Gneiting.cc:    double  *p = PARAM(subphi, GENNSST_INTERN_A);
RandomFields/src/Gneiting.cc:#define GENNSST_DIM_U 0
RandomFields/src/Gneiting.cc:  kdefault(cov, GENNSST_DIM_U, 1);  
RandomFields/src/Gneiting.cc:  if (OWNLOGDIM(0)!=OWNXDIM(0)) SERR("logical and physical dimension differ");
RandomFields/src/Gneiting.cc:  int udim = P0INT(GENNSST_DIM_U),
RandomFields/src/Gneiting.cc:    hdim = OWNLOGDIM(0) - udim;
RandomFields/src/Gneiting.cc:    addModelKey(cov, GENNSST_INTERN);
RandomFields/src/Gneiting.cc:			       XONLY, SYMMETRIC, // viel zu schwach, geht aber
RandomFields/src/Gneiting.cc:  if (!isNormalMixture(cov->key->sub[0])) SERR("'phi' not a normal mixture.");
RandomFields/src/Gneiting.cc:  if (TOTALXDIM(SYSOF(cov->key)) != hdim)
RandomFields/src/Gneiting.cc:  // MUSSS ZWINGEND ALS ZWEITES KOMMEN
RandomFields/src/Gneiting.cc:    if (equalsXonly(type) && !equalsXonly(OWNDOM(0))) type = KERNEL;
RandomFields/src/Gneiting.cc:       MODELNR(subpsi) != MATRIX || PisNULL(M_M) ||
RandomFields/src/Gneiting.cc:       subpsi->kappasub[M_M] != NULL || subpsi->nsub > 1 ||
RandomFields/src/Gneiting.cc:  VDIM0 = VDIM1 = 1;
RandomFields/src/Gneiting.cc:  MEMCOPY(cov->allowedD, cov->sub[1]->allowedD, sizeof(allowedD_type));
RandomFields/src/Gneiting.cc:  I[(int) SYMMETRIC] = true;
RandomFields/src/Gneiting.cc:  I[(int) DOUBLEISOTROPIC] = MODELNR(subpsi) == MATRIX && PisNULL(M_M) &&
RandomFields/src/Gneiting.cc:    subpsi->kappasub[M_M] == NULL && subpsi->nsub > 1;
RandomFields/src/Gneiting.cc:  ra->min[GENNSST_DIM_U] = 1;
RandomFields/src/Gneiting.cc:  ra->max[GENNSST_DIM_U] = OWNLOGDIM(0) - 1;
RandomFields/src/Gneiting.cc:  ra->pmin[GENNSST_DIM_U] = 1;
RandomFields/src/Gneiting.cc:  ra->pmax[GENNSST_DIM_U] = ra->max[GENNSST_DIM_U];
RandomFields/src/Gneiting.cc:  ra->openmin[GENNSST_DIM_U] = false;
RandomFields/src/Gneiting.cc:  ra->openmax[GENNSST_DIM_U] = false;
Binary file RandomFields/src/RMS.o matches
Binary file RandomFields/src/families.o matches
Binary file RandomFields/src/Error.o matches
RandomFields/src/primitive.gauss.mix.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/primitive.gauss.mix.cc: Copyright (C) 2017 -- 2018 Olga Moreva (bivariate models) & Martin Schlather
RandomFields/src/primitive.gauss.mix.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/primitive.gauss.mix.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/primitive.gauss.mix.cc://#define LOG2 M_LN2
RandomFields/src/primitive.gauss.mix.cc:#define CAUCHY_GAMMA 0
RandomFields/src/primitive.gauss.mix.cc:  double gamma = P0(CAUCHY_GAMMA);
RandomFields/src/primitive.gauss.mix.cc:  double gamma = P0(CAUCHY_GAMMA);
RandomFields/src/primitive.gauss.mix.cc:void TBM2Cauchy(double *x, INFO, model *cov, double *v){
RandomFields/src/primitive.gauss.mix.cc:  double gamma = P0(CAUCHY_GAMMA), y2, lpy2;
RandomFields/src/primitive.gauss.mix.cc:    ERR("TBM2 for cauchy only possible for alpha=0.5 + k; k=0, 1, 2, 3 ");
RandomFields/src/primitive.gauss.mix.cc:  double y=*x, gamma = P0(CAUCHY_GAMMA);
RandomFields/src/primitive.gauss.mix.cc:  double ha = *x * *x, gamma = P0(CAUCHY_GAMMA);
RandomFields/src/primitive.gauss.mix.cc:    gamma = P0(CAUCHY_GAMMA);
RandomFields/src/primitive.gauss.mix.cc:  double gamma =  P0(CAUCHY_GAMMA);
RandomFields/src/primitive.gauss.mix.cc:  range->min[CAUCHY_GAMMA] = 0.0;
RandomFields/src/primitive.gauss.mix.cc:  range->max[CAUCHY_GAMMA] = RF_INF;
RandomFields/src/primitive.gauss.mix.cc:  range->pmin[CAUCHY_GAMMA] = 0.09;
RandomFields/src/primitive.gauss.mix.cc:  range->pmax[CAUCHY_GAMMA] = 10.0;
RandomFields/src/primitive.gauss.mix.cc:  range->openmin[CAUCHY_GAMMA] = true;
RandomFields/src/primitive.gauss.mix.cc:  range->openmax[CAUCHY_GAMMA] = true;
RandomFields/src/primitive.gauss.mix.cc:  li->msg[0] = MSGLOCAL_JUSTTRY;
RandomFields/src/primitive.gauss.mix.cc:void DrawMixCauchy(model VARIABLE_IS_NOT_USED *cov, double *random) { //better GR 3.381.4 ?? !!!!
RandomFields/src/primitive.gauss.mix.cc:  *random = -LOG(1.0 -UNIFORM_RANDOM);
RandomFields/src/primitive.gauss.mix.cc:double LogMixDensCauchy(double VARIABLE_IS_NOT_USED *x, double logV, model *cov) {
RandomFields/src/primitive.gauss.mix.cc:  double gamma = P0(CAUCHY_GAMMA);
RandomFields/src/primitive.gauss.mix.cc:   int dim = PREVLOGDIM(0);
RandomFields/src/primitive.gauss.mix.cc:    gamma =  P0(CAUCHY_GAMMA),
RandomFields/src/primitive.gauss.mix.cc:  //  PMI(cov);
RandomFields/src/primitive.gauss.mix.cc:	cov->mpp.mM[i]= cov->mpp.mMplus[i] = sHalf * EXP(logB(mu, nu - mu));
RandomFields/src/primitive.gauss.mix.cc:    ILLEGAL_FRAME;
RandomFields/src/primitive.gauss.mix.cc:#define CTBM_ALPHA 0
RandomFields/src/primitive.gauss.mix.cc:#define CTBM_BETA 1
RandomFields/src/primitive.gauss.mix.cc:#define CTBM_GAMMA 2
RandomFields/src/primitive.gauss.mix.cc:    alpha = P0(CTBM_ALPHA), 
RandomFields/src/primitive.gauss.mix.cc:    beta = P0(CTBM_BETA), 
RandomFields/src/primitive.gauss.mix.cc:    gamma = P0(CTBM_GAMMA),
RandomFields/src/primitive.gauss.mix.cc:    alpha = P0(CTBM_ALPHA), 
RandomFields/src/primitive.gauss.mix.cc:    beta = P0(CTBM_BETA),
RandomFields/src/primitive.gauss.mix.cc:    gamma = P0(CTBM_GAMMA);
RandomFields/src/primitive.gauss.mix.cc:  range->min[CTBM_ALPHA] = 0.0;
RandomFields/src/primitive.gauss.mix.cc:  range->max[CTBM_ALPHA] = 2.0;
RandomFields/src/primitive.gauss.mix.cc:  range->pmin[CTBM_ALPHA] = 0.05;
RandomFields/src/primitive.gauss.mix.cc:  range->pmax[CTBM_ALPHA] = 2.0;
RandomFields/src/primitive.gauss.mix.cc:  range->openmin[CTBM_ALPHA] = true;
RandomFields/src/primitive.gauss.mix.cc:  range->openmax[CTBM_ALPHA] = false;
RandomFields/src/primitive.gauss.mix.cc:  range->min[CTBM_BETA] = 0.0;
RandomFields/src/primitive.gauss.mix.cc:  range->max[CTBM_BETA] = RF_INF;
RandomFields/src/primitive.gauss.mix.cc:  range->pmin[CTBM_BETA] = 0.05;
RandomFields/src/primitive.gauss.mix.cc:  range->pmax[CTBM_BETA] = 10.0;
RandomFields/src/primitive.gauss.mix.cc:  range->openmin[CTBM_BETA] = true;
RandomFields/src/primitive.gauss.mix.cc:  range->openmax[CTBM_BETA] = true;
RandomFields/src/primitive.gauss.mix.cc:  range->min[CTBM_GAMMA] = (double) OWNLOGDIM(0);
RandomFields/src/primitive.gauss.mix.cc:  range->max[CTBM_GAMMA] = RF_INF;
RandomFields/src/primitive.gauss.mix.cc:  range->pmin[CTBM_GAMMA] = range->min[CTBM_GAMMA];
RandomFields/src/primitive.gauss.mix.cc:  range->pmax[CTBM_GAMMA] = range->pmin[CTBM_GAMMA] + 10.0;
RandomFields/src/primitive.gauss.mix.cc:  range->openmin[CTBM_GAMMA] = false;
RandomFields/src/primitive.gauss.mix.cc:  range->openmax[CTBM_GAMMA] = true;
RandomFields/src/primitive.gauss.mix.cc:#define CONSTANT_M 0
RandomFields/src/primitive.gauss.mix.cc:  *nr = *nc = i ==  CONSTANT_M ? SIZE_NOT_DETERMINED : -1;
RandomFields/src/primitive.gauss.mix.cc:    vdimSq = VDIM0 * VDIM1;
RandomFields/src/primitive.gauss.mix.cc:  MEMCOPY(v, P(CONSTANT_M), vdimSq * sizeof(double));
RandomFields/src/primitive.gauss.mix.cc:    vdimSq = VDIM0 * VDIM1;
RandomFields/src/primitive.gauss.mix.cc:  MEMCOPY(v, P(CONSTANT_M), vdimSq * sizeof(double));
RandomFields/src/primitive.gauss.mix.cc:       warning("NOTE that the definition of 'RMconstant' has changed in version 3.0.61. Maybe  'RMfixcov' is the model your are looking for. This note appears only once per session and can be fully suppressed by RFoptions(warn_constant = false)");
RandomFields/src/primitive.gauss.mix.cc:  VDIM0 = VDIM1 = cov->nrow[CONSTANT_M];
RandomFields/src/primitive.gauss.mix.cc:  if (VDIM0 != VDIM1)  RETURN_ERR(ERROR_MATRIX_SQUARE);
RandomFields/src/primitive.gauss.mix.cc:  if (!Ext_is_positive_definite(P(CONSTANT_M), VDIM0)) {
RandomFields/src/primitive.gauss.mix.cc:    cov->monotone = MONOTONE;
RandomFields/src/primitive.gauss.mix.cc:      return cov->q[0] = ERROR_MATRIX_POSDEF;
RandomFields/src/primitive.gauss.mix.cc:    cov->monotone = COMPLETELY_MON;
RandomFields/src/primitive.gauss.mix.cc:    vdim = VDIM0,
RandomFields/src/primitive.gauss.mix.cc:  double *p = P(CONSTANT_M);
RandomFields/src/primitive.gauss.mix.cc:  int maxv = MIN(vdim, MAXMPPVDIM);
RandomFields/src/primitive.gauss.mix.cc:  int vdim = VDIM0;
RandomFields/src/primitive.gauss.mix.cc:void TBM2exponential(double *x, INFO, model VARIABLE_IS_NOT_USED *cov, double *v) 
RandomFields/src/primitive.gauss.mix.cc:    dim = PREVLOGDIM(0);
RandomFields/src/primitive.gauss.mix.cc:    dim=PREVLOGDIM(0);
RandomFields/src/primitive.gauss.mix.cc:  return gammafn(dim12) * POW(M_PI * (1.0 + x2), -dim12);
RandomFields/src/primitive.gauss.mix.cc: int dim = PREVLOGDIM(0);
RandomFields/src/primitive.gauss.mix.cc:  //  PMI(cov);
RandomFields/src/primitive.gauss.mix.cc:  if (HAS_SPECTRAL_FRAME(cov)) {
RandomFields/src/primitive.gauss.mix.cc:   if (PREVLOGDIM(0) <= 2) RETURN_NOERROR;
RandomFields/src/primitive.gauss.mix.cc:	i[xi] = dimfak * 2 * POW(M_PI / (double) (xi*xi), dimHalf) / 
RandomFields/src/primitive.gauss.mix.cc:      cov->mpp.mM[1] = cov->mpp.mMplus[1] = i[1];
RandomFields/src/primitive.gauss.mix.cc:	cov->mpp.mM[2] = cov->mpp.mMplus[2] = i[2];
RandomFields/src/primitive.gauss.mix.cc:       cov->mpp.mM[1]= cov->mpp.mMplus[1] = 
RandomFields/src/primitive.gauss.mix.cc:    ILLEGAL_FRAME;
RandomFields/src/primitive.gauss.mix.cc: int dim = PREVLOGDIM(0);
RandomFields/src/primitive.gauss.mix.cc:    double A = 1.0 - UNIFORM_RANDOM;
RandomFields/src/primitive.gauss.mix.cc:  int dim = OWNLOGDIM(0);
RandomFields/src/primitive.gauss.mix.cc: assert(OWNLOGDIM(0)==2);
RandomFields/src/primitive.gauss.mix.cc:  if ((hx=*Hx=(double *) MALLOC(sizeof(double) * (p + 8 * sizeof(int))))==NULL||
RandomFields/src/primitive.gauss.mix.cc:      (hy=*Hy=(double *) MALLOC(sizeof(double) * (p + 8 *sizeof(int))))==NULL||
RandomFields/src/primitive.gauss.mix.cc:      (hr=*Hr=(double *) MALLOC(sizeof(double) * (p + 8 * sizeof(int))))==NULL){
RandomFields/src/primitive.gauss.mix.cc:    Err=ERRORMEMORYALLOCATION; goto ErrorHandling;
RandomFields/src/primitive.gauss.mix.cc:    phi = UNIFORM_RANDOM * TWOPI;
RandomFields/src/primitive.gauss.mix.cc:    hr[q] = UNIFORM_RANDOM * radius;
RandomFields/src/primitive.gauss.mix.cc:  li->msg[0] = MSGLOCAL_OK;
RandomFields/src/primitive.gauss.mix.cc:  li->msg[0] = MSGLOCAL_OK;
RandomFields/src/primitive.gauss.mix.cc:void DrawMixExp(model VARIABLE_IS_NOT_USED *cov, double *random) {
RandomFields/src/primitive.gauss.mix.cc:  double x = GAUSS_RANDOM(1.0);
RandomFields/src/primitive.gauss.mix.cc:double LogMixDensExp(double VARIABLE_IS_NOT_USED *x, double VARIABLE_IS_NOT_USED logV, model VARIABLE_IS_NOT_USED *cov) {
RandomFields/src/primitive.gauss.mix.cc:    dim = PREVLOGDIM(0);
RandomFields/src/primitive.gauss.mix.cc:    int d, dim=PREVLOGDIM(0);
RandomFields/src/primitive.gauss.mix.cc:    return EXP(- 0.25 * x2 - (double) dim * (M_LN2 + M_LN_SQRT_PI));
RandomFields/src/primitive.gauss.mix.cc:  ASSERT_NEWMODEL_NOT_NULL;
RandomFields/src/primitive.gauss.mix.cc:  //printf("dleete next lines\n");  ILLEGAL_FRAME_STRUCT;
RandomFields/src/primitive.gauss.mix.cc:    addModel(newmodel, GAUSS, cov);       
RandomFields/src/primitive.gauss.mix.cc:    addModelX(newmodel, FIRSTDOLLAR);
RandomFields/src/primitive.gauss.mix.cc:    addModelX(newmodel, TRUNCSUPPORT);
RandomFields/src/primitive.gauss.mix.cc:      addModel(newmodel, GAUSS_DISTR, cov); // to
RandomFields/src/primitive.gauss.mix.cc:      kdefault(*newmodel, GAUSS_DISTR_MEAN, 0.0);
RandomFields/src/primitive.gauss.mix.cc:    ILLEGAL_FRAME_STRUCT;
RandomFields/src/primitive.gauss.mix.cc:double IntUdeU2_intern(int d, double R, double expMR2) {
RandomFields/src/primitive.gauss.mix.cc:  else if (d == 1) return 0.5  * (1.0 - expMR2);
RandomFields/src/primitive.gauss.mix.cc:  return 0.5 * (expMR2 + (d - 1.0) * IntUdeU2_intern(d - 2, R, expMR2));
RandomFields/src/primitive.gauss.mix.cc:  if (HAS_SPECTRAL_FRAME(cov)) {
RandomFields/src/primitive.gauss.mix.cc:   if (OWNLOGDIM(0) <= 2) RETURN_NOERROR;
RandomFields/src/primitive.gauss.mix.cc:      dim = OWNLOGDIM(0);
RandomFields/src/primitive.gauss.mix.cc:      cov->mpp.mM[1] = cov->mpp.mMplus[1] = 
RandomFields/src/primitive.gauss.mix.cc:	cov->mpp.mM[i] = cov->mpp.mM[1] * POW((double) i, -0.5 * dim);
RandomFields/src/primitive.gauss.mix.cc:  else ILLEGAL_FRAME;
RandomFields/src/primitive.gauss.mix.cc:  int dim = PREVLOGDIM(0);
RandomFields/src/primitive.gauss.mix.cc:    E12(s, dim, 2.0 * SQRT(-LOG(1.0 - UNIFORM_RANDOM)), e);
RandomFields/src/primitive.gauss.mix.cc:void DrawMixGauss(model VARIABLE_IS_NOT_USED *cov, double VARIABLE_IS_NOT_USED *random) {
RandomFields/src/primitive.gauss.mix.cc:double LogMixDensGauss(double VARIABLE_IS_NOT_USED *x, double VARIABLE_IS_NOT_USED logV, model VARIABLE_IS_NOT_USED *cov) {
RandomFields/src/primitive.gauss.mix.cc:    factor[MAXMPPDIM+1] = {0, 1 / M_SQRT_PI, INVPI, INVPI / M_SQRT_PI, 
RandomFields/src/primitive.gauss.mix.cc:void getMassGauss(double *a, model *cov, double *kappas, double *m) {
RandomFields/src/primitive.gauss.mix.cc:  double val[MAXMPPDIM + 1],
RandomFields/src/primitive.gauss.mix.cc:    factor[MAXMPPDIM+1] = {1, 
RandomFields/src/primitive.gauss.mix.cc:			   SQRT(2) / M_SQRT_PI, 
RandomFields/src/primitive.gauss.mix.cc:			   2 * SQRT(2) * INVPI / M_SQRT_PI, 
RandomFields/src/primitive.gauss.mix.cc:    val[i] = (2.0 * pnorm(SQRT2 * a[i], 0.0, 1.0, false, false) - 1.0) * M_SQRT_PI;
RandomFields/src/primitive.gauss.mix.cc:    *v = dim == 1 ? FABS(GAUSS_RANDOM(1.0)) : rexp(1.0); 
RandomFields/src/primitive.gauss.mix.cc:      dummy = GAUSS_RANDOM(1.0);
RandomFields/src/primitive.gauss.mix.cc:  // MLE works much better with 0.01 then with 0.05
RandomFields/src/primitive.gauss.mix.cc:  if (OWNLOGDIM(0) > 2)
RandomFields/src/primitive.gauss.mix.cc:  cov->monotone = P0(GENC_ALPHA) <= 1.0 ? COMPLETELY_MON : NORMAL_MIXTURE;
RandomFields/src/primitive.gauss.mix.cc:    li->msg[0] = li->msg[1] = MSGLOCAL_OK;
RandomFields/src/primitive.gauss.mix.cc:    li->msg[0] = (alpha <= thres[1]) ? MSGLOCAL_OK : MSGLOCAL_JUSTTRY;
RandomFields/src/primitive.gauss.mix.cc:    li->msg[0] = MSGLOCAL_OK;
RandomFields/src/primitive.gauss.mix.cc:    li->msg[0] = MSGLOCAL_JUSTTRY;
RandomFields/src/primitive.gauss.mix.cc:  if (OWNLOGDIM(0) > 2)
RandomFields/src/primitive.gauss.mix.cc:      li->msg[0] =MSGLOCAL_OK;
RandomFields/src/primitive.gauss.mix.cc:      li->msg[0] = MSGLOCAL_JUSTTRY;
RandomFields/src/primitive.gauss.mix.cc:  if (OWNLOGDIM(0) > 2)
RandomFields/src/primitive.gauss.mix.cc:    //  OWNDOM(0)=GENERALISEDCOVARIANCE; // later
RandomFields/src/primitive.gauss.mix.cc:    *v = logWM(y * xi, nu, cov->q[WM_LOGGAMMA], 0.0);
RandomFields/src/primitive.gauss.mix.cc:    double  bk[MATERN_NU_THRES + 1L],
RandomFields/src/primitive.gauss.mix.cc:      nuThres = nu <= MATERN_NU_THRES ? nu : MATERN_NU_THRES,
RandomFields/src/primitive.gauss.mix.cc:    if  (xiy <= LOW_MATERN) {*v = 1.0; return;}
RandomFields/src/primitive.gauss.mix.cc:   if (nu > MATERN_NU_THRES) { // factor!=0.0 && 
RandomFields/src/primitive.gauss.mix.cc:       g = MATERN_NU_THRES / nu;
RandomFields/src/primitive.gauss.mix.cc:    *v = xi * Intern_DWM(y * xi, nu, cov->q[WM_LOGGAMMA], 0.0);
RandomFields/src/primitive.gauss.mix.cc:    double nuThres = nu <= MATERN_NU_THRES ? nu : MATERN_NU_THRES,
RandomFields/src/primitive.gauss.mix.cc:      bk[MATERN_NU_THRES + 1L];
RandomFields/src/primitive.gauss.mix.cc:    if (nu > MATERN_NU_THRES) {
RandomFields/src/primitive.gauss.mix.cc:      g = MATERN_NU_THRES / nu,
RandomFields/src/primitive.gauss.mix.cc:    nuThres = nu <= MATERN_NU_THRES ? nu : MATERN_NU_THRES,
RandomFields/src/primitive.gauss.mix.cc:    bk[MATERN_NU_THRES + 1L];
RandomFields/src/primitive.gauss.mix.cc:  if (nu > MATERN_NU_THRES) { // factor!=0.0 && 
RandomFields/src/primitive.gauss.mix.cc:       g = MATERN_NU_THRES / nu,
RandomFields/src/primitive.gauss.mix.cc:    assert(cov->q + WM_LOGGAMMA == &(QVALUE));
RandomFields/src/primitive.gauss.mix.cc:    assert(cov->q + WM_GAMMA == &(QVALUE2));
RandomFields/src/primitive.gauss.mix.cc:    cov->q[WM_LOGGAMMA] = lgammafn(nuThres); // QVALUE
RandomFields/src/primitive.gauss.mix.cc:    cov->q[WM_GAMMA] = gammafn(nuThres); // QVALUE2
RandomFields/src/primitive.gauss.mix.cc:    dim = OWNLOGDIM(0);
RandomFields/src/primitive.gauss.mix.cc:  if (OWNLOGDIM(0) > 2)
RandomFields/src/primitive.gauss.mix.cc:  cov->monotone = alpha <= 1.0 ? COMPLETELY_MON : NORMAL_MIXTURE;
RandomFields/src/primitive.gauss.mix.cc:  VDIM0 = VDIM1 = 2;
RandomFields/src/primitive.gauss.mix.cc:  //PMI(cov);
RandomFields/src/primitive.gauss.mix.cc: if (cov->Sbistable == NULL) return UNKNOWNPARAM;
RandomFields/src/primitive.gauss.mix.cc:      ? ANYPARAM : IGNOREPARAM;
RandomFields/src/primitive.gauss.mix.cc:  case BIStablescale: return SCALEPARAM;
RandomFields/src/primitive.gauss.mix.cc:  case BIStablecdiag : return VARPARAM;
RandomFields/src/primitive.gauss.mix.cc:      ? IGNOREPARAM : ONLYRETURN;
RandomFields/src/primitive.gauss.mix.cc:      ? ANYPARAM : IGNOREPARAM;
RandomFields/src/primitive.gauss.mix.cc:      ? IGNOREPARAM : ONLYRETURN;
RandomFields/src/primitive.gauss.mix.cc:  while (( fmiddle >= MIN(fleft, fright))  &&
RandomFields/src/primitive.gauss.mix.cc:         (EXP(MIN(fleft, MIN(fright, fmiddle))) > epsilon ) )  {
RandomFields/src/primitive.gauss.mix.cc:  if (EXP(MIN(fleft, MIN(fright, fmiddle))) <= epsilon ) {
RandomFields/src/primitive.gauss.mix.cc:void biStableMinRho(model *cov, double *alpha, double *a, double ax, double cx, double *rhomax) {
RandomFields/src/primitive.gauss.mix.cc:  int dim = OWNLOGDIM(0);
RandomFields/src/primitive.gauss.mix.cc:  *rhomax = MIN(*rhomax, 1);
RandomFields/src/primitive.gauss.mix.cc:  int dim = OWNLOGDIM(0);
RandomFields/src/primitive.gauss.mix.cc:    betaa = MAX(alphadiag[0], alphadiag[1]);
RandomFields/src/primitive.gauss.mix.cc:	//       PMI(cov);
RandomFields/src/primitive.gauss.mix.cc:    //notallowed = ( alpha[i21] < MAX(alpha[i11], alpha[i22]) ) ||
RandomFields/src/primitive.gauss.mix.cc:     betaa = MAX(alphadiag[0], alphadiag[1]);
RandomFields/src/primitive.gauss.mix.cc:     betac = 2 - MAX(alphadiag[0], alphadiag[1]);
RandomFields/src/primitive.gauss.mix.cc:     // PMI(cov);
RandomFields/src/primitive.gauss.mix.cc:       //     PMI(cov);
RandomFields/src/primitive.gauss.mix.cc:       //     printf("\nDear Olga, please check the PMI output; if the output looks reasonable you should check your code in the next line.\n");
RandomFields/src/primitive.gauss.mix.cc:       biStableMinRho(cov, alpha, a, left, right, &rhomax);
RandomFields/src/primitive.gauss.mix.cc:      li->msg[0] =MSGLOCAL_OK;
RandomFields/src/primitive.gauss.mix.cc:      li->msg[0] = MSGLOCAL_JUSTTRY;
RandomFields/src/primitive.gauss.mix.cc:  //  PMI(cov->calling->calling);  
RandomFields/src/primitive.gauss.mix.cc:  // if (!R_FINITE(v[0]) || !R_FINITE(v[1]) || !R_FINITE(v[2]) || !R_FINITE(v[3])) { PMI(cov); printf("(%4.3f, %4.3f; %4.3e %4.3e %4.3e %4.3e)\t", x[0], x[1], v[0], v[1], v[2], v[3]); BUG; }
RandomFields/src/operator.extremes.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/operator.extremes.cc: Copyright (C) 2005 -- 2017 Martin Schlather
RandomFields/src/operator.extremes.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/operator.extremes.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/operator.extremes.cc:    vdim = VDIM0,
RandomFields/src/operator.extremes.cc:  if (VDIM0 != VDIM1) BUG;
RandomFields/src/operator.extremes.cc:  //		     OWNDOM(0), OWNISO(0),
RandomFields/src/operator.extremes.cc:  //		     SUBMODEL_DEP, cov->frame)) != NOERROR) RETURN_ERR(err);
RandomFields/src/operator.extremes.cc:  int maxv = MIN(vdim, MAXMPPVDIM);
RandomFields/src/operator.extremes.cc:#define BR_SEMI_FACTOR (2 * BR_FACTOR) // hier Semi-Variogram
RandomFields/src/operator.extremes.cc:  *v = 2.0 * pnorm(SQRT((z - *v) * BR_SEMI_FACTOR), 0.0, 1.0, false, false);
RandomFields/src/operator.extremes.cc:  // b = BR_SEMI_FACTOR
RandomFields/src/operator.extremes.cc:  assert((hasMaxStableFrame(cov) || hasGaussMethodFrame(cov) ||
RandomFields/src/operator.extremes.cc:    //    printf("x=%10g abl=%10g %10g z=%10g %10g\n", *x, abl, BR_SEMI_FACTOR, z, *v);
RandomFields/src/operator.extremes.cc:    //    PMI0(next);
RandomFields/src/operator.extremes.cc:    abl *= BR_SEMI_FACTOR;
RandomFields/src/operator.extremes.cc:    s = SQRT((z - *v) * BR_SEMI_FACTOR); // SQRT(c * gamma)
RandomFields/src/operator.extremes.cc:  // b = BR_SEMI_FACTOR
RandomFields/src/operator.extremes.cc:    s0 = (z - *v) * BR_SEMI_FACTOR;
RandomFields/src/operator.extremes.cc:    abl  *= BR_SEMI_FACTOR;
RandomFields/src/operator.extremes.cc:    abl2 *= BR_SEMI_FACTOR;
RandomFields/src/operator.extremes.cc:  // b = BR_SEMI_FACTOR
RandomFields/src/operator.extremes.cc:    s0 = (z - *v) * BR_SEMI_FACTOR;
RandomFields/src/operator.extremes.cc:    abl  *= BR_SEMI_FACTOR;
RandomFields/src/operator.extremes.cc:    abl2 *= BR_SEMI_FACTOR;
RandomFields/src/operator.extremes.cc:    abl3 *= BR_SEMI_FACTOR;
RandomFields/src/operator.extremes.cc:  cov->rese_derivs = MIN(3, next->rese_derivs); 
RandomFields/src/operator.extremes.cc:      g = SQRT(next_taylor_const  * BR_SEMI_FACTOR * 0.5 / M_PI);
RandomFields/src/operator.extremes.cc:	  cov->taylor[1][TaylorConst] += 2 * g * next_taylor_const * BR_SEMI_FACTOR;
RandomFields/src/operator.extremes.cc:	2.0 / SQRT(2.0 * M_PI * BR_SEMI_FACTOR * next_tail_const);
RandomFields/src/operator.extremes.cc:      cov->tail[0][TaylorExpConst] = 0.5 * BR_SEMI_FACTOR * next_tail_const;
RandomFields/src/operator.extremes.cc:	2.0 / SQRT(2.0 * M_PI * BR_SEMI_FACTOR * next->tail[0][TaylorConst])
RandomFields/src/operator.extremes.cc:	* EXP(-0.5 * BR_SEMI_FACTOR * next->tail[0][TaylorConst]);
RandomFields/src/operator.extremes.cc:    vdim = VDIM0;
RandomFields/src/operator.extremes.cc:  if (vdim != VDIM1) BUG;
RandomFields/src/operator.extremes.cc:   if ((err = CHECK_PASSTF(next, VariogramType, SUBMODEL_DEP, 
RandomFields/src/operator.extremes.cc:			   // hasMaxStableFrame(cov) ? BrMethodType  :
RandomFields/src/operator.extremes.cc:       // if ((err = CHECK(next, dim,  dim, VariogramType, OWNDOM(0), 
RandomFields/src/operator.extremes.cc:       //	   OWNISO(0), SUBMODEL_DEP, 
RandomFields/src/operator.extremes.cc:       //	   hasMaxStableFrame(cov) ? Ma xStableType : EvaluationType))
RandomFields/src/operator.extremes.cc:  cov->monotone = isBernstein(next) ? GNEITING_MON : 
RandomFields/src/operator.extremes.cc:    isMonotone(next) ? MONOTONE : NOT_MONOTONE;
RandomFields/src/operator.extremes.cc:  int maxv = MIN(vdim, MAXMPPVDIM);
RandomFields/src/operator.extremes.cc:  MEMCOPY(cov->pref, DefList[COVNR].pref, sizeof(pref_shorttype)); 
RandomFields/src/operator.extremes.cc:	    TYPE_NAMES[cov->frame], NICK(next));
RandomFields/src/operator.extremes.cc:  } else ILLEGAL_FRAME;
RandomFields/src/operator.extremes.cc:  z = 2.0 * pnorm(SQRT( (z - *v) * BR_SEMI_FACTOR), 0.0, 1.0, true, false) -1.0;
RandomFields/src/operator.extremes.cc:    vdim = VDIM0;
RandomFields/src/operator.extremes.cc:   if (VDIM0 != VDIM1) BUG;
RandomFields/src/operator.extremes.cc:  //		     OWNDOM(0), OWNISO(0), 
RandomFields/src/operator.extremes.cc:  int maxv = MIN(vdim, MAXMPPVDIM);
RandomFields/src/operator.extremes.cc:  t *=  t / (BR_SEMI_FACTOR * (1.0 - alpha)); // 1/2 wegen Erf->qnorm
RandomFields/src/operator.extremes.cc:  z = 2.0 * pnorm(SQRT( (z - *v) * BR_SEMI_FACTOR), 0.0, 1.0, true, false) -1;
RandomFields/src/operator.extremes.cc:  *v = COS(M_PI * z);
RandomFields/src/operator.extremes.cc:    vdim = VDIM0;
RandomFields/src/operator.extremes.cc:  if (VDIM0 != VDIM1) BUG;
RandomFields/src/operator.extremes.cc:  //		     OWNDOM(0), OWNISO(0), 
RandomFields/src/operator.extremes.cc:			  //hasMaxStableFrame(cov) ? BrMethodType :
RandomFields/src/operator.extremes.cc:  int maxv = MIN(vdim, MAXMPPVDIM);
RandomFields/src/operator.extremes.cc:  t *= t / (BR_SEMI_FACTOR * (1.0 - alpha)); // 1/2 wegen Erf->qnorm
RandomFields/src/operator.extremes.cc:  int dim = OWNLOGDIM(0);
RandomFields/src/operator.extremes.cc:	*v = next->taylor[idx][TaylorConst] * p * (p - 1) * POW(2, p-2)/ M_PI;
RandomFields/src/operator.extremes.cc:      *v /= (M_PI * *x);
RandomFields/src/operator.extremes.cc:  int dim = OWNLOGDIM(0);
RandomFields/src/operator.extremes.cc:    cov->taylor[0][TaylorConst] = next->taylor[idx][TaylorConst] / M_PI * 
RandomFields/src/operator.extremes.cc:      cov->tail[0][TaylorConst] = next->tail[0][TaylorConst] / M_PI
RandomFields/src/operator.extremes.cc:    dim = OWNLOGDIM(0),
RandomFields/src/operator.extremes.cc: //		     OWNDOM(0), OWNISO(0),
RandomFields/src/operator.extremes.cc: if (next->randomkappa) RETURN_ERR(ERRORRANDOMKAPPA);
RandomFields/src/operator.extremes.cc:      //APMI(cov);
RandomFields/src/operator.extremes.cc:  if (false && !(hasMaxStableFrame(cov) || hasRandomFrame(cov))) {
RandomFields/src/operator.extremes.cc:    //APMI(cov);    crash();    crash();
RandomFields/src/operator.extremes.cc:    // Eplus, M2 are assumed to be still precise !!
RandomFields/src/operator.extremes.cc:    assert(VDIM0 == 1 && VDIM1 == 1);
RandomFields/src/operator.extremes.cc:  else ILLEGAL_FRAME;
RandomFields/src/operator.extremes.cc:		   OWNDOM(0), OWNISO(0),
RandomFields/src/operator.extremes.cc:		   M axStableType//  otherwise do will fail
RandomFields/src/operator.extremes.cc:    cov->mpp.mM[1] = cov->mpp.mMplus[1] = 1;     
RandomFields/src/operator.extremes.cc:#define STROKORBBALL_DIM 0 // Inner
RandomFields/src/operator.extremes.cc:    dim = OWNLOGDIM(0),
RandomFields/src/operator.extremes.cc:  //		   OWNDOM(0), OWNISO(0),
RandomFields/src/operator.extremes.cc:  if (false && !(hasMaxStableFrame(cov) || hasRandomFrame(cov)))
RandomFields/src/operator.extremes.cc:  assert(MODELNR(local)==POWER_DOLLAR && MODELNR(remote)==LOC);
RandomFields/src/operator.extremes.cc:  double scale = PARAM0(local, POWSCALE);
RandomFields/src/operator.extremes.cc:  PARAM(remote, LOC_SCALE)[0] = scale;
RandomFields/src/operator.extremes.cc:    dim = OWNLOGDIM(0);
RandomFields/src/operator.extremes.cc:  ASSERT_NEWMODEL_NOT_NULL;
RandomFields/src/operator.extremes.cc:    addModel(newmodel, BALL, cov);    
RandomFields/src/operator.extremes.cc:    addModelX(newmodel, POWER_DOLLAR);
RandomFields/src/operator.extremes.cc:      kdefault(scale, STROKORBBALL_DIM, dim);
RandomFields/src/operator.extremes.cc:      addModel(&scale, RECTANGULAR, *newmodel); 
RandomFields/src/operator.extremes.cc:      addModelKappa(*newmodel, POWSCALE, UNIF); 
RandomFields/src/operator.extremes.cc:      kdefault((*newmodel)->kappasub[POWSCALE], UNIF_MIN, P0(0));
RandomFields/src/operator.extremes.cc:      kdefault((*newmodel)->kappasub[POWSCALE], UNIF_MAX, P0(1));
RandomFields/src/operator.extremes.cc:    addModel(&pts, RECTANGULAR, *newmodel);
RandomFields/src/operator.extremes.cc:    addModel(&pts, LOC, *newmodel);
RandomFields/src/operator.extremes.cc:    addModelKappa(pts, LOC_SCALE, NULL_MODEL); 
RandomFields/src/operator.extremes.cc:    addModelX(newmodel, ZHOU); // to do : unif better ?!
RandomFields/src/operator.extremes.cc:  } else ILLEGAL_FRAME_STRUCT;
RandomFields/src/operator.extremes.cc:  if (cov->frame = = M axStableType) {
RandomFields/src/operator.extremes.cc:    // Eplus, M2 are assumed to be still precise !!
RandomFields/src/operator.extremes.cc:  else ILLEGAL_FRAME;
RandomFields/src/operator.extremes.cc:    cov->mpp.mM[1] = cov->mpp.mMplus[1] = 1;     
RandomFields/src/operator.extremes.cc:  int dim = COVNR != STROKORB_BALL_INNER || PisNULL(STROKORBBALL_DIM) 
RandomFields/src/operator.extremes.cc:    ? OWNLOGDIM(0) : P0INT(STROKORBBALL_DIM);
RandomFields/src/operator.extremes.cc:  switch(P0INT(STROKORBBALL_DIM)) {
RandomFields/src/operator.extremes.cc:  if (OWNLOGDIM(0) != 1) SERR("only dimension 1 allowed");
RandomFields/src/operator.extremes.cc:  switch(P0INT(STROKORBBALL_DIM)) {
RandomFields/src/operator.extremes.cc:  if (next->randomkappa) RETURN_ERR(ERRORRANDOMKAPPA);// u.a. Taylor fehlt
RandomFields/src/operator.extremes.cc:  assert(VDIM0 == 1 && VDIM1 == 1);
RandomFields/src/operator.extremes.cc:  cov->mpp.mM[0] = cov->mpp.mMplus[0] = 1;     
RandomFields/src/operator.extremes.cc:    cov->mpp.mM[1] = cov->mpp.mMplus[1] = 1;     
RandomFields/src/operator.extremes.cc:  range->min[STROKORBBALL_DIM] = 1; 
RandomFields/src/operator.extremes.cc:  range->max[STROKORBBALL_DIM] = 3;
RandomFields/src/operator.extremes.cc:  range->pmin[STROKORBBALL_DIM] = 1;
RandomFields/src/operator.extremes.cc:  range->pmax[STROKORBBALL_DIM] = 3;
RandomFields/src/operator.extremes.cc:  range->openmin[STROKORBBALL_DIM] = false;
RandomFields/src/operator.extremes.cc:  range->openmax[STROKORBBALL_DIM] = false;
RandomFields/src/operator.extremes.cc:  assert(MODELNR(local)==POLYGON && MODELNR(remote)==UNIF &&
RandomFields/src/operator.extremes.cc:    dim = LOGDIM(SYSOF(local), 0);
RandomFields/src/operator.extremes.cc:    PARAM(remote, UNIF_MIN)[d] = P->box0[d];
RandomFields/src/operator.extremes.cc:    PARAM(remote, UNIF_MAX)[d] = P->box1[d];
RandomFields/src/operator.extremes.cc:    dim = OWNLOGDIM(0),
RandomFields/src/operator.extremes.cc:  //		   OWNDOM(0), OWNISO(0),
RandomFields/src/operator.extremes.cc:    dim = OWNLOGDIM(0);
RandomFields/src/operator.extremes.cc:  ASSERT_NEWMODEL_NOT_NULL;
RandomFields/src/operator.extremes.cc:      var = PARAM0(sub, DVAR);    
RandomFields/src/operator.extremes.cc:    if (SUBNR != BROWNIAN || PARAM0(sub, BROWN_ALPHA) != 1.0) {
RandomFields/src/operator.extremes.cc:    addModel(&pts, UNIF, NULL, true);
RandomFields/src/operator.extremes.cc:    kdefault(pts, UNIF_NORMED, (int) false);
RandomFields/src/operator.extremes.cc:    PARAMALLOC(pts, UNIF_MIN, dim, 1);
RandomFields/src/operator.extremes.cc:    PARAMALLOC(pts, UNIF_MAX, dim, 1);
RandomFields/src/operator.extremes.cc:    addModel(&shape, POLYGON, NULL, true);
RandomFields/src/operator.extremes.cc:    addModelKappa(shape, POLYGON_BETA, ARCSQRT_DISTR);
RandomFields/src/operator.extremes.cc:    addModelX(newmodel, ZHOU);
RandomFields/src/operator.extremes.cc:    kdefault(*newmodel, ZHOU_NORMED, false);
RandomFields/src/operator.extremes.cc:  } else ILLEGAL_FRAME_STRUCT;
Binary file RandomFields/src/tbm.o matches
Binary file RandomFields/src/operator.o matches
RandomFields/src/Makevars:PKG_LIBS =  $(LAPACK_LIBS) $(BLAS_LIBS)  $(SHLIB_OPENMP_CXXFLAGS) $(FLIBS) 
RandomFields/src/Makevars:PKG_CXXFLAGS =    $(SHLIB_OPENMP_CXXFLAGS)   -msse2 -mssse3 -mavx2 
RandomFields/src/Specific.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/Specific.cc: Copyright (C) 2001 -- 2017 Martin Schlather, 
RandomFields/src/Specific.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/Specific.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/Specific.cc:    dim = ANYDIM; // taken[MAX DIM],
RandomFields/src/Specific.cc:  FRAME_ASSERT_GAUSS_INTERFACE;
RandomFields/src/Specific.cc:  if (DefList[NEXTNR].Specific == MISMATCH || DefList[NEXTNR].Specific ==UNSET)
RandomFields/src/Specific.cc:    SERR1("specific method for '%.50s' not known", NAME(next));
RandomFields/src/Specific.cc:    ASSERT_ONESYSTEM;
RandomFields/src/Specific.cc:      //      printf("SPECIFIC %d %s\n", i, TYPE_NAMES[type[i]]);
RandomFields/src/Specific.cc:		       SUBMODEL_DEP, EvaluationType)) // schwach, damit es
RandomFields/src/Specific.cc:      //      if (i==2) APMI(next);
RandomFields/src/Specific.cc:    //PMI0(next);
RandomFields/src/Specific.cc:    if ((err = CHECK_PASSTF(key, GaussMethodType, VDIM0, GaussMethodType))
RandomFields/src/Specific.cc:  VDIM0 = sub->vdim[0];
RandomFields/src/Specific.cc:  VDIM1 = sub->vdim[1];
RandomFields/src/Specific.cc:  //PMI0(cov);
RandomFields/src/Specific.cc:  FRAME_ASSERT_GAUSS_INTERFACE;
RandomFields/src/Specific.cc:  COPYALLSYSTEMS(PREVSYSOF(cov->key), PREVSYSOF(next), false);
RandomFields/src/Specific.cc:  //  PMI0(cov->key); 
RandomFields/src/Specific.cc:  SET_NR(cov->key, DefList[MODELNR(cov->key)].Specific);
RandomFields/src/Specific.cc:  //if ((err = CHECK_PASSTF(cov->key, GaussMethodType, VDIM0, GaussMethodType))
RandomFields/src/Specific.cc:  cov->key->frame = GaussMethodType;
RandomFields/src/Specific.cc:  set_type(PREVSYSOF(cov->key), 0, GaussMethodType);
RandomFields/src/Specific.cc:  set_type(SYSOF(cov->key), 0, GaussMethodType);
RandomFields/src/Specific.cc:  //APMI(cov);
RandomFields/src/Specific.cc:  if ((err = CHECK_PASSTF(cov->key, GaussMethodType, VDIM0, GaussMethodType))
RandomFields/src/Specific.cc:   //		   cov->vdim, GaussMethodType)) != NOERROR) {
RandomFields/src/Specific.cc:    //    PMI(cov->key); XERR(err);
RandomFields/src/Specific.cc:  FRAME_ASSERT_GAUSS_INTERFACE;
RandomFields/src/Specific.cc:  //printf("specific : %.50s\n", NAME(key));
RandomFields/src/sequential.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/sequential.cc: Copyright (C) 2001 -- 2017 Martin Schlather, 
RandomFields/src/sequential.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/sequential.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/sequential.cc:#define SEQU_BACK (COMMON_GAUSS + 1)
RandomFields/src/sequential.cc:#define SEQU_INIT (COMMON_GAUSS + 2)
RandomFields/src/sequential.cc:    dim = ANYDIM; // taken[MAX DIM],
RandomFields/src/sequential.cc:		   SUBMODEL_DEP, GaussMethodType)) != NOERROR) {
RandomFields/src/sequential.cc:    dim = ANYDIM,
RandomFields/src/sequential.cc:    *MuT = NULL, 
RandomFields/src/sequential.cc:  if (DefList[NEXTNR].implemented[Sequential] != IMPLEMENTED) {
RandomFields/src/sequential.cc:  if (VDIM0 > 1) {
RandomFields/src/sequential.cc:      err=ERRORNOMULTIVARIATE; 
RandomFields/src/sequential.cc:    GERR6("'%.50s' valid only if the number of locations is less than '%.50s' (=%d) . Got %d * %ld = %ld.", NICK(cov), direct[DIRECT_MAXVAR_PARAM],
RandomFields/src/sequential.cc:  if ((U22 = (double *) MALLOC(sizeof(double) * totpntsSQ))==NULL ||
RandomFields/src/sequential.cc:      (Inv22 = (double *) MALLOC(sizeof(double) * totpntsSQ))==NULL ||
RandomFields/src/sequential.cc:      (COV21 = (double *) MALLOC(sizeof(double) * spatialpntsSQback))==NULL ||
RandomFields/src/sequential.cc:      (U11 = (double *) MALLOC(sizeof(double) * spatialpntsSQ))==NULL ||
RandomFields/src/sequential.cc:      (MuT = (double *) MALLOC(sizeof(double) * spatialpntsSQback))==NULL ||
RandomFields/src/sequential.cc:      (G = (double *) MALLOC(sizeof(double) * totpnts))==NULL ||
RandomFields/src/sequential.cc:      (res0 = (double *) MALLOC(sizeof(double) * vdim *
RandomFields/src/sequential.cc:    err=ERRORMEMORYALLOCATION;  
RandomFields/src/sequential.cc:  y = (double*) MALLOC(dim * sizeof(double));
RandomFields/src/sequential.cc:    err=ERRORDECOMPOSITION;
RandomFields/src/sequential.cc:  MEMCOPY(Inv22, U22, sizeof(double) * totpntsSQ);
RandomFields/src/sequential.cc:  // *** MuT
RandomFields/src/sequential.cc:	MuT[l++] = dummy;
RandomFields/src/sequential.cc:  LPRINT("MuT\n");
RandomFields/src/sequential.cc:      LPRINT("%3.2f ", MuT[i + j * totpnts]);
RandomFields/src/sequential.cc:	for (int kk=0; kk<totpnts; kk++) dummy += MuT[i + kk] * COV21[j + kk];
RandomFields/src/sequential.cc:    err=ERRORDECOMPOSITION;
RandomFields/src/sequential.cc:    FREE(MuT);
RandomFields/src/sequential.cc:      S->MuT=MuT;
RandomFields/src/sequential.cc:		    double *U11, double *MuT, double *G) {
RandomFields/src/sequential.cc:    for (int i=0; i<spatialpnts; i++) G[i] = GAUSS_RANDOM(1.0);
RandomFields/src/sequential.cc:	  dummy += MuT[mutj++] * (double) oldrp[j];
RandomFields/src/sequential.cc:  double *G,*U22, *U11, *MuT;
RandomFields/src/sequential.cc:  MuT = S->MuT;
RandomFields/src/sequential.cc:  for (int i=0; i<totpnts; i++) G[i] = GAUSS_RANDOM(1.0);
RandomFields/src/sequential.cc:  sequentialpart(res0, totpnts, S->spatialpnts, S->initial, U11, MuT, G);
RandomFields/src/sequential.cc:  MEMCOPY(res, res0, sizeof(double) * totpnts * vdim);
RandomFields/src/sequential.cc:		 U11, MuT, G);
RandomFields/src/fftVarioAlt.cc: Johannes Martini
RandomFields/src/fftVarioAlt.cc: Copyright (C) 2011 -- 2013 Sebastian Engelke, Johannes Martini
RandomFields/src/fftVarioAlt.cc: Copyright (C) 2014 Sebastian Engelke, Johannes Martini, Martin Schlather
RandomFields/src/fftVarioAlt.cc: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/src/fftVarioAlt.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/fftVarioAlt.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/fftVarioAlt.cc:  phi = Mod(phi, maxAngle);
RandomFields/src/fftVarioAlt.cc:		SEXP VARIABLE_IS_NOT_USED MeanVar,
RandomFields/src/fftVarioAlt.cc:  back = PROTECT(allocMatrix(REALSXP, totalbins, 2) );
RandomFields/src/fftVarioAlt.cc:#define SUMVALS_JJ sumvals[jj]
RandomFields/src/fftVarioAlt.cc:  if ((BinSq = (double *) MALLOC(sizeof(double)* (nbin + 1))) ==NULL) {
RandomFields/src/fftVarioAlt.cc:    err=ERRORMEMORYALLOCATION; goto ErrorHandling; 
RandomFields/src/fftVarioAlt.cc:		      kM1 = k - 1,	
RandomFields/src/fftVarioAlt.cc:		      TkM2 = 2 - k,
RandomFields/src/fftVarioAlt.cc:		      base = binidx + (kphi + Nphihalf * kM1) * nbin,
RandomFields/src/fftVarioAlt.cc:		      Idx = ((Ntheta - 1 - ktheta) * kM1 + 
RandomFields/src/fftVarioAlt.cc:			     ktheta * TkM2) * NphiNbin;
RandomFields/src/fftVarioAlt.cc:		    //		    printf("base=%d %d %d %f %f %f %f\n", base, Idx, jj, SUMVALS_JJ, nbvals[jj], emp_vario[base + Idx], n[base + Idx]);
RandomFields/src/fftVarioAlt.cc:		    emp_vario[base + Idx] += SUMVALS_JJ;
RandomFields/src/fftVarioAlt.cc:		    //		    printf("base=%d %d %d %f %f %f %f\n", base, Idx, jj, SUMVALS_JJ, nbvals[jj], emp_vario[base + Idx], n[base + Idx]);
RandomFields/src/fftVarioAlt.cc:		      basX = binidx + (kphix + Nphihalf * kM1) * nbin;
RandomFields/src/fftVarioAlt.cc:		      emp_vario[basX + Idx] += SUMVALS_JJ;
RandomFields/src/fftVarioAlt.cc:		      Idx = ((Ntheta -1 - kthetaz) * kM1 + kthetaz * TkM2) * 
RandomFields/src/fftVarioAlt.cc:		      emp_vario[base + Idx] += SUMVALS_JJ;
RandomFields/src/fftVarioAlt.cc:			emp_vario[basX + Idx] += SUMVALS_JJ;
RandomFields/src/fftVarioAlt.cc:		    emp_vario[Idx] += SUMVALS_JJ;
RandomFields/src/fftVarioAlt.cc:		      emp_vario[Idx] += SUMVALS_JJ;
RandomFields/src/fftVarioAlt.cc:		      emp_vario[Idx] += SUMVALS_JJ;
RandomFields/src/fftVarioAlt.cc:			emp_vario[Idx] += SUMVALS_JJ;
RandomFields/src/fftVarioAlt.cc:		      emp_vario[Idx] += SUMVALS_JJ;
RandomFields/src/fftVarioAlt.cc:			emp_vario[Idx] += SUMVALS_JJ;
RandomFields/src/fftVarioAlt.cc:			emp_vario[Idx] += SUMVALS_JJ;
RandomFields/src/fftVarioAlt.cc:			  emp_vario[Idx] += SUMVALS_JJ;
RandomFields/src/fftVarioAlt.cc:// 	// die bin-Matrix fuer die aufsummierten werte
RandomFields/src/fftVarioAlt.cc:// 	// die bin-Matrix fuer die gewichte
RandomFields/src/fftVarioAlt.cc:// 	 * MAIN LOOP
RandomFields/src/PoissonPolygon.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/PoissonPolygon.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/PoissonPolygon.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
Binary file RandomFields/src/init.others.o matches
Binary file RandomFields/src/hyperplan.o matches
RandomFields/src/auxiliary.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/auxiliary.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/src/auxiliary.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/auxiliary.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/auxiliary.h:double getMinimalAbsEigenValue(double *Aniso, int dim);
RandomFields/src/auxiliary.h:double *EinheitsMatrix(int dim);
RandomFields/src/auxiliary.h:SEXP Mat(double* V, int row, int col);
RandomFields/src/auxiliary.h:SEXP Mat_t(double* V, int row, int col);
RandomFields/src/auxiliary.h:#define MIN(A,B) ((A) < (B) ? (A) : (B))
RandomFields/src/auxiliary.h:#define MAX(A,B) ((A) > (B) ? (A) : (B))
RandomFields/src/auxiliary.h:#ifdef EVEN_NOT_USED_ON_SCHLATHERS_MACHINE
RandomFields/src/auxiliary.h:#define FMOD fmod
RandomFields/src/auxiliary.h:#define REMAINDER remainder
RandomFields/src/auxiliary.h:#define FDIM fdim
RandomFields/src/auxiliary.h://#define EXPM1(X) (EXP(X) - 1.0)
RandomFields/src/auxiliary.h:#define FMOD(X, Y) ((double) ((X) - (Y) * (int) ((X) / (Y))))
RandomFields/src/auxiliary.h:#define REMAINDER(X, Y) ((double) ((X) - (Y) * FROUND((X) / (Y), 0))) // ROUND(
RandomFields/src/auxiliary.h:#define FDIM(X, Y) FMAX((double) (X) - (Y), 0.0)
RandomFields/src/primitive.matern.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/primitive.matern.cc: Copyright (C) 2017 -- 2018 Olga Moreva (bivariate models) & Martin Schlather
RandomFields/src/primitive.matern.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/primitive.matern.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/primitive.matern.cc://#define LOG2 M_LN2
RandomFields/src/primitive.matern.cc:   80, 80, // TBM
RandomFields/src/primitive.matern.cc:#define GET_NU_GEN(NU) (PisNULL(WM_NOTINV) || P0INT(WM_NOTINV) ? NU : 1.0 / NU)
RandomFields/src/primitive.matern.cc:#define GET_NU GET_NU_GEN(P0(WM_NU))
RandomFields/src/primitive.matern.cc:/* Whittle-Matern or Whittle or Besset ---- rescaled form of Whittle-Matern,
RandomFields/src/primitive.matern.cc:#define LOGGAMMA(nu) lgammafn(nu < MATERN_NU_THRES ? nu : MATERN_NU_THRES)
RandomFields/src/primitive.matern.cc:#define LOW_MATERN 1e-20
RandomFields/src/primitive.matern.cc:double logWM(double x, double nu, double loggamma, double factor) {
RandomFields/src/primitive.matern.cc:    nuThres = nu < MATERN_NU_THRES ? nu : MATERN_NU_THRES,
RandomFields/src/primitive.matern.cc:  double bk[MATERN_NU_THRES + 1L];
RandomFields/src/primitive.matern.cc:  if (x > LOW_MATERN && nu < RF_INF) {
RandomFields/src/primitive.matern.cc:  if (nu > MATERN_NU_THRES) { // factor!=0.0 && 
RandomFields/src/primitive.matern.cc:      g = MATERN_NU_THRES / nu;
RandomFields/src/primitive.matern.cc:double Intern_WM(double x, double nu, double loggamma, double factor) {
RandomFields/src/primitive.matern.cc:  //  printf("vw = %f\n", logWM(x, nu, loggamma, factor));
RandomFields/src/primitive.matern.cc:  return EXP(logWM(x, nu, loggamma, factor));
RandomFields/src/primitive.matern.cc:double Intern_DWM(double x, double nu, double loggamma, double factor) { 
RandomFields/src/primitive.matern.cc:    nuThres = nu <= MATERN_NU_THRES ? nu : MATERN_NU_THRES,
RandomFields/src/primitive.matern.cc:  double bk[MATERN_NU_THRES + 1L];
RandomFields/src/primitive.matern.cc:  if (x > LOW_MATERN && nu < RF_INF) {  
RandomFields/src/primitive.matern.cc:  if (nu > MATERN_NU_THRES) {
RandomFields/src/primitive.matern.cc:      g = MATERN_NU_THRES / nu;
RandomFields/src/primitive.matern.cc:double Intern_DDWM(double x, double nu, double gamma, double factor) { 
RandomFields/src/primitive.matern.cc:    nuThres = nu < MATERN_NU_THRES ? nu : MATERN_NU_THRES, // >
RandomFields/src/primitive.matern.cc:		   bk[MATERN_NU_THRES + 1L];
RandomFields/src/primitive.matern.cc:  if (x > LOW_MATERN && nu < RF_INF) {  
RandomFields/src/primitive.matern.cc:  if (nu > MATERN_NU_THRES) {
RandomFields/src/primitive.matern.cc:      g = MATERN_NU_THRES / nu;
RandomFields/src/primitive.matern.cc:double Intern_D3WM(double x, double nu, double gamma, double factor) { 
RandomFields/src/primitive.matern.cc:    nuThres = nu < MATERN_NU_THRES ? nu : MATERN_NU_THRES,
RandomFields/src/primitive.matern.cc:  double bk[MATERN_NU_THRES + 1L];
RandomFields/src/primitive.matern.cc:  if (x > LOW_MATERN && nu < RF_INF) {
RandomFields/src/primitive.matern.cc:  if (nu > MATERN_NU_THRES) {
RandomFields/src/primitive.matern.cc:      g = MATERN_NU_THRES / nu;
RandomFields/src/primitive.matern.cc:double Intern_D4WM(double x,  double nu, double gamma, double factor) {
RandomFields/src/primitive.matern.cc:    nuThres = nu < MATERN_NU_THRES ? nu : MATERN_NU_THRES,
RandomFields/src/primitive.matern.cc:  double bk[MATERN_NU_THRES + 1L];
RandomFields/src/primitive.matern.cc:  if (x > LOW_MATERN && nu < RF_INF) {
RandomFields/src/primitive.matern.cc:  if (nu > MATERN_NU_THRES) {
RandomFields/src/primitive.matern.cc:      g = MATERN_NU_THRES / nu;
RandomFields/src/primitive.matern.cc:double logNonStWM(double *x, double *y, int *info, model *cov, double factor){
RandomFields/src/primitive.matern.cc:  model *nu = cov->kappasub[WM_NU];
RandomFields/src/primitive.matern.cc:     dim = OWNLOGDIM(0);
RandomFields/src/primitive.matern.cc:      ERR1("'%.50s' is not a positive function", KNAME(WM_NU));
RandomFields/src/primitive.matern.cc:    v = Ext_logWM(norm, nux, nuy, factor);
RandomFields/src/primitive.matern.cc:double ScaleWM(double nu){
RandomFields/src/primitive.matern.cc:bool setWM(model *cov) {
RandomFields/src/primitive.matern.cc:  model *nusub = cov->kappasub[WM_NU];
RandomFields/src/primitive.matern.cc:  //  PMI(cov);  printf("X %d\n", LASTi((PREV)[0]));  printf("%d\n", PREV_INITIALISED);   printf("Y\n");
RandomFields/src/primitive.matern.cc:    set_iso(OWN, 0, isAnySpherical(iso) ? SPHERICAL_SYMMETRIC : SYMMETRIC);
RandomFields/src/primitive.matern.cc:bool allowedDWM(model *cov) {
RandomFields/src/primitive.matern.cc:  model *nusub = cov->kappasub[WM_NU];
RandomFields/src/primitive.matern.cc:  for (int i=FIRST_DOMAIN; i<LAST_DOMAINUSER; D[i++]=false);
RandomFields/src/primitive.matern.cc:bool allowedIWM(model *cov) {
RandomFields/src/primitive.matern.cc:  model *nusub = cov->kappasub[WM_NU];
RandomFields/src/primitive.matern.cc:    I[SYMMETRIC] = I[SPHERICAL_SYMMETRIC] = true;
RandomFields/src/primitive.matern.cc:int initWM(model *cov, gen_storage VARIABLE_IS_NOT_USED  *s) {
RandomFields/src/primitive.matern.cc:  if (!PisNULL(WM_NU)) {
RandomFields/src/primitive.matern.cc:      double nuThres = nu < MATERN_NU_THRES ? nu : MATERN_NU_THRES;
RandomFields/src/primitive.matern.cc:      cov->q[WM_LOGGAMMA] = lgammafn(nuThres);
RandomFields/src/primitive.matern.cc:      cov->q[WM_GAMMA] = gammafn(nuThres);      
RandomFields/src/primitive.matern.cc:int checkWM(model *cov) { 
RandomFields/src/primitive.matern.cc:  model *nusub = cov->kappasub[WM_NU];
RandomFields/src/primitive.matern.cc:    dim = OWNLOGDIM(0);
RandomFields/src/primitive.matern.cc:  set_logdim(OWN, 0, GATTERLOGDIM(0));
RandomFields/src/primitive.matern.cc:    //PMI(cov)
RandomFields/src/primitive.matern.cc:	    DOMAIN_NAMES[OWNDOM(0)], ISO_NAMES[OWNISO(0)]);
RandomFields/src/primitive.matern.cc:    set_xdim(OWN, 0, GATTERXDIM(0));
RandomFields/src/primitive.matern.cc:    if (LOGDIM(SYSOF(nusub), 0) != dim) RETURN_ERR(ERRORWRONGDIM);
RandomFields/src/primitive.matern.cc:    cov->monotone = NORMAL_MIXTURE;
RandomFields/src/primitive.matern.cc:  if (!equalsXonly(OWNDOM(0)) || !isAnyIsotropic(OWNISO(0))) 
RandomFields/src/primitive.matern.cc:	  DOMAIN_NAMES[OWNDOM(0)], ISO_NAMES[OWNISO(0)]);
RandomFields/src/primitive.matern.cc:  if (PisNULL(WM_NU)) QERRC(0, "parameter unset"); 
RandomFields/src/primitive.matern.cc:    initWM(cov, NULL);
RandomFields/src/primitive.matern.cc:    cov->pref[SpectralTBM] =  nu < spectrallimit ? PREF_NONE : 3;
RandomFields/src/primitive.matern.cc:  else cov->pref[SpectralTBM] =
RandomFields/src/primitive.matern.cc:    nu < WhittleUpperNu[SpectralTBM] ? cov->pref[SpectralTBM] : PREF_NONE;
RandomFields/src/primitive.matern.cc:  cov->monotone = nu <= 0.5 ? COMPLETELY_MON : NORMAL_MIXTURE;
RandomFields/src/primitive.matern.cc:void rangeWM(model *cov, range_type *range){
RandomFields/src/primitive.matern.cc:    if (PisNULL(WM_NOTINV) || P0INT(WM_NOTINV)) {
RandomFields/src/primitive.matern.cc:      range->min[WM_NU] = 0.0;
RandomFields/src/primitive.matern.cc:      range->max[WM_NU] = 0.5;
RandomFields/src/primitive.matern.cc:      range->pmin[WM_NU] = 1e-1;
RandomFields/src/primitive.matern.cc:      range->pmax[WM_NU] = 0.5;
RandomFields/src/primitive.matern.cc:      range->openmin[WM_NU] = true;
RandomFields/src/primitive.matern.cc:      range->openmax[WM_NU] = false;
RandomFields/src/primitive.matern.cc:      range->min[WM_NU] = 2.0;
RandomFields/src/primitive.matern.cc:      range->max[WM_NU] = RF_INF;
RandomFields/src/primitive.matern.cc:      range->pmin[WM_NU] = 2.0;
RandomFields/src/primitive.matern.cc:      range->pmax[WM_NU] = 10.0;
RandomFields/src/primitive.matern.cc:      range->openmin[WM_NU] = false;
RandomFields/src/primitive.matern.cc:      range->openmax[WM_NU] = true;
RandomFields/src/primitive.matern.cc:    range->min[WM_NU] = 0.0;
RandomFields/src/primitive.matern.cc:    range->max[WM_NU] = RF_INF;
RandomFields/src/primitive.matern.cc:    range->pmin[WM_NU] = 1e-1;
RandomFields/src/primitive.matern.cc:    range->pmax[WM_NU] = 10.0;
RandomFields/src/primitive.matern.cc:    range->openmin[WM_NU] = true;
RandomFields/src/primitive.matern.cc:    range->openmax[WM_NU] = false;
RandomFields/src/primitive.matern.cc:  booleanRange(WM_NOTINV);
RandomFields/src/primitive.matern.cc:void coinitWM(model *cov, localfactstype *li) {
RandomFields/src/primitive.matern.cc:    li->msg[0] = li->msg[1] = MSGLOCAL_OK;
RandomFields/src/primitive.matern.cc:    li->msg[0] = (nu <= thres[1]) ? MSGLOCAL_OK : MSGLOCAL_JUSTTRY;
RandomFields/src/primitive.matern.cc:void ieinitWM(model *cov, localfactstype *li) {
RandomFields/src/primitive.matern.cc:    li->msg[0] = MSGLOCAL_OK;
RandomFields/src/primitive.matern.cc:    li->msg[0] = MSGLOCAL_JUSTTRY;
RandomFields/src/primitive.matern.cc:double densityWM(double *x, model *cov, double factor) {
RandomFields/src/primitive.matern.cc:    dim =  PREVLOGDIM(0);
RandomFields/src/primitive.matern.cc:			 - (double) dim * M_LN_SQRT_PI
RandomFields/src/primitive.matern.cc:void Matern(double *x, INFO, model *cov, double *v) {
RandomFields/src/primitive.matern.cc:  *v = Intern_WM(*x, GET_NU, cov->q[WM_LOGGAMMA], SQRT2);
RandomFields/src/primitive.matern.cc:  // printf("%f %f %f %f\n", *x, *v, GET_NU, cov->q[WM_LOGGAMMA]);
RandomFields/src/primitive.matern.cc:void logMatern(double *x, INFO, model *cov, double *v, double *Sign) { 
RandomFields/src/primitive.matern.cc:  *v = logWM(*x, nu, cov->q[WM_LOGGAMMA], SQRT2);
RandomFields/src/primitive.matern.cc:void NonStMatern(double *x, double *y, int *info, model *cov, double *v){ 
RandomFields/src/primitive.matern.cc:  *v = EXP(logNonStWM(x, y, info, cov, SQRT2));
RandomFields/src/primitive.matern.cc:void logNonStMatern(double *x, double *y, int *info, model *cov, double *v, 
RandomFields/src/primitive.matern.cc:  *v = logNonStWM(x, y, info, cov, SQRT2);
RandomFields/src/primitive.matern.cc:void DMatern(double *x, INFO, model *cov, double *v) {
RandomFields/src/primitive.matern.cc:  *v =Intern_DWM(*x, GET_NU, cov->q[WM_LOGGAMMA], SQRT2);
RandomFields/src/primitive.matern.cc:void DDMatern(double *x, INFO, model *cov, double *v) {
RandomFields/src/primitive.matern.cc:  *v=Intern_DDWM(*x, GET_NU, cov->q[WM_GAMMA], SQRT2);
RandomFields/src/primitive.matern.cc:void D3Matern(double *x, INFO, model *cov, double *v) {
RandomFields/src/primitive.matern.cc:  *v=Intern_D3WM(*x, GET_NU,  cov->q[WM_GAMMA], SQRT2);
RandomFields/src/primitive.matern.cc:void D4Matern(double *x, INFO, model *cov, double *v) {
RandomFields/src/primitive.matern.cc:  *v=Intern_D4WM(*x, GET_NU, cov->q[WM_GAMMA], SQRT2);
RandomFields/src/primitive.matern.cc:void InverseMatern(double *x, model *cov, double *v) {
RandomFields/src/primitive.matern.cc:  if (*x == 0.05) *v = SQRT2 * SQRT(nu) /  ScaleWM(nu);
RandomFields/src/primitive.matern.cc:void inversenonstatMatern(double *x, model *cov, double *left, double*right) {
RandomFields/src/primitive.matern.cc:  model *nufct = cov->kappasub[WM_NU];
RandomFields/src/primitive.matern.cc:  int dim = PREVTOTALXDIM;
RandomFields/src/primitive.matern.cc:  if (nufct == NULL) InverseMatern(x, cov, &inv);
RandomFields/src/primitive.matern.cc:    if (*x == 0.05) inv = SQRT2 * SQRT(nu) /  ScaleWM(nu);
RandomFields/src/primitive.matern.cc:int checkMatern(model *cov) { 
RandomFields/src/primitive.matern.cc:  kdefault(cov, WM_NOTINV, true);
RandomFields/src/primitive.matern.cc:  return checkWM(cov);
RandomFields/src/primitive.matern.cc:Types TypeWM(Types required, model *cov, isotropy_type requ_iso){
RandomFields/src/primitive.matern.cc:  //  printf("requ=%.50s, %.50s\n", TYPE_NAMES[required], ISO_NAMES[requ_iso]);
RandomFields/src/primitive.matern.cc:  //  PMI(cov->calling);
RandomFields/src/primitive.matern.cc:  model *nusub = cov->kappasub[WM_NU];
RandomFields/src/primitive.matern.cc:      if ((equalsXonly(OWNDOM(0)) && !isRandom(nusub)) ||
RandomFields/src/primitive.matern.cc:    //    printf("TC0 %.50s %d %d %.50s\n",  TYPE_NAMES[required], !isEarthSymmetric(requ_iso), nusub != NULL, ISO_NAMES[requ_iso]);
RandomFields/src/primitive.matern.cc:double densityMatern(double *x, model *cov) {
RandomFields/src/primitive.matern.cc:  return densityWM(x, cov, SQRT2);
RandomFields/src/primitive.matern.cc:int initMatern(model *cov, gen_storage *s) {
RandomFields/src/primitive.matern.cc:  if (HAS_SPECTRAL_FRAME(cov)) {
RandomFields/src/primitive.matern.cc:    if (OWNLOGDIM(0) <= 2) RETURN_NOERROR;
RandomFields/src/primitive.matern.cc:    cs->density = densityMatern;
RandomFields/src/primitive.matern.cc:  else ILLEGAL_FRAME;
RandomFields/src/primitive.matern.cc:void spectralMatern(model *cov, gen_storage *S, double *e) { 
RandomFields/src/primitive.matern.cc:  int dim = PREVLOGDIM(0);
RandomFields/src/primitive.matern.cc:	SQRT( 2.0 * nu * (POW(1.0 - UNIFORM_RANDOM, -1.0 / nu) - 1.0) ), e);
RandomFields/src/primitive.matern.cc:  *v = Intern_WM(*x, nu, cov->q[WM_LOGGAMMA], 0.0);
RandomFields/src/primitive.matern.cc:  *v = logWM(*x, nu, cov->q[WM_LOGGAMMA], 0.0);
RandomFields/src/primitive.matern.cc:  *v = EXP(logNonStWM(x, y, info, cov, 0.0));
RandomFields/src/primitive.matern.cc:  *v = logNonStWM(x, y, info, cov, 0.0);
RandomFields/src/primitive.matern.cc:  *v =Intern_DWM(*x, GET_NU, cov->q[WM_LOGGAMMA], 0.0);
RandomFields/src/primitive.matern.cc:  *v=Intern_DDWM(*x, GET_NU, cov->q[WM_GAMMA], 0.0);
RandomFields/src/primitive.matern.cc:  *v=Intern_D3WM(*x, GET_NU,  cov->q[WM_GAMMA], PisNULL(WM_NOTINV) ? 0.0 : SQRT2);
RandomFields/src/primitive.matern.cc:  *v=Intern_D4WM(*x, GET_NU, cov->q[WM_GAMMA], PisNULL(WM_NOTINV) ? 0.0 : SQRT2);
RandomFields/src/primitive.matern.cc:  *v = *x == 0.05 ?  1.0 / ScaleWM(nu) : RF_NA;
RandomFields/src/primitive.matern.cc:  model *nufct = cov->kappasub[WM_NU];
RandomFields/src/primitive.matern.cc:  int dim = PREVTOTALXDIM;
RandomFields/src/primitive.matern.cc:    if (*x == 0.05) inv = 1.0 /  ScaleWM(nu);
RandomFields/src/primitive.matern.cc:void TBM2Whittle(double *x, int *info, model *cov, double *v) 
RandomFields/src/primitive.matern.cc:  assert(PisNULL(WM_NOTINV));
RandomFields/src/primitive.matern.cc:  if (nu == 0.5) TBM2exponential(x, info, cov, v);
RandomFields/src/primitive.matern.cc:  return densityWM(x, cov, PisNULL(WM_NOTINV) ? 0.0 : SQRT2);
RandomFields/src/primitive.matern.cc:  if (HAS_SPECTRAL_FRAME(cov)) {
RandomFields/src/primitive.matern.cc:    if (PisNULL(WM_NU)) {
RandomFields/src/primitive.matern.cc:      if (OWNLOGDIM(0) <= 2) RETURN_NOERROR;
RandomFields/src/primitive.matern.cc:    } else return initMatern(cov, s);
RandomFields/src/primitive.matern.cc:  else ILLEGAL_FRAME;
RandomFields/src/primitive.matern.cc:  if (PisNULL(WM_NOTINV)) {
RandomFields/src/primitive.matern.cc:    int dim = PREVLOGDIM(0);
RandomFields/src/primitive.matern.cc:      double nu = P0(WM_NU);
RandomFields/src/primitive.matern.cc:      E12(s, dim, SQRT(POW(1.0 - UNIFORM_RANDOM, -1.0 / nu) - 1.0), e);
RandomFields/src/primitive.matern.cc:  } else spectralMatern(cov, S, e);
RandomFields/src/primitive.matern.cc:void DrawMixWM(model VARIABLE_IS_NOT_USED *cov, double *random) { // inv scale
RandomFields/src/primitive.matern.cc:  *random = -0.25 / LOG(UNIFORM_RANDOM);
RandomFields/src/primitive.matern.cc:double LogMixDensW(double VARIABLE_IS_NOT_USED *x, double logV, model *cov) {
RandomFields/src/primitive.matern.cc:  return PisNULL(WM_NOTINV)
RandomFields/src/primitive.matern.cc:    ? (M_LN2  + 0.5 * logV) * (1.0 - nu) - 0.5 *lgammafn(nu)
RandomFields/src/primitive.matern.cc:    // - 0.25 /  cov->mpp[DRAWMIX_V]  - 2.0 * (LOG2 + logV) )
RandomFields/src/primitive.matern.cc:// s tatic double eM025 = EXP(-0.25);
RandomFields/src/primitive.matern.cc://void DrawMixNonStWM(model *cov, double *random) { // inv scale
RandomFields/src/primitive.matern.cc://  model *nu = cov->sub[WM_NU];  
RandomFields/src/primitive.matern.cc://    minnu = P(WM_NU][0];
RandomFields/src/primitive.matern.cc:  if (UNIFORM_RANDOM < p){
RandomFields/src/primitive.matern.cc:    cov_a->WMalpha = beta;
RandomFields/src/primitive.matern.cc:    logU =  LOG(UNIFORM_RANDOM * eM025);
RandomFields/src/primitive.matern.cc:    cov_a->WMfactor = -0.5 * LOG(0.25 * p * (beta - 1.0)) + 0.25;
RandomFields/src/primitive.matern.cc:    cov_a->WMalpha = alpha;
RandomFields/src/primitive.matern.cc:    logU = LOG(eM025 + UNIFORM_RANDOM * (1.0 - eM025));
RandomFields/src/primitive.matern.cc:    cov_a->WMfactor = -0.5 * LOG(0.25 * (1.0 - p) * (alpha - 1.0));
RandomFields/src/primitive.matern.cc:  *random = LOG(-0.25 / logU) / (cov_a->WMalpha - 1.0); //=invscale
RandomFields/src/primitive.matern.cc://double LogMixDensNonStWM(double *x, double logV, model *cov) {
RandomFields/src/primitive.matern.cc:    alpha = cov_a->WMalpha,
RandomFields/src/primitive.matern.cc:    nu = P(WM_NU][0];
RandomFields/src/primitive.matern.cc:   z = - nu  * M_LN2 // in g0  // eine 2 kuerzt sich raus
RandomFields/src/primitive.matern.cc:    + cov_a->WMfactor // lambda
RandomFields/src/primitive.matern.cc:	       (1.0 - nu) * M_LN2 
RandomFields/src/primitive.matern.cc:	       , -cov_a->WMfactor
RandomFields/src/primitive.matern.cc:  *v =Intern_WM(*x, GET_NU,  cov->q[WM_LOGGAMMA], 0.0);
RandomFields/src/primitive.matern.cc:  *v = logWM(*x, nu, cov->q[WM_LOGGAMMA], 0.0);
RandomFields/src/primitive.matern.cc:  *v =Intern_DWM(*x, GET_NU, cov->q[WM_LOGGAMMA], 0.0);
RandomFields/src/primitive.matern.cc:  *v=Intern_DDWM(*x, GET_NU, cov->q[WM_GAMMA], 0.0);
RandomFields/src/primitive.matern.cc:  *v=Intern_D3WM(*x, GET_NU, cov->q[WM_GAMMA], 0.0);
RandomFields/src/primitive.matern.cc:  *v=Intern_D4WM(*x, GET_NU, cov->q[WM_GAMMA], 0.0);
RandomFields/src/primitive.matern.cc:  *v = (*x == 0.05) ? 1.0 / ScaleWM(GET_NU) : RF_NA;
RandomFields/src/primitive.matern.cc:/* Whittle-Matern or Whittle or Besset */ 
RandomFields/src/primitive.matern.cc:/* Whittle-Matern or Whittle or Besset */ 
RandomFields/src/primitive.matern.cc:void biWM2basic(model *cov, 
RandomFields/src/primitive.matern.cc:    dim = (double) OWNLOGDIM(0), 
RandomFields/src/primitive.matern.cc:      nunew[i] = nu[i] < MATERN_NU_THRES ? nu[i] : MATERN_NU_THRES;
RandomFields/src/primitive.matern.cc:  // dies wiederspricht aber der MLE Maximierung, da dann
RandomFields/src/primitive.matern.cc:int initbiWM2(model *cov, gen_storage *stor) {
RandomFields/src/primitive.matern.cc:    int derivs = nu[i] - 1.0 > MAXINT ? MAXINT : (int) (nu[i] - 1.0);
RandomFields/src/primitive.matern.cc:      biWM2basic(cov, a, lg, aorig, nunew);
RandomFields/src/primitive.matern.cc:      biWM2basic(cov, a, lg, aorig, nunew);
RandomFields/src/primitive.matern.cc:      biWM2basic(cov, a, lg, aorig, nunew);
RandomFields/src/primitive.matern.cc:  biWM2basic(cov, S->a, S->lg, S->aorig, S->nunew);
RandomFields/src/primitive.matern.cc:    double nuThres = nu[i] < MATERN_NU_THRES ? nu[i] : MATERN_NU_THRES;
RandomFields/src/primitive.matern.cc:     cov->q[WM_LOGGAMMA + 2 * i] =  lgammafn(nuThres);
RandomFields/src/primitive.matern.cc:    cov->q[WM_GAMMA + 2 * i] = gammafn(nuThres);
RandomFields/src/primitive.matern.cc:void kappa_biWM(int i, model *cov, int *nr, int *nc){
RandomFields/src/primitive.matern.cc:void biWM2(double *x, int *info, model *cov, double *v) {
RandomFields/src/primitive.matern.cc:    v[i] = c[i] * Intern_WM(FABS(S->a[i] * xx), S->nunew[i],
RandomFields/src/primitive.matern.cc:			 cov->q[WM_LOGGAMMA + 2 * i], 0.0);
RandomFields/src/primitive.matern.cc:    if (!PisNULL(BInotinvnu) && nu[i] > MATERN_NU_THRES) {
RandomFields/src/primitive.matern.cc:      *v = *v * MATERN_NU_THRES / nu[i] + 
RandomFields/src/primitive.matern.cc:	(1 - MATERN_NU_THRES / nu[i]) * w;
RandomFields/src/primitive.matern.cc:void biWM2D(double *x, int *info, model *cov, double *v) {
RandomFields/src/primitive.matern.cc:    v[i] = c[i] * S->a[i] * Intern_DWM(FABS(S->a[i] * xx), S->nunew[i],
RandomFields/src/primitive.matern.cc:				    cov->q[WM_LOGGAMMA + 2 * i], 0.0);
RandomFields/src/primitive.matern.cc:    if (!PisNULL(BInotinvnu) && nu[i] > MATERN_NU_THRES) {
RandomFields/src/primitive.matern.cc:      *v = *v * MATERN_NU_THRES / nu[i] + 
RandomFields/src/primitive.matern.cc:	(1 - MATERN_NU_THRES / nu[i]) * w;
RandomFields/src/primitive.matern.cc:void biWM2DD(double *x, int *info, model *cov, double *v) {
RandomFields/src/primitive.matern.cc:      Intern_DDWM(FABS(S->a[i] * xx), S->nunew[i], cov->q[WM_GAMMA + 2 * i],0.0);
RandomFields/src/primitive.matern.cc:    if (!PisNULL(BInotinvnu) && nu[i] > MATERN_NU_THRES) {
RandomFields/src/primitive.matern.cc:      *v = *v * MATERN_NU_THRES / nu[i] +
RandomFields/src/primitive.matern.cc:    (1 - MATERN_NU_THRES / nu[i]) * w;
RandomFields/src/primitive.matern.cc:void biWM2D3(double *x,int *info, model *cov, double *v) {
RandomFields/src/primitive.matern.cc:      Intern_D3WM(FABS(S->a[i] * xx), S->nunew[i], cov->q[WM_GAMMA + 2 * i], 0.0);
RandomFields/src/primitive.matern.cc:    if (!PisNULL(BInotinvnu) && nu[i] > MATERN_NU_THRES) {
RandomFields/src/primitive.matern.cc:      *v = *v * MATERN_NU_THRES / nu[i] +
RandomFields/src/primitive.matern.cc:    (1 - MATERN_NU_THRES / nu[i]) * w;
RandomFields/src/primitive.matern.cc:void biWM2D4(double *x, int *info, model *cov, double *v) {
RandomFields/src/primitive.matern.cc:    v[i] = c[i] * Sa2 * Sa2 * Intern_D4WM(FABS(S->a[i] * xx), S->nunew[i],
RandomFields/src/primitive.matern.cc:				       cov->q[WM_GAMMA + 2 * i],0.0);
RandomFields/src/primitive.matern.cc:    if (!PisNULL(BInotinvnu) && nu[i] > MATERN_NU_THRES) {
RandomFields/src/primitive.matern.cc:      *v = *v * MATERN_NU_THRES / nu[i] +
RandomFields/src/primitive.matern.cc:    (1 - MATERN_NU_THRES / nu[i]) * w;
RandomFields/src/primitive.matern.cc:int checkbiWM2(model *cov) {
RandomFields/src/primitive.matern.cc:  //  PMI(cov);
RandomFields/src/primitive.matern.cc:  if ((err=initbiWM2(cov, &s)) != NOERROR) {
RandomFields/src/primitive.matern.cc:  VDIM0 = VDIM1 = 2;  
RandomFields/src/primitive.matern.cc:  if (cov->Sbiwm == NULL) return UNKNOWNPARAM;
RandomFields/src/primitive.matern.cc:      ? CRITICALPARAM :IGNOREPARAM;
RandomFields/src/primitive.matern.cc:      ? IGNOREPARAM : ONLYRETURN;
RandomFields/src/primitive.matern.cc:      ? VARPARAM : IGNOREPARAM;
RandomFields/src/primitive.matern.cc:      ? ANYPARAM : IGNOREPARAM;
RandomFields/src/primitive.matern.cc:      ? IGNOREPARAM : ONLYRETURN;
RandomFields/src/primitive.matern.cc:  case BIs : return SCALEPARAM;
RandomFields/src/primitive.matern.cc:void rangebiWM2(model VARIABLE_IS_NOT_USED *cov, range_type *range){
RandomFields/src/primitive.matern.cc:void coinitbiWM2(model *cov, localfactstype *li) {
RandomFields/src/primitive.matern.cc:    li->msg[0] =MSGLOCAL_OK;
RandomFields/src/primitive.matern.cc:    li->msg[0] = MSGLOCAL_JUSTTRY;
RandomFields/src/primitive.matern.cc:// PARS WM
RandomFields/src/primitive.matern.cc:/* Whittle-Matern or Whittle or Besset */ 
RandomFields/src/primitive.matern.cc:#define PARSWM_V vdim2
RandomFields/src/primitive.matern.cc:void kappa_parsWM(int i, model VARIABLE_IS_NOT_USED *cov, int *nr, int *nc){
RandomFields/src/primitive.matern.cc:int initparsWM(model *cov, gen_storage VARIABLE_IS_NOT_USED  *s) {
RandomFields/src/primitive.matern.cc:    dim = (double) OWNLOGDIM(0), 
RandomFields/src/primitive.matern.cc:    vdim = cov->nrow[PARSnudiag], // hier noch nicht cov->vdim, falls initparsWM von check aufgerufen wird, und cov->vdim noch nicht gesetzt ist
RandomFields/src/primitive.matern.cc:    cov->q[vdiag + PARSWM_V] = 1.0;
RandomFields/src/primitive.matern.cc:      cov->q[idx + PARSWM_V] = cov->q[vdiag + vdim * (j-i) + PARSWM_V] =
RandomFields/src/primitive.matern.cc:void parsWM(double *x, INFO, model *cov, double *v) {
RandomFields/src/primitive.matern.cc:    vdim = VDIM0,
RandomFields/src/primitive.matern.cc:      v[idx] = v[vdiag + vdim * (j-i)] = cov->q[PARSWM_V + idx] *
RandomFields/src/primitive.matern.cc:	Intern_WM(*x, half, cov->q[idx], 0.0);
RandomFields/src/primitive.matern.cc:void parsWMD(double *x, INFO, model *cov, double *v) {
RandomFields/src/primitive.matern.cc:    vdim = VDIM0,
RandomFields/src/primitive.matern.cc:      v[idx] = v[vdiag + vdim * (j-i)] = cov->q[PARSWM_V + idx] *
RandomFields/src/primitive.matern.cc:	Intern_DWM(*x, half, cov->q[idx], 0.0);
RandomFields/src/primitive.matern.cc:int checkparsWM(model *cov) { 
RandomFields/src/primitive.matern.cc:  VDIM0 = VDIM1 = vdim;
RandomFields/src/primitive.matern.cc:  if (vdim == 0) SERR1("'%.50s' not given", KNAME(PARSnudiag));
RandomFields/src/primitive.matern.cc:    int derivs = nudiag[i] - 1.0 > MAXINT ? MAXINT : (int) (nudiag[i] - 1.0);
RandomFields/src/primitive.matern.cc:    initparsWM(cov, NULL);
RandomFields/src/primitive.matern.cc:    #define dummyN (5 * ParsWMMaxVDim)
RandomFields/src/primitive.matern.cc:    double value[ParsWMMaxVDim], ivalue[ParsWMMaxVDim], 
RandomFields/src/primitive.matern.cc:void rangeparsWM(model VARIABLE_IS_NOT_USED *cov, range_type *range){
Binary file RandomFields/src/auxiliary.o matches
RandomFields/src/init.general.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/init.general.cc: Copyright (C) 2001 -- 2017 Martin Schlather
RandomFields/src/init.general.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/init.general.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/init.general.cc:// to do: MLE: random parameters einsammeln
RandomFields/src/init.general.cc:#include "QMath.h"
RandomFields/src/init.general.cc:  FIRST_PLANE, LAST_PLANE, EARTHKM2CART, EARTHMILES2CART,
RandomFields/src/init.general.cc:  EARTHKM2GNOMONIC, EARTHMILES2GNOMONIC,
RandomFields/src/init.general.cc:  EARTHKM2ORTHOGRAPHIC, EARTHMILES2ORTHOGRAPHIC,  
RandomFields/src/init.general.cc:  FIRST_TRAFO, LAST_TRAFO, MATHDIV;
RandomFields/src/init.general.cc:KEY_type *PIDKEY[PIDMODULUS];
RandomFields/src/init.general.cc:char CovNames[MAXNRCOVFCTS][MAXCHAR], CovNickNames[MAXNRCOVFCTS][MAXCHAR],
RandomFields/src/init.general.cc://                        CE         CO         CI        TBM       Sp
RandomFields/src/init.general.cc:  PREF_MATHDEF = {PREF_BEST, PREF_BEST, PREF_BEST, PREF_BEST, PREF_BEST,
RandomFields/src/init.general.cc:const char *CAT_TYPE_NAMES[OtherType + 1] = {
RandomFields/src/init.general.cc:  // PointShapeType, ShapeType, TrendType, RandomOrShape, Manifold,
RandomFields/src/init.general.cc:  // ProcessType, GaussMethodType, NormedProcessType, BrMethodType,
RandomFields/src/init.general.cc:  // RandomType, InterfaceType, MathDefType, OtherType
RandomFields/src/init.general.cc:    "RM", "RM", "RM", "RM",
RandomFields/src/init.general.cc:    "RM", "RM", "RM", "RM", "RM", 
RandomFields/src/init.general.cc:  *REG_NAMES[MODEL_MAX+1] = {"reg0", "reg1", "reg2", "reg3", "reg4", 
RandomFields/src/init.general.cc:  *POSITIVITY_NAMES[(int) pt_mismatch + 1] = 
RandomFields/src/init.general.cc:  **LIST_OF_NAMES[nNamesOfNames] = // see also NAME_OF_NAMES in AutoRandomF*.cc
RandomFields/src/init.general.cc:				 {EQ_NAMES, ISO_NAMES, DOMAIN_NAMES,
RandomFields/src/init.general.cc:				  TYPE_NAMES, MONOTONE_NAMES, MODE_NAMES,
RandomFields/src/init.general.cc:				  OUTPUTMODE_NAMES, REPORTCOORD_NAMES,
RandomFields/src/init.general.cc:				  UNITS_NAMES, COORD_SYS_NAMES,
RandomFields/src/init.general.cc:				  CARTESIAN_SYS_NAMES, TYPEOF_PARAM_NAMES};
RandomFields/src/init.general.cc://  int SYS_TO_ISO[nr_coord_sys_proj] =  {GNOMONIC_PROJ, ORTHOGRAPHIC_PROJ};
RandomFields/src/init.general.cc:char STANDARDPARAM[MAXPARAM][MAXCHAR],
RandomFields/src/init.general.cc:  STANDARDSUB[MAXSUB][MAXCHAR];
RandomFields/src/init.general.cc:  KEY_type *p = PIDKEY[mypid % PIDMODULUS];
RandomFields/src/init.general.cc:    PIDKEY[mypid % PIDMODULUS] = neu;
RandomFields/src/init.general.cc:    if (PIDKEY[mypid % PIDMODULUS] != neu) { // another process had the
RandomFields/src/init.general.cc:    if (PIDKEY[mypid % PIDMODULUS] != neu) BUG;
RandomFields/src/init.general.cc:      PRINTF("Do not forget to run 'RFoptions(storing=FALSE)' after each call of a parallel command (e.g. from packages 'parallel') that calls a function in 'RandomFields'. (OMP within RandomFields is not affected.) This message can be suppressed by 'RFoptions(warn_parallel=FALSE)'."); // ok
RandomFields/src/init.general.cc:  return ZERO(PREVTOTALXDIM, cov->base); // i_ncol
RandomFields/src/init.general.cc:  assert(MODEL_MAX == 30); // otherwise change REG_NAMES
RandomFields/src/init.general.cc:  assert(OtherType == 20 && LASTTYPE == 30); // otherwise change TYPE_NAMES, 
RandomFields/src/init.general.cc:  //                                           CAT_TYPE_NAMES[OtherType + 1]
RandomFields/src/init.general.cc: assert(LAST_ISO == 20); // otherwise change ISO_NAMES
RandomFields/src/init.general.cc:  //  assert(MAXMPPDIM <= MAXSIMUDIM); // ZERO
RandomFields/src/init.general.cc:     "identity", "M", "matern", "tbm", "U",
RandomFields/src/init.general.cc:     "binaryprocess", "gauss.process", "Cov", "CovMatrix",
RandomFields/src/init.general.cc:    if (isManifold(SYSTYPE(C->systems[0], 0)) && C->TypeFct == NULL) 
RandomFields/src/init.general.cc:    if (isMathDef(DefList + nr)) {
RandomFields/src/init.general.cc:      if (!(isParamDepI(C) || isParamDepD(C) || isSubModelI(C)))
RandomFields/src/init.general.cc:      if (C->kappanames[k][0] == ONEARGUMENT_NAME
RandomFields/src/init.general.cc:	    C->Iallowed != allowedPrevModelI &&
RandomFields/src/init.general.cc:      for (i=0; i<ntypefcts; i++) if (!STRCMP(typefcts[i], C->name)) break;
RandomFields/src/init.general.cc:	PRINTF("Martin, read instructions for typefcts: '%s'\n", C->name);
RandomFields/src/init.general.cc:    if (nr != COVARIATE && nr != FIXCOV && nr != VARIOGRAM2COV &&
RandomFields/src/init.general.cc:	  PRINTF("Martin, see KeyInfo.cc fctn Param to deal with %s\n",C->name);
RandomFields/src/init.general.cc:    err = 10; // MISMATCH=-4
RandomFields/src/init.general.cc:    if (nr > LAST_TRAFO && C->maxmoments < 0 && C->maxmoments != SUBMODEL_DEP &&
RandomFields/src/init.general.cc:    if (nr != VARIOGRAM2COV && nr !=  VAR2COV_PROC && nr != PREDICT_CALL) {
RandomFields/src/init.general.cc:	    (k==C->kappas-1 || STRCMP(C->kappanames[k+1], COVARIATE_RAW_NAME))){
RandomFields/src/init.general.cc:	  PRINTF("%s: Martin, all functions that have additional points inside must set KT->rawConcerns = neverRaw; then included in the exception list", C->name);
RandomFields/src/init.general.cc:void InitModelList() {
RandomFields/src/init.general.cc:  for (int i=0; i<MAXPARAM; i++) SPRINTF(STANDARDPARAM[i], "k%d", i+1);
RandomFields/src/init.general.cc:  for (int i=0; i<MAXSUB; i++) SPRINTF(STANDARDSUB[i], "u%d", i+1);
RandomFields/src/init.general.cc:  /* ja nicht setzen !! macht riesen aerger, da RF opt ions InitModel
RandomFields/src/init.general.cc:    for (i=0; i<MAX UNITS; i++) {
RandomFields/src/init.general.cc:  for (int i=0; i<PIDMODULUS; i++) PIDKEY[i] = NULL; 
RandomFields/src/init.general.cc:  DefList = (defn*) MALLOC(sizeof(defn) * (MAXNRCOVFCTS+1));
RandomFields/src/init.general.cc:    IncludeModel("#",  OtherType, 1, 1, 0, NULL, PREVMODEL_D, PREVMODEL_I,
RandomFields/src/init.general.cc:  		 checkNotOK, NULL, PREF_NOTHING, true, SUBMODEL_DEP,
RandomFields/src/init.general.cc:  		 SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP, MON_SUB_DEP);
RandomFields/src/init.general.cc:  FIRST_TRAFO = EARTHKM2CART= // 14
RandomFields/src/init.general.cc:      IncludeModel(">",  OtherType, 1, 1, 0, NULL,
RandomFields/src/init.general.cc:		   PREVMODEL_D, PREVMODEL_I, // dummy values
RandomFields/src/init.general.cc:		   checkEarth, NULL, PREF_NOTHING, true, SUBMODEL_DEP,
RandomFields/src/init.general.cc:		   4, (ext_bool) SUBMODEL_DEP, MON_SUB_DEP);
RandomFields/src/init.general.cc:  addCov(EarthKM2CartStat);
RandomFields/src/init.general.cc:  addlogCov(EarthKM2Cart);//
RandomFields/src/init.general.cc:  EARTHMILES2CART = addFurtherCov(EarthMiles2CartStat, ErrD);// 15
RandomFields/src/init.general.cc:  addlogCov(EarthMiles2Cart);// 
RandomFields/src/init.general.cc:  FIRST_PLANE = EARTHKM2GNOMONIC =
RandomFields/src/init.general.cc:  EARTHMILES2GNOMONIC =  CopyModel(">", EARTHKM2GNOMONIC); // 17
RandomFields/src/init.general.cc:  EARTHKM2ORTHOGRAPHIC = addFurtherCov(EarthKM2OrthogStat, ErrD);// 18
RandomFields/src/init.general.cc:  addlogCov(EarthKM2Orthog);// 
RandomFields/src/init.general.cc:  EARTHMILES2ORTHOGRAPHIC = addFurtherCov(EarthMiles2OrthogStat, ErrD);// 19
RandomFields/src/init.general.cc:  addlogCov(EarthMiles2Orthog);// 
RandomFields/src/init.general.cc:  LAST_PLANE = EARTHMILES2ORTHOGRAPHIC;
RandomFields/src/init.general.cc:  LAST_TRAFO =  EARTHMILES2ORTHOGRAPHIC;
RandomFields/src/init.general.cc:  //                  CE CO CI TBM Sp di sq Tr av n mpp Hy spf any
RandomFields/src/init.general.cc:    IncludeModel("+", ManifoldType, 1, MAXSUB, 1, NULL,
RandomFields/src/init.general.cc:		 SUBMODEL_DEP, SUBMODEL_DEP,
RandomFields/src/init.general.cc:		 (ext_bool) SUBMODEL_DEP, MON_SUB_DEP);
RandomFields/src/init.general.cc:  addTBM(NULL, spectralplus);
RandomFields/src/init.general.cc:  //                 CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.general.cc:  MULT =
RandomFields/src/init.general.cc:    IncludeModel("*", ManifoldType, 1, MAXSUB, 0, NULL, PREV_SUB_D, PREV_SUB_I,
RandomFields/src/init.general.cc:		 checkmal, NULL, pmal, false, SUBMODEL_DEP, SUBMODEL_DEP,
RandomFields/src/init.general.cc:		 (ext_bool) SUBMODEL_DEP, MON_SUB_DEP);
RandomFields/src/init.general.cc:  //              CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.general.cc:  FIRSTDOLLAR = IncludeModel("$",  ManifoldType, // to do: tcftype durch einen allgemeinen Type ersetzen, da auch Trend dem "$" folgen kann. Z.Z. nicht moeglich.
RandomFields/src/init.general.cc:			false, SUBMODEL_DEP, SUBMODEL_DEP,
RandomFields/src/init.general.cc:			(ext_bool) SUBMODEL_DEP, MON_SUB_DEP);
RandomFields/src/init.general.cc:  addTBM(tbm2S, NULL, spectralS);
RandomFields/src/init.general.cc:  //                CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.general.cc:    IncludeModel("$power", ManifoldType, // to do: tcftype durch einen allgemeinen Type ersetzen, da auch Trend dem "$" folgen kann. Z.Z. nicht moeglich.
RandomFields/src/init.general.cc:		 true, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.general.cc:		 MON_SUB_DEP);
RandomFields/src/init.general.cc:  includeCovModels();  
RandomFields/src/init.general.cc:  includeOtherModels();
RandomFields/src/init.general.cc:   IncludeModel("minus", MathDefType, 0, 0, 3, NULL, XONLY, PREVMODEL_I,
RandomFields/src/init.general.cc:	       checkMath, rangeMath, PREF_TREND,
RandomFields/src/init.general.cc:	       false,SCALAR, PREVMODEL_DEP, falsch, NOT_MONOTONE);
RandomFields/src/init.general.cc:  change_sortof(MATH_FACTOR, TRENDPARAM);
RandomFields/src/init.general.cc:  addCov(Mathminus);
RandomFields/src/init.general.cc:  AddVariant(TrendType, PREVMODEL_I);
RandomFields/src/init.general.cc:  IncludeModel("plus", MathDefType, 0, 0, 3, NULL, XONLY, PREVMODEL_I,
RandomFields/src/init.general.cc:	       checkMath, rangeMath, PREF_MATHDEF, 
RandomFields/src/init.general.cc:	      false,SCALAR, 1, falsch, NOT_MONOTONE);
RandomFields/src/init.general.cc:  change_sortof(MATH_FACTOR, TRENDPARAM);
RandomFields/src/init.general.cc:  addCov(Mathplus);
RandomFields/src/init.general.cc:  AddVariant(TrendType, PREVMODEL_I);
RandomFields/src/init.general.cc:  MATHDIV = IncludeModel("div", MathDefType, 0, 0, 3, NULL, XONLY, PREVMODEL_I,
RandomFields/src/init.general.cc:	       checkDivMult, rangeMath, PREF_MATHDEF, 
RandomFields/src/init.general.cc:	      false,SCALAR, 1, falsch, NOT_MONOTONE);
RandomFields/src/init.general.cc:  change_sortof(MATH_FACTOR, TRENDPARAM);
RandomFields/src/init.general.cc:  addCov(Mathdiv);
RandomFields/src/init.general.cc:  AddVariant(TrendType, PREVMODEL_I);
RandomFields/src/init.general.cc:  IncludeModel("mult", MathDefType, 0, 0, 3, NULL, XONLY, PREVMODEL_I,
RandomFields/src/init.general.cc:	       checkDivMult, rangeMath, PREF_MATHDEF, 
RandomFields/src/init.general.cc:	      false,SCALAR, 1, falsch, NOT_MONOTONE);
RandomFields/src/init.general.cc:  change_sortof(MATH_FACTOR, TRENDPARAM);
RandomFields/src/init.general.cc:  addCov(Mathmult);
RandomFields/src/init.general.cc:  AddVariant(TrendType, PREVMODEL_I);
RandomFields/src/init.general.cc:    IncludeModelR("const", MathDefType, 0, 0, 2, NULL, XONLY, PREVMODEL_I,
RandomFields/src/init.general.cc:		 check_c, rangec, PREF_MATHDEF, 
RandomFields/src/init.general.cc:		 false, SCALAR, PREVMODEL_DEP, falsch, NOT_MONOTONE);
RandomFields/src/init.general.cc:  kappanames(CONST_A_NAME, REALSXP, COVARIATE_NAME_NAME, STRSXP);
RandomFields/src/init.general.cc:  change_sortof(CONST_C, TRENDPARAM);
RandomFields/src/init.general.cc:  change_sortof(CONST_NAME, IGNOREPARAM);
RandomFields/src/init.general.cc:  addCov(Mathc);
RandomFields/src/init.general.cc:  AddVariant(TrendType, PREVMODEL_I);
RandomFields/src/init.general.cc:  AddVariant(NegDefType, PREVMODEL_I);
RandomFields/src/init.general.cc:  AddVariant(TcfType, PREVMODEL_I);
RandomFields/src/init.general.cc:  PROJ_MODEL = 
RandomFields/src/init.general.cc:  IncludeModel("p", MathDefType, 0, 0, 4, NULL, XONLY, PARAMDEP_I,
RandomFields/src/init.general.cc:	       checkproj, rangeproj, PREF_MATHDEF, 
RandomFields/src/init.general.cc:	       INTERN_SHOW,  SCALAR, INFDIM-1, falsch, NOT_MONOTONE);
RandomFields/src/init.general.cc:	     COVARIATE_NAME_NAME, STRSXP);
RandomFields/src/init.general.cc:  change_sortof(PROJ_FACTOR , TRENDPARAM);
RandomFields/src/init.general.cc:  change_sortof(PROJ_NAME, IGNOREPARAM); 
RandomFields/src/init.general.cc:  AddVariant(TrendType, PREVMODEL_I);
RandomFields/src/init.general.cc:  IncludeModel("c", MathDefType, 0, 0, 18, NULL, PREV_SUB_D, PREV_SUB_I,
RandomFields/src/init.general.cc:	       check_bind, rangeMath, PREF_TREND, 
RandomFields/src/init.general.cc:	       INTERN_SHOW, PARAM_DEP, 1, falsch, NOT_MONOTONE);
RandomFields/src/init.general.cc:  change_sortof(DefList[BIND].kappas - 1, TRENDPARAM);
RandomFields/src/init.general.cc:  addCov(Mathbind);
RandomFields/src/init.general.cc:  AddVariant(TrendType, SUBMODEL_I);
RandomFields/src/init.general.cc:  IncludeModel("is", MathDefType, 0, 0, 3, NULL, XONLY, PREVMODEL_I,
RandomFields/src/init.general.cc:	       checkMath, rangeMathIs, PREF_TREND, 
RandomFields/src/init.general.cc:	      false, SCALAR, 1, falsch, NOT_MONOTONE);
RandomFields/src/init.general.cc:  addCov(MathIs);
RandomFields/src/init.general.cc:  AddVariant(TrendType, PREVMODEL_I);
RandomFields/src/init.general.cc:  includeStandardMath();
Binary file RandomFields/src/InternalCov.noncritical.o matches
RandomFields/src/rf_interfaces.cc:Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/rf_interfaces.cc: Copyright (C) 2001 -- 2003 Martin Schlather
RandomFields/src/rf_interfaces.cc: Copyright (C) 2004 -- 2004 Yindeng Jiang & Martin Schlather
RandomFields/src/rf_interfaces.cc: Copyright (C) 2005 -- 2017 Martin Schlather
RandomFields/src/rf_interfaces.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/rf_interfaces.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/rf_interfaces.cc:  Long vdimtot; vdimtot = loc->totalpoints * VDIM0;
RandomFields/src/rf_interfaces.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/rf_interfaces.cc:  if (v==NULL) return; // EvaluateModel needs information about size
RandomFields/src/rf_interfaces.cc:    MEMCOPY(res, cov->rf, sizeof(double) * vdimtot);
RandomFields/src/rf_interfaces.cc:      frame = GaussMethodType;
RandomFields/src/rf_interfaces.cc:      iso = S YMMETRIC;
RandomFields/src/rf_interfaces.cc:	   (err = C HECK(sub, loc->timespacedim, OWNXDIM(0), type, 
RandomFields/src/rf_interfaces.cc:    if ((err = C HECK(sub, loc->timespacedim, OWNXDIM(0), ProcessType,
RandomFields/src/rf_interfaces.cc:  VDIM0=subvdim; 
RandomFields/src/rf_interfaces.cc:  VDIM1=sub->vdim[1]; 
RandomFields/src/rf_interfaces.cc:  //APMI(next);
RandomFields/src/rf_interfaces.cc:    addModel(&(cov->key), GAUSSPROC);
RandomFields/src/rf_interfaces.cc:    if ((err = C HECK(sub, loc->timespacedim, OWNXDIM(0), ProcessType,
RandomFields/src/rf_interfaces.cc:		     cov->vdim, GaussMethodType)) != NOERROR) {
RandomFields/src/rf_interfaces.cc:    subframe = GaussMethodType;    
RandomFields/src/rf_interfaces.cc:  } else if (is BernoulliProcess(next)) subframe = FRAME_ BERNOULLI;
RandomFields/src/rf_interfaces.cc:  else if (isGaussMethod(next)) subframe = GaussMethodType;   
RandomFields/src/rf_interfaces.cc:  else if (isBrMethod(next)) subframe = BrMethodType;    
RandomFields/src/rf_interfaces.cc:  else if (nr = = EXTREMALTPROC) subframe = SchlatherType;
RandomFields/src/rf_interfaces.cc:  else if (nr = = SMIT HPROC) subframe = SmithType;
RandomFields/src/rf_interfaces.cc:    ILLEGAL_FRAME;
RandomFields/src/rf_interfaces.cc:	(err = C HECK(sub, loc->timespacedim, OWNXDIM(0), ProcessType,
RandomFields/src/rf_interfaces.cc:		     PREVDOM(0), PREVISO(0), cov->vdim,
RandomFields/src/rf_interfaces.cc:      PMI(sub); // OK
RandomFields/src/rf_interfaces.cc:    direct.cc, gausslikeli(Fct nIntern, CovarianceMatrix), startGetNset (StandardCovMatrix), RMS (covmatrixS)
RandomFields/src/rf_interfaces.cc:    che ck_covmatri called by struct_cov, RFCovMatrix
RandomFields/src/rf_interfaces.cc:      // CovarianceMatrix only
RandomFields/src/rf_interfaces.cc:    RETURN_ERR(ERRORMEMORYALLOCATION);
RandomFields/src/rf_interfaces.cc:    RETURN_ERR(ERRORMEMORYALLOCATION);
RandomFields/src/rf_interfaces.cc:#define SIMU_CHECKONLY 0
RandomFields/src/rf_interfaces.cc:#define SIMU_SEED 1
RandomFields/src/rf_interfaces.cc:#define SIMU_ENV 2
RandomFields/src/rf_interfaces.cc:  assert(!P0INT(SIMU_CHECKONLY));
RandomFields/src/rf_interfaces.cc:  Long vdimtot = Loctotalpoints(cov) * VDIM0;
RandomFields/src/rf_interfaces.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/rf_interfaces.cc:    return; // EvaluateModel needs information about size
RandomFields/src/rf_interfaces.cc:      assert(!PisNULL(SIMU_SEED) && !PisNULL(SIMU_ENV));
RandomFields/src/rf_interfaces.cc:      addIntVariable((char*) "seed", &simu_seed, 1, 1, PENV(SIMU_ENV)->sexp);
RandomFields/src/rf_interfaces.cc:      eval(PLANG(SIMU_SEED)->sexp, PENV(SIMU_ENV)->sexp);
RandomFields/src/rf_interfaces.cc:    //if(false) for (int k=0; k<vdimtot; k++)  if (sub->rf[k] <= 0.0) APMI(sub);
RandomFields/src/rf_interfaces.cc:    MEMCOPY(res, cov->rf, sizeof(double) * vdimtot);
RandomFields/src/rf_interfaces.cc:  //  PMI(cov);
RandomFields/src/rf_interfaces.cc:  kdefault(cov, SIMU_CHECKONLY, false);
RandomFields/src/rf_interfaces.cc:    //    PMI(sub);
RandomFields/src/rf_interfaces.cc:       //      PMI0(cov);
RandomFields/src/rf_interfaces.cc:      // printf("\nj=%d ownxdim = %d %s\n", j, OWNXDIM(0), TYPE_NAMES[type]);
RandomFields/src/rf_interfaces.cc:	 (err = CHECK(sub, dim, OWNXDIM(0), type, 
RandomFields/src/rf_interfaces.cc:    if ((err = CHECK(sub, dim, OWNXDIM(0), ProcessType, XONLY, PREVISO(0),
RandomFields/src/rf_interfaces.cc:  VDIM0=subvdim; 
RandomFields/src/rf_interfaces.cc:  VDIM1=sub->vdim[1]; 
RandomFields/src/rf_interfaces.cc:    addModelKey(cov, isnowVariogram(next) ? GAUSSPROC : SHAPE_FCT_PROC);
RandomFields/src/rf_interfaces.cc:    if ((err = CHECK(sub, Loctsdim(cov), OWNXDIM(0), ProcessType, XONLY, 
RandomFields/src/rf_interfaces.cc:  if (P0INT(SIMU_CHECKONLY)) RETURN_NOERROR;
RandomFields/src/rf_interfaces.cc:      PMI(sub); // OK
RandomFields/src/rf_interfaces.cc:  //  PMI(sub);
RandomFields/src/rf_interfaces.cc:  booleanRange(SIMU_CHECKONLY);
RandomFields/src/rf_interfaces.cc:  int idx[simu_n] = {SIMU_SEED, SIMU_ENV};
RandomFields/src/rf_interfaces.cc:	  // PMI(kap);
RandomFields/src/rf_interfaces.cc:   *nr = *nc = i <= LIKELIHOOD_DATA ? SIZE_NOT_DETERMINED
RandomFields/src/rf_interfaces.cc:  if (isProcess(process->sub[0]))//besser: EmptySubOK(MODELNR(process->sub[0])))
RandomFields/src/rf_interfaces.cc:    //    APMI0(sub);
RandomFields/src/rf_interfaces.cc:  VDIM0=sub->vdim[0]; 
RandomFields/src/rf_interfaces.cc:  VDIM1=sub->vdim[1]; 
RandomFields/src/rf_interfaces.cc:  cov->q[1] = VDIM0;
RandomFields/src/rf_interfaces.cc:      vdimtot = totpts * VDIM0;
RandomFields/src/rf_interfaces.cc:    //    PMI0(cov);
RandomFields/src/rf_interfaces.cc:    //    printf("repet = %d %d %d %d\n", repet,  vdimtot , VDIM0,datatot);
RandomFields/src/rf_interfaces.cc:    addModelKey(cov, GAUSSPROC); // struct_gauss_logli calls alloc_fctn
RandomFields/src/rf_interfaces.cc:    if ((err = CHECK(sub, Loctsdim(cov), OWNXDIM(0), ProcessType, XONLY, 
RandomFields/src/rf_interfaces.cc:  if (cR < 0 || cR > MODEL_MAX) BUG;	
RandomFields/src/rf_interfaces.cc:    SERR1("'%.50s' may not be used when distances are given", NAME(cov));
RandomFields/src/rf_interfaces.cc:    addModelKey(cov, GAUSSPROC);
RandomFields/src/rf_interfaces.cc:    if ((err = CHECK(sub, Loctsdim(cov), OWNXDIM(0), ProcessType, XONLY, 
RandomFields/src/rf_interfaces.cc:#define EVALDISTR_DIM 4 // r
RandomFields/src/rf_interfaces.cc:  *nc = *nr = i <= EVALDISTR_N ? SIZE_NOT_DETERMINED
RandomFields/src/rf_interfaces.cc:    : i == EVALDISTR_DIM ? 1 : -1;
RandomFields/src/rf_interfaces.cc:    dim = ANYDIM,
RandomFields/src/rf_interfaces.cc:  if (v==NULL) return; // EvaluateModel needs information about size
RandomFields/src/rf_interfaces.cc:    dim = ANYDIM, 
RandomFields/src/rf_interfaces.cc:    int nn = 1; // !! 1 obwohl 2 reserviert werden !! Wg EvaluateModel
RandomFields/src/rf_interfaces.cc:   /*  cov->qlen = 1; // !! 1 obwohl 2 reserviert werden !! Wg EvaluateModel
RandomFields/src/rf_interfaces.cc:      cov->q = (double *) MALLOC(sizeof(double) * (cov->qlen + 1)); // QALLOC NOT APPROPRIATE
RandomFields/src/rf_interfaces.cc:		C->kappanames[EVALDISTR_X], C->kappanames[EVALDISTR_DIM]);
RandomFields/src/rf_interfaces.cc:		C->kappanames[EVALDISTR_Q], C->kappanames[EVALDISTR_DIM]);
RandomFields/src/rf_interfaces.cc:  // PMI(sub);
RandomFields/src/rf_interfaces.cc:  range->min[EVALDISTR_DIM] = 1;
RandomFields/src/rf_interfaces.cc:  range->max[EVALDISTR_DIM] = RF_INF;
RandomFields/src/rf_interfaces.cc:  range->pmin[EVALDISTR_DIM] = 1;
RandomFields/src/rf_interfaces.cc:  range->pmax[EVALDISTR_DIM] = 10;
RandomFields/src/rf_interfaces.cc:  range->openmin[EVALDISTR_DIM] = false;
RandomFields/src/rf_interfaces.cc:  range->openmax[EVALDISTR_DIM] = true;
RandomFields/src/rf_interfaces.cc:    dim = ANYDIM;
RandomFields/src/rf_interfaces.cc:    if ((cov->rf = (double*) MALLOC(sizeof(double) * size)) 
RandomFields/src/rf_interfaces.cc:	== NULL) RETURN_ERR(ERRORMEMORYALLOCATION); 
RandomFields/src/rf_interfaces.cc:      prevdom = PREVDOM(0),
RandomFields/src/rf_interfaces.cc:      nextdom = DOM(C->systems[0], 0);
RandomFields/src/rf_interfaces.cc:    case RandomOrShapeType :case MathDefType:
RandomFields/src/rf_interfaces.cc:    case ProcessType:  case NormedProcessType:  case BrMethodType:
RandomFields/src/rf_interfaces.cc:    case PoissonGaussType:  case GaussMethodType:
RandomFields/src/rf_interfaces.cc:      if (nexttype != ManifoldType && nexttype != OtherType)
RandomFields/src/rf_interfaces.cc:      // printf("f=%d (%s, %s, %s)\n", t,	     TYPE_NAMES[frames[t]], TYPE_NAMES[types[t]],	     DOMAIN_NAMES[dom[t]]);
RandomFields/src/rf_interfaces.cc:		       SUBMODEL_DEP, frames[t])) == NOERROR) break;
RandomFields/src/rf_interfaces.cc:      //      PMI1(cov);
RandomFields/src/rf_interfaces.cc:  VDIM0 = next->vdim[0]; 
RandomFields/src/rf_interfaces.cc:  VDIM1 = next->vdim[1]; 
RandomFields/src/rf_interfaces.cc:  GETSTOMODEL;
RandomFields/src/rf_interfaces.cc:  model *get_cov = STOMODEL->get_cov;
RandomFields/src/rf_interfaces.cc:    nr = MODELNR(STOMODEL->get_cov),
RandomFields/src/rf_interfaces.cc:    double *p = PARAM(get_cov, param_nr);    
RandomFields/src/rf_interfaces.cc:    int *p = PARAMINT(get_cov, param_nr);
RandomFields/src/rf_interfaces.cc:int SearchParam(model *cov, get_storage *s, model_storage *STOMODEL) {
RandomFields/src/rf_interfaces.cc:      if (orig == NULL) SERR1("value of '%.50s' too high", KNAME(RFGET_UP));
RandomFields/src/rf_interfaces.cc:    if (nr<0 || nr>MODEL_MAX) SERR("invalid register number");
RandomFields/src/rf_interfaces.cc:    if (up != 0) SERR1("'%.50s' may not be given.", KNAME(RFGET_UP));
RandomFields/src/rf_interfaces.cc:  STOMODEL->orig = orig;
RandomFields/src/rf_interfaces.cc:    while (DefList[MODELNR(orig)].maxsub > 0 && orig != NULL &&
RandomFields/src/rf_interfaces.cc:      orig = (MODELNR(orig) == PLUS || MODELNR(orig) == MULT || MODELNR(orig)==MPPPLUS) 
RandomFields/src/rf_interfaces.cc:    if (orig == NULL || DefList[MODELNR(orig)].maxsub == 0) 
RandomFields/src/rf_interfaces.cc:    if (COVNR != MODELNR(orig)) 
RandomFields/src/rf_interfaces.cc:    int nsub = DefList[MODELNR(orig)].maxsub;
RandomFields/src/rf_interfaces.cc:	kappas = DefList[MODELNR(orig)].kappas;
RandomFields/src/rf_interfaces.cc:	  s->idx = (int *) MALLOC(sizeof(int) * s->size);
RandomFields/src/rf_interfaces.cc:	STOMODEL->get_cov = orig;
RandomFields/src/rf_interfaces.cc:  NEWSTOMODEL;
RandomFields/src/rf_interfaces.cc:  GETSTOMODEL;
RandomFields/src/rf_interfaces.cc:  if ((err = SearchParam(cov, s, STOMODEL)) != NOERROR) RETURN_ERR(err);
RandomFields/src/rf_interfaces.cc:  range->max[RFGET_REGISTER] = MODEL_MAX;
RandomFields/src/rf_interfaces.cc:  range->pmax[RFGET_REGISTER] = MODEL_USER;
RandomFields/src/rf_interfaces.cc:  NEWSTOMODEL;
RandomFields/src/rf_interfaces.cc:  GETSTOMODEL;
RandomFields/src/rf_interfaces.cc:  if ((err = SearchParam(cov, s, STOMODEL)) != NOERROR) RETURN_ERR(err);
RandomFields/src/rf_interfaces.cc:  if (isGaussMethod(next) || equalsBernoulliProcess(next)) {
RandomFields/src/rf_interfaces.cc:    else if (NEXTNR == TBM_PROC_USER) {
RandomFields/src/rf_interfaces.cc:      if (NEXTNR == TBM_PROC_INTERN) next = next->sub[0];   
RandomFields/src/rf_interfaces.cc:    else if (NEXTNR == RANDOMCOIN_USER) {
RandomFields/src/rf_interfaces.cc:  if (isBrMethod(next)) {
RandomFields/src/rf_interfaces.cc:    if (MODELNR(next->calling) == BROWNRESNICKPROC && isBrMethod(next)) {
RandomFields/src/rf_interfaces.cc:  assert(dim == OWNLOGDIM(0));
RandomFields/src/rf_interfaces.cc:  // PMI(cov)
RandomFields/src/rf_interfaces.cc:    if (isIsoMismatch(iso[endfor-1])) BUG;
RandomFields/src/rf_interfaces.cc:    if ((err = CHECK(sub, dim, OWNXDIM(0), type, 
RandomFields/src/rf_interfaces.cc:    (domain_type) k, iso[i], SUBMODEL_DEP, frame))
RandomFields/src/rf_interfaces.cc:    if (equalsIsoMismatch(iso)) BUG;
RandomFields/src/rf_interfaces.cc:      if ((err = CHECK(sub, dim, OWNXDIM(0),
RandomFields/src/rf_interfaces.cc:		       (domain_type) k, iso, SUBMODEL_DEP, frame))
RandomFields/src/rf_interfaces.cc:      //PMI1(cov);
RandomFields/src/rf_interfaces.cc:  if ((err = alloc_fctn(cov, dim, VDIM0 * VDIM1)) != NOERROR)
RandomFields/src/rf_interfaces.cc:  if (rows > 0) VDIM0 = rows;
RandomFields/src/rf_interfaces.cc:  if (cols > 0) VDIM1 = cols;
RandomFields/src/rf_interfaces.cc:#define VDIMS								\
RandomFields/src/rf_interfaces.cc:					     VDIMS;
RandomFields/src/rf_interfaces.cc:					     VDIMS;
RandomFields/src/rf_interfaces.cc:  if (v==NULL) return; // EvaluateModel needs information about size
RandomFields/src/rf_interfaces.cc:  //APMI(cov);
RandomFields/src/rf_interfaces.cc:  { CARTESIAN_COORD, ISO_MISMATCH, CARTESIAN_COORD, EARTH_COORD,
RandomFields/src/rf_interfaces.cc:    SPHERICAL_COORD, CARTESIAN_COORD, CARTESIAN_COORD, ISO_MISMATCH };
RandomFields/src/rf_interfaces.cc:			   SUBMODEL_DEP,
RandomFields/src/rf_interfaces.cc:    //		    OWNISO(0), SUBMODEL_DEP, 
RandomFields/src/rf_interfaces.cc:    //		    cov->frame = = Any Type ? Any Type : GaussMethodType);
RandomFields/src/rf_interfaces.cc:    VDIM0 = sub->vdim[0];
RandomFields/src/rf_interfaces.cc:    VDIM1 = sub->vdim[1];
RandomFields/src/rf_interfaces.cc:    if ((err = alloc_fctn(cov, dim, VDIM0 * VDIM1)) != NOERROR) RETURN_ERR(err);
RandomFields/src/rf_interfaces.cc:    if ((err = COVNR == COVMATRIX ? check_covmatrix(cov) : check_cov(cov))
RandomFields/src/rf_interfaces.cc:    //    if (cov->Seval == NULL) { PMI0(cov); crash(); }
RandomFields/src/rf_interfaces.cc:void CovMatrix(double VARIABLE_IS_NOT_USED *x, INFO, model *cov, double *v){
RandomFields/src/rf_interfaces.cc:  if (v==NULL) return; // EvaluateModel needs information about size
RandomFields/src/rf_interfaces.cc:  assert(dim == OWNLOGDIM(0));
RandomFields/src/rf_interfaces.cc:      : isSpherical(iso) ? SPHERICAL_SYMMETRIC
RandomFields/src/rf_interfaces.cc:      : ISO_MISMATCH;
RandomFields/src/rf_interfaces.cc:    if (PREVXDIM(0) != PREVLOGDIM(0)) BUG;
RandomFields/src/rf_interfaces.cc:  if ((err = CHECK(sub, dim, OWNXDIM(0), PosDefType, XONLY, iso,
RandomFields/src/rf_interfaces.cc:		   SUBMODEL_DEP, EvaluationType)) != NOERROR) {
RandomFields/src/rf_interfaces.cc:    if ((err = CHECK(sub, dim, OWNXDIM(0), 
RandomFields/src/rf_interfaces.cc:		     PosDefType, KERNEL, CARTESIAN_COORD, SUBMODEL_DEP,
RandomFields/src/rf_interfaces.cc:      //      APMI(cov)
RandomFields/src/rf_interfaces.cc:      if ((err = CHECK(sub, dim, OWNXDIM(0), VariogramType, XONLY,
RandomFields/src/rf_interfaces.cc:		       SUBMODEL_DEP, EvaluationType)) != NOERROR) {
RandomFields/src/rf_interfaces.cc:  rows = VDIM0 = sub->vdim[0]; 
RandomFields/src/rf_interfaces.cc:  cols = VDIM1 = sub->vdim[1]; 
RandomFields/src/rf_interfaces.cc:  if (v==NULL) return; // EvaluateModel needs information about size
RandomFields/src/rf_interfaces.cc:  if (v==NULL) return; // EvaluateModel needs information about size
RandomFields/src/rf_interfaces.cc:  if ((err = CHECK(sub, Loctsdim(cov), OWNXDIM(0), VariogramType,
RandomFields/src/rf_interfaces.cc:  if (v==NULL) return; // EvaluateModel needs information about size
RandomFields/src/rf_interfaces.cc:  //  PMI0(cov); // PMI0(genuine->calling);  PMI0(genuine);
RandomFields/src/rf_interfaces.cc:   // assert(XDIM(PREVSYSOF(genuine), 0) == LOGDIM(PREVSYSOF(genuine), 0));
RandomFields/src/rf_interfaces.cc:   if (XDIM(PREVSYSOF(genuine), 0) != LOGDIM(PREVSYSOF(genuine), 0)) BUG;
RandomFields/src/rf_interfaces.cc:  //  PMI(cov);
RandomFields/src/rf_interfaces.cc: if (vdimSq > fctn->rowscols) {PMI(cov); BUG;} //
RandomFields/src/rf_interfaces.cc:#define FUNCTION2 FCTN(x, info, genuine, cross); VDIM_LOOP(cross[u])
RandomFields/src/rf_interfaces.cc:#define FUNCTION2_Y NONSTATCOV(x, y, info, genuine, cross); VDIM_LOOP(cross[u])
RandomFields/src/rf_interfaces.cc:  PERFORM_PREPARE;
RandomFields/src/rf_interfaces.cc:  // PMI0(genuine);
RandomFields/src/rf_interfaces.cc:  PERFORM(FUNCTION, FUNCTION2, FUNCTION_Y, FUNCTION2_Y);
RandomFields/src/rf_interfaces.cc:    XERR(ERRORMEMORYALLOCATION);
RandomFields/src/rf_interfaces.cc:  //    *nr = SIZE_NOT_DETERMINED;
RandomFields/src/rf_interfaces.cc:  *nr = *nc = (i==PREDICT_GIVEN) ? SIZE_NOT_DETERMINED : -1;
RandomFields/src/rf_interfaces.cc:  // PMI1(cov);
RandomFields/src/rf_interfaces.cc:      vdim = VDIM0,
RandomFields/src/rf_interfaces.cc:    return; // EvaluateModel needs information about size
RandomFields/src/rf_interfaces.cc:  if (VDIM0 !=sub->vdim[0] || VDIM1 != sub->vdim[1])
RandomFields/src/rf_interfaces.cc:  if ((err = alloc_fctn(sub, dim, VDIM0 * VDIM1)) != NOERROR)
RandomFields/src/rf_interfaces.cc:  cov->q[1] = VDIM0;
Binary file RandomFields/src/MLE.o matches
Binary file RandomFields/src/convhull2D.o matches
RandomFields/src/fftVario.cc: Johannes Martini
RandomFields/src/fftVario.cc: Copyright (C) 2011 -- 2013 Sebastian Engelke, Johannes Martini
RandomFields/src/fftVario.cc: Copyright (C) 2014 Sebastian Engelke, Johannes Martini, Martin Schlather
RandomFields/src/fftVario.cc: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/src/fftVario.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/fftVario.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/fftVario.cc:  phi = Mod(phi, maxAngle);
RandomFields/src/fftVario.cc:		SEXP MeanVar,
RandomFields/src/fftVario.cc:  SEXP Back = PROTECT(allocMatrix(REALSXP, back_totalbins, 2 + pseudo));
RandomFields/src/fftVario.cc:  if ((BinSq = (double *) MALLOC(sizeof(double)* (nbin + 1))) ==NULL) {
RandomFields/src/fftVario.cc:    err=ERRORMEMORYALLOCATION; goto ErrorHandling; 
RandomFields/src/fftVario.cc:    meanVar = REAL(MeanVar);
RandomFields/src/fftVario.cc:		      kM1 = k - 1,	
RandomFields/src/fftVario.cc:		      TkM2 = 2 - k,
RandomFields/src/fftVario.cc:		      base = binidx + (kphi + Nphihalf * kM1) * nbin,
RandomFields/src/fftVario.cc:		      Idx = ((Ntheta - 1 - ktheta) * kM1 + 
RandomFields/src/fftVario.cc:			     ktheta * TkM2) * NphiNbin;
RandomFields/src/fftVario.cc:		      basX = binidx + (kphix + Nphihalf * kM1) * nbin;
RandomFields/src/fftVario.cc:		      Idx = ((Ntheta -1 - kthetaz) * kM1 + kthetaz * TkM2) * 
RandomFields/src/fftVario.cc:// 	// die bin-Matrix fuer die aufsummierten werte
RandomFields/src/fftVario.cc:// 	// die bin-Matrix fuer die gewichte
RandomFields/src/fftVario.cc:// 	 * MAIN LOOP
Binary file RandomFields/src/y.o matches
RandomFields/src/operator.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/operator.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/src/operator.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/operator.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/operator.h:#define BUBBLE_MINSCALE 2 // must be decreasing-- will be turned into tau=1/s^2!
RandomFields/src/operator.h:#define BLEND_MULTI 0
RandomFields/src/operator.h:#define M_M 0
RandomFields/src/operator.h:#define M_VDIM 1
RandomFields/src/operator.h:void kappaM(int i, model *cov, int *nr, int *nc);
RandomFields/src/operator.h:void Matrix(double *x, int *, model *cov, double *v);
RandomFields/src/operator.h:void nonstatM(double *x, double *y, int *, model *cov, double *v);
RandomFields/src/operator.h:int checkM(model *cov);
RandomFields/src/operator.h:bool allowedDM(model *cov);
RandomFields/src/operator.h:bool allowedIM(model *cov);
RandomFields/src/operator.h:void rangeM(model *cov, int k, int i, int j, simple_range_type *range);
RandomFields/src/operator.h:sortsofparam sortof_M(model *cov, int k, int row, int col,
RandomFields/src/operator.h:Types TypeM(Types required, model *cov, isotropy_type i);
RandomFields/src/operator.h:int initM(model *cov, gen_storage *s);
RandomFields/src/operator.h:bool setM(model *cov);
RandomFields/src/operator.h:void TBM2Id(double *x, int *, model *cov, double *v);
RandomFields/src/operator.h:#define DMAX DPROJ
RandomFields/src/operator.h:bool allowedDS(model *cov); // returns true when everything is OK, eg RMconst
RandomFields/src/operator.h:void NonStWM(double *x, double *y, int *, model *cov, double *v);
RandomFields/src/operator.h:int checkNonStWM(model *cov); 
RandomFields/src/operator.h:void rangeNonStWM(model *cov, range_type* ra); 
RandomFields/src/operator.h://void DrawMixNonStWM(model *cov, double *random);
RandomFields/src/operator.h://double LogMixWeightNonStWM(double *x, double logV, model *cov);
RandomFields/src/operator.h:void MaStein(double *x, int *, model *cov, double *v);
RandomFields/src/operator.h:int check_MaStein(model *cov);
RandomFields/src/operator.h:void range_MaStein(model *cov, range_type* ra);
RandomFields/src/operator.h:void TBM2nsst(double *x, int *, model *cov, double *v);
RandomFields/src/operator.h:#define STP_M 2
RandomFields/src/operator.h:#define QAM_THETA 0
RandomFields/src/operator.h:#define TBMOP_FULLDIM 0
RandomFields/src/operator.h:#define TBMOP_TBMDIM 1
RandomFields/src/operator.h:#define TBMOP_LAYERS 2
RandomFields/src/operator.h:#define TBMOP_COV 0
RandomFields/src/operator.h:#define pLOC_DIAM 0 // parameter p
RandomFields/src/operator.h:#define LOCAL_CUTOFF_MSG (LOCAL_R + 1)
RandomFields/src/operator.h:#define CUTOFF_B (LOCAL_CUTOFF_MSG + 1)
RandomFields/src/operator.h:#define CUTOFF_MAX (CUTOFF_CONSTANT + 1)   /* size of vector q */
RandomFields/src/operator.h:#define CUTOFF_R (CUTOFF_MAX + 1)
RandomFields/src/operator.h:#define CUTOFF_CUBE_M (CUTOFF_CUBE_N + 1)
RandomFields/src/operator.h:#define CUTOFF_CUBE_L (CUTOFF_CUBE_M + 1)
RandomFields/src/operator.h:#define CUTOFF_MULTIVARIATE_MAX (CUTOFF_CUBE_L + 1)
RandomFields/src/operator.h:#define INTRINSIC_A0 (LOCAL_CUTOFF_MSG + 1)
RandomFields/src/operator.h:#define INTRINSIC_MAX (INTRINSIC_B + 1) /* size of vector q */
RandomFields/src/operator.h:#define LOCAL_MAX (INTRINSIC_MAX + CUTOFF_MAX) /* sicher ist sicher */
RandomFields/src/operator.h:#define SCATTER_MAX 1
RandomFields/src/operator.h:#define PRODPROC_RANDOM 0
RandomFields/src/intrinsics.h:// PKG_CXXFLAGS =  $(SHLIB_OPENMP_CXXFLAGS) -mavx -msse -msse2 -msse3 -msse4 -msse4a -march=core-avx2
RandomFields/src/intrinsics.h:#define SSEMODE 30
RandomFields/src/intrinsics.h:#define SSEMODE 20
RandomFields/src/intrinsics.h:#define SSEMODE 10
RandomFields/src/intrinsics.h:#define SSEMODE 0
RandomFields/src/intrinsics.h:// #define FMA_AVAILABLE __FMA__
RandomFields/src/intrinsics.h:  (__GNUC__ == 4 && (__GNUC_MINOR__ > 9 ||				\
RandomFields/src/intrinsics.h:		     (__GNUC_MINOR__ == 9 &&  __GNUC_PATCHLEVEL__ >= 1)))
RandomFields/src/intrinsics.h://#define OpenMP4 1
RandomFields/src/intrinsics.h:#define MAXDOUBLE _mm256_max_pd
RandomFields/src/intrinsics.h:#define MULTDOUBLE _mm256_mul_pd 
RandomFields/src/intrinsics.h:#define MAXDOUBLE _mm_max_pd
RandomFields/src/intrinsics.h:#define MULTDOUBLE _mm_mul_pd 
RandomFields/src/MLE.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/MLE.cc: Copyright (C) 2001 -- 2017 Martin Schlather, 
RandomFields/src/MLE.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/MLE.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/MLE.cc:#include "QMath.h"
RandomFields/src/MLE.cc:  return MISMATCH;
RandomFields/src/MLE.cc:		   covptr_type covModels, 
RandomFields/src/MLE.cc:  // printf("%s\n", NAME(cov));
RandomFields/src/MLE.cc:  while(STRNCMP(C->name, InternalName, STRLEN(InternalName)) == 0) {
RandomFields/src/MLE.cc:  // in initNerror.cc by IncludeModel or IncludePrim
RandomFields/src/MLE.cc:      while(STRNCMP(CC->name, InternalName, STRLEN(InternalName)) == 0) {
RandomFields/src/MLE.cc:    //    printf("NApos : %s %d %d %d\n", NAME(cov), i, istrend, excludetrends);
RandomFields/src/MLE.cc:    if (i==0 && type[i] == INTSXP && STRCMP(C->kappanames[i], ELEMENT) == 0){
RandomFields/src/MLE.cc:      if (*elmnts >= MAX_MLE_ELMNTS ) 
RandomFields/src/MLE.cc:      if (P0INT(i) == NA_INTEGER) ERR1("'%.50s' may not be NA", ELEMENT);
RandomFields/src/MLE.cc:      // to do!! covModels[*NAs] hierher uebertragen !! s.u.
RandomFields/src/MLE.cc:	  if (*NAs >= MAX_NA) SERR("maximum number of NA reached");	
RandomFields/src/MLE.cc:	  sorts[*NAs] = SortOf(cov, i, r, c, original_model);  // ANYPARAM;
RandomFields/src/MLE.cc:	    covModels[*NAs] = cov;
RandomFields/src/MLE.cc:		SERR1("%.20s: integer variables currently not allowed to be 'NA'", KNAME(i)); // !!!
RandomFields/src/MLE.cc:		while (!is_top(calling) && (MODELNR(calling) ==PLUS))
RandomFields/src/MLE.cc:		  ? (equalsNugget(NEXTNR) ? NUGGETVAR : VARPARAM)
RandomFields/src/MLE.cc:		  : ANYPARAM; 
RandomFields/src/MLE.cc:		if (no_variance && sorts[*NAs] <= SIGNEDSDPARAM)
RandomFields/src/MLE.cc:		  sorts[*NAs] = ANYPARAM;
RandomFields/src/MLE.cc:			sorts[*NAs] <= SIGNEDSDPARAM || sorts[*NAs] ==NUGGETVAR 
RandomFields/src/MLE.cc:		sorts[*NAs] = SCALEPARAM;	
RandomFields/src/MLE.cc:		sorts[*NAs] = r==c ? DIAGPARAM : ANISOPARAM;
RandomFields/src/MLE.cc:	      // printf(">> %s %d %d\n", NAME(cov), i, equalsnowTrendParam(cov, i));
RandomFields/src/MLE.cc:	      if (istrend) {// || nr==MLEMI XEDEFFECT)
RandomFields/src/MLE.cc:		sorts[*NAs] = TRENDPARAM;
RandomFields/src/MLE.cc:		  sorts[*NAs] = INTEGERPARAM; 
RandomFields/src/MLE.cc:		  if (no_variance && sorts[*NAs] <= SIGNEDSDPARAM)
RandomFields/src/MLE.cc:		    sorts[*NAs] = ANYPARAM;
RandomFields/src/MLE.cc:	      if (isConst(cov) && !PisNULL(CONST_NAME)) {
RandomFields/src/MLE.cc:		//		printf("******* *%s\n", P0CHAR(CONST_NAME));
RandomFields/src/MLE.cc:		strcopyN(names[*NAs], P0CHAR(CONST_NAME),  2 * SHORTlen);
RandomFields/src/MLE.cc:		    STRNCMP(names[*NAs], names[*NAs-1], STRLEN(names[*NAs]))){
RandomFields/src/MLE.cc:	    //	    printf("%s %d\n", NAME(cov), *NAs);
RandomFields/src/MLE.cc:			      coord, covModels,
RandomFields/src/MLE.cc:			      sort != VARPARAM && sort != VARONLYMLE,
RandomFields/src/MLE.cc:  for (i=0; i<MAXSUB; i++) {
RandomFields/src/MLE.cc:			      coord, covModels,
RandomFields/src/MLE.cc:SEXP GetNAPositions(SEXP Model_reg, SEXP Model, SEXP x,
RandomFields/src/MLE.cc: int Reg = INTEGER(Model_reg)[0];
RandomFields/src/MLE.cc:    vdim1[MAX_NA], vdim2[MAX_NA], covzaehler[MAXNRCOVFCTS], found[MAX_NA],
RandomFields/src/MLE.cc:     coord[MAX_NA];
RandomFields/src/MLE.cc:  covptr_type covModels;
RandomFields/src/MLE.cc:  sortsofparam sorts[MAX_NA];
RandomFields/src/MLE.cc:  bool bayesian[MAX_NA];  
RandomFields/src/MLE.cc:  if (Model != R_NilValue) {
RandomFields/src/MLE.cc:    cov = InitIntern(Reg, Model, x, true, ignoreValues);
RandomFields/src/MLE.cc:    for (i=0; i<MAXNRCOVFCTS;  covzaehler[i++]=0);
RandomFields/src/MLE.cc:			    coord, covModels,
RandomFields/src/MLE.cc:  // PMI0(cov);
RandomFields/src/MLE.cc:	//&& !PisNULL(i) // wichtig, da ja noch der Parameter durch ein Modell 
RandomFields/src/MLE.cc:    (CALLING != NULL && CALLINGNR == PLUS && isMal(cov));
RandomFields/src/MLE.cc:  for (i=0; i<MAXSUB; i++) {
RandomFields/src/MLE.cc:  if (STRCMP(Nick(cov), Nick(cov_bound)) != 0) {
RandomFields/src/MLE.cc:	  w = PARAM(cov_bound, i)[idx];
RandomFields/src/MLE.cc:	  w = PARAMINT(cov_bound, i)[idx] == NA_INTEGER 
RandomFields/src/MLE.cc:	    ? RF_NA : (double) PARAMINT(cov_bound, i)[idx];	  
RandomFields/src/MLE.cc:  for (i=0; i<MAXSUB; i++) {
RandomFields/src/MLE.cc:SEXP Take2ndAtNaOf1st(SEXP model_reg, SEXP Model, SEXP model_bound,
RandomFields/src/MLE.cc:    nr[2] = {INTEGER(model_reg)[0], MODEL_BOUNDS};
RandomFields/src/MLE.cc:    models[2] = {Model, model_bound};
RandomFields/src/MLE.cc:#define MAXDIM0 4  
RandomFields/src/MLE.cc:    CheckModel(models[m], NULL, NULL, NULL, NULL, 0, 0, 0, 0,
RandomFields/src/MLE.cc:  bounds_pointer = NUMERIC_POINTER(bounds);
RandomFields/src/MLE.cc:  //  PMI(key[nr[0]]);
RandomFields/src/MLE.cc:  //  PMI(key[nr[1]]);
RandomFields/src/MLE.cc:	dmin = PARAM0(min, i);
RandomFields/src/MLE.cc:	dmax = PARAM0(max, i);
RandomFields/src/MLE.cc:	dmin = PARAM0INT(min, i) == NA_INTEGER 
RandomFields/src/MLE.cc:	  ? RF_NA : (double) PARAM0INT(min, i);
RandomFields/src/MLE.cc:	dmax = PARAM0INT(max, i) == NA_INTEGER 
RandomFields/src/MLE.cc:	  ? RF_NA : (double) PARAM0INT(max, i);
RandomFields/src/MLE.cc:	dmin = LPARAM0(min, i);
RandomFields/src/MLE.cc:	dmax = LPARAM0(max, i);
RandomFields/src/MLE.cc:	  DORANDOM(sub, &rr);
RandomFields/src/MLE.cc:      //  PMI(cov->kappasub[i]);
RandomFields/src/MLE.cc:  for (i=0; i<MAXSUB; i++) {
RandomFields/src/MLE.cc:    if (COVNR == MULT) {
RandomFields/src/MLE.cc:    if (!isProcess(cov) || !equalsXonly(SUBDOM(0))) facts->trans_inv = false;
RandomFields/src/MLE.cc:  if (!equalsXonly(OWNDOM(0))) facts->trans_inv = false;
RandomFields/src/MLE.cc:      if (facts->neffect >= MAX_LIN_COMP) ERR("too many linear components");
RandomFields/src/MLE.cc:    if (MODELNR(component) == PLUS) {
RandomFields/src/MLE.cc:    if (facts->neffect >= MAX_LIN_COMP) ERR("too many linear components");
RandomFields/src/MLE.cc:    //    for (i=0; i<MAXSUB; i++) if (calling->sub[i] == cov) break;
RandomFields/src/MLE.cc:    //    assert (i<MAXSUB);
RandomFields/src/MLE.cc:// called by gausslikeli.cc and MLE.cc
RandomFields/src/MLE.cc:  //  bool *trans_inv, bool *isotropic, double **Matrix,
RandomFields/src/MLE.cc:  //int *neffect, int effect[MAXSUB],
RandomFields/src/MLE.cc:  //int *NAs, int nas[MAXSUB], NAname_type names) {
RandomFields/src/MLE.cc:    mem_vdim1[MAX_NA],
RandomFields/src/MLE.cc:    mem_vdim2[MAX_NA],
RandomFields/src/MLE.cc:    covzaehler[MAXNRCOVFCTS], 
RandomFields/src/MLE.cc:  sortsofparam mem_sorts[MAX_NA];
RandomFields/src/MLE.cc:  int mem_found[MAX_NA], mem_coord[MAX_NA];
RandomFields/src/MLE.cc:  bool mem_bayesian[MAX_NA];
RandomFields/src/MLE.cc:  double mle_min[MAX_NA], mle_max[MAX_NA], mle_pmin[MAX_NA], mle_pmax[MAX_NA],
RandomFields/src/MLE.cc:    mle_openmin[MAX_NA], mle_openmax[MAX_NA],
RandomFields/src/MLE.cc:    err = ERRORINVALIDMODEL;
RandomFields/src/MLE.cc:  //  s->ELMNTS = 
RandomFields/src/MLE.cc:  for (i=0; i<MAXNRCOVFCTS;  covzaehler[i++]=0);
RandomFields/src/MLE.cc:			   &(s->NAS), s->MEMORY, 
RandomFields/src/MLE.cc:			   //s->ELMNTS , s->MEMORY_ELMNTS,
RandomFields/src/MLE.cc:			   s->COVMODELS,
RandomFields/src/MLE.cc:  //  PMI(sub);
RandomFields/src/MLE.cc:  //  PMI(cov);
RandomFields/src/MLE.cc:    if (isDollar(facts->Var) && !PARAMisNULL(facts->Var, DVAR) &&
RandomFields/src/MLE.cc:      double var = PARAM0(facts->Var, DVAR);
RandomFields/src/MLE.cc:	facts->pt_variance = PARAM(facts->Var, DVAR);
RandomFields/src/MLE.cc:	  if (s->MEMORY[i] == facts->pt_variance) {
RandomFields/src/MLE.cc:	      s->MEMORY[j-1] = s->MEMORY[j];
RandomFields/src/MLE.cc:    facts->Matrix = NULL;
RandomFields/src/MLE.cc:    facts->Matrix = (double*) MALLOC(rows * MINMAX_ENTRIES * sizeof(double));
RandomFields/src/MLE.cc:    matrix = facts->Matrix;
RandomFields/src/MLE.cc:      matrix[j + MINMAX_PMIN * rows ] = mle_pmin[k];
RandomFields/src/MLE.cc:      matrix[j + MINMAX_PMAX * rows] = mle_pmax[k];
RandomFields/src/MLE.cc:      if (sort >= FIRSTONLYMLE && sort <= LASTONLYMLE) {
RandomFields/src/MLE.cc:	case VARONLYMLE : sort = VARPARAM; break;
RandomFields/src/MLE.cc:	case CRITONLYMLE : sort = CRITICALPARAM; break;
RandomFields/src/MLE.cc:	case ONLYMLE : sort = ANYPARAM; break;
RandomFields/src/MLE.cc:      matrix[j + MINMAX_TYPE * rows] = sort;
RandomFields/src/MLE.cc:      matrix[j + MINMAX_NAN * rows] = !ISNA(values[mem_found[k]]);
RandomFields/src/MLE.cc:      matrix[j + MINMAX_MIN * rows] = mle_min[k];
RandomFields/src/MLE.cc:      matrix[j + MINMAX_MAX * rows] = mle_max[k];
RandomFields/src/MLE.cc:      matrix[j + MINMAX_OMIN * rows] = mle_openmin[k];
RandomFields/src/MLE.cc:      matrix[j + MINMAX_OMAX * rows] = mle_openmax[k];
RandomFields/src/MLE.cc:      matrix[j + MINMAX_ROWS * rows] = mem_vdim1[k];
RandomFields/src/MLE.cc:      matrix[j + MINMAX_COLS * rows] = mem_vdim2[k];
RandomFields/src/MLE.cc:      matrix[j + MINMAX_BAYES * rows] = mem_bayesian[k];
RandomFields/src/MLE.cc:      matrix[j + MINMAX_COORD * rows] = mem_coord[k];
RandomFields/src/MLE.cc:SEXP SetAndGetModelFacts(model *cov, int shortlen, int allowforintegerNA,
RandomFields/src/MLE.cc:  const char *colnames[MINMAX_ENTRIES] =
RandomFields/src/MLE.cc:   matrix, nameAns, nameMatrix, RownameMatrix, 
RandomFields/src/MLE.cc:  factsNaN = facts->Matrix + rows * (MINMAX_NAN - 1); // MINMAX_NAN is R coded
RandomFields/src/MLE.cc:    //printf("i=%d %10g %d; %d %d %d %d\n", i, factsNaN[i], rows,MINMAX_PMIN,  MINMAX_PMAX, MINMAX_TYPE, MINMAX_NAN);
RandomFields/src/MLE.cc:  PROTECT(matrix =  allocMatrix(REALSXP, rows, MINMAX_ENTRIES));
RandomFields/src/MLE.cc:  PROTECT(RownameMatrix = allocVector(STRSXP, rows));
RandomFields/src/MLE.cc:  PROTECT(nameMatrix = allocVector(VECSXP, 2));
RandomFields/src/MLE.cc:  //printf("%d\n", facts->Matrix != NULL);
RandomFields/src/MLE.cc:    MEMCOPY(REAL(matrix), facts->Matrix, rows * MINMAX_ENTRIES * sizeof(double));
RandomFields/src/MLE.cc:      SET_STRING_ELT(RownameMatrix, i, mkChar(facts->names[i]));
RandomFields/src/MLE.cc:  SET_VECTOR_ELT(nameMatrix, 0, RownameMatrix);
RandomFields/src/MLE.cc:  SET_VECTOR_ELT(nameMatrix, 1, Char(colnames, MINMAX_ENTRIES));
RandomFields/src/MLE.cc:  setAttrib(matrix, R_DimNamesSymbol, nameMatrix);
RandomFields/src/MLE.cc:SEXP SetAndGetModelLikelihood(SEXP Model_reg, SEXP Model, SEXP x,
RandomFields/src/MLE.cc:  int Reg = INTEGER(Model_reg)[0];
RandomFields/src/MLE.cc:  CheckModel(Model, NULL, NULL, NULL,NULL, 0, 0, 0, 0,
RandomFields/src/MLE.cc:  return SetAndGetModelFacts(KT->KEY[Reg], 
RandomFields/src/MLE.cc:SEXP SetAndGetModelFacts(SEXP Model_reg, SEXP Model, SEXP spatialdim, 
RandomFields/src/MLE.cc:  // called with ygiven=TRUE only RFgetModelInfo_model
RandomFields/src/MLE.cc:  int Reg = INTEGER(Model_reg)[0],
RandomFields/src/MLE.cc:  CheckModel(Model, x0, y0, T0, ygiven ? T0 : NULL,
RandomFields/src/MLE.cc:  return SetAndGetModelFacts(KT->KEY[Reg], INTEGER(shortlen)[0],
RandomFields/src/MLE.cc:void expliciteDollarMLE(int* reg, double *values) { // 
RandomFields/src/MLE.cc:  if (cov->base->global.general.naturalscaling==NATSCALE_MLE) {
RandomFields/src/MLE.cc:    values[un++] = s->MEMORY[i][0];
RandomFields/src/MLE.cc:    s->MEMORY[i][0] = RF_NA;
RandomFields/src/MLE.cc: //      print("reg=%d i=%d %d %ld %10g %ld\n", *reg, i, NAs, s->MEMORY[i], values[un], pt_variance);
RandomFields/src/MLE.cc:    //     print("mem=%ld %10g\n", (Long) s->MEMORY[i], values[un]) ;  
RandomFields/src/MLE.cc:    if (s->MEMORY[i] == pt_variance) BUG; //continue;
RandomFields/src/MLE.cc:    s->MEMORY[i][0] = values[un++];
RandomFields/src/MLE.cc:   //   PMI(KEY()[*reg]);
RandomFields/src/MLE.cc:      cov = s->COVMODELS[i];
RandomFields/src/MLE.cc:      if (i==0 || cov != s->COVMODELS[i-1]) {
RandomFields/src/MLE.cc:  //APMI(KEY()[*reg]);
RandomFields/src/brownresnick.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/brownresnick.cc: Copyright (C) 2001 -- 2017 Martin Schlather, 
RandomFields/src/brownresnick.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURSE.  See the
RandomFields/src/brownresnick.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/brownresnick.cc:SEXP EstimBRsimuKoeff(SEXP M, SEXP Chol, SEXP N) {
RandomFields/src/brownresnick.cc:    c = ncols(M),
RandomFields/src/brownresnick.cc:  if (c != ncols(Chol) || c != nrows(M) || c != nrows(Chol))
RandomFields/src/brownresnick.cc:  PROTECT(Ans = allocMatrix(REALSXP, c, c));
RandomFields/src/brownresnick.cc:      for (int i=0; i<c; i++) Xneuj[i] = GAUSS_RANDOM(1.0);
RandomFields/src/brownresnick.cc:	*m = REAL(M) + c * i,
RandomFields/src/brownresnick.cc:#define DefMax(I) Double ALIGNED Max##I = ZERODOUBLE;
RandomFields/src/brownresnick.cc:      DefMax(0); DefMax(1); DefMax(2); DefMax(3); DefMax(4); DefMax(5);
RandomFields/src/brownresnick.cc:#define MaxX(I)\
RandomFields/src/brownresnick.cc:	Max##I = MAXDOUBLE(Max##I, MULTDOUBLE(mlocation, LOADDOUBLE(v+I*aligned_c)));
RandomFields/src/brownresnick.cc:	MaxX(0); MaxX(1); MaxX(2); MaxX(3); MaxX(4); MaxX(5);
RandomFields/src/brownresnick.cc:#define MaxS(I)						\
RandomFields/src/brownresnick.cc:      double *d##I = (double *) &Max##I,		\
RandomFields/src/brownresnick.cc:      MaxS(0); MaxS(1); MaxS(2); MaxS(3); MaxS(4); MaxS(5);
RandomFields/src/brownresnick.cc:#define MaxT(I) max##I = max##I < d##I[2] ? d##I[2] : max##I;	\
RandomFields/src/brownresnick.cc:      MaxT(0); MaxT(1); MaxT(2); MaxT(3); MaxT(4); MaxT(5);
RandomFields/src/brownresnick.cc:#define MaxU(I) z = *m * v[I * aligned_c]; max##I = max##I > z ? max##I : z;
RandomFields/src/brownresnick.cc:	MaxU(0); MaxU(1); MaxU(2); MaxU(3); MaxU(4); MaxU(5);
RandomFields/src/brownresnick.cc:      m = REAL(M) + c * i;
RandomFields/src/brownresnick.cc:	    a = MULTDOUBLE(Invmax0, LOADDOUBLE(v));
RandomFields/src/brownresnick.cc:#define Add(I) a = ADDDOUBLE(a, MULTDOUBLE(Invmax##I, LOADDOUBLE(v+I*aligned_c)))
RandomFields/src/brownresnick.cc:	  STOREuDOUBLE(ans, ADDDOUBLE(LOADuDOUBLE(ans), MULTDOUBLE(mlocation, a) ));
RandomFields/src/brownresnick.cc:#define Mult(I) v[I * aligned_c] * invmax##I
RandomFields/src/brownresnick.cc:	  *ans += *m * (Mult(0) +Mult(1) +Mult(2) +Mult(3) +Mult(4) +Mult(5));
RandomFields/src/brownresnick.cc:	  ans[j] += m[j] * (Mult(0) +Mult(1) +Mult(2) +Mult(3) +Mult(4)+Mult(5));
RandomFields/src/brownresnick.cc:	*m = REAL(M) + c * i;
RandomFields/src/convhull2D.cc: * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
RandomFields/src/convhull2D.cc: * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR AT&T MAKE ANY
RandomFields/src/convhull2D.cc: * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
RandomFields/src/convhull2D.cc: *	    A.M. Andrew, "Another Efficient Algorithm for Convex Hulls in Two Dimensions",
RandomFields/src/startGetNset.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/startGetNset.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/src/startGetNset.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/startGetNset.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/startGetNset.h:int IncludeModel(const char *name, Types type, int minsub, int maxsub,
RandomFields/src/startGetNset.h:int IncludeModelR(const char *name, Types type, int minsub, int maxsub,
RandomFields/src/startGetNset.h:int CopyModel(const char *name, int which);
RandomFields/src/startGetNset.h:int CopyModel(const char *name, int which, Types type);
RandomFields/src/startGetNset.h:int CopyModel(const char *name, int which, checkfct check);
RandomFields/src/startGetNset.h://void addTBM(covfct tbm2, covfct spaceD);
RandomFields/src/startGetNset.h:int addTBM(covfct tbm2);
RandomFields/src/startGetNset.h:void addTBM(covfct tbm2, initfct Init, spectral_do spectral);
RandomFields/src/startGetNset.h:void addTBM(initfct Init, spectral_do spectral);
RandomFields/src/startGetNset.h:void addGaussMixture(draw_random drawmix, log_mixdens logmixdens);
RandomFields/src/startGetNset.h:		return_covmat CovMatrix, ext_bool_ret_fct isCovMatrix
RandomFields/src/startGetNset.h:		//tworeturns_fct InverseCovMatrix,
RandomFields/src/startGetNset.h:		//ext_bool_ret_fct isInverseCovMatrix,
RandomFields/src/startGetNset.h:int checkMissing(model *cov);
RandomFields/src/startGetNset.h:void includeStandardMath();
RandomFields/src/startGetNset.h:bool allowedPrevModelI(model *cov);
RandomFields/src/startGetNset.h:Types TypeGaussMethod(Types required, model *cov, isotropy_type required_iso);
RandomFields/src/startGetNset.h:void Implemented(Methods Meth);
Binary file RandomFields/src/primitive.gauss.mix.o matches
RandomFields/src/init.others.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/init.others.cc: Copyright (C) 2017 -- 2018 Martin Schlather
RandomFields/src/init.others.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/init.others.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/init.others.cc:  DISTRIBUTION, DETERM_DISTR, GAUSS_DISTR, SETPARAM, COVFCTN, ANGLE,
RandomFields/src/init.others.cc:  COVMATRIX, RFGET, STROKORB_MONO, STROKORB_BALL_INNER, RECTANGULAR,
RandomFields/src/init.others.cc:  CONST, BIND, PROJ_MODEL,
RandomFields/src/init.others.cc:  POLYGON, SCATTER, MCMC_PGS, MCMC,LIKELIHOOD_CALL, LINEARPART_CALL,
RandomFields/src/init.others.cc:  IDCOORD, MULT_INVERSE,
RandomFields/src/init.others.cc:  TRUNCSUPPORT, SHAPESTP, SHAPEAVE, BROWNRESNICK, UNIF, MPPPLUS, 
RandomFields/src/init.others.cc:  BRSHIFTED_USER, BRMIXED_USER, BRORIGINAL_USER, BRNORMED,
RandomFields/src/init.others.cc:  BRSHIFTED_INTERN, BRMIXED_INTERN, BRORIGINAL_INTERN,   
RandomFields/src/init.others.cc:  EXTREMALGAUSSIAN, RANDOMSIGN,  DECLARE,
RandomFields/src/init.others.cc:  COVARIATE, TRAFO, TRAFOPROC, PROJMODEL,
RandomFields/src/init.others.cc:  VARIOGRAM_CALL, SIMULATE, DUMMY,
RandomFields/src/init.others.cc:  MISSING_COV, NULL_MODEL,
RandomFields/src/init.others.cc:  DOLLAR_PROC,R, PLUS_PROC, M_PROC,
RandomFields/src/init.others.cc:  MPPPLUS_PROC, MULT_PROC, 
RandomFields/src/init.others.cc:  GAUSSPROC, POISSONPROC,  SCHLATHERPROC, SMITHPROC, CHI2PROC,
RandomFields/src/init.others.cc:  EXTREMALTPROC, TPROC, SHAPE_FCT_PROC, PROD_PROC, VAR2COV_PROC,
RandomFields/src/init.others.cc:  CIRCEMBED,  SPECTRAL_PROC_USER, SPECTRAL_PROC_INTERN,
RandomFields/src/init.others.cc:  RANDOMCOIN_USER, CE_CUTOFFPROC_USER, CE_CUTOFFPROC_INTERN, 
RandomFields/src/init.others.cc:  CE_INTRINPROC_USER, CE_INTRINPROC_INTERN, TBM_PROC_USER, TBM_PROC_INTERN,
RandomFields/src/init.others.cc:  SCALEMODEL, BUBBLE, FCTNFCTN
RandomFields/src/init.others.cc:void includeOtherModels() {  
RandomFields/src/init.others.cc:  MISSING_COV =
RandomFields/src/init.others.cc:		checkMissing,  NULL, INFDIM, (ext_bool) true, NOT_MONOTONE);
RandomFields/src/init.others.cc:  NULL_MODEL =
RandomFields/src/init.others.cc:    IncludePrim("null", ManifoldType, 1, XONLY, ISOTROPIC, checkOK,
RandomFields/src/init.others.cc:		rangeNullModel, INFDIM, (ext_bool) true, NOT_MONOTONE);
RandomFields/src/init.others.cc:  addCov(NullModel, NullModel, NullModel, NullModel, NullModel, NULL);
RandomFields/src/init.others.cc:  addTypeFct(TypeNullModel);
RandomFields/src/init.others.cc:        //           CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.others.cc:  SHAPE_FCT = IncludeModel("shape", ShapeType, // !!! nicht TrendTYpe
RandomFields/src/init.others.cc:		       //       da wie ganz MathDef behandelt
RandomFields/src/init.others.cc:		       XONLY, PARAMDEP_I,
RandomFields/src/init.others.cc:		       false, PARAM_DEP, INFDIM, (ext_bool) false,
RandomFields/src/init.others.cc:		       NOT_MONOTONE);
RandomFields/src/init.others.cc:  // change_sortof(SHAPE_FCT_MEAN, TRENDPARAM);
RandomFields/src/init.others.cc:  change_typeof(SHAPE_FCT_MEAN, ShapeType);
RandomFields/src/init.others.cc:    IncludeModel("select", TcfType, 1, MAXSUB, 1, NULL, PREV_SUB_D, PREV_SUB_I,
RandomFields/src/init.others.cc:		 true, PARAM_DEP, INFDIM, (ext_bool)SUBMODEL_DEP, NOT_MONOTONE);
RandomFields/src/init.others.cc:   IncludeModel("angle", ShapeType, 0, 0, 4, kappa_Angle, XONLY,
RandomFields/src/init.others.cc:	       false, PARAM_DEP, INFDIM, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.others.cc:		    SCALAR, INFDIM-1, (ext_bool) true, MONOTONE);
RandomFields/src/init.others.cc:    IncludeModel("covariate", ShapeType, 0, 0, 7, kappa_covariate,
RandomFields/src/init.others.cc:		 INTERN_SHOW, PARAM_DEP, INFDIM-1, (ext_bool) false,
RandomFields/src/init.others.cc:		 NOT_MONOTONE);
RandomFields/src/init.others.cc:  kappanames(COVARIATE_C_NAME, LISTOF + REALSXP,
RandomFields/src/init.others.cc:	     COVARIATE_X_NAME, VECSXP, 
RandomFields/src/init.others.cc:	     COVARIATE_RAW_NAME, INTSXP,
RandomFields/src/init.others.cc:	     COVARIATE_EXTRA_DATA_NAME, INTSXP,
RandomFields/src/init.others.cc:	     COVARIATE_ADDNA_NAME, INTSXP,
RandomFields/src/init.others.cc:	     COVARIATE_NAME_NAME, STRSXP);
RandomFields/src/init.others.cc:  change_sortof(COVARIATE_X, DONOTVERIFYPARAM);
RandomFields/src/init.others.cc:  change_sortof(COVARIATE_RAW, IGNOREPARAM);
RandomFields/src/init.others.cc:  change_sortof(COVARIATE_ADDNA, IGNOREPARAM);
RandomFields/src/init.others.cc:  change_sortof(COVARIATE_FACTOR, TRENDPARAM); 
RandomFields/src/init.others.cc:  change_sortof(COVARIATE_NAME, IGNOREPARAM); 
RandomFields/src/init.others.cc:  change_sortof(COVARIATE_EXTRA_DATA, IGNOREPARAM);
RandomFields/src/init.others.cc:  AddVariant(ShapeType, ISOTROPIC); // only if CovarianceMatrix with distances
RandomFields/src/init.others.cc:  IncludeModel("declare", // never change name without checking all .cc, .R
RandomFields/src/init.others.cc:	       0, 0, 16, kappa_declare, PREVMODEL_D, PREVMODEL_I,
RandomFields/src/init.others.cc:	       PARAM_DEP, INFDIM, falsch, NOT_MONOTONE);
RandomFields/src/init.others.cc:  AddVariant(TrendType, PREVMODEL_I);
RandomFields/src/init.others.cc:	      PARAM_DEP, EaxxaMaxDim, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.others.cc:	      checkEtAxxA, rangeEtAxxA, 3, EaxxaMaxDim, (ext_bool) false,
RandomFields/src/init.others.cc:	      NOT_MONOTONE);
RandomFields/src/init.others.cc:    IncludeModel("idcoord", ShapeType, 0, 0, 0, NULL, XONLY, PREVMODEL_I,
RandomFields/src/init.others.cc:	       false, PARAM_DEP, INFDIM, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.others.cc:    //   IncludeModel("trafo", ManifoldType, 0, 1, 1, NULL, PREVMODEL_D, PREVMODEL_I,
RandomFields/src/init.others.cc:   IncludeModel("trafo", ManifoldType, 0, 1, 1, kappatrafo,
RandomFields/src/init.others.cc:		PARAMDEP_D, PARAMDEP_I,
RandomFields/src/init.others.cc:		false, PARAM_DEP, INFDIM-1, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.others.cc:  change_typeof(TRAFO_ISO, NN2); // ISO_NAMES
RandomFields/src/init.others.cc:  MULT_INVERSE =
RandomFields/src/init.others.cc:    IncludeModel("mult_inverse", ShapeType, 1, 1, 0, NULL,
RandomFields/src/init.others.cc:		 PREVMODEL_D, PREVMODEL_I,
RandomFields/src/init.others.cc:		 true, SCALAR, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP, MON_SUB_DEP);
RandomFields/src/init.others.cc:    IncludeModel("polygon",  ShapeType, 0, 0, 1, NULL, XONLY, CARTESIAN_COORD, 
RandomFields/src/init.others.cc:	       false, SCALAR, 2, (ext_bool) true, MONOTONE);
RandomFields/src/init.others.cc:	      checkrational, rangerational, INFDIM, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.others.cc:	      NOT_MONOTONE);
RandomFields/src/init.others.cc:	      checkRotat, rangeRotat, PARAM_DEP, 3, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.others.cc:  SCATTER = IncludeModel("scatter",  PosDefType, 1, 1, 2, NULL, 
RandomFields/src/init.others.cc:			 PREVMODEL_D, PREVMODEL_I, 
RandomFields/src/init.others.cc:			 true, SUBMODEL_DEP, SUBMODEL_DEP,
RandomFields/src/init.others.cc:			 (ext_bool) SUBMODEL_DEP, NOT_MONOTONE);
RandomFields/src/init.others.cc:  RANDOMSIGN = 
RandomFields/src/init.others.cc:    IncludeModel("sign",  ShapeType, 1, 1, 1, NULL, XONLY, PREVMODEL_I,
RandomFields/src/init.others.cc:		 false, SCALAR, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.others.cc:		 NOT_MONOTONE);
RandomFields/src/init.others.cc:  SETPARAM = // nur Handling von Parametern von shape nach pts
RandomFields/src/init.others.cc:    IncludeModel("setparam", ManifoldType, 1, 1, 1, NULL, 
RandomFields/src/init.others.cc:		 PREVMODEL_D, PREVMODEL_I,
RandomFields/src/init.others.cc:		 true, SUBMODEL_DEP, SUBMODEL_DEP,
RandomFields/src/init.others.cc:		 (ext_bool) SUBMODEL_DEP, MON_SUB_DEP);
RandomFields/src/init.others.cc:  addTBM(NULL, spectralsetparam);
RandomFields/src/init.others.cc:  STROKORB_MONO =
RandomFields/src/init.others.cc:    IncludeModel("m2r", ShapeType, 1, 1, 0, NULL, XONLY, ISOTROPIC,
RandomFields/src/init.others.cc:		 false, SCALAR, 3, (ext_bool) SUBMODEL_DEP, MON_SUB_DEP);
RandomFields/src/init.others.cc:  IncludeModel("m3b", ShapeType, 1, 1, 
RandomFields/src/init.others.cc:	       false, SCALAR, 3, (ext_bool) true, MONOTONE);
RandomFields/src/init.others.cc:    IncludeModel("r3binner", ShapeType, 1, 1, 1, NULL,
RandomFields/src/init.others.cc:		 true, 1, 1, (ext_bool) true, NOT_MONOTONE);
RandomFields/src/init.others.cc:  IncludeModel("mps", ShapeType, 1, 1, 0, NULL, XONLY,CARTESIAN_COORD,
RandomFields/src/init.others.cc:	       //	       false, SCALAR, INFDIM, falsch, NOT_MONOTONE);
RandomFields/src/init.others.cc:	       false, SCALAR, 2, (ext_bool) true, MONOTONE);
RandomFields/src/init.others.cc:    IncludeModel("truncsupport", ShapeType, 
RandomFields/src/init.others.cc:		 1, 1, 1, NULL, XONLY, PREVMODEL_I, checktruncsupport,
RandomFields/src/init.others.cc:		 SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP, MON_SUB_DEP);
RandomFields/src/init.others.cc:    IncludeModel("arcsqrt", RandomType, 0, 0, 1, NULL, 
RandomFields/src/init.others.cc:		 DOMAIN_MISMATCH, ISO_MISMATCH, // set to "cart sys"
RandomFields/src/init.others.cc:		 true, 1, 1, (ext_bool) false, MON_MISMATCH); // to do: nicht mismatch,
RandomFields/src/init.others.cc:  DETERM_DISTR = 
RandomFields/src/init.others.cc:    IncludeModel("determ", RandomType, 0, 0, 1, kappa_determ, 
RandomFields/src/init.others.cc:		 DOMAIN_MISMATCH, ISO_MISMATCH, // set to "cart sys"
RandomFields/src/init.others.cc:		 false, SUBMODEL_DEP, INFDIM-1, (ext_bool) SUBMODEL_DEP, MON_MISMATCH);
RandomFields/src/init.others.cc:  DISTRIBUTION = // FREEVARIABLE vorhanden. Muss extra in SpecialRMmodel.R
RandomFields/src/init.others.cc:    IncludeModel("distr", RandomType, 0, 0, 16, kappa_distr, 
RandomFields/src/init.others.cc:		 DOMAIN_MISMATCH, ISO_MISMATCH, // set to "cart sys"
RandomFields/src/init.others.cc:		 true, PARAM_DEP, INFDIM-1, (ext_bool) false, MON_MISMATCH);
RandomFields/src/init.others.cc:  change_sortof(DISTR_DX, IGNOREPARAM);
RandomFields/src/init.others.cc:  change_sortof(DISTR_PX, IGNOREPARAM);
RandomFields/src/init.others.cc:  change_sortof(DISTR_QX, IGNOREPARAM);
RandomFields/src/init.others.cc:  change_sortof(DISTR_RX, IGNOREPARAM);
RandomFields/src/init.others.cc:    IncludeModel("normal", RandomType, 0, 0, 3, kappa_gauss_distr, 
RandomFields/src/init.others.cc:		 DOMAIN_MISMATCH, ISO_MISMATCH, // set to "cart sys"
RandomFields/src/init.others.cc:		 false, PARAM_DEP, INFDIM-1, (ext_bool) false, MON_MISMATCH);
RandomFields/src/init.others.cc:    IncludeModel("setDistr", RandomType, 1, 1, 1, NULL, 
RandomFields/src/init.others.cc:		 DOMAIN_MISMATCH, ISO_MISMATCH,
RandomFields/src/init.others.cc:		 true, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP, MON_MISMATCH);
RandomFields/src/init.others.cc:    IncludeModel("loc", RandomType, 1, 1, 3, kappa_loc, 
RandomFields/src/init.others.cc:		 DOMAIN_MISMATCH, ISO_MISMATCH,  // set to "cart sys"
RandomFields/src/init.others.cc:		 false, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP, MON_MISMATCH);
RandomFields/src/init.others.cc:  MCMC =
RandomFields/src/init.others.cc:    IncludeModel("mcmc", RandomType, 1, 1, 6, kappa_mcmc, 
RandomFields/src/init.others.cc:		 // ACHTUNG! Model kann auch ueber cov->q uebergeben werden.
RandomFields/src/init.others.cc:		DOMAIN_MISMATCH, ISO_MISMATCH, // set to "cart sys"
RandomFields/src/init.others.cc:		false, PARAM_DEP,  INFDIM-1, (ext_bool) true, MON_MISMATCH);
RandomFields/src/init.others.cc:  kappanames(distr[RECT_MCMC_N], INTSXP,  "sigma", REALSXP, 
RandomFields/src/init.others.cc:    IncludeModel("rectangular", RandomType, 1, 1, 11, NULL, 
RandomFields/src/init.others.cc:		 // ACHTUNG! Model kann auch ueber cov->q uebergeben werden.
RandomFields/src/init.others.cc:		 DOMAIN_MISMATCH, ISO_MISMATCH, // set to "cart sys"
RandomFields/src/init.others.cc:		 false, PARAM_DEP,  INFDIM-1, (ext_bool) true, MON_MISMATCH);
RandomFields/src/init.others.cc:  kappanames(distr[RECT_SAFETY], REALSXP, distr[RECT_MINSTEPLENGTH], REALSXP,
RandomFields/src/init.others.cc:	     distr[RECT_MAXSTEPS], INTSXP, distr[RECT_PARTS], INTSXP, 
RandomFields/src/init.others.cc:	     distr[RECT_MAXIT], INTSXP, distr[RECT_INNERMIN], REALSXP,
RandomFields/src/init.others.cc:	     distr[RECT_OUTERMAX], REALSXP, distr[RECT_MCMC_N], INTSXP,
RandomFields/src/init.others.cc:    IncludeModel("spheric", RandomType, 0, 0, 3, NULL,
RandomFields/src/init.others.cc:		 DOMAIN_MISMATCH, ISO_MISMATCH, // set to "cart sys"
RandomFields/src/init.others.cc:		 false, 1, 1, (ext_bool) true, MON_MISMATCH);
RandomFields/src/init.others.cc:  UNIF = IncludeModel("unif", RandomType, 0, 0, 3, kappa_unif, 
RandomFields/src/init.others.cc:		      DOMAIN_MISMATCH, ISO_MISMATCH, // set to "cart sys"
RandomFields/src/init.others.cc:		      false, PARAM_DEP,  INFDIM-1, (ext_bool) true, MON_MISMATCH);
RandomFields/src/init.others.cc:  MCMC_PGS =
RandomFields/src/init.others.cc:    IncludeModel("MCMC_PGS", PointShapeType, 2, 2, 5, NULL, 
RandomFields/src/init.others.cc:		 true, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP, MON_MISMATCH);
RandomFields/src/init.others.cc:  RandomShape(SUBMODEL_DEP, struct_mcmc_pgs, init_mcmc_pgs, 
RandomFields/src/init.others.cc:    IncludeModel("zhou", PointShapeType, 2, 2, 5, NULL, 
RandomFields/src/init.others.cc:		 true, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP, MON_MISMATCH);
RandomFields/src/init.others.cc:  RandomShape(SUBMODEL_DEP, struct_Zhou, init_Zhou, 
RandomFields/src/init.others.cc:    IncludeModel("ballani", PointShapeType, 2, 2, 5, NULL, 
RandomFields/src/init.others.cc:		 true, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP, MON_MISMATCH);
RandomFields/src/init.others.cc:  RandomShape(SUBMODEL_DEP, struct_Ballani, init_Ballani, 
RandomFields/src/init.others.cc:    IncludeModel("standardShape", PointShapeType, 1, 2, 0, NULL, 
RandomFields/src/init.others.cc:		 true, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP, MON_MISMATCH);
RandomFields/src/init.others.cc:  RandomShape(SUBMODEL_DEP, struct_standard_shape, init_standard_shape, 
RandomFields/src/init.others.cc:  //           CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.others.cc:   MPPPLUS =
RandomFields/src/init.others.cc:    IncludeModel("++",  PointShapeType, 1, MAXSUB, 1, kappamppplus, 
RandomFields/src/init.others.cc:		 PREVMODEL_D, PREVMODEL_I, // CARTESIAN_COORD,
RandomFields/src/init.others.cc:		 false, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP, 
RandomFields/src/init.others.cc:		 MON_MISMATCH);
RandomFields/src/init.others.cc:    IncludeModel("statShape", PointShapeType, 1, 1, 0, NULL, 
RandomFields/src/init.others.cc:		 true, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.others.cc:		 MON_MISMATCH);
RandomFields/src/init.others.cc:  RandomShape(SUBMODEL_DEP, // treated as if arbitrary
RandomFields/src/init.others.cc:  SIMULATE =
RandomFields/src/init.others.cc:    IncludeModel("Simulate", InterfaceType, 1, 1, 3, NULL, 
RandomFields/src/init.others.cc:		 XONLY, PARAMDEP_I, //UNREDUCED, 
RandomFields/src/init.others.cc:		 INTERN_SHOW, SUBMODEL_DEP, SUBMODEL_DEP,
RandomFields/src/init.others.cc:		 (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.others.cc:		 MON_MISMATCH);
RandomFields/src/init.others.cc:    IncludeModel("Covariance", InterfaceType, 1, 1, 0, NULL, XONLY, PARAMDEP_I,
RandomFields/src/init.others.cc:		 INTERN_SHOW, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.others.cc:		 MON_MISMATCH);
RandomFields/src/init.others.cc:  COVMATRIX = 
RandomFields/src/init.others.cc:    IncludeModel("CovMatrix", InterfaceType, 1, 1, 0, NULL, XONLY, PARAMDEP_I,
RandomFields/src/init.others.cc:		 INTERN_SHOW, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.others.cc:		 MON_MISMATCH);
RandomFields/src/init.others.cc:  addCov(CovMatrix);
RandomFields/src/init.others.cc:  DUMMY =
RandomFields/src/init.others.cc:    IncludeModel("Dummy", InterfaceType, 1, 1, 0, NULL, XONLY, PREVMODEL_I,
RandomFields/src/init.others.cc:	       true, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.others.cc:	       MON_MISMATCH);
RandomFields/src/init.others.cc:    IncludeModel("get", InterfaceType, 1, 1, 2, NULL, XONLY, UNREDUCED,
RandomFields/src/init.others.cc:		 true, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.others.cc:		 MON_MISMATCH);  
RandomFields/src/init.others.cc:  IncludeModel("Fctn", InterfaceType, 1, 1, 0, NULL, XONLY, UNREDUCED, 
RandomFields/src/init.others.cc:	       true, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.others.cc:	       MON_MISMATCH);
RandomFields/src/init.others.cc:  IncludeModel("Distr", InterfaceType, 1, 1, 5, kappa_EvalDistr,
RandomFields/src/init.others.cc:	       true, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.others.cc:	       MON_MISMATCH);
RandomFields/src/init.others.cc:  IncludeModel("loglikelihood", InterfaceType, 1, 1, 4, kappalikelihood, 
RandomFields/src/init.others.cc:	       XONLY, PARAMDEP_I, check_likelihood, range_likelihood,PREF_AUX, 
RandomFields/src/init.others.cc:	       INTERN_SHOW, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool)SUBMODEL_DEP,
RandomFields/src/init.others.cc:	       MON_MISMATCH);
RandomFields/src/init.others.cc:  IncludeModel("linearpart", InterfaceType, 1, 1, 0, NULL,
RandomFields/src/init.others.cc:	       true, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.others.cc:	       MON_MISMATCH);
RandomFields/src/init.others.cc:    IncludeModel("predict", InterfaceType, 2, 2, 5, kappapredict, 
RandomFields/src/init.others.cc:		 XONLY, PARAMDEP_I,check_predict, range_predict, PREF_AUX, 
RandomFields/src/init.others.cc:		 true, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.others.cc:		 MON_MISMATCH);
RandomFields/src/init.others.cc:	     //	     , INTERNAL_PARAM, INTSXP, INTERNAL_PARAM, INTSXP
RandomFields/src/init.others.cc:  IncludeModel("Pseudovariogram", InterfaceType, 1, 1, 1, NULL, 
RandomFields/src/init.others.cc:	       XONLY, PARAMDEP_I, check_pseudovario, range_pseudovario,
RandomFields/src/init.others.cc:	       INTERN_SHOW, SUBMODEL_DEP, SUBMODEL_DEP,
RandomFields/src/init.others.cc:	       (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.others.cc:	       MON_MISMATCH);
RandomFields/src/init.others.cc:  kappanames(INTERNAL_PARAM, REALSXP);
RandomFields/src/init.others.cc:  IncludeModel("Pseudomadogram", InterfaceType, 1, 1, 1, NULL, 
RandomFields/src/init.others.cc:	       XONLY, PARAMDEP_I, check_pseudomado, range_pseudomado,
RandomFields/src/init.others.cc:	       INTERN_SHOW, SUBMODEL_DEP, SUBMODEL_DEP,
RandomFields/src/init.others.cc:	       (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.others.cc:	       MON_MISMATCH);
RandomFields/src/init.others.cc:  IncludeModel("Madogram", InterfaceType, 1, 1, 1, NULL, 
RandomFields/src/init.others.cc:	       XONLY, PARAMDEP_I, check_pseudomado, range_pseudomado, PREF_AUX, 
RandomFields/src/init.others.cc:	       INTERN_SHOW, SCALAR, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.others.cc:	       MON_MISMATCH);
RandomFields/src/init.others.cc:  VARIOGRAM_CALL = // ALWAYS WITHIN FUNCTION WITHOUT GENUINE I NIT
RandomFields/src/init.others.cc:    IncludeModel("Variogram", InterfaceType, 1, 1, 0, NULL, 
RandomFields/src/init.others.cc:		 XONLY, PARAMDEP_I, check_vario, NULL, PREF_AUX, 
RandomFields/src/init.others.cc:		 INTERN_SHOW, SUBMODEL_DEP, SUBMODEL_DEP,
RandomFields/src/init.others.cc:		 (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.others.cc:		 MON_MISMATCH);
RandomFields/src/init.others.cc:    IncludeModel("Density", InterfaceType, 1, 1, 3, NULL, 
RandomFields/src/init.others.cc:	       true, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP, MON_MISMATCH);
RandomFields/src/init.others.cc:  // processes  //        CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.others.cc:    = IncludeModel("$proc", ProcessType,		   
RandomFields/src/init.others.cc:		   true, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.others.cc:		   MON_SUB_DEP);
RandomFields/src/init.others.cc:  AddVariant(GaussMethodType, UNREDUCED);
RandomFields/src/init.others.cc:    IncludeModel("plusproc", ProcessType, 1, MAXSUB, 1, NULL, 
RandomFields/src/init.others.cc:		 true, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.others.cc:		 MON_SUB_DEP);
RandomFields/src/init.others.cc:  AddVariant(GaussMethodType, UNREDUCED);
RandomFields/src/init.others.cc:  IncludeModel("prodproc", ProcessType, 1, 1, 0, NULL, 
RandomFields/src/init.others.cc:	       true, PARAM_DEP, INFDIM-1, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.others.cc:  AddVariant(GaussMethodType, UNREDUCED);
RandomFields/src/init.others.cc:  IncludeModel("trafoproc", ProcessType, 1, 1, 1, kappatrafo, 
RandomFields/src/init.others.cc:	       true, PARAM_DEP, INFDIM-1, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.others.cc:  AddVariant(GaussMethodType, UNREDUCED);
RandomFields/src/init.others.cc:  MPPPLUS_PROC =
RandomFields/src/init.others.cc:  IncludeModel("mppplusproc", ProcessType, 1, MAXSUB, 1, kappamppplus, 
RandomFields/src/init.others.cc:		 true, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.others.cc:	       MON_SUB_DEP);
RandomFields/src/init.others.cc:  // addSpecific(MPPPLUS);
RandomFields/src/init.others.cc:  MULT_PROC =  // also ok for distances??
RandomFields/src/init.others.cc:    IncludeModel("multproc", ProcessType, 1, MAXSUB, 1, NULL, 
RandomFields/src/init.others.cc:	       true, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.others.cc:	       MON_SUB_DEP);
RandomFields/src/init.others.cc:  addSpecific(MULT);
RandomFields/src/init.others.cc:  AddVariant(GaussMethodType, UNREDUCED);
RandomFields/src/init.others.cc:  M_PROC = // also ok for distances??
RandomFields/src/init.others.cc:    IncludeModelR("matrixproc", ProcessType, 1, MAXSUB, 2, kappaM,
RandomFields/src/init.others.cc:		  checkM, rangeM, PREF_ALL, 
RandomFields/src/init.others.cc:		  true, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.others.cc:		  MON_SUB_DEP);
RandomFields/src/init.others.cc:  addSpecific(MATRIX);
RandomFields/src/init.others.cc:  RandomShape(2, structMproc, initMproc, doMproc, false, false, true);
RandomFields/src/init.others.cc:  AddVariant(GaussMethodType, UNREDUCED);
RandomFields/src/init.others.cc:  IncludeModel("covproc", ProcessType, 1, MAXSUB, 2, NULL, 
RandomFields/src/init.others.cc:	       true, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.others.cc:	       MON_SUB_DEP);
RandomFields/src/init.others.cc:  addSpecific(VARIOGRAM2COV);
RandomFields/src/init.others.cc:  AddVariant(GaussMethodType, UNREDUCED);
RandomFields/src/init.others.cc:    IncludeModel(METHOD_NAMES[Shapefctproc], ProcessType, 
RandomFields/src/init.others.cc:		 false, SUBMODEL_DEP, INFDIM-1, (ext_bool) false,
RandomFields/src/init.others.cc:		 MON_MISMATCH);
RandomFields/src/init.others.cc:  AddVariant(GaussMethodType, UNREDUCED);
RandomFields/src/init.others.cc:    IncludeModelR(METHOD_NAMES[Average], GaussMethodType, 1, 2, 3, kappaGProc, 
RandomFields/src/init.others.cc:		 false, SCALAR, MAXMPPDIM, (ext_bool) false, MON_MISMATCH);
RandomFields/src/init.others.cc:  change_sortof(GAUSS_BOXCOX, ANYPARAM);
RandomFields/src/init.others.cc:  //  change_typeof(RANDOMCOIN_INTENSITY, RandomType);
RandomFields/src/init.others.cc:  RANDOMCOIN_USER = CopyModel(METHOD_NAMES[RandomCoin], AVERAGE_USER);
RandomFields/src/init.others.cc:  AVERAGE_INTERN =  CopyModel("averageIntern", AVERAGE_USER);
RandomFields/src/init.others.cc:  addSpecific(RANDOMCOIN_USER, false);
RandomFields/src/init.others.cc:  CIRCEMBED = // und die anderen fehlen auch noch !!
RandomFields/src/init.others.cc:    IncludeModelR(METHOD_NAMES[CircEmbed], GaussMethodType, 1, 1, 13, kappa_ce,
RandomFields/src/init.others.cc:		 false, SUBMODEL_DEP, MAXCEDIM, (ext_bool) false, MON_MISMATCH);
RandomFields/src/init.others.cc:	     CE[CE_FORCE - COMMON_GAUSS - 1], INTSXP,
RandomFields/src/init.others.cc:	     CE[CE_MMIN - COMMON_GAUSS - 1], REALSXP, 
RandomFields/src/init.others.cc:	     CE[CE_STRATEGY - COMMON_GAUSS - 1], INTSXP, 
RandomFields/src/init.others.cc:	     CE[CE_MAXGB - COMMON_GAUSS - 1], REALSXP,
RandomFields/src/init.others.cc:	     CE[CE_MAXMEM - COMMON_GAUSS - 1], INTSXP,
RandomFields/src/init.others.cc:	     CE[CE_TOLIM - COMMON_GAUSS - 1], REALSXP, 
RandomFields/src/init.others.cc:	     CE[CE_TOLRE - COMMON_GAUSS - 1], REALSXP,
RandomFields/src/init.others.cc:	     CE[CE_TRIALS - COMMON_GAUSS - 1], INTSXP, 
RandomFields/src/init.others.cc:	     CE[CE_USEPRIMES - COMMON_GAUSS - 1], INTSXP, 
RandomFields/src/init.others.cc:	     CE[CE_DEPENDENT - COMMON_GAUSS - 1], INTSXP,
RandomFields/src/init.others.cc:	     CE[CE_APPROXSTEP - COMMON_GAUSS - 1], REALSXP, 
RandomFields/src/init.others.cc:	     CE[CE_APPROXMAXGRID - COMMON_GAUSS - 1], INTSXP);
RandomFields/src/init.others.cc:  change_sortof(GAUSS_BOXCOX, ANYPARAM);
RandomFields/src/init.others.cc:    IncludeModelR(METHOD_NAMES[CircEmbedCutoff], GaussMethodType, 1, 1, 15, 
RandomFields/src/init.others.cc:		 false, SCALAR, MAXCEDIM,  (ext_bool) false, MON_MISMATCH);
RandomFields/src/init.others.cc:	     CE[CE_FORCE - COMMON_GAUSS - 1], INTSXP, 
RandomFields/src/init.others.cc:	     CE[CE_MMIN - COMMON_GAUSS - 1], REALSXP, 
RandomFields/src/init.others.cc:	     CE[CE_STRATEGY - COMMON_GAUSS - 1], INTSXP, 
RandomFields/src/init.others.cc:	     CE[CE_MAXGB - COMMON_GAUSS - 1], REALSXP,
RandomFields/src/init.others.cc:	     CE[CE_MAXMEM - COMMON_GAUSS - 1], INTSXP,
RandomFields/src/init.others.cc:	     CE[CE_TOLIM - COMMON_GAUSS - 1], REALSXP,
RandomFields/src/init.others.cc:	     CE[CE_TOLRE - COMMON_GAUSS - 1], REALSXP,
RandomFields/src/init.others.cc:	     CE[CE_TRIALS - COMMON_GAUSS - 1], INTSXP,
RandomFields/src/init.others.cc:	     CE[CE_USEPRIMES - COMMON_GAUSS - 1], INTSXP, 
RandomFields/src/init.others.cc:	     CE[CE_DEPENDENT - COMMON_GAUSS - 1], INTSXP,
RandomFields/src/init.others.cc:	     CE[CE_APPROXSTEP - COMMON_GAUSS - 1], REALSXP, 
RandomFields/src/init.others.cc:	     CE[CE_APPROXMAXGRID - COMMON_GAUSS - 1], INTSXP,
RandomFields/src/init.others.cc:  change_sortof(GAUSS_BOXCOX, ANYPARAM);
RandomFields/src/init.others.cc:  CE_CUTOFFPROC_INTERN = CopyModel("cutoffIntern", CE_CUTOFFPROC_USER);
RandomFields/src/init.others.cc:    IncludeModelR(METHOD_NAMES[CircEmbedIntrinsic], GaussMethodType, 
RandomFields/src/init.others.cc:		 false, SCALAR, MAXCEDIM, (ext_bool) false, MON_MISMATCH);
RandomFields/src/init.others.cc:  nickname(METHOD_NAMES[CircEmbedIntrinsic]);
RandomFields/src/init.others.cc:	     CE[CE_FORCE - COMMON_GAUSS - 1], INTSXP, 
RandomFields/src/init.others.cc:	     CE[CE_MMIN - COMMON_GAUSS - 1], REALSXP, 
RandomFields/src/init.others.cc:	     CE[CE_STRATEGY - COMMON_GAUSS - 1], INTSXP, 
RandomFields/src/init.others.cc:	     CE[CE_MAXGB - COMMON_GAUSS - 1], REALSXP,
RandomFields/src/init.others.cc:	     CE[CE_MAXMEM - COMMON_GAUSS - 1], INTSXP,
RandomFields/src/init.others.cc:	     CE[CE_TOLIM - COMMON_GAUSS - 1], REALSXP, 
RandomFields/src/init.others.cc:	     CE[CE_TOLRE - COMMON_GAUSS - 1], REALSXP,
RandomFields/src/init.others.cc:	     CE[CE_TRIALS - COMMON_GAUSS - 1], INTSXP, 
RandomFields/src/init.others.cc:	     CE[CE_USEPRIMES - COMMON_GAUSS - 1], INTSXP, 
RandomFields/src/init.others.cc:	     CE[CE_DEPENDENT - COMMON_GAUSS - 1], INTSXP, 
RandomFields/src/init.others.cc:	     CE[CE_APPROXSTEP - COMMON_GAUSS - 1], REALSXP, 
RandomFields/src/init.others.cc:	     CE[CE_APPROXMAXGRID - COMMON_GAUSS - 1], INTSXP,
RandomFields/src/init.others.cc:  change_sortof(GAUSS_BOXCOX, ANYPARAM);
RandomFields/src/init.others.cc:  CE_INTRINPROC_INTERN = CopyModel("intrinsIntern", CE_INTRINPROC_USER);
RandomFields/src/init.others.cc:    IncludeModelR(METHOD_NAMES[Direct], GaussMethodType, 
RandomFields/src/init.others.cc:		 1, 1, 1, kappaGProc, XONLY, PARAMDEP_I,
RandomFields/src/init.others.cc:		 false,  SUBMODEL_DEP, INFDIM-1, (ext_bool) false,
RandomFields/src/init.others.cc:		 MON_MISMATCH);
RandomFields/src/init.others.cc:  change_sortof(GAUSS_BOXCOX, ANYPARAM);
RandomFields/src/init.others.cc:  addTypeFct(TypeGaussMethod);
RandomFields/src/init.others.cc:    IncludeModelR(METHOD_NAMES[Hyperplane], GaussMethodType, 1, 1, 6, kappaGProc,
RandomFields/src/init.others.cc:		 false, SCALAR, 2, (ext_bool) false, MON_MISMATCH);
RandomFields/src/init.others.cc:  change_sortof(GAUSS_BOXCOX, ANYPARAM);
RandomFields/src/init.others.cc:    CopyModel("hyperIntern", HYPERPLANE_USER, check_hyperplane_intern);
RandomFields/src/init.others.cc:    IncludeModelR(METHOD_NAMES[Nugget], GaussMethodType, 
RandomFields/src/init.others.cc:		 1, 1, 3, kappaGProc, XONLY, PARAMDEP_I,
RandomFields/src/init.others.cc:		 PREVMODEL_DEP, INFDIM, (ext_bool) true, MON_MISMATCH);
RandomFields/src/init.others.cc:  change_sortof(GAUSS_BOXCOX, ANYPARAM);
RandomFields/src/init.others.cc:  addTypeFct(TypeGaussMethod);
RandomFields/src/init.others.cc:  NUGGET_INTERN = CopyModel("nuggetIntern", NUGGET_USER);
RandomFields/src/init.others.cc:  /* see simu.cc, CMbuild for special treatment of nugget when
RandomFields/src/init.others.cc:  /* cf. convert.R, PrepareModel, near end of function */
RandomFields/src/init.others.cc:    IncludeModelR(METHOD_NAMES[Sequential], GaussMethodType, 1, 1, 3,
RandomFields/src/init.others.cc:		 false, SCALAR, INFDIM-1, (ext_bool) false, MON_MISMATCH);
RandomFields/src/init.others.cc:  change_sortof(GAUSS_BOXCOX, ANYPARAM);
RandomFields/src/init.others.cc:    IncludeModelR(METHOD_NAMES[SpectralTBM], GaussMethodType,  1, 1, 5,
RandomFields/src/init.others.cc:		 false, SCALAR, MAXTBMSPDIM, (ext_bool) false, MON_MISMATCH);
RandomFields/src/init.others.cc:  change_sortof(GAUSS_BOXCOX, ANYPARAM);
RandomFields/src/init.others.cc:  SPECTRAL_PROC_INTERN = CopyModel("spectralIntern", SPECTRAL_PROC_USER);
RandomFields/src/init.others.cc:    IncludeModelR(METHOD_NAMES[Specific], GaussMethodType, 1, 1, 1, kappaGProc,
RandomFields/src/init.others.cc:		 false, SUBMODEL_DEP, MAXTBMSPDIM, (ext_bool) false,
RandomFields/src/init.others.cc:		 MON_MISMATCH);
RandomFields/src/init.others.cc:  change_sortof(GAUSS_BOXCOX, ANYPARAM);
RandomFields/src/init.others.cc:  TBM_PROC_USER = 
RandomFields/src/init.others.cc:    IncludeModelR(METHOD_NAMES[TBM], GaussMethodType,  1, 1, 9, tbm_kappasproc, 
RandomFields/src/init.others.cc:		 false, PARAM_DEP, SUBMODEL_DEP, (ext_bool) false,
RandomFields/src/init.others.cc:		 MON_MISMATCH);
RandomFields/src/init.others.cc:  change_sortof(GAUSS_BOXCOX, ANYPARAM);
RandomFields/src/init.others.cc:  change_sortof(TBM_LAYERS, ONLYRETURN); // NA will not be estimated
RandomFields/src/init.others.cc:  TBM_PROC_INTERN = CopyModel("tbmIntern", TBM_PROC_USER);
RandomFields/src/init.others.cc:  addSpecific(TBM_PROC_USER);
RandomFields/src/init.others.cc:  gaussmethod[CircEmbed] = CIRCEMBED;
RandomFields/src/init.others.cc:  gaussmethod[TBM] = TBM_PROC_INTERN;
RandomFields/src/init.others.cc:  gaussmethod[SpectralTBM] = SPECTRAL_PROC_INTERN;
RandomFields/src/init.others.cc:  gaussmethod[Nothing] =  gaussmethod[Forbidden] = MISMATCH;
RandomFields/src/init.others.cc:  BRNORMED =
RandomFields/src/init.others.cc:    IncludeModel("loggaussnormed", NormedProcessType, 1, 1, 5, kappabrnormed, 
RandomFields/src/init.others.cc:		 false, SUBMODEL_DEP, MAXMPPDIM, (ext_bool) false,
RandomFields/src/init.others.cc:		 MON_MISMATCH);
RandomFields/src/init.others.cc:  //RandomShape(SUBMODEL_DEP, struct_brnormed, init_brnormed, // 2.2.19
RandomFields/src/init.others.cc:    IncludeModel("brorig", BrMethodType, 1, 2, 3, NULL, 
RandomFields/src/init.others.cc:		 false, SCALAR, MAXMPPDIM, (ext_bool) false, MON_MISMATCH);
RandomFields/src/init.others.cc:    CopyModel("brorigIntern", BRORIGINAL_USER, PointShapeType);
RandomFields/src/init.others.cc:  RandomShape(SUBMODEL_DEP, structBRintern, init_BRorig, do_BRorig);
RandomFields/src/init.others.cc:  BRMIXED_USER =
RandomFields/src/init.others.cc:    IncludeModel("brmixed", BrMethodType, 1, 2, 10, kappaBRmixed, 
RandomFields/src/init.others.cc:		 false, SUBMODEL_DEP, MAXMPPDIM, (ext_bool) false,
RandomFields/src/init.others.cc:		 MON_MISMATCH);
RandomFields/src/init.others.cc:  BRMIXED_INTERN =
RandomFields/src/init.others.cc:    CopyModel("brmixedIntern", BRMIXED_USER, PointShapeType); 
RandomFields/src/init.others.cc:  RandomShape(SUBMODEL_DEP, structBRintern, init_BRmixed, do_BRmixed);
RandomFields/src/init.others.cc:    IncludeModel("brshifted", BrMethodType, 
RandomFields/src/init.others.cc:		 false, SCALAR, MAXMPPDIM, (ext_bool) false, MON_MISMATCH);
RandomFields/src/init.others.cc:    CopyModel("brshiftIntern", BRSHIFTED_USER, PointShapeType); 
RandomFields/src/init.others.cc:  RandomShape(SUBMODEL_DEP, structBRintern, init_BRshifted, do_BRshifted);
RandomFields/src/init.others.cc:    IncludeModel(BR_NAME, BrMethodType, // ProcessType
RandomFields/src/init.others.cc:		 false, SCALAR, MAXMPPDIM, (ext_bool) false, MON_MISMATCH);
RandomFields/src/init.others.cc:    IncludeModelR("binaryprocess", NormedProcessType, 1, 1, 3,
RandomFields/src/init.others.cc:		 kappa_binaryprocess, XONLY, PARAMDEP_I,
RandomFields/src/init.others.cc:		 false, SUBMODEL_DEP, INFDIM, (ext_bool) false, MON_MISMATCH);
RandomFields/src/init.others.cc:  kappanames(INTERNAL_PARAM, REALSXP, "stationary_only", 
RandomFields/src/init.others.cc:    IncludeModelR("gauss.process", GaussMethodType, // formerly Processtype
RandomFields/src/init.others.cc:		 1, 1, 2, kappaGProc, XONLY, PARAMDEP_I,
RandomFields/src/init.others.cc:		 false, SUBMODEL_DEP, INFDIM, (ext_bool) false, MON_MISMATCH);
RandomFields/src/init.others.cc:  change_sortof(GAUSS_BOXCOX, ANYPARAM);
RandomFields/src/init.others.cc:  addTypeFct(TypeGaussMethod);
RandomFields/src/init.others.cc:    IncludeModel("poisson", PoissonType, 1, 2, 2, NULL,
RandomFields/src/init.others.cc:		 false, SUBMODEL_DEP, MAXMPPDIM, (ext_bool) false,
RandomFields/src/init.others.cc:		 MON_MISMATCH);
RandomFields/src/init.others.cc:    IncludeModel("extremalgauss", SchlatherType, 1, 2, 3, NULL, 
RandomFields/src/init.others.cc:		 false, SCALAR, INFDIM, (ext_bool) false, MON_MISMATCH);
RandomFields/src/init.others.cc:  nickname(EG_NAME);
RandomFields/src/init.others.cc:  EXTREMALTPROC =
RandomFields/src/init.others.cc:    IncludeModel("extremalt", SchlatherType, 1, 1, 4, NULL, 
RandomFields/src/init.others.cc:		 false, SCALAR, INFDIM, (ext_bool) false, MON_MISMATCH);
RandomFields/src/init.others.cc:  nickname(OPITZ_NAME);
RandomFields/src/init.others.cc:  SMITHPROC =
RandomFields/src/init.others.cc:    IncludeModel(SMITH_NAME, SmithType, 1, 2, 3, NULL, XONLY, UNREDUCED,
RandomFields/src/init.others.cc:		 false, SCALAR, MAXMPPDIM, (ext_bool) false, MON_MISMATCH);
RandomFields/src/init.others.cc:  //  change_typeof(SMITH_INTENSITY, RandomType);
RandomFields/src/init.others.cc:    IncludeModelR("chi2", ProcessType, 1, 1, 2, kappaGProc, XONLY, UNREDUCED,
RandomFields/src/init.others.cc:		 false, SUBMODEL_DEP, INFDIM, (ext_bool) false, MON_MISMATCH);
RandomFields/src/init.others.cc:  change_sortof(GAUSS_BOXCOX, ANYPARAM);
RandomFields/src/init.others.cc:    IncludeModelR("t", ProcessType, 1, 1, 2, kappaGProc, XONLY, UNREDUCED,
RandomFields/src/init.others.cc:		 false, SUBMODEL_DEP, INFDIM, (ext_bool) false, MON_MISMATCH);
RandomFields/src/init.others.cc:  change_sortof(GAUSS_BOXCOX, ANYPARAM);
RandomFields/src/kleinkram.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/kleinkram.cc: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/src/kleinkram.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/kleinkram.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/kleinkram.cc://const char *RTYPE_NAMES[LAST_R_TYPE_NAME + 1] = {
RandomFields/src/kleinkram.cc:const char *RTYPE_NAMES[LAST_R_TYPE_NAME + 1] = {
RandomFields/src/kleinkram.cc:  "SYMSXP", "LISTSXP", "CLOSXP", "ENVSXP", "PROMSXP",
RandomFields/src/kleinkram.cc:#pragma omp parallel for num_threads(CORES) if (MULTIMINSIZE(ncol)) schedule(dynamic, 20)
RandomFields/src/kleinkram.cc:    MEMCOPY(y, x, sizeof(double) * nrow);
RandomFields/src/kleinkram.cc:    MEMCOPY(y, x, sizeof(double) * nrow);
RandomFields/src/kleinkram.cc:#pragma omp parallel for num_threads(CORES) if (MULTIMINSIZE(ncol) && MULTIMINSIZE(nrow))
RandomFields/src/kleinkram.cc:    MEMCOPY(y1, x1, sizeof(double) * nrow);
RandomFields/src/kleinkram.cc:    MEMCOPY(y2, x2, sizeof(double) * nrow);
RandomFields/src/kleinkram.cc:#pragma omp parallel for num_threads(CORES) reduction(+:sum) if (MULTIMINSIZE(nrow) && MULTIMINSIZE(nrow))
RandomFields/src/kleinkram.cc:    MEMCOPY(y, x, sizeof(double) * nrow);
RandomFields/src/kleinkram.cc:#pragma omp parallel for num_threads(CORES) if (MULTIMINSIZE(ncol) && MULTIMINSIZE(nrow))
RandomFields/src/kleinkram.cc:    MEMCOPY(y1, x1, sizeof(double) * nrow);
RandomFields/src/kleinkram.cc:    MEMCOPY(y2, x2, sizeof(double) * nrow);
RandomFields/src/kleinkram.cc:    *dummy = (double*) MALLOC(sizeof(double) * size); // dummy = XC
RandomFields/src/kleinkram.cc:  int    dimM1 = dim - 1;
RandomFields/src/kleinkram.cc:#pragma omp parallel for num_threads(CORES) if (MULTIMINSIZE(dim)) reduction(+:xVy) 
RandomFields/src/kleinkram.cc:    for (j += dimM1; i<dim; i++, j+=dim) dummy += x[i] * U[j];
RandomFields/src/kleinkram.cc:  int   dimM1 = dim - 1;
RandomFields/src/kleinkram.cc:#pragma omp parallel for num_threads(CORES) if (MULTIMINSIZE(dim))
RandomFields/src/kleinkram.cc:    for (j += dimM1; i<dim; i++, j+=dim) dummy += x[i] * U[j];
RandomFields/src/kleinkram.cc:  int dimM1 = dim - 1;
RandomFields/src/kleinkram.cc:    for (j += dimM1; i<dim; i++, j+=dim) dummy += x[i] * U[j];
RandomFields/src/kleinkram.cc:  int    dimM1 = dim - 1;
RandomFields/src/kleinkram.cc:    for (j += dimM1; i<dim; i++, j+=dim) dummy += x[i] * U[j];
RandomFields/src/kleinkram.cc:  double *m0 = (double*) MALLOC(sizeof(double) * dim1 * dim3);
RandomFields/src/kleinkram.cc:SEXP Mat(double* V, int row, int col, int max) {
RandomFields/src/kleinkram.cc:  if (V==NULL) return allocMatrix(REALSXP, 0, 0);
RandomFields/src/kleinkram.cc:  PROTECT(dummy=allocMatrix(REALSXP, row, col));
RandomFields/src/kleinkram.cc:SEXP Mat(double* V, int row, int col) {
RandomFields/src/kleinkram.cc:  return Mat(V, row, col, MAXINT);
RandomFields/src/kleinkram.cc:SEXP Mat_t(double* V, int row, int col, int max) {
RandomFields/src/kleinkram.cc:  if (V==NULL) return allocMatrix(REALSXP, 0, 0);
RandomFields/src/kleinkram.cc:  PROTECT(dummy=allocMatrix(REALSXP, row, col));
RandomFields/src/kleinkram.cc:SEXP Mat_t(double* V, int row, int col) {
RandomFields/src/kleinkram.cc:  return Mat_t(V, row, col, MAXINT);
RandomFields/src/kleinkram.cc:SEXP MatString(char **V, int row, int col, int max) {
RandomFields/src/kleinkram.cc:  if (V==NULL) return allocMatrix(STRSXP, 0, 0);
RandomFields/src/kleinkram.cc:  PROTECT(dummy=allocMatrix(STRSXP, row, col));
RandomFields/src/kleinkram.cc:SEXP MatString(char** V, int row, int col) {
RandomFields/src/kleinkram.cc:  return MatString(V, row, col, MAXINT);
RandomFields/src/kleinkram.cc:SEXP MatInt(int* V, int row, int col, int max) {
RandomFields/src/kleinkram.cc:  if (V==NULL) return allocMatrix(INTSXP, 0, 0);
RandomFields/src/kleinkram.cc:  PROTECT(dummy=allocMatrix(INTSXP, row, col));
RandomFields/src/kleinkram.cc:SEXP MatInt(int* V, int row, int col) {
RandomFields/src/kleinkram.cc:  return MatInt(V, row, col, MAXINT);
RandomFields/src/kleinkram.cc:  return Array3D(V, depth, row, col, MAXINT);
RandomFields/src/kleinkram.cc:SEXP String(char V[][MAXCHAR], int n, int max) {
RandomFields/src/kleinkram.cc:SEXP String(char V[][MAXCHAR], int n) {return String(V, n, n);}
RandomFields/src/kleinkram.cc:	   name, R_TYPE_NAME(TYPEOF(p)));  
RandomFields/src/kleinkram.cc:	   name, R_TYPE_NAME(TYPEOF(p)));
RandomFields/src/kleinkram.cc:void String(SEXP el, char *name, char names[][MAXCHAR], int maxlen) {
RandomFields/src/kleinkram.cc:      strcopyN(names[i], CHAR(STRING_ELT(el, i)), MAXCHAR);
RandomFields/src/kleinkram.cc:  num = NUM;
RandomFields/src/kleinkram.cc:  num = NUM;
RandomFields/src/kleinkram.cc:  num = NUM;
RandomFields/src/kleinkram.cc:int Match(char *name, name_type List, int n) {
RandomFields/src/kleinkram.cc:  // == NOMATCHING, -1, if no matching function is found
RandomFields/src/kleinkram.cc:  // == MULTIPLEMATCHING,-2, if multiple matching fctns are found,  
RandomFields/src/kleinkram.cc:  //  print("Match %d %d %.50s %.50s %d\n", Nr, n, name, List[Nr], ln);
RandomFields/src/kleinkram.cc:  while ( Nr < n  && STRNCMP(name, List[Nr], ln)) {
RandomFields/src/kleinkram.cc:      while ( (j<n) && STRNCMP(name, List[j], ln)) {j++;}
RandomFields/src/kleinkram.cc:    if (multiplematching) {return MULTIPLEMATCHING;}
RandomFields/src/kleinkram.cc:  } else return NOMATCHING;
RandomFields/src/kleinkram.cc:int Match(char *name, const char * List[], int n) {
RandomFields/src/kleinkram.cc:  // printf("Matching\n");
RandomFields/src/kleinkram.cc:  //    print("Matchx %d %d %.50s %.50s %d\n", Nr, n, name, List[Nr], ln);
RandomFields/src/kleinkram.cc:  while ( Nr < n  && STRNCMP(name, List[Nr], ln)) {
RandomFields/src/kleinkram.cc:      while ( (j<n) && STRNCMP(name, List[j], ln)) {j++;}
RandomFields/src/kleinkram.cc:    if (multiplematching) {return MULTIPLEMATCHING;}
RandomFields/src/kleinkram.cc:  } else return NOMATCHING;
RandomFields/src/kleinkram.cc:    RFERROR2("option '%.50s' is too lengthy. Maximum length is %d.",
RandomFields/src/kleinkram.cc:      ans[k] = Match((char*) CHAR(STRING_ELT(el, k)), List, n);
RandomFields/src/kleinkram.cc:	if (STRCMP((char*) CHAR(STRING_ELT(el, k)), " ") == 0 ||
RandomFields/src/kleinkram.cc:	    STRCMP((char*) CHAR(STRING_ELT(el, k)), "") == 0) {
RandomFields/src/kleinkram.cc:  return Mod(y, modulus) - halfmodulus;
RandomFields/src/kleinkram.cc:#ifndef RANDOMFIELDS_DEBUGGING  
Binary file RandomFields/src/NULL.o matches
Binary file RandomFields/src/gausslikeli.o matches
Binary file RandomFields/src/spectral.o matches
RandomFields/src/InternalCov.noncritical.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/InternalCov.noncritical.cc:   in RFsimu.h, since there is gno error check (e.g. initialization of RANDOM)
RandomFields/src/InternalCov.noncritical.cc: * definitions for the random coin method can be found in MPPFcts.cc
RandomFields/src/InternalCov.noncritical.cc:   SophisticatedModel.cc; hyper models also in Hypermodel.cc
RandomFields/src/InternalCov.noncritical.cc: Copyright (C) 2005 -- 2017 Martin Schlather
RandomFields/src/InternalCov.noncritical.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/InternalCov.noncritical.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/InternalCov.noncritical.cc:      else if (v > MAXINT) { BUG}
RandomFields/src/InternalCov.noncritical.cc:      else if (v < -MAXINT) { BUG}
RandomFields/src/InternalCov.noncritical.cc:      ERR2("parameter '%.50s' in '%.50s' is undefined.", KNAME(i), NAME(cov));
RandomFields/src/InternalCov.noncritical.cc:	     COVNR, NAME(cov), i, cov->nrow[i], cov->ncol[i]);
RandomFields/src/InternalCov.noncritical.cc:	   KNAME(i), NAME(cov), CONTACT);
RandomFields/src/InternalCov.noncritical.cc:  // der Modelle und Operatoren feststehen -- die Parameter unten muessen, falls
RandomFields/src/InternalCov.noncritical.cc:    n = SYSTEMS(def),
RandomFields/src/InternalCov.noncritical.cc:    last = LASTSYSTEM(def);
RandomFields/src/InternalCov.noncritical.cc:  //  printf("'%s' ----------------\n", NAME(cov)); 
RandomFields/src/InternalCov.noncritical.cc:    set_maxdim(OWN, s, MAXDIM(def, s)); 
RandomFields/src/InternalCov.noncritical.cc:  if ((C->vdim == PREVMODEL_DEP  ||  C->vdim == SUBMODEL_DEP)) {    
RandomFields/src/InternalCov.noncritical.cc:    VDIM0 = vdim0;
RandomFields/src/InternalCov.noncritical.cc:    VDIM1 = vdim1;
RandomFields/src/InternalCov.noncritical.cc:    assert(C->vdim != MISMATCH); // ???
RandomFields/src/InternalCov.noncritical.cc:    VDIM0 = VDIM1 = C->vdim;     
RandomFields/src/InternalCov.noncritical.cc:    for (int i=0; i<MAXMPPVDIM; i++) cov->mpp.maxheights[i] = 1.0; // maxv
RandomFields/src/InternalCov.noncritical.cc:  cov->monotone=C->Monotone;
RandomFields/src/InternalCov.noncritical.cc:  MEMCOPY(cov->pref, C->pref, sizeof(pref_shorttype));
RandomFields/src/InternalCov.noncritical.cc:  //for (Methods i=Nothing+1; i<Forbidden; i++) cov->pref[i] = PREF_NONE;
RandomFields/src/InternalCov.noncritical.cc://  if (val == SUBMODEL_DEP) return sub; // for Dimension
RandomFields/src/InternalCov.noncritical.cc://    //    if (*val == PARAM_DEP) {model *cov; crash(cov);}
RandomFields/src/InternalCov.noncritical.cc://    assert(val != PARAM_DEP);
RandomFields/src/InternalCov.noncritical.cc:  if (val == SUBMODEL_DEP) return sub;
RandomFields/src/InternalCov.noncritical.cc:  if (val == MON_SUB_DEP) return sub;
RandomFields/src/InternalCov.noncritical.cc:  int last = OWNLASTSYSTEM;
RandomFields/src/InternalCov.noncritical.cc:  if (last == SUBLASTSYSTEM) {
RandomFields/src/InternalCov.noncritical.cc:      //    set_maxdim(OWN, s, merge_integer(MAXDIM(OWN, s), MAXDIM(SUB, s)));
RandomFields/src/InternalCov.noncritical.cc:	 (cov->full_derivs == MISMATCH && isRandom(cov) && isRandom(sub)));
RandomFields/src/InternalCov.noncritical.cc:    if (C->vdim == SUBMODEL_DEP) {
RandomFields/src/InternalCov.noncritical.cc:      VDIM0 = sub->vdim[0];
RandomFields/src/InternalCov.noncritical.cc:      VDIM1 = sub->vdim[1];
RandomFields/src/InternalCov.noncritical.cc:int alloc_mpp_M(model *cov, int moments) {
RandomFields/src/InternalCov.noncritical.cc:  // printf("alloc %s %d max=%d==%d\n", NAME(cov), moments, maxmoments, PARAM_DEP);
RandomFields/src/InternalCov.noncritical.cc:  //  printf("maxmoments %s = %d %d %d\n", NAME(cov), maxmoments, MISMATCH, PARAM_DEP);
RandomFields/src/InternalCov.noncritical.cc:  //PMI(cov);
RandomFields/src/InternalCov.noncritical.cc:  //if (maxmoments == PARAM_DEP) crash();
RandomFields/src/InternalCov.noncritical.cc:  // PMI0(cov);
RandomFields/src/InternalCov.noncritical.cc:  assert(maxmoments != MISMATCH && maxmoments != PARAM_DEP);
RandomFields/src/InternalCov.noncritical.cc:  if (moments > maxmoments && maxmoments != SUBMODEL_DEP) {
RandomFields/src/InternalCov.noncritical.cc:  if (cov->mpp.mM != NULL) free_mpp_M(cov);
RandomFields/src/InternalCov.noncritical.cc:    vdim = VDIM0,
RandomFields/src/InternalCov.noncritical.cc:  // if (vdim > MAXMPPVDIM) SERR1("multivariate dimension (%d) too large", vdim);
RandomFields/src/InternalCov.noncritical.cc:  cov->mpp.mM = (double*) MALLOC(bytes);
RandomFields/src/InternalCov.noncritical.cc:  cov->mpp.mMplus = (double*) MALLOC(bytes);
RandomFields/src/InternalCov.noncritical.cc:  for (int i=0; i<nmvdim; i++) cov->mpp.mMplus[i] = cov->mpp.mM[i] = RF_NA;
RandomFields/src/InternalCov.noncritical.cc:    cov->mpp.mMplus[idx + 0] = cov->mpp.mM[idx + 0] = RF_INF;
RandomFields/src/InternalCov.noncritical.cc:    if (v < MAXMPPVDIM) cov->mpp.maxheights[v] = maxheight; // maxv
RandomFields/src/InternalCov.noncritical.cc:  // cov->mpp.mMplus[0] = cov->mpp.mM[0] = 1.0;
RandomFields/src/InternalCov.noncritical.cc:void free_mpp_M(model *cov) {
RandomFields/src/InternalCov.noncritical.cc:  FREE(cov->mpp.mM);
RandomFields/src/InternalCov.noncritical.cc:  FREE(cov->mpp.mMplus);
RandomFields/src/InternalCov.noncritical.cc:  cov->mpp.mM = cov->mpp.mMplus = NULL;
RandomFields/src/InternalCov.noncritical.cc:int UpdateMPPprev(model * cov, int moments) {
RandomFields/src/InternalCov.noncritical.cc:    vdim = VDIM0;
RandomFields/src/InternalCov.noncritical.cc:    if (calling->mpp.moments == SUBMODEL_DEP &&
RandomFields/src/InternalCov.noncritical.cc:	(err = alloc_mpp_M(calling, moments)) != NOERROR) RETURN_ERR(err);
RandomFields/src/InternalCov.noncritical.cc:      calling->mpp.mMplus[i] = cov->mpp.mMplus[i];
RandomFields/src/InternalCov.noncritical.cc:      calling->mpp.mM[i]     = cov->mpp.mM[i];
RandomFields/src/InternalCov.noncritical.cc:  //  printf("initialising %s\n", NAME(cov));
RandomFields/src/InternalCov.noncritical.cc:  // printf("Iintern %s = %d mom=%d, vdim=%d\n", NAME(cov), cov->mpp.moments, moments, VDIM0);
RandomFields/src/InternalCov.noncritical.cc:  if (cov->mpp.moments != SUBMODEL_DEP && cov->mpp.moments != PARAM_DEP) {
RandomFields/src/InternalCov.noncritical.cc:    if ((err = alloc_mpp_M(cov, moments)) != NOERROR) RETURN_ERR(err);
RandomFields/src/InternalCov.noncritical.cc:    if (cov->mpp.moments == PARAM_DEP) cov->mpp.moments = moments;
RandomFields/src/InternalCov.noncritical.cc:  if ((err = UpdateMPPprev(cov, moments)) != NOERROR) {
RandomFields/src/InternalCov.noncritical.cc:  // printf("returning from initialising %s without e rror.\n", NAME(cov)); // PMI0(cov);
RandomFields/src/InternalCov.noncritical.cc:  for (i=0; i<MAXPARAM; i++) {
RandomFields/src/InternalCov.noncritical.cc:  for (i=0; i<MAXSUB; i++) {
RandomFields/src/InternalCov.noncritical.cc:int INIT_RANDOM_intern(model *cov, int moments, gen_storage *s, // kein err
RandomFields/src/InternalCov.noncritical.cc:	moments > DefList[COVNR].maxmoments) SERR("Moments do not match");
RandomFields/src/InternalCov.noncritical.cc:    if (cov->mpp.moments != SUBMODEL_DEP && cov->mpp.moments != PARAM_DEP) {
RandomFields/src/InternalCov.noncritical.cc:      if ((err = alloc_mpp_M(cov, moments)) != NOERROR) RETURN_ERR(err);
RandomFields/src/InternalCov.noncritical.cc:      if (cov->mpp.moments == PARAM_DEP) cov->mpp.moments = moments;
RandomFields/src/InternalCov.noncritical.cc:    if (ISNAN(cov->mpp.mM[moments])) {
RandomFields/src/InternalCov.noncritical.cc:    if ((err = UpdateMPPprev(cov, moments)) != NOERROR) RETURN_ERR(err);
RandomFields/src/InternalCov.noncritical.cc:  if (s->dosimulate) DORANDOM(cov, p);
RandomFields/src/InternalCov.noncritical.cc:    //    dummy = (double*) MALLOC(sizeof(double) * len);
RandomFields/src/InternalCov.noncritical.cc:    //    DORANDOM(cov, dummy);
RandomFields/src/InternalCov.noncritical.cc:  //    PMI(cov->calling);
RandomFields/src/InternalCov.noncritical.cc:    TALLOC_GATTER_GLOBAL(z1, GATTERTOTALXDIM);
RandomFields/src/InternalCov.noncritical.cc:  int n = GATTERLASTSYSTEM;
RandomFields/src/InternalCov.noncritical.cc:  //  PMI0(cov);  printf("n=%d\n", n);
RandomFields/src/InternalCov.noncritical.cc:      dim = GATTERXDIM(s);
RandomFields/src/InternalCov.noncritical.cc:     //    printf("stat2 %s\n", NAME(cov));
RandomFields/src/InternalCov.noncritical.cc:      //      printf("dim = %d %s %d\n", dim, NAME(cov), trafo);
RandomFields/src/InternalCov.noncritical.cc:      if (trafo) MEMCOPY(z, x, sizeof(double) * dim); else *Z = x;
RandomFields/src/InternalCov.noncritical.cc:      if (trafo) MEMCOPY(z, x, sizeof(double) * dim); else *Z = x;
RandomFields/src/InternalCov.noncritical.cc:      int dimM1 = dim - 1;
RandomFields/src/InternalCov.noncritical.cc:      for (int d=0; d<dimM1; d++) b += x[d] * x[d];
RandomFields/src/InternalCov.noncritical.cc:      z[1] = FABS(x[dimM1]);
RandomFields/src/InternalCov.noncritical.cc:      if (trafo) MEMCOPY(z, x, sizeof(double) * dim); else *Z = x;
RandomFields/src/InternalCov.noncritical.cc:      if (trafo) MEMCOPY(z, x, sizeof(double) * dim); else *Z = x;
RandomFields/src/InternalCov.noncritical.cc:      //      PMI(cov);
RandomFields/src/InternalCov.noncritical.cc:    z += OWNXDIM(s);
RandomFields/src/InternalCov.noncritical.cc:#ifdef SCHLATHERS_MACHINE
RandomFields/src/InternalCov.noncritical.cc:      PRINTF("%s", NAME(calling));
RandomFields/src/InternalCov.noncritical.cc:    PRINTF("%s%s (%d i=%d e=%d) [INFO_TRACE]\n", NAME(cov), where,
RandomFields/src/InternalCov.noncritical.cc:  //  if (!equalsXonly(PREVDOM(0))) { PMI0(cov); crash(); }
RandomFields/src/InternalCov.noncritical.cc:  assert(equalsXonly(PREVDOM(0)));
RandomFields/src/InternalCov.noncritical.cc:  TALLOC_GATTER(z, OWNTOTALXDIM);
RandomFields/src/InternalCov.noncritical.cc:  //  if (OWNTOTALXDIM == 2)
RandomFields/src/InternalCov.noncritical.cc:  //	   (*z1)[2], x, VDIM0, OWNTOTALXDIM);
RandomFields/src/InternalCov.noncritical.cc:  //  printf("stat2: %s\n", NAME(cov));
RandomFields/src/InternalCov.noncritical.cc:  assert(equalsXonly(PREVDOM(0)));
RandomFields/src/InternalCov.noncritical.cc:  TALLOC_GATTER(z, OWNTOTALXDIM);
RandomFields/src/InternalCov.noncritical.cc:  assert(PREVDOM(0) == KERNEL);
RandomFields/src/InternalCov.noncritical.cc:  int n = GATTERLASTSYSTEM;
RandomFields/src/InternalCov.noncritical.cc:      dim = GATTERXDIM(s);
RandomFields/src/InternalCov.noncritical.cc:    //    printf("nonstat2 %s\n", NAME(cov));
RandomFields/src/InternalCov.noncritical.cc:	//	if (dim == 1) APMI(cov->calling);
RandomFields/src/InternalCov.noncritical.cc:      int dimM1 = dim - 1;
RandomFields/src/InternalCov.noncritical.cc:      for (int d=0; d<dimM1; d++) {
RandomFields/src/InternalCov.noncritical.cc:      z[1] = FABS(x[dimM1] - y[dimM1]);
RandomFields/src/InternalCov.noncritical.cc:      //      PMI(cov);
RandomFields/src/InternalCov.noncritical.cc:    z += OWNXDIM(s);
RandomFields/src/InternalCov.noncritical.cc:  //  if (PREVDOM(0) != KERNEL) {PMI0(cov); crash(); }
RandomFields/src/InternalCov.noncritical.cc:  assert(PREVDOM(0) == KERNEL);
RandomFields/src/InternalCov.noncritical.cc:      prevdim = PREVXDIM(0),
RandomFields/src/InternalCov.noncritical.cc:      xdim = GATTERTOTALXDIM;
RandomFields/src/InternalCov.noncritical.cc:  if (equalsKernel(OWNDOM(0))) {
RandomFields/src/InternalCov.noncritical.cc:    // printf("> %s ", NAME(cov));
RandomFields/src/InternalCov.noncritical.cc:    TALLOC_GATTER(z, OWNTOTALXDIM);
RandomFields/src/InternalCov.noncritical.cc:  assert(PREVDOM(0) == KERNEL);
RandomFields/src/InternalCov.noncritical.cc:    int xdim = GATTERTOTALXDIM;
RandomFields/src/InternalCov.noncritical.cc:  if (equalsKernel(OWNDOM(0))) {
RandomFields/src/InternalCov.noncritical.cc:    TALLOC_GATTER(z, OWNTOTALXDIM);
RandomFields/src/InternalCov.noncritical.cc:  int dim = GATTERXDIM(0); // frueher prevxdim
RandomFields/src/InternalCov.noncritical.cc:    if (OWNTOTALXDIM == 1) {
RandomFields/src/InternalCov.noncritical.cc:      assert(OWNTOTALXDIM == 2);
RandomFields/src/InternalCov.noncritical.cc:  int dim = GATTERXDIM(0); // frueher prevxdim
RandomFields/src/InternalCov.noncritical.cc:    //   assert(PREVTOTALXDIM == 2);
RandomFields/src/InternalCov.noncritical.cc:  int dim = GATTERXDIM(0);
RandomFields/src/InternalCov.noncritical.cc:    //   assert(PREVTOTALXDIM == 2);
RandomFields/src/InternalCov.noncritical.cc:  int dim = GATTERXDIM(0);
RandomFields/src/InternalCov.noncritical.cc:    //   assert(PREVTOTALXDIM == 2);
RandomFields/src/InternalCov.noncritical.cc:      //      PMI0(param);
RandomFields/src/InternalCov.noncritical.cc:	if ((err = INIT_RANDOM(param, 0, s, P(i))) != NOERROR) RETURN_ERR(err);
RandomFields/src/InternalCov.noncritical.cc:    case GaussMethodType :
RandomFields/src/InternalCov.noncritical.cc:      if (cov->method==SpectralTBM) {
RandomFields/src/InternalCov.noncritical.cc:    case BrMethodType: case SmithType: case SchlatherType :
RandomFields/src/InternalCov.noncritical.cc:      assert((cov->mpp.moments < 0) xor (cov->mpp.mM != NULL));
RandomFields/src/InternalCov.noncritical.cc:      // PMI0(cov);      crash();
RandomFields/src/InternalCov.noncritical.cc:      BUG; // ILLEGAL_FRAME;
RandomFields/src/InternalCov.noncritical.cc:  //    if (param != NULL && isnowRandom(param)) DORANDOM(param, P(i));
RandomFields/src/InternalCov.noncritical.cc:  assert(equalsXonly(OWNDOM(0)));
RandomFields/src/InternalCov.noncritical.cc:  int dim = PREVTOTALXDIM;
RandomFields/src/InternalCov.noncritical.cc:  TALLOC_GATTER(z, PREVTOTALXDIM);
RandomFields/src/InternalCov.noncritical.cc:  assert(equalsXonly(OWNDOM(0)));
RandomFields/src/InternalCov.noncritical.cc:  int dim = PREVTOTALXDIM;
RandomFields/src/InternalCov.noncritical.cc:  TALLOC_GATTER(z, PREVTOTALXDIM);
RandomFields/src/InternalCov.noncritical.cc:    PRINTF("%s ", NAME(cov));
RandomFields/src/InternalCov.noncritical.cc:  if (OWNISO(0) != PREVISO(0) && OWNISO(0) != ISO_MISMATCH) { APMI(cov); } //
RandomFields/src/InternalCov.noncritical.cc:  // for MLE
RandomFields/src/InternalCov.noncritical.cc:  return k<0 ? VARPARAM : C->sortof_tab[k];
RandomFields/src/InternalCov.noncritical.cc:  for(int i=FIRST_DOMAIN; i<= LAST_DOMAINUSER; i++) cov->allowedD[i] = true;
RandomFields/src/InternalCov.noncritical.cc:  for(int i=FIRST_DOMAIN; i<=LAST_DOMAINUSER; i++) cov->allowedD[i] = true;
RandomFields/src/InternalCov.noncritical.cc:  // dom=PREVMODEL_D wiederholt aufruft.
RandomFields/src/InternalCov.noncritical.cc:  //printf("Dsub: %s\n", NAME(cov));
RandomFields/src/InternalCov.noncritical.cc:  assert((int) FIRST_DOMAIN == 0);
RandomFields/src/InternalCov.noncritical.cc:  // keine Varianten bei DOMAIN
RandomFields/src/InternalCov.noncritical.cc:  assert(!isSubModelD(C) || C->Dallowed != NULL);
RandomFields/src/InternalCov.noncritical.cc:  domain_type dom = DEFDOM(0);
RandomFields/src/InternalCov.noncritical.cc:    for (int i=(int) FIRST_DOMAIN; i<=(int) LAST_DOMAINUSER; a[i++] = false);
RandomFields/src/InternalCov.noncritical.cc:  //printf("allowedfalse %s\n", NAME(cov));
RandomFields/src/InternalCov.noncritical.cc:  //printf("allowedtrue %s\n", NAME(cov));
RandomFields/src/InternalCov.noncritical.cc:  //  printf("all %s\n", NAME(cov));
RandomFields/src/InternalCov.noncritical.cc:  // if (cov->IallowedDone) return false; // 20.10.19 auskommentiert wegen wiederholten aufruf bei iso=PREVMODEL_I
RandomFields/src/InternalCov.noncritical.cc:  //printf("allowedI:%s %d\n", NAME(cov), cov->zaehler);
RandomFields/src/InternalCov.noncritical.cc:  //  printf("Isub: %s (%d)\n", NAME(cov), cov->zaehler);
RandomFields/src/InternalCov.noncritical.cc:  assert(!isSubModelI(C) || C->Iallowed != NULL);
RandomFields/src/InternalCov.noncritical.cc:    //    printf("fixed %s\n", ISO_NAMES[iso]);
RandomFields/src/InternalCov.noncritical.cc:      //I[SYMMETRIC] = I[EARTH_SYMMETRIC] = I[SPHERICAL_SYMMETRIC] = false;
RandomFields/src/InternalCov.noncritical.cc:    assert(!isParamDepI(C) && !isSubModelI(C));
RandomFields/src/InternalCov.noncritical.cc:  //  printf("allowed check for %s\n", NAME(cov));
RandomFields/src/InternalCov.noncritical.cc:  MEMCOPY(I, sub[j]->allowedI, sizeof(allowedI_type));
RandomFields/src/InternalCov.noncritical.cc:  //  printf("%s j=%d\n", NAME(sub[j]), j);  printI(sub[j]);
RandomFields/src/InternalCov.noncritical.cc:  //PMI(sub[j]);
RandomFields/src/InternalCov.noncritical.cc:    //    PMI(cov);    printI(cov);    printI(cov->sub[0]);
RandomFields/src/InternalCov.noncritical.cc:    //    printf("allowIsub %s %d<%d %d<%d %d<%d\n", NAME(cov), idx_C,CARTESIAN_COORD, idx_E, EARTH_COORD ,idx_S,SPHERICAL_COORD);
RandomFields/src/InternalCov.noncritical.cc:    if (equalsSymmetric((isotropy_type) idx_C)) I[EARTH_SYMMETRIC] = true;
RandomFields/src/InternalCov.noncritical.cc:    else I[EARTH_COORD] = I[EARTH_SYMMETRIC] = true;
RandomFields/src/InternalCov.noncritical.cc:      idx_S = SPHERICAL_SYMMETRIC;    
RandomFields/src/InternalCov.noncritical.cc:    if (idx_E >= EARTH_COORD) idx_E = EARTH_SYMMETRIC;
RandomFields/src/InternalCov.noncritical.cc:  //  printf("%s:", NAME(cov));
RandomFields/src/primitive.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/primitive.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/src/primitive.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/primitive.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/primitive.h:#define HAS_SPECTRAL_FRAME(cov)				\
RandomFields/src/primitive.h:  hasGaussMethodFrame(cov) && cov->method==SpectralTBM
RandomFields/src/primitive.h:void AngleMatrix(model *cov, double *A);
RandomFields/src/primitive.h:void TBM2Cauchy(double *x, int *, model *cov, double *v);
RandomFields/src/primitive.h:void DrawMixCauchy(model *cov, double *random); 
RandomFields/src/primitive.h:double LogMixDensCauchy(double *x, double logV, model *cov);
RandomFields/src/primitive.h:void TBM2exponential(double *x, int *, model *cov, double *v);
RandomFields/src/primitive.h:void DrawMixExp(model *cov, double *random);
RandomFields/src/primitive.h:double LogMixDensExp(double *x, double logV, model *cov);
RandomFields/src/primitive.h:void DrawMixGauss(model *cov, double *random);
RandomFields/src/primitive.h:double LogMixDensGauss(double *x, double logV, model *cov);
RandomFields/src/primitive.h://void getMassGauss(double *a, model *cov, double *kappas, double *m);
RandomFields/src/primitive.h:#define GENGNEITING_MU 1
RandomFields/src/primitive.h:/* Whittle-Matern or Whittle or Besset ---- rescaled form of Whittle-Matern,
RandomFields/src/primitive.h:#define WM_NU 0
RandomFields/src/primitive.h:#define WM_NOTINV 1
RandomFields/src/primitive.h:void Matern(double *x, int *, model *cov, double *v);
RandomFields/src/primitive.h:void NonStMatern(double *x, double *y, int *, model *cov, double *v);
RandomFields/src/primitive.h:void logNonStMatern(double *x, double*y, 
RandomFields/src/primitive.h:void logMatern(double *x, int *, model *cov, double *v, double *Sign);
RandomFields/src/primitive.h:void DMatern(double *x, int *, model *cov, double *v);
RandomFields/src/primitive.h:void DDMatern(double *x, int *, model *cov, double *v);
RandomFields/src/primitive.h:void D3Matern(double *x, int *, model *cov, double *v);
RandomFields/src/primitive.h:void D4Matern(double *x, int *, model *cov, double *v);
RandomFields/src/primitive.h:int checkMatern(model *cov);
RandomFields/src/primitive.h:void rangeWM(model *cov, range_type* ra);
RandomFields/src/primitive.h:void ieinitWM(model *cov, localfactstype *li);
RandomFields/src/primitive.h:void coinitWM(model *cov, localfactstype *li);
RandomFields/src/primitive.h:double densityMatern(double *x, model *cov);
RandomFields/src/primitive.h:int initMatern(model *cov, gen_storage *s);
RandomFields/src/primitive.h:void spectralMatern(model *cov, gen_storage *s, double *e); 
RandomFields/src/primitive.h:void InverseMatern(double *x, model *cov, double *v);
RandomFields/src/primitive.h:void inversenonstatMatern(double *x, model *cov, double *left, double*right);
RandomFields/src/primitive.h:#define WM_LOGGAMMA 0
RandomFields/src/primitive.h:#define WM_GAMMA 1
RandomFields/src/primitive.h:double Intern_DWM(double x, double nu, double loggamma, double factor);
RandomFields/src/primitive.h:#define NUGGET_VDIM 1
RandomFields/src/primitive.h:#define NUGGET_PROC_TOL (COMMON_GAUSS + 1)
RandomFields/src/primitive.h:#define NUGGET_PROC_VDIM (COMMON_GAUSS + 2)
RandomFields/src/primitive.h:void NullModel(double *x, int *, model *cov, double *v);
RandomFields/src/primitive.h:Types TypeNullModel(Types required, model *cov, isotropy_type i);
RandomFields/src/primitive.h:void rangeNullModel(model VARIABLE_IS_NOT_USED *cov, range_type *range);
RandomFields/src/primitive.h:void TBM2power(double *x, int *, model *cov, double *v);
RandomFields/src/primitive.h:void TBM2spherical(double *x, int *, model *cov, double *v);
RandomFields/src/primitive.h:/* Whittle-Matern or Whittle or Besset */ 
RandomFields/src/primitive.h:void TBM2Whittle(double *x, int *, model *cov, double *v);
RandomFields/src/primitive.h:bool allowedDWM(model *cov);
RandomFields/src/primitive.h:bool allowedIWM(model *cov);
RandomFields/src/primitive.h:bool setWM(model *cov);
RandomFields/src/primitive.h:Types TypeWM(Types required, model *cov, isotropy_type required_iso);
RandomFields/src/primitive.h:int initWM(model *cov, gen_storage *stor);
RandomFields/src/primitive.h:int checkWM(model *cov);
RandomFields/src/primitive.h:void DrawMixWM(model *cov, double *random);
RandomFields/src/primitive.h:double LogMixDensW(double *x, double logV, model *cov);
RandomFields/src/primitive.h:double WM(double x, double nu, double factor);
RandomFields/src/primitive.h:double logWM(double x, double nu1, double nu2, double factor);
RandomFields/src/primitive.h:double DWM(double x, double nu, double factor);
RandomFields/src/primitive.h:#define GNEITING_MU 1
RandomFields/src/primitive.h:#define GNEITING_GAMMA 4
RandomFields/src/primitive.h:void kappa_biWM(int i, model *cov, int *nr, int *nc);
RandomFields/src/primitive.h:void biWM2(double *x, int *, model *cov, double *v);
RandomFields/src/primitive.h:void biWM2D(double *x, int *, model *cov, double *v);
RandomFields/src/primitive.h:void biWM2DD(double *x, int *, model *cov, double *v);
RandomFields/src/primitive.h:void biWM2D3(double *x, int *, model *cov, double *v);
RandomFields/src/primitive.h:void biWM2D4(double *x, int *, model *cov, double *v);
RandomFields/src/primitive.h:int checkbiWM2(model *cov);
RandomFields/src/primitive.h:void rangebiWM2(model *cov, range_type* ra);
RandomFields/src/primitive.h:int initbiWM2(model *cov, gen_storage *s);
RandomFields/src/primitive.h:void coinitbiWM2(model *cov, localfactstype *li);
RandomFields/src/primitive.h:void rangebiWM2(model *cov, range_type* ra);
RandomFields/src/primitive.h:void kappa_parsWM(int i, model *cov, int *nr, int *nc);
RandomFields/src/primitive.h:void parsWM(double *x, int *, model *cov, double *v);
RandomFields/src/primitive.h:void parsWMD(double *x, int *, model *cov, double *v);
RandomFields/src/primitive.h:int checkparsWM(model *cov);
RandomFields/src/primitive.h:void rangeparsWM(model *cov, range_type* ra);
RandomFields/src/primitive.h:int initparsWM(model *cov, gen_storage *s);
Binary file RandomFields/src/cubicsolver.o matches
RandomFields/src/hyperplan.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/hyperplan.cc: Copyright (C) 2001 -- 2017 Martin Schlather, 
RandomFields/src/hyperplan.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/hyperplan.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USV.
RandomFields/src/hyperplan.cc:#define HYPER_SUPERPOS (COMMON_GAUSS + 1)
RandomFields/src/hyperplan.cc:#define HYPER_MAXLINES (COMMON_GAUSS + 2)
RandomFields/src/hyperplan.cc:#define HYPER_MAR_DISTR (COMMON_GAUSS + 3)
RandomFields/src/hyperplan.cc:#define HYPER_MAR_PARAM (COMMON_GAUSS + 4)
RandomFields/src/hyperplan.cc:#define HYPER_ADDITIVE (COMMON_GAUSS + 5)
RandomFields/src/hyperplan.cc:double uniform(double VARIABLE_IS_NOT_USED p) {return UNIFORM_RANDOM;}
RandomFields/src/hyperplan.cc:  return EXP(LOG(-1.0/LOG(UNIFORM_RANDOM)) / p);
RandomFields/src/hyperplan.cc:  return (double) (UNIFORM_RANDOM <= p);
RandomFields/src/hyperplan.cc:   dim = OWNLOGDIM(0)
RandomFields/src/hyperplan.cc:    ; // taken[MAX DIM],
RandomFields/src/hyperplan.cc:  ASSERT_ONESYSTEM;
RandomFields/src/hyperplan.cc:  kdefault(cov, HYPER_MAXLINES, gp->maxlines);
RandomFields/src/hyperplan.cc:  kdefault(cov, HYPER_MAR_DISTR, gp->mar_distr);
RandomFields/src/hyperplan.cc:  kdefault(cov, HYPER_MAR_PARAM, gp->mar_param);
RandomFields/src/hyperplan.cc:    ? ISOTROPIC : SYMMETRIC;
RandomFields/src/hyperplan.cc:		     GaussMethodType)) != NOERROR) RETURN_ERR(err);
RandomFields/src/hyperplan.cc:    if (intern == NULL || MODELNR(intern) != HYPERPLANE_INTERN) {
RandomFields/src/hyperplan.cc:		     GaussMethodType))!= NOERROR) RETURN_ERR(err);
RandomFields/src/hyperplan.cc:    dim = OWNLOGDIM(0);    
RandomFields/src/hyperplan.cc:  kdefault(cov, HYPER_MAXLINES, gp->maxlines);
RandomFields/src/hyperplan.cc:  kdefault(cov, HYPER_MAR_DISTR, gp->mar_distr);
RandomFields/src/hyperplan.cc:  kdefault(cov, HYPER_MAR_PARAM, gp->mar_param);
RandomFields/src/hyperplan.cc:  if ((err = CHECK(next, dim,  dim, PosDefType, XONLY, SYMMETRIC, 
RandomFields/src/hyperplan.cc:		   SCALAR, GaussMethodType)) != NOERROR) {
RandomFields/src/hyperplan.cc:  //  printf("OK!!!!! %d %d\n", next->pref[Hyperplane], PREF_NONE);  PMI(cov);
RandomFields/src/hyperplan.cc:  case HYPER_MAXLINES :
RandomFields/src/hyperplan.cc:  case HYPER_MAR_DISTR :
RandomFields/src/hyperplan.cc:    range->min = HYPER_UNIFORM;
RandomFields/src/hyperplan.cc:    range->pmin = HYPER_UNIFORM;
RandomFields/src/hyperplan.cc:  case HYPER_MAR_PARAM :
RandomFields/src/hyperplan.cc:  assert(!PisNULL(HYPER_MAXLINES));
RandomFields/src/hyperplan.cc:    maxlines = P0INT(HYPER_MAXLINES),
RandomFields/src/hyperplan.cc:    dim = ANYDIM,
RandomFields/src/hyperplan.cc:    min[MAXHYPERDIM], max[MAXHYPERDIM],
RandomFields/src/hyperplan.cc:  if (dim > MAXHYPERDIM) {
RandomFields/src/hyperplan.cc:    err=ERRORMAXDIMMETH; goto ErrorHandling;
RandomFields/src/hyperplan.cc:    err = ERRORWRONGDIM;
RandomFields/src/hyperplan.cc:	 (Loctsdim(cov) == loc->cani_nrow && PREVXDIM(0) == loc->cani_ncol));
RandomFields/src/hyperplan.cc:  if ((cell = (cell_type*) MALLOC(sizeof(cell_type))) == NULL){
RandomFields/src/hyperplan.cc:       MALLOC(*integers * sizeof(unsigned int))) == NULL)
RandomFields/src/hyperplan.cc:  int    integers, bits, q, endfor, err, len[MAXHYPERDIM],
RandomFields/src/hyperplan.cc:    vdim = VDIM0,
RandomFields/src/hyperplan.cc:    dim = OWNLOGDIM(0),
RandomFields/src/hyperplan.cc:    mar_distr = P0INT(HYPER_MAR_DISTR);
RandomFields/src/hyperplan.cc:    mar_param = P0(HYPER_MAR_PARAM);
RandomFields/src/hyperplan.cc:      case HYPER_UNIFORM : randomvar=uniform; break;
RandomFields/src/hyperplan.cc:	    if (isMdiag(Type(loc->caniso, loc->cani_nrow, loc->cani_ncol))) {
RandomFields/src/hyperplan.cc:		    err = ERRORMEMORYALLOCATION;
RandomFields/src/hyperplan.cc:		  err = ERRORMEMORYALLOCATION;
RandomFields/src/hyperplan.cc:    if (hasGaussMethodFrame(cov)) {
RandomFields/src/hyperplan.cc:      case HYPER_UNIFORM : 
RandomFields/src/xport_import.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/xport_import.h: Copyright (C) 2015 Martin Schlather
RandomFields/src/xport_import.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/xport_import.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/xport_import.h:  CALL(invertMatrix);				\
RandomFields/src/xport_import.h:  CALL(logWM);					\
RandomFields/src/xport_import.h:  CALL(sleepMicro);				\
RandomFields/src/metropolis.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/metropolis.cc: Metropolis-Hasting for drawing from the spectral density
RandomFields/src/metropolis.cc: Copyright (C) 2000 -- 2017 Martin Schlather, 
RandomFields/src/metropolis.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/metropolis.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/metropolis.cc:  double p, proposal[MAXTBMSPDIM], dx,
RandomFields/src/metropolis.cc:  if (dim >= MAXTBMSPDIM) BUG;
RandomFields/src/metropolis.cc:    if (p>=1 || UNIFORM_RANDOM < p) {
RandomFields/src/metropolis.cc:  double Sigma[maxSearch], x[MAXTBMSPDIM], oldx[MAXTBMSPDIM], log_s, p,
RandomFields/src/metropolis.cc:    if (i >= maxSearch) GERR("Metropolis search algorithm for optimal sd failed\n -- check whether the scale of the problem has been chosen appropriately");
RandomFields/src/metropolis.cc:	   s->sigma, s->nmetro, p, prop_factor, zaehler, OWNLOGDIM(0));
Binary file RandomFields/src/variogramAndCo.o matches
RandomFields/src/rf_interfaces.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/rf_interfaces.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/src/rf_interfaces.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/rf_interfaces.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/rf_interfaces.h:model *InitIntern(int cR, SEXP Model, SEXP x, bool NA_OK,
RandomFields/src/rf_interfaces.h:void CovMatrix(double *x, int *, model *cov, double *v);
RandomFields/src/rf_interfaces.h:int SearchParam(model *cov, get_storage *s, model_storage *STOMODEL) ;
Binary file RandomFields/src/nugget.o matches
Binary file RandomFields/src/primitive.cov.o matches
RandomFields/src/Processes.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/Processes.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/src/Processes.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/Processes.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/Processes.h:  if (j >= MAXBOXCOXVDIM || !R_FINITE(global->fit.BC_lambdaLB[2 * j + i]) ||   \
RandomFields/src/Processes.h:// Gauss Methods
RandomFields/src/Processes.h:#define COMMON_GAUSS 0
RandomFields/src/Processes.h:#define CE_FORCE (COMMON_GAUSS + 1)
RandomFields/src/Processes.h:#define CE_MMIN  (COMMON_GAUSS + 2)
RandomFields/src/Processes.h:#define CE_STRATEGY  (COMMON_GAUSS + 3)
RandomFields/src/Processes.h:#define CE_MAXGB  (COMMON_GAUSS + 4)
RandomFields/src/Processes.h:#define CE_MAXMEM  (COMMON_GAUSS + 5)
RandomFields/src/Processes.h:#define CE_TOLIM  (COMMON_GAUSS + 6)
RandomFields/src/Processes.h:#define CE_TOLRE  (COMMON_GAUSS + 7)
RandomFields/src/Processes.h:#define CE_TRIALS (COMMON_GAUSS +  8)
RandomFields/src/Processes.h:#define CE_USEPRIMES  (COMMON_GAUSS + 9)
RandomFields/src/Processes.h:#define CE_DEPENDENT  (COMMON_GAUSS + 10)
RandomFields/src/Processes.h:#define CE_APPROXSTEP  (COMMON_GAUSS + 11)
RandomFields/src/Processes.h:#define CE_APPROXMAXGRID  (COMMON_GAUSS + 12) // alway last of CE_*
RandomFields/src/Processes.h:#define CE_LAST CE_APPROXMAXGRID 
RandomFields/src/Processes.h:#define TBM_FULLDIM (COMMON_GAUSS + 1)
RandomFields/src/Processes.h:#define TBM_TBMDIM (COMMON_GAUSS + 2)
RandomFields/src/Processes.h:#define TBM_LAYERS (COMMON_GAUSS + 3)
RandomFields/src/Processes.h:#define GAUSSPROC_STATONLY  (COMMON_GAUSS + 1)
RandomFields/src/Processes.h://#define BOXCOX_TRAFO boxcox_trafo(boxcox, res, Loctotalpoints(cov) * VDIM0); 
RandomFields/src/Processes.h:#define BOXCOX_INVERSE_PARAM(GAUSS_BOXCOX)				\
RandomFields/src/Processes.h:  boxcox_inverse(P(GAUSS_BOXCOX), VDIM0, res, Loctotalpoints(cov), 1)
RandomFields/src/Processes.h:#define BOXCOX_INVERSE BOXCOX_INVERSE_PARAM(GAUSS_BOXCOX)
RandomFields/src/Processes.h:#define FRAME_ASSERT_GAUSS assert(hasGaussMethodFrame(cov));
RandomFields/src/Processes.h:#define FRAME_ASSERT_GAUSS_INTERFACE assert(hasGaussMethodFrame(cov) || (cov->calling != NULL && hasInterfaceFrame(cov->calling) && cov->calling->calling == NULL));
RandomFields/src/Processes.h:#define GEV_MU 1
RandomFields/src/Processes.h:#define LAST_MAXSTABLE GEV_S
RandomFields/src/Processes.h:#define MPP_SHAPE 0
RandomFields/src/Processes.h:#define MPP_TCF 1
RandomFields/src/Processes.h:int structMproc(model *cov, model **newmodel);
RandomFields/src/Processes.h:int initMproc(model *cov, gen_storage *s);
RandomFields/src/Processes.h:void doMproc(model *cov, gen_storage *s);
RandomFields/src/gausslikeli.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/gausslikeli.cc: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/src/gausslikeli.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/gausslikeli.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/gausslikeli.cc:#include "QMath.h"
RandomFields/src/gausslikeli.cc:  if (cR < 0 || cR > MODEL_MAX) BUG;					\
RandomFields/src/gausslikeli.cc:void SqMatrixcopyNA(double *dest, double *src, double *cond, int rows) {
RandomFields/src/gausslikeli.cc:  int len = 2 * MAXBOXCOXVDIM;
RandomFields/src/gausslikeli.cc:    vdim = VDIM0,
RandomFields/src/gausslikeli.cc:      MEMCOPY(REAL(partY), L->YhatWithoutNA[set], 
RandomFields/src/gausslikeli.cc:	PROTECT(partX = allocMatrix(REALSXP, totptsvdim, betatot));
RandomFields/src/gausslikeli.cc:	MEMCOPY(REAL(partX), L->X[set], 
RandomFields/src/gausslikeli.cc:    MEMCOPY(REAL(Y), 
RandomFields/src/gausslikeli.cc:      PROTECT(X = allocMatrix(REALSXP, totptsvdim, betatot));
RandomFields/src/gausslikeli.cc:      MEMCOPY(REAL(X), L->X[cov->base->set],
RandomFields/src/gausslikeli.cc:    vdim = VDIM0,
RandomFields/src/gausslikeli.cc:    MEMCOPY(pres, data, ndata * sizeof(double));
RandomFields/src/gausslikeli.cc:    work = (double *) MALLOC(nrow * vdim * sizeof(double));
RandomFields/src/gausslikeli.cc:    vdim = VDIM0,
RandomFields/src/gausslikeli.cc:  if (L->work == NULL)  L->work = (double*) MALLOC(max * sizeof(double));
RandomFields/src/gausslikeli.cc:      PROTECT(res = allocMatrix(REALSXP, nrow, ncol));
RandomFields/src/gausslikeli.cc:	 MODELNR(conditioning) == GAUSSPROC);				\
RandomFields/src/gausslikeli.cc:    vdim = VDIM0,							\
RandomFields/src/gausslikeli.cc:  if ((X = (double*) MALLOC(pred_totvdim * sizeof(double))) == NULL) {
RandomFields/src/gausslikeli.cc:    // printf("%d %d \n", pred_tot, vdim); APMI(cov);
RandomFields/src/gausslikeli.cc:    err = ERRORMEMORYALLOCATION; goto ErrorHandling;
RandomFields/src/gausslikeli.cc:  //MEMCOPY(pres, data, ndata * sizeof(double));
RandomFields/src/gausslikeli.cc:    work = (double *) MALLOC(nrow * vdim * sizeof(double));
RandomFields/src/gausslikeli.cc:  MEMCOPY(&Sparam, &(cov->base->global_utils.solve), sizeof(solve_param)); \
RandomFields/src/gausslikeli.cc:  Sparam.Methods[0] = Cholesky;						\
RandomFields/src/gausslikeli.cc:  Sparam.Methods[1] = NoFurtherInversionMethod
RandomFields/src/gausslikeli.cc:  // APMI(predict);
RandomFields/src/gausslikeli.cc:	 MODELNR(conditioning) == GAUSSPROC);				
RandomFields/src/gausslikeli.cc:  //  PMI(cov);
RandomFields/src/gausslikeli.cc:    vdim = VDIM0,							
RandomFields/src/gausslikeli.cc:  CovarianceMatrix(conditioning, false, L->C);  // tot x tot x vdim x vdim //sub -> cov 30.12.15
RandomFields/src/gausslikeli.cc:  //PMI0(cov);  printf("totYvdimrepet=%d %d %d, vdim=%d set=%d\n", totYvdimrepet, repet, ncol, vdim,cov->base->set);
RandomFields/src/gausslikeli.cc:      SqMatrixcopyNA(Ccur, L->C, resi, totptsYvdim);
RandomFields/src/gausslikeli.cc:    vdim = VDIM0,
RandomFields/src/gausslikeli.cc:  //if (VDIM1 != 1) BUG;
RandomFields/src/gausslikeli.cc:      MEMCOPY(Xdata, SET_OUT_OF(datasets), ndata * sizeof(double));
RandomFields/src/gausslikeli.cc:	// gleoch alles mit allem Multiplizieren, um's einfach zumachen.
RandomFields/src/gausslikeli.cc:	MEMCOPY(L->sumY, dataWithoutNA, sizeof(double) * notnas);
RandomFields/src/gausslikeli.cc:  // PMI(cov);
RandomFields/src/gausslikeli.cc:    vdim = VDIM0,
RandomFields/src/gausslikeli.cc:  // PMI(cov);
RandomFields/src/gausslikeli.cc:  //  if (VDIM1 != 1) BUG;
RandomFields/src/gausslikeli.cc:      MEMCOPY(Xdata, SET_OUT_OF(datasets), ndata * sizeof(double));
RandomFields/src/gausslikeli.cc:    ///   PMI0(cov);
RandomFields/src/gausslikeli.cc:    CovarianceMatrix(cov, false, L->C); //sub -> cov 30.12.15
RandomFields/src/gausslikeli.cc:	SqMatrixcopyNA(Ccur, L->C, datacur, totptsvdim);
RandomFields/src/gausslikeli.cc:      MEMCOPY(L->CinvXY, Xcur, notnas * XYcols * sizeof(double));
RandomFields/src/gausslikeli.cc:	  MEMCOPY(L->sumY, dataWithoutNA, sizeof(double) * notnas);
RandomFields/src/gausslikeli.cc:    MEMCOPY(beta, L->XCY, sizeof(double) * all_betatot);
RandomFields/src/gausslikeli.cc:    //   printf("%.50s AC %10g %10g %10g %10g %d done\n", NAME(cov), beta[0], beta[1], beta[2], beta[3], all_betatot); BUG;
RandomFields/src/gausslikeli.cc:    MEMCOPY(v + 1 + facts->globalvariance, beta, all_betatot * sizeof(double));
RandomFields/src/gausslikeli.cc:	  lambdaM1 = lambda - 1.0,
RandomFields/src/gausslikeli.cc:	*v += lambdaM1 * sum;
RandomFields/src/gausslikeli.cc:  //  APMI(cov);  BUG;
RandomFields/src/gausslikeli.cc:  assert (*reg >= 0 && *reg <= MODEL_MAX);
RandomFields/src/gausslikeli.cc:  if (*neffect >= MAX_LIN_COMP) ERR("too many linear components");
RandomFields/src/gausslikeli.cc:    if (MODELNR(component) == PLUS) {
RandomFields/src/gausslikeli.cc:    // printf("%.50s %d %ld\n", NAME(cov), facts->effect[*neffect], (Long) L);
RandomFields/src/gausslikeli.cc:    //  if (L->effect[*neffect] > LastMixedEffect) { } else 
RandomFields/src/gausslikeli.cc:      if (MODELNR(component) == MULT) {
RandomFields/src/gausslikeli.cc:	nr = MODELNR(component);
RandomFields/src/gausslikeli.cc:      if (nr == MULT) {
RandomFields/src/gausslikeli.cc:	  if (MODELNR(subcomp) == CONST && ISNA(PARAM0(subcomp, CONST_C))){
RandomFields/src/gausslikeli.cc:      char abbr[LENMSG];
RandomFields/src/gausslikeli.cc:      //      printf("%d %.50s %.50s\n", *neffect, NAME(component), NAME(comp));
RandomFields/src/gausslikeli.cc:      if (nr == COVARIATE) AbbrBeta(PARAM0CHAR(comp, COVARIATE_NAME), abbr);
RandomFields/src/gausslikeli.cc:      else if (nr == SHAPE_FCT && comp->kappasub[SHAPE_FCT_MEAN] != NULL) 
RandomFields/src/gausslikeli.cc:	AbbrBeta(NICK(comp->kappasub[SHAPE_FCT_MEAN]) + 2, abbr);
RandomFields/src/gausslikeli.cc:      else if (nr == MULT) {
RandomFields/src/gausslikeli.cc:	if (MODELNR(comp) == PROJ_MODEL) {
RandomFields/src/gausslikeli.cc:	  if (PARAMisNULL(comp, PROJ_NAME))
RandomFields/src/gausslikeli.cc:	    SPRINTF(abbr, "proj%d", PARAM0INT(comp, PROJ_PROJ));
RandomFields/src/gausslikeli.cc:	  else AbbrBeta(PARAM0CHAR(comp, PROJ_NAME), abbr);
RandomFields/src/gausslikeli.cc:	else if (MODELNR(comp) == SHAPE_FCT &&
RandomFields/src/gausslikeli.cc:		 comp->kappasub[SHAPE_FCT_MEAN] != NULL)
RandomFields/src/gausslikeli.cc:	  AbbrBeta(NICK(comp->kappasub[SHAPE_FCT_MEAN]) + 2, abbr);
RandomFields/src/gausslikeli.cc:      //  if (L->betanames[*neffect] != NULL) {printf("%.50s %d %.50s\n", NAME(cov),  *neffect, L->betanames[*neffect]); crash();} else  printf("%.50s %d NULL\n", NAME(cov),  *neffect); 
RandomFields/src/gausslikeli.cc:	L->betanames[base] = (char*) MALLOC(bytes);
RandomFields/src/gausslikeli.cc:	  L->betanames[base + jj] = (char*) MALLOC(bytes);
RandomFields/src/gausslikeli.cc:    if (MODELNR(component) == PLUS) {
RandomFields/src/gausslikeli.cc:      if (MODELNR(component) == MULT) {
RandomFields/src/gausslikeli.cc:#define MAX_TOTALPTS 10000
RandomFields/src/gausslikeli.cc:  // APMI(cov);
RandomFields/src/gausslikeli.cc:    if (Loctotalpoints(cov) < MAX_TOTALPTS) {
RandomFields/src/gausslikeli.cc:    MAX_TOTALPTS / SQRT((double) dim)) {
RandomFields/src/gausslikeli.cc:    vdim = VDIM0,
RandomFields/src/gausslikeli.cc:    ? (usr_bool) PARAM0INT(calling, LIKELIHOOD_NA_VAR)
RandomFields/src/gausslikeli.cc:    CALLINGNR == LIKELIHOOD_CALL && PARAM0INT(calling, LIKELIHOOD_IGNORETREND); 
RandomFields/src/gausslikeli.cc:    CALLINGNR == LIKELIHOOD_CALL && PARAM0INT(calling, LIKELIHOOD_BETASSEPARATE);
RandomFields/src/gausslikeli.cc:  if (L->fixedtrends + 1 < MAX_LIN_COMP)
RandomFields/src/gausslikeli.cc:      (double **) MALLOC( L->cum_n_betas[L->fixedtrends] * sizeof(double**) );
RandomFields/src/gausslikeli.cc:  // alloc_cov is need for both CovarianceMatrix and FctnInternXal
RandomFields/src/gausslikeli.cc:  // APMI0(cov);
RandomFields/src/gausslikeli.cc:  if ((err = alloc_fctn(cov, OWNTOTALXDIM, n)) !=NOERROR) goto ErrorHandling;
RandomFields/src/gausslikeli.cc:  L->sumY = (double *) MALLOC(L->max_total_data * sizeof(double)); 
RandomFields/src/gausslikeli.cc:    //PMI0(cov);
RandomFields/src/gausslikeli.cc:    listcpy(&(L->datasets),  PARAMLIST(calling, LIKELIHOOD_DATA), false);
RandomFields/src/gausslikeli.cc:    L->data_nas = (int *) MALLOC(sets * sizeof(int));
RandomFields/src/gausslikeli.cc:      //PMI0(cov->calling);   printf("nrow = %d %d\n", nrow, ncol);
RandomFields/src/gausslikeli.cc:      int vdimMax = MIN(vdim, MAXBOXCOXVDIM),
RandomFields/src/gausslikeli.cc:	  for(i=0; i<vdimMax; i++) {
RandomFields/src/gausslikeli.cc:	  for(i=0; i<vdimMax; i++) {
RandomFields/src/gausslikeli.cc:    //    PMI(cov);
RandomFields/src/gausslikeli.cc:    L->C = (double *) MALLOC(totdata_bytes);    
RandomFields/src/gausslikeli.cc:      L->Cwork = (double *) MALLOC(totdata_bytes);
RandomFields/src/gausslikeli.cc:      L->Xwork = (double*) MALLOC(tot * sizeof(double));
RandomFields/src/gausslikeli.cc:      L->XitXi =  (double*) MALLOC(sizeof(double) * betatot * 
RandomFields/src/gausslikeli.cc:      L->XCY = (double *) MALLOC(all_betatot * sizeof(double)); 
RandomFields/src/gausslikeli.cc:      L->betavec = (double *) MALLOC(all_betatot * sizeof(double)); 
RandomFields/src/gausslikeli.cc:    L->CinvXY = (double*) MALLOC(sizeof(double) *
RandomFields/src/gausslikeli.cc:	MEMCOPY(Xdata, data, ndata * sizeof(double));
RandomFields/src/gausslikeli.cc:	//	APMI(cov);
RandomFields/src/gausslikeli.cc:  //  assert(cov->Slikelihood != NULL);  printf("%d\n", addressbits(cov->Slikelihood));  APMI(cov);
Binary file RandomFields/src/userinterfaces.o matches
RandomFields/src/variogramAndCo.cc:Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/variogramAndCo.cc: Copyright (C) 2005 -- 2017 Martin Schlather
RandomFields/src/variogramAndCo.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/variogramAndCo.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/variogramAndCo.cc:  if (equalsnowGaussMethod(sub) || SUBNR==GAUSSPROC) {
RandomFields/src/variogramAndCo.cc:    while (equalsnowGaussMethod(sub) || SUBNR==GAUSSPROC) sub = sub->sub[0];
RandomFields/src/variogramAndCo.cc:    //assert(({PMI(cov, "cov matrix"); true;})); //
RandomFields/src/variogramAndCo.cc:  if (equalsnowGaussMethod(cov) || COVNR==GAUSSPROC) cov = cov->sub[0];	\
RandomFields/src/variogramAndCo.cc:  if (calling->Sfctn == NULL) {  /*//PMI0(calling); printf("NULL !!\n");*/ \
RandomFields/src/variogramAndCo.cc://  printf("OKcc\n\n");PMI0(calling);PMI0(cov);assert(calling != NULL && (equalsnowInterface(calling) || isnowProcess(calling))); printf("OK\n\n");
RandomFields/src/variogramAndCo.cc:/* assert(VDIM0 == VDIM1); */	
RandomFields/src/variogramAndCo.cc:      vdim = VDIM0,      
RandomFields/src/variogramAndCo.cc:  //PMI0(cov);
RandomFields/src/variogramAndCo.cc:  bool kernel = equalsKernel(DOM(PREVSYSOF(genuine), 0));   
RandomFields/src/variogramAndCo.cc:    assert(({/*P M I(cov, "Cov/vario"); */ cov->pref[Nothing] != PREF_NONE &&
RandomFields/src/variogramAndCo.cc:      assert(({PMI(cov); true;})); //
RandomFields/src/variogramAndCo.cc:#define MULT 					\
RandomFields/src/variogramAndCo.cc:  VDIM_LOOP(cross[u]);
RandomFields/src/variogramAndCo.cc:#define MULT_Y		\
RandomFields/src/variogramAndCo.cc:  VDIM_LOOP(cross[u])
RandomFields/src/variogramAndCo.cc:#define PSEUDO_MULT 							\
RandomFields/src/variogramAndCo.cc:  VDIM_LOOP(C0y[u] - cross[u])
RandomFields/src/variogramAndCo.cc:#define VARIO_MULT 							\
RandomFields/src/variogramAndCo.cc:  VDIM_LOOP(C0y[u] - 0.5 * (cross[u] + cross[w]))	
RandomFields/src/variogramAndCo.cc:#define VARIO_MULT_Y 							\
RandomFields/src/variogramAndCo.cc:  VDIM_LOOP(0.5 * (C0x[u] + C0y[u] - cross[u] - cross[w]))
RandomFields/src/variogramAndCo.cc:#define PSEUDO_MULT_Y							\
RandomFields/src/variogramAndCo.cc:  double *C = v + VDIM_0 * i_row + i_col * VDIMtotX;			\
RandomFields/src/variogramAndCo.cc:    for (Long m1=n1; w<vdimSq; m1+=MINCR, w+=vdimP1){		\
RandomFields/src/variogramAndCo.cc:      MEMCOPY(y, LocY(cov) + spatialdim * (i_col_base % spptsY),
RandomFields/src/variogramAndCo.cc:    PERFORM_PREPARE;
RandomFields/src/variogramAndCo.cc:    PERFORM(UNIVAR, MULT, UNIVAR_Y, MULT_Y);
RandomFields/src/variogramAndCo.cc:    PERFORM(VARIO_UNIVAR, PSEUDO_MULT, VARIO_UNIVAR_Y, PSEUDO_MULT_Y);
RandomFields/src/variogramAndCo.cc:    PERFORM(VARIO_UNIVAR, VARIO_MULT, VARIO_UNIVAR_Y, VARIO_MULT_Y);
RandomFields/src/variogramAndCo.cc:void CovarianceMatrix(model *Cov, bool ignore_y, double *v) {
RandomFields/src/variogramAndCo.cc:#define  StartCovarianceMatrix(TOTX, TOTY)			\
RandomFields/src/variogramAndCo.cc:  Long totM1 = totX - 1;					\
RandomFields/src/variogramAndCo.cc:  StartCovarianceMatrix(0, 0);
RandomFields/src/variogramAndCo.cc:#define MULTICOV						\
RandomFields/src/variogramAndCo.cc:  double *C = v + VDIM_0 * i_row + i_col * VDIMtotX,		\
RandomFields/src/variogramAndCo.cc:    *D = v + VDIM_0 * i_col + i_row * VDIMtotX;			\
RandomFields/src/variogramAndCo.cc:  for (Long n=0, m0=0; n<NEND; n+=NINCR, m0+=MINCR) {		\
RandomFields/src/variogramAndCo.cc:    for (Long m=n, n0=m0; m<endfor; m+=MINCR, n0+=NINCR) {	\
RandomFields/src/variogramAndCo.cc:  bool kernel = equalsKernel(DOM(PREVSYSOF(genuine), 0));
RandomFields/src/variogramAndCo.cc:	    MULTICOV;
RandomFields/src/variogramAndCo.cc:	    double *Calt = v + VDIM_0 * i_col_alt + i_row_alt * VDIMtotX,  
RandomFields/src/variogramAndCo.cc:	      *C = v + VDIM_0 * i_col + i_row * VDIMtotX;
RandomFields/src/variogramAndCo.cc:	      for (int m=n; m<endfor; m+=MINCR) {				
RandomFields/src/variogramAndCo.cc:	      C = v + VDIM_0 * i_row + i_col * VDIMtotX;		
RandomFields/src/variogramAndCo.cc:	      Calt = v + VDIM_0 * i_row_alt + i_col_alt * VDIMtotX;	
RandomFields/src/variogramAndCo.cc:	      for (int m=0; m<ENDFORINCR; m+=MINCR) {			
RandomFields/src/variogramAndCo.cc:	  STANDARDINKREMENT_Y;
RandomFields/src/variogramAndCo.cc:	  //	APMI(genuine);
RandomFields/src/variogramAndCo.cc:	STANDARDINKREMENT_X;
RandomFields/src/variogramAndCo.cc:	  MULTICOV; 
RandomFields/src/variogramAndCo.cc:	  STANDARDINKREMENT_Y;
RandomFields/src/variogramAndCo.cc:	  //	APMI(genuine);
RandomFields/src/variogramAndCo.cc:	STANDARDINKREMENT_X;
RandomFields/src/variogramAndCo.cc:	    else COV(x0 + (i_row * totM1 - (i_row * (i_row + 1)) / 2 + i_col -1)
RandomFields/src/variogramAndCo.cc:	  MULTICOV; 
RandomFields/src/variogramAndCo.cc:	  //PMI(genuine);	  printf("kernel =  %d\n", kernel);
RandomFields/src/variogramAndCo.cc:	  MULTICOV; 
RandomFields/src/variogramAndCo.cc:} // CovarianzMatrix
RandomFields/src/variogramAndCo.cc:void CovarianceMatrix(model *Cov, bool ignore_y, int *idx, int Nidx,
RandomFields/src/variogramAndCo.cc:  StartCovarianceMatrix(Nidx, Nidx);
RandomFields/src/variogramAndCo.cc:  bool kernel = equalsKernel(DOM(PREVSYSOF(genuine), 0));
RandomFields/src/variogramAndCo.cc:	MULTICOV;
RandomFields/src/variogramAndCo.cc:	  else COV(x0 + (I * totM1 - (I * (I + 1)) / 2 + J -1)
RandomFields/src/variogramAndCo.cc:	  MULTICOV; 
RandomFields/src/variogramAndCo.cc:	  MULTICOV;
RandomFields/src/variogramAndCo.cc:} // CovarianzMatrix
RandomFields/src/variogramAndCo.cc:void CovarianceMatrixCols(model *Cov, bool ignore_y, int row, double *v) {
RandomFields/src/variogramAndCo.cc:  StartCovarianceMatrix(1, 0);
RandomFields/src/variogramAndCo.cc:#define MULTICOV_COL							\
RandomFields/src/variogramAndCo.cc:  double *C = v + VDIM_0 * 0 + i_col * VDIMtotX;			\
RandomFields/src/variogramAndCo.cc:  for (Long m=0; m<ENDFORINCR; m+=MINCR) {				\
RandomFields/src/variogramAndCo.cc:      MULTICOV_COL; 
RandomFields/src/variogramAndCo.cc:      STANDARDINKREMENT_Y;
RandomFields/src/variogramAndCo.cc:      //	APMI(genuine);
RandomFields/src/variogramAndCo.cc:	  int i_min = MIN(i_col, row),
RandomFields/src/variogramAndCo.cc:	    i_max = MAX(i_col, row);
RandomFields/src/variogramAndCo.cc:	  COV(x + (i_min * totM1 - (i_min * (i_min + 1)) / 2 + i_max -1) *
RandomFields/src/variogramAndCo.cc:	MULTICOV_COL;
RandomFields/src/variogramAndCo.cc:  	MULTICOV_COL;
RandomFields/src/variogramAndCo.cc:} // CovarianzMatrixCol
RandomFields/src/variogramAndCo.cc:void InverseCovMatrix(model *cov, double *v, double *det) {// currently unused
RandomFields/src/variogramAndCo.cc:  // needed when Markov models are implemented
RandomFields/src/variogramAndCo.cc:  Long vdimtot = Loctotalpoints(cov) * VDIM0;
RandomFields/src/variogramAndCo.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/variogramAndCo.cc:  if (reg < 0 || reg > MODEL_MAX) XERR(ERRORREGISTER);	\
RandomFields/src/variogramAndCo.cc:  if (INTEGER(reg)[0] < 0 || INTEGER(reg)[0] > MODEL_MAX) XERR(ERRORREGISTER); \
RandomFields/src/variogramAndCo.cc:  if (equalsnowGaussMethod(truecov)) truecov = truecov->sub[0]
RandomFields/src/variogramAndCo.cc://  if (cov->pref[Nothing] == PREF_NONE) { PMI(cov); XERR(ERRORINVALIDMODEL) }
RandomFields/src/variogramAndCo.cc:  //  printf("%s %d %d %d\n", NAME(cov), old, neu, cov->prevloc);
RandomFields/src/variogramAndCo.cc:  assert(sizeof(model_storage) == 120 && MAXSUB==10 && MAXPARAM == 20);
RandomFields/src/variogramAndCo.cc:    // if (alle > 1) {   PMI0(cov);     APMI(cov->calling);    }
RandomFields/src/variogramAndCo.cc:    GETSTOMODEL;
RandomFields/src/variogramAndCo.cc:    if (STOMODEL->cov != NULL) ResetLoc(STOMODEL->cov, old, neu, alle);
RandomFields/src/variogramAndCo.cc:    if (STOMODEL->vario != NULL) ResetLoc(STOMODEL->vario, old, neu, alle);
RandomFields/src/variogramAndCo.cc:    if (STOMODEL->orig != NULL) ResetLoc(STOMODEL->orig, old, neu, alle);
RandomFields/src/variogramAndCo.cc:    if (STOMODEL->get_cov != NULL) ResetLoc(STOMODEL->get_cov, old, neu, alle);
RandomFields/src/variogramAndCo.cc:    if (STOMODEL->remote != NULL) ResetLoc(STOMODEL->remote, old, neu, alle);
RandomFields/src/variogramAndCo.cc:    for (int i=0; i<MAXSUB; i++)
RandomFields/src/variogramAndCo.cc:      if (STOMODEL->keys[i]!=NULL) ResetLoc(STOMODEL->keys[i], old, neu, alle);
RandomFields/src/variogramAndCo.cc:#ifdef SCHLATHERS_MACHINE
RandomFields/src/variogramAndCo.cc:#ifdef SCHLATHERS_MACHINE
RandomFields/src/variogramAndCo.cc:#ifdef SCHLATHERS_MACHINE
RandomFields/src/variogramAndCo.cc:#ifdef SCHLATHERS_MACHINE
RandomFields/src/variogramAndCo.cc:SEXP MomentsIntern(SEXP reg, SEXP Alpha) { // used
RandomFields/src/variogramAndCo.cc:    vdim =VDIM0,
RandomFields/src/variogramAndCo.cc:  if (alpha == VARIOGRAM) Variogram(truecov, REAL(ans));
RandomFields/src/convhull2D.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/convhull2D.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/convhull2D.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
Binary file RandomFields/src/primitive.matern.o matches
RandomFields/src/Error.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/Error.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/src/Error.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/Error.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/Error.h:#define LOCAL_MSG char MSG[LENERRMSG]
RandomFields/src/Error.h:#define FAILED(M) {PRINTF(M); return ERRORFAILED;}
RandomFields/src/Error.h:#define FAILED1(M,A) {PRINTF(M,A); return ERRORFAILED;}
RandomFields/src/Error.h:#define FAILED2(M,A,B) {PRINTF(M,A,B); return ERRORFAILED;}
RandomFields/src/Error.h:#define FAILED3(M,A,B,C) {PRINTF(M,A,B,C); return ERRORFAILED;}
RandomFields/src/Error.h:void errorMSG(int err, KEY_type *KT, char* m);
RandomFields/src/Error.h:void errorMSG(int err, errorstring_type err_msg, KEY_type *KT, char* m);
RandomFields/src/Error.h:void errorMSG(int err, char* m);
RandomFields/src/Error.h:void errorMSG(int err,  errorstring_type err_msg, char* m);
RandomFields/src/Error.h:#define MERR(X) {LOCAL_ERRLOC_MSG; LPRINT("error msg: ");	\
RandomFields/src/Error.h:    errorMSG(X, cov->err_msg, cov->base, ERRMSG); if (PL<PL_ERRORS) {PRINTF("%s\n", ERRMSG);}}
RandomFields/src/Error.h:#define XERR(X) {LOCAL_MSG; /* UERR; */ errorMSG(X, MSG);  RFERROR(MSG);}
RandomFields/src/Error.h:#define QERR(X) {LOCAL_ERRORSTRING; SPRINTF(cov->err_msg, "'%.50s' : %.500s", param_name, X); DEBUGINFOERR; RETURN_ERR(ERRORM);}
RandomFields/src/Error.h:#define QERRX(ERR, X) {LOCAL_ERRORSTRING; LOCAL_MSG; errorMSG(ERR, MSG); SPRINTF(cov->err_msg, "'%.50s' : %.300s (%.500s)", param_name, X, MSG); DEBUGINFOERR; RETURN_ERR(ERRORM);}
RandomFields/src/Error.h:#define QERRC(NR,X) {LOCAL_ERRORSTRING; SPRINTF(cov->err_msg, "%.50s '%.50s': %.800s", NAME(cov), DefList[COVNR].kappanames[NR], X); DEBUGINFOERR; RETURN_ERR(ERRORM);}
RandomFields/src/Error.h:#define QERRC1(NR,X,Y) {LOCAL_ERRORSTRING; LOCAL_MSG; SPRINTF(MSG, "%.50s '%.50s': %.800s",NAME(cov), DefList[COVNR].kappanames[NR], X); SPRINTF(cov->err_msg, MSG, KNAME(Y)); DEBUGINFOERR; RETURN_ERR(ERRORM);}
RandomFields/src/Error.h:#define QERRC2(NR,X,Y,Z) {LOCAL_ERRORSTRING; LOCAL_MSG; SPRINTF(MSG, "%.50s '%.50s': %.800s", NAME(cov), DefList[COVNR].kappanames[NR], X); SPRINTF(cov->err_msg, MSG, KNAME(Y), KNAME(Z)); DEBUGINFOERR; RETURN_ERR(ERRORM);}
RandomFields/src/Error.h:#define GQERRC(NR,X) {LOCAL_ERRORSTRING; SPRINTF(cov->err_msg, "%.50s '%.50s': %.800s", NAME(cov), DefList[COVNR].kappanames[NR], X); DEBUGINFOERR; goto ErrorHandling;}
RandomFields/src/Error.h:#define GQERRC1(NR,X,Y) {LOCAL_ERRORSTRING; LOCAL_MSG; SPRINTF(MSG, "%.50s '%.50s': %.800s",NAME(cov), DefList[COVNR].kappanames[NR], X); SPRINTF(cov->err_msg, MSG, KNAME(Y)); DEBUGINFOERR; goto ErrorHandling;}
RandomFields/src/Error.h:#define GQERRC2(NR,X,Y,Z) {LOCAL_ERRORSTRING; LOCAL_MSG; SPRINTF(MSG, "%.50s '%.50s': %.800s", NAME(cov), DefList[COVNR].kappanames[NR], X); SPRINTF(cov->err_msg, MSG, KNAME(Y), KNAME(Z)); DEBUGINFOERR; goto ErrorHandling;}
RandomFields/src/Error.h:    if (STRCMP(X, "") == 0)	{					\
RandomFields/src/Error.h:// !!! anything from ERRORM=4 to ERRORMEND=12 will give free error messages
RandomFields/src/Error.h:#define XERRORM ERRORM
RandomFields/src/Error.h:#define XERRORCHANGESYSTEM 5
RandomFields/src/Error.h:#define XERRORILLEGALFRAME 6
RandomFields/src/Error.h:#define XERRORBADVDIM 16
RandomFields/src/Error.h://#define XERRORTRAFOSYSTEM 15
RandomFields/src/Error.h:#define XERRORVDIMNOTPROGRAMMEDYET 19
RandomFields/src/Error.h:				    method is not given/known, e.g. TBM2 for 
RandomFields/src/Error.h:#define XERRORDECOMPOSITION 26   /* direct.cc */
RandomFields/src/Error.h:#define XERRORRANDOMKAPPA 29
RandomFields/src/Error.h:#define XERRORSUBMETHODFAILED 30 /* aufsplitten der Modelle bringt nichts */
RandomFields/src/Error.h:#define XERRORMAXDIMMETH 31     /* max dimension of method exceeded */
RandomFields/src/Error.h:#define XERRORINVALIDMODEL 33 /* no gauss method available, including 'Nothing'*/
RandomFields/src/Error.h:#define XERRORODDMODEL 34     /* no gauss method available */
RandomFields/src/Error.h:#define XERROROUTOFMETHODLIST 35 /* no further method we can try is available */
RandomFields/src/Error.h:#define XERRORWRONGDOM 38
RandomFields/src/Error.h:#define XERRORWRONGDIM 40        /* (tbm) dimension couldn't be reduced to be 
RandomFields/src/Error.h:#define XERRORTOOMANYLINES 41    /* Hyperplane tesselation: estimated simulated
RandomFields/src/Error.h:#define XERRORNOVARIOGRAM 43     /* variograms aren't allowed in ci & direct */
RandomFields/src/Error.h:#define XERRORTBMCOMBI 45
RandomFields/src/Error.h:#define XERRORTOOMANYLOC 56
RandomFields/src/Error.h://#define ERRORDUMMY 99            /* no error, only for tracing purposes */
RandomFields/src/Error.h:#define XERRORNORMALMIXTURE 101    /* normal mixture required */
RandomFields/src/Error.h:#define XERRORNOMULTIVARIATE 102   /* vdim > 1 isn't allowed */
RandomFields/src/Error.h:#define XERROR_MATRIX_SQUARE 103
RandomFields/src/Error.h:#define XERROR_MATRIX_VDIM 104
RandomFields/src/Error.h:#define XERROR_MATRIX_POSDEF 105
RandomFields/src/Error.h:#define ERRORDIM 119              /* dim<1 oder dim>MAXDIM */
RandomFields/src/Error.h:#define XERRORCEDIM 120              /* dim<1 oder dim>MAXDIM */
RandomFields/src/Error.h:#define XERRORDIAMETERNOTGIVEN 128
RandomFields/src/Error.h:#define XERRORUNKNOWNMETHOD 131  
RandomFields/src/Error.h:#define XERRORNOSTATMATCH 134     /* no matching ISO/STAT found in check2 */
RandomFields/src/Error.h:#define XERRORUNKNOWNMAXTYPE 204 
RandomFields/src/Error.h:#define XERRORATOMP 253
RandomFields/src/Error.h:#define MSGLOCAL_OK 400 /* don't change ordering! (the less the better) */
RandomFields/src/Error.h:#define XMSGLOCAL_NUMOK 401
RandomFields/src/Error.h:#define XMSGLOCAL_JUSTTRY 402
RandomFields/src/Error.h:#define XMSGLOCAL_ENDOFLIST 403
RandomFields/src/Error.h:#define XMSGLOCAL_SIGNPHI 404
RandomFields/src/Error.h:#define XMSGLOCAL_SIGNPHIFST 405
RandomFields/src/Error.h:#define XMSGLOCAL_SIGNPHISND 406
RandomFields/src/Error.h:#define XMSGLOCAL_INITINTRINSIC 407
RandomFields/src/Error.h:#define XMSGLOCAL_FAILED 408
RandomFields/src/Error.h:#define XMSGLOCAL_NOPOSITIVEROOT 409
RandomFields/src/Error.h:#define XMSGLOCAL_NOTSYMMETRICMULTIVARIATE 410
RandomFields/src/Error.h:#define XMSGLOCAL_WRONGRADII 411
RandomFields/src/Error.h:/* don't use numbers 800 -- 900 : reserved to MPP package */
RandomFields/src/Error.h:#ifdef RANDOMFIELDS_DEBUGGING
RandomFields/src/Error.h:#define M1ERR(X,M) __extension__({ LPRINT("%s [%d] ", M, X);	\
RandomFields/src/Error.h:      errorMSG(X, cov->err_msg, cov->base, msg_0);		\
RandomFields/src/Error.h:#define ERRX(E)  M1ERR(X##E, "error: ")
RandomFields/src/Error.h://#define DEBUGINFOERR __extension__({PRINTF("f=%s l=%d\n",__FILE__,__LINE__);MERR(X##E);})
RandomFields/src/Error.h:#define ERRC(E) M1ERR(X##E, "default / obvious error : ")
RandomFields/src/Error.h:// _extension__({M2ERR(X##E);PRINTF("\t\tfile=%s line=%d\n",__FILE__,__LINE__); X##E;})
RandomFields/src/Error.h:#define ERRORCHANGESYSTEM ERRX(ERRORCHANGESYSTEM)
RandomFields/src/Error.h:#define ERRORILLEGALFRAME ERRX(ERRORILLEGALFRAME)
RandomFields/src/Error.h://#define ERRORTRAFOSYSTEM ERRX(ERRORTRAFOSYSTEM)
RandomFields/src/Error.h:#define ERRORBADVDIM ERRX(ERRORBADVDIM)
RandomFields/src/Error.h:#define ERRORVDIMNOTPROGRAMMEDYET ERRX(ERRORVDIMNOTPROGRAMMEDYET)
RandomFields/src/Error.h:#define ERRORDECOMPOSITION ERRX(ERRORDECOMPOSITION)
RandomFields/src/Error.h:#define ERRORRANDOMKAPPA ERRX(ERRORRANDOMKAPPA)
RandomFields/src/Error.h:#define ERRORSUBMETHODFAILED ERRX(ERRORSUBMETHODFAILED)
RandomFields/src/Error.h:#define ERRORMAXDIMMETH ERRX(ERRORMAXDIMMETH)
RandomFields/src/Error.h:#define ERRORINVALIDMODEL ERRX(ERRORINVALIDMODEL)
RandomFields/src/Error.h:#define ERRORODDMODEL ERRX(ERRORODDMODEL)
RandomFields/src/Error.h:#define ERROROUTOFMETHODLIST ERRX(ERROROUTOFMETHODLIST)
RandomFields/src/Error.h:#define ERRORWRONGDOM ERRX(ERRORWRONGDOM)
RandomFields/src/Error.h:#define ERRORWRONGDIM ERRX(ERRORWRONGDIM)
RandomFields/src/Error.h:#define ERRORTOOMANYLINES ERRX(ERRORTOOMANYLINES)
RandomFields/src/Error.h:#define ERRORNOVARIOGRAM ERRX(ERRORNOVARIOGRAM)
RandomFields/src/Error.h:#define ERRORTBMCOMBI ERRX(ERRORTBMCOMBI)
RandomFields/src/Error.h:#define ERRORMAXVDIM ERRX(ERRORMAXVDIM)
RandomFields/src/Error.h:#define ERRORTOOMANYLOC ERRX(ERRORTOOMANYLOC)
RandomFields/src/Error.h:#define ERRORNORMALMIXTURE ERRX(ERRORNORMALMIXTURE)
RandomFields/src/Error.h:#define ERRORNOMULTIVARIATE ERRX(ERRORNOMULTIVARIATE)
RandomFields/src/Error.h:#define ERROR_MATRIX_SQUARE ERRX(ERROR_MATRIX_SQUARE) 
RandomFields/src/Error.h:#define ERROR_MATRIX_VDIM ERRX(ERROR_MATRIX_VDIM)
RandomFields/src/Error.h:#define ERROR_MATRIX_POSDEF ERRX(ERROR_MATRIX_POSDEF)
RandomFields/src/Error.h:#define ERRORCEDIM ERRX(ERRORCEDIM)
RandomFields/src/Error.h:#define ERRORDIAMETERNOTGIVEN ERRX(ERRORDIAMETERNOTGIVEN) 
RandomFields/src/Error.h:#define ERRORUNKNOWNMETHOD ERRX(ERRORUNKNOWNMETHOD)
RandomFields/src/Error.h:#define ERRORNOSTATMATCH ERRX(ERRORNOSTATMATCH)
RandomFields/src/Error.h:#define ERRORUNKNOWNMAXTYPE ERRX(ERRORUNKNOWNMAXTYPE)
RandomFields/src/Error.h:#define ERRORATOMP ERRX(ERRORATOMP)
RandomFields/src/Error.h:#define MSGLOCAL_NUMOK ERRX(MSGLOCAL_NUMOK)
RandomFields/src/Error.h:#define MSGLOCAL_JUSTTRY ERRX(MSGLOCAL_JUSTTRY)
RandomFields/src/Error.h:#define MSGLOCAL_ENDOFLIST ERRX(MSGLOCAL_ENDOFLIST)
RandomFields/src/Error.h:#define MSGLOCAL_SIGNPHI ERRX(MSGLOCAL_SIGNPHI)
RandomFields/src/Error.h:#define MSGLOCAL_SIGNPHIFST ERRX(MSGLOCAL_SIGNPHIFST)
RandomFields/src/Error.h:#define MSGLOCAL_SIGNPHISND ERRX(MSGLOCAL_SIGNPHISND)
RandomFields/src/Error.h:#define MSGLOCAL_INITINTRINSIC ERRX(MSGLOCAL_INITINTRINSIC)
RandomFields/src/Error.h:#define MSGLOCAL_FAILED ERRX(MSGLOCAL_FAILED)
RandomFields/src/Error.h:#define MSGLOCAL_NOPOSITIVEROOT ERRX(MSGLOCAL_NOPOSITIVEROOT)
RandomFields/src/Error.h:#define MSGLOCAL_NOTSYMMETRICMULTIVARIATE ERRX(MSGLOCAL_NOTSYMMETRICMULTIVARIATE)
RandomFields/src/Error.h:#define MSGLOCAL_WRONGRADII ERRX(MSGLOCAL_WRONGRADII)
RandomFields/src/Error.h:#define CERRORCHANGESYSTEM ERRC(ERRORCHANGESYSTEM)
RandomFields/src/Error.h://#define CERRORTRAFOSYSTEM ERRC(ERRORTRAFOSYSTEM)
RandomFields/src/Error.h:#define CERRORBADVDIM ERRC(ERRORBADVDIM)
RandomFields/src/Error.h:#define CERRORVDIMNOTPROGRAMMEDYET ERRC(ERRORVDIMNOTPROGRAMMEDYET)
RandomFields/src/Error.h:#define CERRORDECOMPOSITION ERRC(ERRORDECOMPOSITION)
RandomFields/src/Error.h:#define CERRORRANDOMKAPPA ERRC(ERRORRANDOMKAPPA)
RandomFields/src/Error.h:#define CERRORSUBMETHODFAILED ERRC(ERRORSUBMETHODFAILED)
RandomFields/src/Error.h:#define CERRORMAXDIMMETH ERRC(ERRORMAXDIMMETH)
RandomFields/src/Error.h:#define CERRORINVALIDMODEL ERRC(ERRORINVALIDMODEL)
RandomFields/src/Error.h:#define CERRORODDMODEL ERRC(ERRORODDMODEL)
RandomFields/src/Error.h:#define CERROROUTOFMETHODLIST ERRC(ERROROUTOFMETHODLIST)
RandomFields/src/Error.h:#define CERRORWRONGDOM ERRC(ERRORWRONGDOM)
RandomFields/src/Error.h:#define CERRORWRONGDIM ERRC(ERRORWRONGDIM)
RandomFields/src/Error.h:#define CERRORTOOMANYLINES ERRC(ERRORTOOMANYLINES)
RandomFields/src/Error.h:#define CERRORNOVARIOGRAM ERRC(ERRORNOVARIOGRAM)
RandomFields/src/Error.h:#define CERRORTBMCOMBI ERRC(ERRORTBMCOMBI)
RandomFields/src/Error.h:#define CERRORMAXVDIM ERRC(ERRORMAXVDIM)
RandomFields/src/Error.h:#define CERRORTOOMANYLOC ERRC(ERRORTOOMANYLOC)
RandomFields/src/Error.h:#define CERRORNORMALMIXTURE ERRC(ERRORNORMALMIXTURE)
RandomFields/src/Error.h:#define CERRORNOMULTIVARIATE ERRC(ERRORNOMULTIVARIATE)
RandomFields/src/Error.h:#define CERROR_MATRIX_SQUARE ERRC(ERROR_MATRIX_SQUARE) 
RandomFields/src/Error.h:#define CERROR_MATRIX_VDIM ERRC(ERROR_MATRIX_VDIM)
RandomFields/src/Error.h:#define CERROR_MATRIX_POSDEF ERRC(ERROR_MATRIX_POSDEF)
RandomFields/src/Error.h:#define CERRORCEDIM ERRC(ERRORCEDIM)
RandomFields/src/Error.h:#define CERRORDIAMETERNOTGIVEN ERRC(ERRORDIAMETERNOTGIVEN) 
RandomFields/src/Error.h:#define CERRORUNKNOWNMETHOD ERRC(ERRORUNKNOWNMETHOD)
RandomFields/src/Error.h:#define CERRORNOSTATMATCH ERRC(ERRORNOSTATMATCH)
RandomFields/src/Error.h:#define CERRORUNKNOWNMAXTYPE ERRC(ERRORUNKNOWNMAXTYPE)
RandomFields/src/Error.h:#define CERRORATOMP ERRC(ERRORATOMP)
RandomFields/src/Error.h:#define CMSGLOCAL_NUMOK ERRC(MSGLOCAL_NUMOK)
RandomFields/src/Error.h:#define CMSGLOCAL_JUSTTRY ERRC(MSGLOCAL_JUSTTRY)
RandomFields/src/Error.h:#define CMSGLOCAL_ENDOFLIST ERRC(MSGLOCAL_ENDOFLIST)
RandomFields/src/Error.h:#define CMSGLOCAL_SIGNPHI ERRC(MSGLOCAL_SIGNPHI)
RandomFields/src/Error.h:#define CMSGLOCAL_SIGNPHIFST ERRC(MSGLOCAL_SIGNPHIFST)
RandomFields/src/Error.h:#define CMSGLOCAL_SIGNPHISND ERRC(MSGLOCAL_SIGNPHISND)
RandomFields/src/Error.h:#define CMSGLOCAL_INITINTRINSIC ERRC(MSGLOCAL_INITINTRINSIC)
RandomFields/src/Error.h:#define CMSGLOCAL_FAILED ERRC(MSGLOCAL_FAILED)
RandomFields/src/Error.h:#define CMSGLOCAL_NOPOSITIVEROOT ERRC(MSGLOCAL_NOPOSITIVEROOT)
RandomFields/src/Error.h:#define CMSGLOCAL_NOTSYMMETRICMULTIVARIATE ERRC(MSGLOCAL_NOTSYMMETRICMULTIVARIATE)
RandomFields/src/Error.h:#define CMSGLOCAL_WRONGRADII ERRC(MSGLOCAL_WRONGRADII)
RandomFields/src/Error.h:#define CERRORM ERRC(ERRORM)
RandomFields/src/Error.h:#define TOOLS_METHOD 372
RandomFields/src/Error.h:#define TOOLS_DIM 373
RandomFields/src/Error.h:#define MATRIX_NOT_CHECK_YET -999  /* must be a negative value that isn't used somewhere else ! */
Binary file RandomFields/src/extremes.o matches
Binary file RandomFields/src/operator.extremes.o matches
RandomFields/src/circulant.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/circulant.cc: Copyright (C) 2001 -- 2003 Martin Schlather
RandomFields/src/circulant.cc: Copyright (C) 2004 -- 2005 Yindeng Jiang & Martin Schlather
RandomFields/src/circulant.cc: Copyright (C) 2006 -- 2011 Martin Schlather
RandomFields/src/circulant.cc: Copyright (C) 2011 -- 2015 Peter Menck & Martin Schlather
RandomFields/src/circulant.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/circulant.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/circulant.cc:#include <R_ext/Lapack.h> // MULT 
RandomFields/src/circulant.cc:/*           CIRCULANT EMBEDDING METHOD (1994) ALGORITHM             */
RandomFields/src/circulant.cc:  if ((FFT->work = (double*) MALLOC(4 * maxmaxf * sizeof(double)))==NULL || 
RandomFields/src/circulant.cc:	(FFT->iwork = (int*) MALLOC(maxmaxp  * sizeof(int)))==NULL) { 
RandomFields/src/circulant.cc:    Err=ERRORMEMORYALLOCATION; goto ErrorHandling;
RandomFields/src/circulant.cc:      MEMCOPY(nfac, FFT->NFAC[i], sizeof(int) * 21);
RandomFields/src/circulant.cc:#define LOCPROC_DIAM  (CE_LAST + 1)// parameter p
RandomFields/src/circulant.cc:  double  steps[MAXCEDIM], 
RandomFields/src/circulant.cc:  Long  hilfsm[MAXCEDIM],
RandomFields/src/circulant.cc:    maxGB = P0(CE_MAXGB),
RandomFields/src/circulant.cc:    tolIm = P0(CE_TOLIM),
RandomFields/src/circulant.cc:    *mmin = P(CE_MMIN);
RandomFields/src/circulant.cc:  int dim = OWNLOGDIM(0),
RandomFields/src/circulant.cc:    dimM1 = dim - 1,
RandomFields/src/circulant.cc:    vdim   = VDIM0,
RandomFields/src/circulant.cc:    lenmmin = cov->nrow[CE_MMIN],
RandomFields/src/circulant.cc:    vdimSq = vdim * vdim, // PM 12/12/2008
RandomFields/src/circulant.cc:    maxmem = P0INT(CE_MAXMEM),
RandomFields/src/circulant.cc:    useprimes = (bool) P0INT(CE_USEPRIMES),
RandomFields/src/circulant.cc:  double *tmp = (double *) MALLOC(vdim * vdim * sizeof(double)),	
RandomFields/src/circulant.cc:    *tmpLambda = (double *) MALLOC(vdim * sizeof(double)), 
RandomFields/src/circulant.cc:    *rwork = (double *) MALLOC( (vdim * 3 -2) * sizeof(double));
RandomFields/src/circulant.cc:    *R = (complex*) MALLOC(vdim * vdim * sizeof(complex)),
RandomFields/src/circulant.cc:    *work = (complex *) MALLOC(worksize * sizeof(complex));
RandomFields/src/circulant.cc:assert(VDIM0 == VDIM1);
RandomFields/src/circulant.cc:  if (dim > MAXCEDIM) RETURN_ERR(ERRORMAXDIMMETH);
RandomFields/src/circulant.cc:  // PM 12/12/2008
RandomFields/src/circulant.cc:  multivariate = VDIM0 > 1;
RandomFields/src/circulant.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/circulant.cc:        GERR3("Minimum size in direction %d is %10g. Got %10g\n",
RandomFields/src/circulant.cc:    if (hilfsm_d >=  MAXINT) {err=ERRORMEMORYALLOCATION; goto ErrorHandling;}
RandomFields/src/circulant.cc:    if (hilfsm_d >=  MAXINT) {err=ERRORMEMORYALLOCATION; goto ErrorHandling;}
RandomFields/src/circulant.cc:      if (hilfsm[i] < MAXINT) {
RandomFields/src/circulant.cc:	GERR3("Each direction allows for at most %d points. Got %d in the %d-th direction", (int) MAXINT, (int) hilfsm[i], i);
RandomFields/src/circulant.cc:      LPRINT("Memory need for ");
RandomFields/src/circulant.cc:	    realmtot * vdimSq, CE[CE_MAXMEM - COMMON_GAUSS - 1], 
RandomFields/src/circulant.cc:	    maxmem, CE[CE_MAXMEM - COMMON_GAUSS - 1])
RandomFields/src/circulant.cc:	    realmtot* vdimSq * 32e-9, CE[CE_MAXGB - COMMON_GAUSS - 1], 
RandomFields/src/circulant.cc:	    maxGB, CE[CE_MAXGB - COMMON_GAUSS - 1]);
RandomFields/src/circulant.cc:    if ((c = (double **) MALLOC(vdimSq * sizeof(double *))) == NULL) {
RandomFields/src/circulant.cc:      err=ERRORMEMORYALLOCATION; goto ErrorHandling;
RandomFields/src/circulant.cc:      if( (c[l] = (double *) MALLOC(2L * mtot * sizeof(double))) == NULL) {
RandomFields/src/circulant.cc:	err=ERRORMEMORYALLOCATION; goto ErrorHandling;
RandomFields/src/circulant.cc:     int index[MAXCEDIM],
RandomFields/src/circulant.cc:     double hx[MAXCEDIM];
RandomFields/src/circulant.cc:	double z[MAXCEDIM];
RandomFields/src/circulant.cc:    if( (Lambda = (double **) MALLOC(vdim * sizeof(double *))) == NULL) {
RandomFields/src/circulant.cc:      err=ERRORMEMORYALLOCATION; goto ErrorHandling;
RandomFields/src/circulant.cc:      if( (Lambda[l] = (double *) MALLOC(mtot * sizeof(double))) == NULL) {
RandomFields/src/circulant.cc:	err=ERRORMEMORYALLOCATION; goto ErrorHandling;
RandomFields/src/circulant.cc:	  //// optim_lwork.r  von den Werten der Matrix ab ??
RandomFields/src/circulant.cc:	  //  INTEGER FUNCTION ILAENV( ISPEC, NAME, OPTS, N1, N2, N3, N4 )
RandomFields/src/circulant.cc:  //     C2 = SUBNAM( 2: 3 )
RandomFields/src/circulant.cc:  //    C3 = SUBNAM( 4: 6 )
RandomFields/src/circulant.cc:      for (int i=0; i<mtot; i++) { // MULT
RandomFields/src/circulant.cc:	      err=ERRORMEMORYALLOCATION; goto ErrorHandling;
RandomFields/src/circulant.cc:	    double cc, maxcc, hx[MAXCEDIM];
RandomFields/src/circulant.cc:	      // MUSS HIER ETWAS GEAENDERT WERDEN FUER MULTIVARIAT?
RandomFields/src/circulant.cc:    // tolerance CIRCEMBED.tol_re/CIRCEMBED.tol_im 
RandomFields/src/circulant.cc:    r = Lambda[0][0]; // MULT
RandomFields/src/circulant.cc:      err=ERRORMEMORYALLOCATION; goto ErrorHandling;
RandomFields/src/circulant.cc:	  err=ERRORMEMORYALLOCATION;goto ErrorHandling;
RandomFields/src/circulant.cc:  if ((s->gauss1 = (complex *) MALLOC(sizeof(complex) * vdim)) == NULL) {
RandomFields/src/circulant.cc:    err=ERRORMEMORYALLOCATION; goto ErrorHandling;
RandomFields/src/circulant.cc:  if ((s->gauss2 = (complex *) MALLOC(sizeof(complex) * vdim)) == NULL) {
RandomFields/src/circulant.cc:    err=ERRORMEMORYALLOCATION; goto ErrorHandling;
RandomFields/src/circulant.cc:  if (i == CE_MMIN) *nr = 0;
RandomFields/src/circulant.cc:    dim = ANYDIM; // taken[MAX DIM],
RandomFields/src/circulant.cc:  FRAME_ASSERT_GAUSS_INTERFACE;
RandomFields/src/circulant.cc:  if (PisNULL(CE_MMIN)) {
RandomFields/src/circulant.cc:    PALLOC(CE_MMIN, dim, 1);
RandomFields/src/circulant.cc:      P(CE_MMIN)[i] = gp->mmin[i];
RandomFields/src/circulant.cc:  kdefault(cov, CE_MAXGB, gp->maxGB);
RandomFields/src/circulant.cc:  kdefault(cov, CE_MAXMEM, (int) gp->maxmem);
RandomFields/src/circulant.cc:  kdefault(cov, CE_TOLIM, gp->tol_im);
RandomFields/src/circulant.cc:  kdefault(cov, CE_USEPRIMES, (int) gp->useprimes);
RandomFields/src/circulant.cc:  kdefault(cov, CE_APPROXMAXGRID, gp->maxgridsize);
RandomFields/src/circulant.cc:    dim = ANYDIM;
RandomFields/src/circulant.cc:  //  PMI0(cov); printf("%d %s\n", hasInterfaceFrame(cov->calling), NAME(cov->calling));
RandomFields/src/circulant.cc:  FRAME_ASSERT_GAUSS_INTERFACE; 
RandomFields/src/circulant.cc:  ASSERT_ONESYSTEM;
RandomFields/src/circulant.cc:  if (dim > MAXCEDIM) RETURN_ERR(ERRORCEDIM);
RandomFields/src/circulant.cc:  if (Loctsdim(cov) > MAXCEDIM || OWNTOTALXDIM > MAXCEDIM)
RandomFields/src/circulant.cc:    RETURN_ERR(ERRORCEDIM);
RandomFields/src/circulant.cc:    if ((err = CHECK_PASSFRAME(cov->key, GaussMethodType)) != NOERROR) {
RandomFields/src/circulant.cc:       //PMI(cov->key); XERR(err);
RandomFields/src/circulant.cc:		     SUBMODEL_DEP, GaussMethodType)) != NOERROR) {
RandomFields/src/circulant.cc:      //      APMI(cov);
RandomFields/src/circulant.cc:      //    XERR(err); APMI(cov);
RandomFields/src/circulant.cc:      if ((err = CHECK(next, dim, dim, VariogramType, XONLY, SYMMETRIC, 
RandomFields/src/circulant.cc:		       SUBMODEL_DEP, GaussMethodType)) != NOERROR) {
RandomFields/src/circulant.cc:      //PMI(cov);
RandomFields/src/circulant.cc:  case CE_MMIN : 
RandomFields/src/circulant.cc:  case CE_MAXGB :
RandomFields/src/circulant.cc:  case CE_MAXMEM :
RandomFields/src/circulant.cc:    range->max = MAXINT;
RandomFields/src/circulant.cc:  case CE_TOLIM :
RandomFields/src/circulant.cc:    BooleanRange(CE_USEPRIMES);
RandomFields/src/circulant.cc:  case CE_APPROXMAXGRID :
RandomFields/src/circulant.cc:  int  HalfMp1[MAXCEDIM], HalfMaM[2][MAXCEDIM], index[MAXCEDIM], 
RandomFields/src/circulant.cc:    dim, *mm, *cumm, *halfm, // MULT added vars l, pos
RandomFields/src/circulant.cc:    *res = cov->rf; // MULT *c->**c
RandomFields/src/circulant.cc:  bool vfree[MAXCEDIM+1], noexception; // MULT varname free->vfree
RandomFields/src/circulant.cc:  Long mtot, start[MAXCEDIM], end[MAXCEDIM];
RandomFields/src/circulant.cc:  dim = OWNLOGDIM(0);
RandomFields/src/circulant.cc:    HalfMp1[i] =  ((mm[i] % 2)==1) ? -1 : halfm[i];
RandomFields/src/circulant.cc:    HalfMaM[0][i] = halfm[i];
RandomFields/src/circulant.cc:    HalfMaM[1][i] = mm[i] - 1;
RandomFields/src/circulant.cc:  //bool *xx; xx = (bool*) MALLOC(sizeof(bool) * mtot);
RandomFields/src/circulant.cc:  vfree[MAXCEDIM] = false;
RandomFields/src/circulant.cc:  // PM 12/12/2008
RandomFields/src/circulant.cc:    // MULT
RandomFields/src/circulant.cc:	if ((index[k]==0) || (index[k]==HalfMp1[k])) {
RandomFields/src/circulant.cc:	  gauss1[k].r = GAUSS_RANDOM(1.0);
RandomFields/src/circulant.cc:	  gauss1[k].i = GAUSS_RANDOM(1.0);
RandomFields/src/circulant.cc:	  gauss2[k].r = GAUSS_RANDOM(1.0);
RandomFields/src/circulant.cc:	  gauss2[k].i = GAUSS_RANDOM(1.0);
RandomFields/src/circulant.cc:	  gauss1[k].r = GAUSS_RANDOM(1.0);
RandomFields/src/circulant.cc:	  gauss1[k].i = GAUSS_RANDOM(1.0);
RandomFields/src/circulant.cc:      if (++index[k]>HalfMaM[vfree[k]][k]) {
RandomFields/src/circulant.cc:	while((k<dim) && (++index[k]>HalfMaM[vfree[k]][k])) {
RandomFields/src/circulant.cc:    // MULT
RandomFields/src/circulant.cc:  Long totpts = loc->totalpoints; // MULT
RandomFields/src/circulant.cc:    for(l=0; l<vdim; l++) { // MULT
RandomFields/src/circulant.cc:    for (int l=0; l<vdim; l++) { // MULT
RandomFields/src/circulant.cc:  double *s=NULL, G[MAXCEDIM+1], e[MAXCEDIM], D[MAXCEDIM], *V=NULL;
RandomFields/src/circulant.cc:  s = (double*) MALLOC(dimsq * sizeof(double));
RandomFields/src/circulant.cc:  V = (double*) MALLOC(dimsq * sizeof(double));
RandomFields/src/circulant.cc:    F77_NAME(dsvdc)(s, &dim, &dim, &dim, D, // SVD
RandomFields/src/circulant.cc:    dim = ANYDIM,
RandomFields/src/circulant.cc:  FRAME_ASSERT_GAUSS_INTERFACE;
RandomFields/src/circulant.cc:  ASSERT_ONESYSTEM;
RandomFields/src/circulant.cc:   if (dim > MAXCEDIM) RETURN_ERR(ERRORCEDIM);
RandomFields/src/circulant.cc:      *RMintrinsic = key->sub[0];
RandomFields/src/circulant.cc:    while (intern != NULL && MODELNR(intern) != CE_INTRINPROC_INTERN &&
RandomFields/src/circulant.cc:	   MODELNR(intern) != CE_CUTOFFPROC_INTERN) {
RandomFields/src/circulant.cc:    else if (MODELNR(key) == CE_INTRINPROC_INTERN || 
RandomFields/src/circulant.cc:	     MODELNR(key) == CE_CUTOFFPROC_INTERN) { 
RandomFields/src/circulant.cc:      //if (RMintrinsic->nr == GAUSSPROC) RMintrinsic = RMintrinsic->sub[0];
RandomFields/src/circulant.cc:      if (MODELNR(RMintrinsic) != CUTOFF && MODELNR(RMintrinsic) != STEIN) {
RandomFields/src/circulant.cc:      if (!PisNULL(LOCPROC_DIAM)) 
RandomFields/src/circulant.cc:	kdefault(RMintrinsic, pLOC_DIAM, P0(LOCPROC_DIAM));
RandomFields/src/circulant.cc:	kdefault(RMintrinsic, pLOC_DIAM, P0(LOCPROC_R));
RandomFields/src/circulant.cc:		     SUBMODEL_DEP, GaussMethodType)) != NOERROR) {
RandomFields/src/circulant.cc:      if (PisNULL(LOCPROC_DIAM))
RandomFields/src/circulant.cc:	kdefault(cov, LOCPROC_DIAM, PARAM0(RMintrinsic, pLOC_DIAM));  
RandomFields/src/circulant.cc:              XONLY, ISOTROPIC, SUBMODEL_DEP, GaussMethodType))
RandomFields/src/circulant.cc:       if (isDollar(next) && !PARAMisNULL(next, DANISO)) {
RandomFields/src/circulant.cc:             XONLY, ISOTROPIC, SUBMODEL_DEP, GaussMethodType);
RandomFields/src/circulant.cc:       // PMI(cov, "out");
RandomFields/src/circulant.cc:  VDIM0 = VDIM1 = sub->vdim[0];
RandomFields/src/circulant.cc:    cncol = ANYDIM,
RandomFields/src/circulant.cc:  double grid_ext[MAXCEDIM], old_mmin[MAXCEDIM];
RandomFields/src/circulant.cc:    *mmin = P(CE_MMIN);
RandomFields/src/circulant.cc:  ASSERT_ONESYSTEM;
RandomFields/src/circulant.cc:	loc->cani_ncol != timespacedim) RETURN_ERR(ERRORCEDIM);
RandomFields/src/circulant.cc:  //printf("diameter %d \n",LOCPROC_DIAM); APMI(cov);
RandomFields/src/circulant.cc:  if (!PARAMisNULL(key->sub[0], LOCPROC_R))
RandomFields/src/circulant.cc:    kdefault(key, pLOC_DIAM, P0(LOCPROC_R));
RandomFields/src/circulant.cc:  PARAMFREE(key, CE_MMIN);
RandomFields/src/circulant.cc:  PARAMALLOC(key, CE_MMIN, ANYDIM, 1);
RandomFields/src/circulant.cc:  PCOPY(key, cov, CE_MMIN);
RandomFields/src/circulant.cc:  kdefault(key, CE_MAXGB, P0(CE_MAXGB));
RandomFields/src/circulant.cc:  kdefault(key, CE_MAXMEM, P0INT(CE_MAXMEM));
RandomFields/src/circulant.cc:  kdefault(key, CE_TOLIM, P0(CE_TOLIM));
RandomFields/src/circulant.cc:  kdefault(key, CE_USEPRIMES, P0INT(CE_USEPRIMES));
RandomFields/src/circulant.cc:  //  APMI(key);
RandomFields/src/circulant.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/circulant.cc:  err = CHECK_PASSTF(key, GaussMethodType, VDIM0, GaussMethodType);
RandomFields/src/circulant.cc:  //	      GaussMethodType,
RandomFields/src/circulant.cc:  //            OWNDOM(0), OWNISO(0), SUBMODEL_DEP, GaussMethodType); 
RandomFields/src/circulant.cc:  if ((err < MSGLOCAL_OK && err != NOERROR) 
RandomFields/src/circulant.cc:      || err >=MSGLOCAL_ENDOFLIST // 30.5.13 : neu
RandomFields/src/circulant.cc:      if (q->msg != MSGLOCAL_OK) {
RandomFields/src/circulant.cc:	if (!DefList[MODELNR(local)].alternative(local)) break;
RandomFields/src/circulant.cc:  // APMI(cov);
RandomFields/src/circulant.cc:  addModelKey(cov, cutoff ? CUTOFF : STEIN);
RandomFields/src/circulant.cc:  addModelKey(cov, CIRCEMBED);
RandomFields/src/circulant.cc:  // erst danach bzw. innerhalb von init der check zum ersten Mal
RandomFields/src/circulant.cc:  //APMI(cov);
RandomFields/src/circulant.cc:     vdim = VDIM0;
RandomFields/src/circulant.cc:    //PMI(sub);
RandomFields/src/circulant.cc:    // PMI(sub);
RandomFields/src/circulant.cc:    if ( VDIM0 > 1) {
RandomFields/src/circulant.cc:        double normal1 = GAUSS_RANDOM(1.0),
RandomFields/src/circulant.cc:	  normal2 = GAUSS_RANDOM(1.0),
RandomFields/src/circulant.cc:  if (i == CE_MMIN) *nr = 0;
RandomFields/src/circulant.cc:  case LOCPROC_DIAM : 
RandomFields/src/circulant.cc:    range->min = 0.0; //  CUTOFF_DIAM
RandomFields/src/circulant.cc:  case LOCPROC_DIAM : 
RandomFields/src/circulant.cc:    range->min = 0.0; //  CUTOFF_DIAM
RandomFields/src/circulant.cc:  double x[MAXCEDIM], dx[MAXCEDIM],  
RandomFields/src/circulant.cc:  Long index[MAXCEDIM];
RandomFields/src/circulant.cc:    dim = ANYDIM,
RandomFields/src/circulant.cc:  // PMI(cov->calling);
RandomFields/src/circulant.cc: #ifdef SCHLATHERS_MACHUINE
RandomFields/src/circulant.cc:  //  PMI(cov->calling);
RandomFields/src/circulant.cc:      double normal = GAUSS_RANDOM(1.0);
RandomFields/src/circulant.cc:      double normal = GAUSS_RANDOM(1.0);
RandomFields/src/circulant.cc:	 || COVNR==CIRCEMBED);
RandomFields/src/circulant.cc:  if (next->pref[COVNR==CIRCEMBED ? CircEmbed : 
RandomFields/src/circulant.cc:  //PMI(cov);
RandomFields/src/circulant.cc:    ASSERT_NEWMODEL_NULL;
RandomFields/src/circulant.cc:    double max[MAXCEDIM], min[MAXCEDIM],  centre[MAXCEDIM], 
RandomFields/src/circulant.cc:      x[3 * MAXCEDIM],
RandomFields/src/circulant.cc:      maxgridsize = P0INT(CE_APPROXMAXGRID),
RandomFields/src/circulant.cc:    if (OWNTOTALXDIM  != Loctsdim(cov))
RandomFields/src/circulant.cc:			 VDIM0, VDIM1, GaussMethodType, false))
RandomFields/src/circulant.cc:	//	     cov->domprev, cov->isoprev, VDIM0, cov->fr  ame)  
RandomFields/src/circulant.cc:  if (COVNR == CIRCEMBED) { RETURN_NOERROR; }
RandomFields/src/circulant.cc:    if (COVNR==CIRCEMBED) return init_circ_embed(cov, S);
RandomFields/src/circulant.cc: Long i, cumgridlen[MAXCEDIM], 
RandomFields/src/circulant.cc:    // maxgridsize = P0INT(CE_APPROXMAXGRID),
RandomFields/src/circulant.cc:   dim = ANYDIM;
RandomFields/src/circulant.cc:  ASSERT_ONESYSTEM;
RandomFields/src/circulant.cc:  cov->method = COVNR==CIRCEMBED ? CircEmbed 
RandomFields/src/circulant.cc:  if (COVNR==CIRCEMBED) err = init_circ_embed(cov->key, S);
RandomFields/src/circulant.cc:    if (COVNR==CIRCEMBED) do_circ_embed(cov, S);
RandomFields/src/circulant.cc:  //  PMI(cov);
RandomFields/src/circulant.cc:     vdim = VDIM0,
RandomFields/src/circulant.cc:  // APMI(key);
RandomFields/src/operator.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/operator.cc: Copyright (C) 2005 -- 2017 Martin Schlather
RandomFields/src/operator.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/operator.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/operator.cc:#define MAXCOMPONENTS 6
RandomFields/src/operator.cc:model = RM e x p()
RandomFields/src/operator.cc:RFcov(RMbernoulli(m odel, t=t), LOG(x))
RandomFields/src/operator.cc:  double a, var, V, r, expMa, Vd,
RandomFields/src/operator.cc:    *v = ((M_1_PI * ASIN(r / var) + 0.5) - p) * p;
RandomFields/src/operator.cc:    expMa = EXP(-a);
RandomFields/src/operator.cc:    double ad = expMa;
RandomFields/src/operator.cc:    vdim = VDIM0,
RandomFields/src/operator.cc:  if (VDIM0 != VDIM1) BUG;
RandomFields/src/operator.cc:  //		     OWNDOM(0), OWNISO(0),
RandomFields/src/operator.cc:  //		     SUBMODEL_DEP, cov->frame)) != NOERROR) RETURN_ERR(err);
RandomFields/src/operator.cc:  int maxv = MIN(vdim, MAXMPPVDIM);
RandomFields/src/operator.cc:#define MASTEIN_NU 0
RandomFields/src/operator.cc:#define MASTEIN_DELTA 1
RandomFields/src/operator.cc:#define MASTEIN_MAXNU 80
RandomFields/src/operator.cc:void MaStein(double *x, int *info, model *cov, double *v) {
RandomFields/src/operator.cc:    nu = P0(MASTEIN_NU),
RandomFields/src/operator.cc:    delta = P0(MASTEIN_DELTA);
RandomFields/src/operator.cc:  if (nuG >= (double) MASTEIN_MAXNU) {
RandomFields/src/operator.cc:    ERR("Whittle Matern function cannot be evaluated with parameter value b+g(t) greater than 80.");
RandomFields/src/operator.cc:    bk[MASTEIN_MAXNU + 1L];
RandomFields/src/operator.cc:int check_MaStein(model *cov) {
RandomFields/src/operator.cc:  ASSERT_ONESYSTEM;
RandomFields/src/operator.cc:  if (OWNTOTALXDIM != 2) SERR("reduced dimension must be 2");
RandomFields/src/operator.cc:		   SYMMETRIC, SCALAR, EvaluationType)) != NOERROR)
RandomFields/src/operator.cc:  if (cov->ncol[MASTEIN_NU] != 1 || cov->nrow[MASTEIN_NU] != 1) 
RandomFields/src/operator.cc:  if (cov->ncol[MASTEIN_DELTA] != 1 || cov->nrow[MASTEIN_DELTA] != 1) 
RandomFields/src/operator.cc:  set_maxdim(OWN, 0, MAXDIM(NEXT, 0));
RandomFields/src/operator.cc:void range_MaStein(model *cov, range_type *range){
RandomFields/src/operator.cc:  range->min[MASTEIN_NU] = 0.0; // 
RandomFields/src/operator.cc:  range->max[MASTEIN_NU] = RF_INF;
RandomFields/src/operator.cc:  range->pmin[MASTEIN_NU] = 1e-2;
RandomFields/src/operator.cc:  range->pmax[MASTEIN_NU] = 10.0;
RandomFields/src/operator.cc:  range->openmin[MASTEIN_NU] = true;
RandomFields/src/operator.cc:  range->openmax[MASTEIN_NU] = true;
RandomFields/src/operator.cc:  range->min[MASTEIN_DELTA] = 0.5 * (double) (OWNLOGDIM(0) - 1); // d
RandomFields/src/operator.cc:  range->max[MASTEIN_DELTA] = RF_INF;
RandomFields/src/operator.cc:  range->pmin[MASTEIN_DELTA] = range->min[MASTEIN_DELTA];
RandomFields/src/operator.cc:  range->pmax[MASTEIN_DELTA] = 10;
RandomFields/src/operator.cc:  range->openmin[MASTEIN_DELTA] = false;
RandomFields/src/operator.cc:  range->openmax[MASTEIN_DELTA] = true;
RandomFields/src/operator.cc:  *nc = SIZE_NOT_DETERMINED;
RandomFields/src/operator.cc:  *nr = i < DefList[COVNR].kappas  ? OWNLOGDIM(0) : -1;
RandomFields/src/operator.cc:  double y[ShiftMaxDim],
RandomFields/src/operator.cc:    z[ShiftMaxDim] = { RF_NAN },
RandomFields/src/operator.cc:    logicaldim = OWNLOGDIM(0),
RandomFields/src/operator.cc:    vdim = VDIM0,
RandomFields/src/operator.cc:    vdimM1 = vdim - 1,
RandomFields/src/operator.cc:  for (jh=h-logicaldim, j=-1; j<vdimM1; j++, jh+=logicaldim) {
RandomFields/src/operator.cc:    for (ih=h-logicaldim, i=-1; i<vdimM1; i++, ih+=logicaldim, pv++) {
RandomFields/src/operator.cc:  if (OWNTOTALXDIM > ShiftMaxDim)
RandomFields/src/operator.cc:	  StpMaxDim, OWNXDIM(0));
RandomFields/src/operator.cc:  COPYALLSYSTEMS(PREVSYSOF(next), OWN, false);
RandomFields/src/operator.cc:  //		     (dim > 1) ? SYMMETRIC : ISOTROPIC, 
RandomFields/src/operator.cc:  VDIM0 = VDIM1 = cov->ncol[SHIFT_DELAY] + 1;
RandomFields/src/operator.cc:    logicaldim = OWNLOGDIM(0),
RandomFields/src/operator.cc:    xdim = OWNXDIM(0),
RandomFields/src/operator.cc:   dim = OWNLOGDIM(0);
RandomFields/src/operator.cc:   // isotropy_type isotropy = OWNDOM(0);
RandomFields/src/operator.cc:  if ((err = CHECK(next, dim, 1, PosDefType, OWNDOM(0), ISOTROPIC,
RandomFields/src/operator.cc:    if ((err = CHECK(next, dim, dim, PosDefType, OWNDOM(0),
RandomFields/src/operator.cc:		     SYMMETRIC, SCALAR, EvaluationType)) != NOERROR) {
RandomFields/src/operator.cc:  int diffpref = MIN(2, PREF_BEST - cov->pref[CircEmbed]);
RandomFields/src/operator.cc:  int maxv = MIN(dim, MAXMPPVDIM);
RandomFields/src/operator.cc:  VDIM0 = VDIM1 = P0INT(VECTOR_D);
RandomFields/src/operator.cc:  range->max[VECTOR_D] = OWNLOGDIM(0);
RandomFields/src/operator.cc:  *nr = i == 0  ? SIZE_NOT_DETERMINED : -1;
RandomFields/src/operator.cc:     logicaldim = OWNLOGDIM(0),
RandomFields/src/operator.cc:      dimP2sqM1 =  dimP2 * dimP2 -1; // for three dimensions much
RandomFields/src/operator.cc:    for (i=0; i<=dimP2sqM1; i++) v[i] = 0.0;
RandomFields/src/operator.cc:    for (i=dimP3; i<dimP2sqM1; i+=dimP3) v[i] = diag; // diag 2,3
RandomFields/src/operator.cc:    N->D4(norm, info, next, v + dimP2sqM1);
RandomFields/src/operator.cc:    v[dimP2sqM1] *= (8.0 / 3.0); 
RandomFields/src/operator.cc:    N->D4(norm, info, next, v + dimP2sqM1); // rechts unten 
RandomFields/src/operator.cc:    v[dimP2sqM1] += 2.0 * D3n - D2nsq + D1n3;
RandomFields/src/operator.cc:      logicaldim = OWNLOGDIM(0),
RandomFields/src/operator.cc:      dimP2sqM1 =  dimP2 * dimP2 -1; // for three dimensions much
RandomFields/src/operator.cc:  double dummy[MAXCOMPONENTS * MAXCOMPONENTS];
RandomFields/src/operator.cc:    for (i=0; i<=dimP2sqM1; i++) v[i] = 0.0;
RandomFields/src/operator.cc:    for (i=dimP3; i<dimP2sqM1; i+=dimP3) v[i] = diag;  // diag 2,3
RandomFields/src/operator.cc:    N->D4(norm, info, next, v + dimP2sqM1);
RandomFields/src/operator.cc:    v[dimP2sqM1] *= (8.0 / 3.0);    
RandomFields/src/operator.cc:    N->D4(norm, info, next, v + dimP2sqM1); // rechts unten 
RandomFields/src/operator.cc:    v[dimP2sqM1] += 2.0 * D3n - D2nsq + D1n3;
RandomFields/src/operator.cc:    totaldim = OWNLOGDIM(0),
RandomFields/src/operator.cc:  // statt STATIONARY : VARIOGRAM ?? s. Paper mit Scheuerer
RandomFields/src/operator.cc:  if ((err = CHECK(next, totaldim, 1, PosDefType, OWNDOM(0), ISOTROPIC,
RandomFields/src/operator.cc:    if ((err = CHECK(next, totaldim, 1, PosDefType, OWNDOM(0), DOUBLEISOTROPIC,
RandomFields/src/operator.cc:    SERR1("model '%.50s' currently coded only for dim=2", NAME(cov));
RandomFields/src/operator.cc:  int diffpref = MIN(2, PREF_BEST - cov->pref[CircEmbed]);
RandomFields/src/operator.cc:  if (components > MAXCOMPONENTS) SERR("dimension of space too large");
RandomFields/src/operator.cc:	      KNAME(i), i+1, PINT(DIVCURL_WHICH)[i], components);
RandomFields/src/operator.cc:  int maxv = MIN(totaldim, MAXMPPVDIM);
RandomFields/src/operator.cc:  VDIM0 = VDIM1 = nwhich;
RandomFields/src/operator.cc:  int  dim = OWNLOGDIM(0),
RandomFields/src/operator.cc:#define MA1_ALPHA 0
RandomFields/src/operator.cc:#define MA1_BETA 1
RandomFields/src/operator.cc:    alpha = P0(MA1_ALPHA),
RandomFields/src/operator.cc:    theta = P0(MA1_BETA);
RandomFields/src/operator.cc:  if ((err = CHECK_PASSFRAME(next, EvaluationType)) != NOERROR) RETURN_ERR(err);
RandomFields/src/operator.cc:  //  if ((err = CHECK(next, cov->tsdim, cov->xdimown, PosDefType, OWNDOM(0),
RandomFields/src/operator.cc:  range->min[MA1_ALPHA] = 0.0;
RandomFields/src/operator.cc:  range->max[MA1_ALPHA] = RF_INF;
RandomFields/src/operator.cc:  range->pmin[MA1_ALPHA] = 0.01;
RandomFields/src/operator.cc:  range->pmax[MA1_ALPHA] = 10;
RandomFields/src/operator.cc:  range->openmin[MA1_ALPHA] = true;
RandomFields/src/operator.cc:  range->openmax[MA1_ALPHA] = true;
RandomFields/src/operator.cc:  range->min[MA1_BETA] = 0.0;
RandomFields/src/operator.cc:  range->max[MA1_BETA] = 1.0;
RandomFields/src/operator.cc:  range->pmin[MA1_BETA] = 0.0;
RandomFields/src/operator.cc:  range->pmax[MA1_BETA] = 1.0;
RandomFields/src/operator.cc:  range->openmin[MA1_BETA] = true;
RandomFields/src/operator.cc:  range->openmax[MA1_BETA] = true;
RandomFields/src/operator.cc:  //  if ((err = CHECK(next, cov->tsdim, cov->xdimown, VariogramType, OWNDOM(0),
RandomFields/src/operator.cc:void kappaM(int i, model *cov, int *nr, int *nc){
RandomFields/src/operator.cc:  *nc = SIZE_NOT_DETERMINED;
RandomFields/src/operator.cc:  *nr = i < DefList[COVNR].kappas  ? SIZE_NOT_DETERMINED : -1;
RandomFields/src/operator.cc:void M(model *cov, double *M1, double *Z,  double *M2, double *V) {
RandomFields/src/operator.cc:  // M C M^t
RandomFields/src/operator.cc:  assert(M2 != NULL);
RandomFields/src/operator.cc:    ncol = cov->ncol[M_M],
RandomFields/src/operator.cc:    nrow = cov->nrow[M_M];
RandomFields/src/operator.cc://      SUBROUTINE DGEMM(TRANSA,TRANSB,M,N,K, ALPHA,A,LDA,B,LDB, BETA,C,LDC)
RandomFields/src/operator.cc:// M : rows of op(A)
RandomFields/src/operator.cc:// LD-X : first dimension of X   \command{\link{RMflat}} \tab constant in space \cr
RandomFields/src/operator.cc:    if (cov->kappasub[M_M] == NULL && nsub == 1) {
RandomFields/src/operator.cc:      // V = Z * M1 %*% t(M2)
RandomFields/src/operator.cc:      //      printf("M:%10g %10g   %10g %10g (%d)\n", M1[0], M1[1], M2[0], M2[1], cov->zaehler);
RandomFields/src/operator.cc:      TALLOC_X1(Mz, nrow * ncol);  // !! ja nicht X1, da kollision mit 'Matrix'
RandomFields/src/operator.cc:	for (int j=0; j<nrow; j++) *(Mz++) = *(M1++) * zi;
RandomFields/src/operator.cc:      matmult_2ndtransp(Mz, M2, V, nrow, ncol, nrow);
RandomFields/src/operator.cc:    TALLOC_X1(Mz, nrow * ncol);// !! ja nicht X1, da kollision mit 'Matrix'
RandomFields/src/operator.cc:    matmult(M1, Z, Mz, nrow, ncol, ncol);   
RandomFields/src/operator.cc:    matmult_2ndtransp(Mz, M2, V, nrow, ncol, nrow);
RandomFields/src/operator.cc:    //printf("mz = %f %f; V=%f\n", Mz[0], Mz[1], *V);
RandomFields/src/operator.cc:void Mshape(model *cov, double *M1, double *Z,  double *V) {
RandomFields/src/operator.cc:  // M C M^t
RandomFields/src/operator.cc:    ncol = cov->ncol[M_M],
RandomFields/src/operator.cc:    nrow = cov->nrow[M_M],
RandomFields/src/operator.cc://      SUBROUTINE DGEMM(TRANSA,TRANSB,M,N,K, ALPHA,A,LDA,B,LDB, BETA,C,LDC)
RandomFields/src/operator.cc:// M : rows of op(A)
RandomFields/src/operator.cc:// LD-X : first dimension of X   \command{\link{RMflat}} \tab constant in space \cr
RandomFields/src/operator.cc:    if (cov->kappasub[M_M] == NULL && nsub == 1) {
RandomFields/src/operator.cc:      for (int i=0; i<nrow; i++) V[i] = M1[i] * z;
RandomFields/src/operator.cc:	for (int j=0; j<nrow; j++) *(p++) += *(M1++) * zi;
RandomFields/src/operator.cc:    matmult(M1, Z, V, nrow, ncol, vdim1);
RandomFields/src/operator.cc:void NoM(double *z, int ncol, int n, double *v) {
RandomFields/src/operator.cc:void NoMshape(double *z, int nrow, int n, double *v) {
RandomFields/src/operator.cc:// plus + M + whittle
RandomFields/src/operator.cc:void Matrix(double *x, int *info, model *cov, double *v) { // RMmatrix
RandomFields/src/operator.cc:  assert(cov->kappasub[M_M] == NULL);
RandomFields/src/operator.cc:    ncol = cov->ncol[M_M];
RandomFields/src/operator.cc:  //  printf("M nsub=%d %f %f %f %f %d\n", nsub, z[0], z[1], z[2], z[3], PisNULL(M_M));
RandomFields/src/operator.cc:    if (PisNULL(M_M)) NoM(z, ncol, nsub, v);
RandomFields/src/operator.cc:    else M(cov, P(M_M), z, P(M_M), v);
RandomFields/src/operator.cc:    if (PisNULL(M_M)) NoMshape(z, cov->nrow[M_M], nsub, v);
RandomFields/src/operator.cc:    else Mshape(cov, P(M_M), z, v);
RandomFields/src/operator.cc:  //  printf("%f %f %f \n", P(M_M)[0], P(M_M)[1], v[0]);
RandomFields/src/operator.cc:void nonstatM(double *x, double *y, int *info, model *cov, double *v){
RandomFields/src/operator.cc:    nrow = cov->nrow[M_M],
RandomFields/src/operator.cc:    ncol = cov->ncol[M_M];
RandomFields/src/operator.cc:  if (cov->kappasub[M_M] == NULL) {
RandomFields/src/operator.cc:    if (PisNULL(M_M)) NoM(z, ncol, nsub, v);
RandomFields/src/operator.cc:    else M(cov, P(M_M), z,  P(M_M), v);
RandomFields/src/operator.cc:      dim = OWNXDIM(0),
RandomFields/src/operator.cc:    TALLOC_X2(M1, total);
RandomFields/src/operator.cc:    TALLOC_X3(M2, total);
RandomFields/src/operator.cc:    FCTN(x, info, cov->kappasub[M_M], M1);
RandomFields/src/operator.cc:    FCTN(y, info + INFOS_PER_COORD, cov->kappasub[M_M], M2);
RandomFields/src/operator.cc:    M(cov, M1, z, M2, v);
RandomFields/src/operator.cc:int initM(model *cov, gen_storage VARIABLE_IS_NOT_USED *s) {
RandomFields/src/operator.cc:   if (!PisNULL(M_M) && cov->nsub==1 && isnowNegDef(cov)) {
RandomFields/src/operator.cc:    int vdim = cov->nrow[M_M],
RandomFields/src/operator.cc:      ncol = cov->ncol[M_M];
RandomFields/src/operator.cc:    matmult_2ndtransp(P(M_M), P(M_M), cov->q, vdim, ncol, vdim);
RandomFields/src/operator.cc:int checkM(model *cov) {  
RandomFields/src/operator.cc:  assert(COVNR == M_PROC || cov->Splus == NULL || !cov->Splus->keys_given);
RandomFields/src/operator.cc:    dim = OWNTOTALXDIM;
RandomFields/src/operator.cc:  bool is_negdef = isnowNegDef(cov) || COVNR == M_PROC;
RandomFields/src/operator.cc:  ASSERT_ONESYSTEM;
RandomFields/src/operator.cc:  //  printf("checkM nsub=%d %d %d\n", cov->nsub, SUBNR, BIND);
RandomFields/src/operator.cc:    if (j >= MAXSUB) SERR("too many submodels");
RandomFields/src/operator.cc:    subvdim = !PisNULL(M_VDIM) ? P0INT(M_VDIM) : cov->nsub > 1 ? cov->nsub : 0;
RandomFields/src/operator.cc:  model *k = cov->kappasub[M_M];
RandomFields/src/operator.cc:  //  printf("B subvdim = %d %d %d\n ", subvdim, k!=NULL, !PisNULL(M_M));
RandomFields/src/operator.cc:		     SUBMODEL_DEP, EvaluationType)) != NOERROR) RETURN_ERR(err);
RandomFields/src/operator.cc:  } else if (!PisNULL(M_M)) {
RandomFields/src/operator.cc:    vdim = cov->nrow[M_M];
RandomFields/src/operator.cc:    ncol = cov->ncol[M_M];
RandomFields/src/operator.cc:      initM(cov, NULL);
RandomFields/src/operator.cc:    SERR("number of submodel is different from the number of columns of 'M'");
RandomFields/src/operator.cc:  //  PMI(cov);
RandomFields/src/operator.cc:  int required_vdim = cov->nsub > 1 ? 1 : subvdim != 0 ? subvdim : VDIM0;
RandomFields/src/operator.cc:    domain_type dom = OWNDOM(0);
RandomFields/src/operator.cc:			    OWNDOM(0))) != NOERROR)
RandomFields/src/operator.cc:	  (err = CHECKPOS2NEG(sub, 1, EvaluationType, OWNDOM(0))) != NOERROR)	
RandomFields/src/operator.cc:    if ((err = CHECK_VDIM(sub, dim, dim, ShapeType, XONLY,
RandomFields/src/operator.cc:  VDIM0 = vdim;
RandomFields/src/operator.cc:  VDIM1 = is_negdef ? vdim : cov->sub[0]->vdim[1];
RandomFields/src/operator.cc:     err = CHECK_VDIM(sub, dim, dim, ShapeType, XONLY,
RandomFields/src/operator.cc:     if (sub->vdim[0] != VDIM1)
RandomFields/src/operator.cc:  cov->ncol[M_M] = subvdim;
RandomFields/src/operator.cc:  int maxv = MIN(vdim, MAXMPPVDIM);
RandomFields/src/operator.cc:    (vdim == subvdim && cov->kappasub[M_M] == NULL) ? 4 : 5;
RandomFields/src/operator.cc:  if (cov->kappasub[M_M] != NULL)
RandomFields/src/operator.cc:  //PMI(cov->calling == NULL ? cov : cov->calling->calling == NULL ? cov->calling : cov->calling->calling );
RandomFields/src/operator.cc:  //  PMI0(cov);
RandomFields/src/operator.cc:  //  printf("VDIM %d %d\n", VDIM0, VDIM1);
RandomFields/src/operator.cc:bool allowedDM(model *cov) {
RandomFields/src/operator.cc:  if (cov->kappasub[M_M] != NULL) {
RandomFields/src/operator.cc:    for (int i=(int) FIRST_DOMAIN; i<=(int) LAST_DOMAINUSER; D[i++] = false);
RandomFields/src/operator.cc:bool allowedIM(model *cov) {
RandomFields/src/operator.cc:  if (cov->kappasub[M_M] != NULL) {
RandomFields/src/operator.cc:    I[SYMMETRIC] = I[SPHERICAL_SYMMETRIC] = I[EARTH_SYMMETRIC] = true;
RandomFields/src/operator.cc:sortsofparam sortof_M(model VARIABLE_IS_NOT_USED *cov,
RandomFields/src/operator.cc:  return k == M_M ? (row==col ? SDPARAM : SIGNEDSDPARAM) : INTEGERPARAM;
RandomFields/src/operator.cc:void rangeM(model VARIABLE_IS_NOT_USED *cov, int k, int i, int j,
RandomFields/src/operator.cc:  case M_M : {
RandomFields/src/operator.cc:  case M_VDIM : {
RandomFields/src/operator.cc:Types TypeM(Types required, model *cov, isotropy_type required_iso){
RandomFields/src/operator.cc:int structMproc(model *cov, model **newmodel) {
RandomFields/src/operator.cc:  ASSERT_NEWMODEL_NULL;
RandomFields/src/operator.cc:  NEWSTOMODEL;
RandomFields/src/operator.cc:  GETSTOMODEL;
RandomFields/src/operator.cc:  int newdim = PREVLOGDIM(0);
RandomFields/src/operator.cc:    if ((err = covcpy(STOMODEL->keys + i, cov->sub[i])) != NOERROR) RETURN_ERR(err);
RandomFields/src/operator.cc:    assert(!isGaussMethod(STOMODEL->keys[i]));
RandomFields/src/operator.cc:    addModelX(STOMODEL->keys + i, GAUSSPROC);
RandomFields/src/operator.cc:    model *key = STOMODEL->keys[i]; // hier und nicht frueher!
RandomFields/src/operator.cc:    //    printf("structM A %d\n", i);
RandomFields/src/operator.cc:    //printf("structM B\n");
RandomFields/src/operator.cc:  //printf("structM C\n");
RandomFields/src/operator.cc:int initMproc(model *cov, gen_storage *S){
RandomFields/src/operator.cc:  //  PMI(cov); //crash();
RandomFields/src/operator.cc:  GETSTOMODEL;
RandomFields/src/operator.cc:    if ((err = INIT(STOMODEL->keys[i], 0, S)) != NOERROR) RETURN_ERR(err);
RandomFields/src/operator.cc:    STOMODEL->keys[i]->simu.active = true;
RandomFields/src/operator.cc:void doMproc(model *cov, gen_storage *S){
RandomFields/src/operator.cc:  //  printf("mvdim=%d\n", M_VDIM);
RandomFields/src/operator.cc:  //  PMI0(cov)
RandomFields/src/operator.cc:    vdim = VDIM0,
RandomFields/src/operator.cc:    *subrf[MAXSUB] = {NULL};
RandomFields/src/operator.cc:    subM = cov->kappasub[M_M] != NULL,
RandomFields/src/operator.cc:    anyM = subM || !PisNULL(M_M),
RandomFields/src/operator.cc:  GETSTOMODEL;
RandomFields/src/operator.cc:    assert(STOMODEL->keys[i] != NULL);
RandomFields/src/operator.cc:    DO(STOMODEL->keys[i], S);
RandomFields/src/operator.cc:    subrf[i] = STOMODEL->keys[i]->rf;
RandomFields/src/operator.cc:  if (!anyM) {
RandomFields/src/operator.cc:      for (int j=0; j<vdim; j++, rf+=tot) MEMCOPY(rf, subrf[j], bytes);
RandomFields/src/operator.cc:  TALLOC_X3(M0, keyvdim * keyvdim);
RandomFields/src/operator.cc:    *M = subM ? M0 : P(M_M),
RandomFields/src/operator.cc:  if (subM) COV(x, info, cov->kappasub[M_M], M);			\
RandomFields/src/operator.cc:    Ax(M, w, vdim, keyvdim, rf);					\
RandomFields/src/operator.cc:    Ax(M, w, vdim, keyvdim, zz);					\
RandomFields/src/operator.cc:  trafo &= subM;
RandomFields/src/operator.cc:  double *v = NULL,    // dummy for PERFORM
RandomFields/src/operator.cc:  //PMI(cov);
RandomFields/src/operator.cc:  PERFORM_PREPARE;
RandomFields/src/operator.cc:  PERFORM(BUG, do_loop, BUG, BUG);
RandomFields/src/operator.cc:  *nr = i < DefList[COVNR].kappas ? SIZE_NOT_DETERMINED : -1;
RandomFields/src/operator.cc:    vdim = VDIM0 * VDIM1,
RandomFields/src/operator.cc:    tsxdim = OWNTOTALXDIM;
RandomFields/src/operator.cc:    STANDARDINKREMENT_X;
RandomFields/src/operator.cc:      cov->mpp.mM[i] = cov->mpp.mMplus[i] = RF_NA;
RandomFields/src/operator.cc:    //    PMI0(cov);    printf("prevxtot=%d \n", PREVTOTALXDIM);
RandomFields/src/operator.cc:    //  else ILLEGAL_FRAME;
RandomFields/src/operator.cc:    dim = OWNTOTALXDIM,
RandomFields/src/operator.cc:    vdim = VDIM0 * VDIM1;
RandomFields/src/operator.cc:  if (!hasRandomFrame(cov)) ILLEGAL_FRAME;
RandomFields/src/operator.cc:  if (PisNULL(SCATTER_MAX)) {
RandomFields/src/operator.cc:    PALLOC(SCATTER_MAX, dim, 1);
RandomFields/src/operator.cc:    for (d=0; d<dim; d++) PINT(SCATTER_MAX)[d] = gp->scatter_max[d];
RandomFields/src/operator.cc:  } else if ((nr = cov->nrow[SCATTER_MAX]) < dim) {
RandomFields/src/operator.cc:    int j, *m = PINT(SCATTER_MAX);
RandomFields/src/operator.cc:    PtoNULL(SCATTER_MAX);
RandomFields/src/operator.cc:    PALLOC(SCATTER_MAX, dim, 1);
RandomFields/src/operator.cc:      PINT(SCATTER_MAX)[d] = m[j++];
RandomFields/src/operator.cc:    PtoNULL(SCATTER_MAX);
RandomFields/src/operator.cc:    PALLOC(SCATTER_MAX, dim, 1);
RandomFields/src/operator.cc:      PINT(SCATTER_MAX)[d] = m[j++];
RandomFields/src/operator.cc:  COPYALLSYSTEMS(PREVSYSOF(next), OWN, false);	
RandomFields/src/operator.cc:  if ((err = CHECK_GEN(next, VDIM0, VDIM1, cov->frame, true)) != NOERROR)
RandomFields/src/operator.cc:  // if ((err = CHECK_VDIM(next, cov->tsdim, cov->xdimown, ShapeType, OWNDOM(0),  
RandomFields/src/operator.cc:  //			OWNISO(0), VDIM0, VDIM1,
RandomFields/src/operator.cc:		     KNAME(SCATTER_STEP));
RandomFields/src/operator.cc:      if (PINT(SCATTER_MAX)[d] < 0) {
RandomFields/src/operator.cc:	  min[d] = -(max[d] = PINT(SCATTER_MAX)[d]);
RandomFields/src/operator.cc:  range->min[SCATTER_MAX] = - 1;
RandomFields/src/operator.cc:  range->max[SCATTER_MAX] = MAXINT;
RandomFields/src/operator.cc:  range->pmin[SCATTER_MAX] = 0;
RandomFields/src/operator.cc:  range->pmax[SCATTER_MAX] = 999;
RandomFields/src/operator.cc:  range->openmin[SCATTER_MAX] = false;
RandomFields/src/operator.cc:  range->openmax[SCATTER_MAX] = true;
RandomFields/src/operator.cc:  //vdim = VDIM0;
RandomFields/src/operator.cc:  if (VDIM1 != 1) SERR("matrix-valued shape functions cannot be initialised");
RandomFields/src/operator.cc:#define SCHUR_M 0
RandomFields/src/operator.cc:  double *M = P(SCHUR_M);
RandomFields/src/operator.cc:  int vdim = cov->nrow[M != NULL ? SCHUR_M : SCHUR_DIAG]; 
RandomFields/src/operator.cc:  *nc = i == SCHUR_M ? vdim : 1;
RandomFields/src/operator.cc:void SchurMult(model *cov, double *v){
RandomFields/src/operator.cc:  double *M = P(SCHUR_M);
RandomFields/src/operator.cc:    vdim = VDIM0;
RandomFields/src/operator.cc:  if (!PisNULL(SCHUR_M)) {
RandomFields/src/operator.cc:    int nrow2 = cov->nrow[SCHUR_M] * cov->nrow[SCHUR_M];
RandomFields/src/operator.cc:    for (i=0; i<nrow2; i++) v[i] *= M[i]; 
RandomFields/src/operator.cc:  SchurMult(cov, v);
RandomFields/src/operator.cc:  SchurMult(cov, v);
RandomFields/src/operator.cc:  SchurMult(cov, v);
RandomFields/src/operator.cc:  SchurMult(cov, v);
RandomFields/src/operator.cc:  SchurMult(cov, v);
RandomFields/src/operator.cc:  SchurMult(cov, v);
RandomFields/src/operator.cc:    *M=P(SCHUR_M),
RandomFields/src/operator.cc:    vdim = cov->nrow[M != NULL ? SCHUR_M : SCHUR_DIAG],
RandomFields/src/operator.cc:    maxv = MIN(vdim, MAXMPPVDIM),
RandomFields/src/operator.cc:  VDIM0 = VDIM1 = vdim;
RandomFields/src/operator.cc:  if ((err = CHECK_PASSTF(next, PosDefType, nrow[SCHUR_M], EvaluationType))
RandomFields/src/operator.cc:  //  if ((err = CHECK(next, cov->tsdim, cov->xdimown, PosDefType, OWNDOM(0), 
RandomFields/src/operator.cc:  //		     OWNISO(0), nrow[SCHUR_M], EvaluationType)) != NOERROR) 
RandomFields/src/operator.cc:  if ((M != NULL) xor (diag == NULL || red == NULL))
RandomFields/src/operator.cc:	  KNAME(SCHUR_DIAG), KNAME(SCHUR_RED), KNAME(SCHUR_M));
RandomFields/src/operator.cc:  C = (double*) MALLOC(bytes);
RandomFields/src/operator.cc:  if (M == NULL) {
RandomFields/src/operator.cc:	  GERR1("elements of '%.50s' negative.", KNAME(SCHUR_DIAG));
RandomFields/src/operator.cc:  } else MEMCOPY(C, M, bytes);
RandomFields/src/operator.cc:  //    for (int j=0;j<vdim;j++) printf("%f ", M[i * vdim + j]);
RandomFields/src/operator.cc:      !Ext_is_positive_definite(C, ncol[SCHUR_M])) 
RandomFields/src/operator.cc:	  nrow[SCHUR_M], ncol[SCHUR_M], KNAME(SCHUR_M));
RandomFields/src/operator.cc:  case SCHUR_M : {
RandomFields/src/operator.cc:#define ID_VDIM 0
RandomFields/src/operator.cc:  VDIM0 = VDIM1 = !PisNULL(ID_VDIM) ? P0INT(ID_VDIM) : SUBMODEL_DEP;
RandomFields/src/operator.cc:  //  if ((err = CHECK(next, cov->tsdim, cov->xdimown, PosDefType, OWNDOM(0),
RandomFields/src/operator.cc:  if (VDIM0 == SUBMODEL_DEP) {
RandomFields/src/operator.cc:    VDIM0 = next->vdim[0];
RandomFields/src/operator.cc:    VDIM1 = next->vdim[1];
RandomFields/src/operator.cc:void TBM2Id(double *x, int*info, model *cov, double *v){  
RandomFields/src/operator.cc:  TBM2CALL(x, info, next, v)
RandomFields/src/operator.cc:  range->min[ID_VDIM] = 1.0;
RandomFields/src/operator.cc:  range->max[ID_VDIM] = RF_INF;
RandomFields/src/operator.cc:  range->pmin[ID_VDIM] = 1.0;
RandomFields/src/operator.cc:  range->pmax[ID_VDIM] = 10;
RandomFields/src/operator.cc:  range->openmin[ID_VDIM] = false;
RandomFields/src/operator.cc:  range->openmax[ID_VDIM] = true;
RandomFields/src/operator.cc:    vdim = VDIM0,
RandomFields/src/operator.cc:    vdim = VDIM0,
RandomFields/src/operator.cc:  assert(VDIM0 == 1);
RandomFields/src/operator.cc:  assert(VDIM0 == 1);
RandomFields/src/operator.cc:      vdim = VDIM0;
RandomFields/src/operator.cc:  if ((err = CHECKPOSVAR(next, VariogramType, OWNDOM(0), OWNISO(0), SCALAR,
RandomFields/src/operator.cc:    if ((err = CHECKPOSVAR(next, VariogramType, OWNDOM(0), OWNISO(0), KERNEL,
RandomFields/src/operator.cc:  if (VDIM0 > 1 && P0INT(EXP_N) != - 1)
RandomFields/src/operator.cc:    SERR1("'%.50s' must be '-1' in the multivariate case", KNAME(EXP_N));
RandomFields/src/operator.cc:  if (VDIM0 > 1) SERR("multivariate case not programmed yet");
RandomFields/src/operator.cc:	    TYPE_NAMES[SYSTYPE(OWN, 0)]);
RandomFields/src/operator.cc:	    TYPE_NAMES[SYSTYPE(OWN, 0)]); 
RandomFields/src/operator.cc:  int maxv = MIN(vdim, MAXMPPVDIM);
RandomFields/src/operator.cc:    (isBernstein(next)) ? NORMAL_MIXTURE : 
RandomFields/src/operator.cc:    isMonotone(next->monotone) ? MONOTONE : NOT_MONOTONE;
RandomFields/src/operator.cc:    y = MAX(*x, 0);
RandomFields/src/operator.cc:    y = MAX(*x, 0);
RandomFields/src/operator.cc:      int dim = PREVTOTALXDIM;
RandomFields/src/operator.cc:  //   APMI0(cov);
RandomFields/src/operator.cc:  if ((err = CHECK_PASSFRAME(next, //EvaluationType
RandomFields/src/operator.cc:  //		   OWNDOM(0), OWNISO(0), SCALAR, EvaluationType)) != NOERROR){
RandomFields/src/operator.cc:  assert(VDIM0 == 1);
RandomFields/src/operator.cc:    isMonotone(next->monotone) && P0(POW_ALPHA) > 0 ? MONOTONE : NOT_MONOTONE;
RandomFields/src/operator.cc:    *theta = P(QAM_THETA);
RandomFields/src/operator.cc:    nsubM1 = nsub - 1;
RandomFields/src/operator.cc:  //  cov->monotone = NORMAL_MIXTURE;
RandomFields/src/operator.cc:  for (i=0; i<nsubM1; i++) {
RandomFields/src/operator.cc:    sum += P(QAM_THETA)[i];
RandomFields/src/operator.cc:  if ((err = CHECK(next, 1,  1, PosDefType, OWNDOM(0), OWNISO(0), 
RandomFields/src/operator.cc:  if (!isNormalMixture(next->monotone))
RandomFields/src/operator.cc:    if ((err = CHECK_PASSFRAME(sub, EvaluationType)) != NOERROR) RETURN_ERR(err);
RandomFields/src/operator.cc:    //		       OWNDOM(0), OWNISO(0),  SCALAR, EvaluationType)) != NOERROR)
RandomFields/src/operator.cc:  range->min[QAM_THETA] = 0.0;
RandomFields/src/operator.cc:  range->max[QAM_THETA] = 1.0;
RandomFields/src/operator.cc:  range->pmin[QAM_THETA] = 0.0;
RandomFields/src/operator.cc:  range->pmax[QAM_THETA] = pmax;
RandomFields/src/operator.cc:  range->openmin[QAM_THETA] = false;
RandomFields/src/operator.cc:  range->openmax[QAM_THETA] = false;
RandomFields/src/operator.cc:  *nc = (i==QAM_THETA) ? 1 : -1;
RandomFields/src/operator.cc:  *nr = i == QAM_THETA ? nsub : -1;
RandomFields/src/operator.cc:    vdim = VDIM0,
RandomFields/src/operator.cc:    *theta = P(QAM_THETA),
RandomFields/src/operator.cc:    s[MAXSUB];
RandomFields/src/operator.cc:  VDIM0 = VDIM1 = vdim;
RandomFields/src/operator.cc:    vdim = VDIM0,
RandomFields/src/operator.cc:    vdim = VDIM0,
RandomFields/src/operator.cc:   if ((err = CHECK_PASSFRAME(next, EvaluationType)) != NOERROR) RETURN_ERR(err);
RandomFields/src/operator.cc:   // if ((err = CHECK(next, cov->tsdim, cov->xdimown, PosDefType, OWNDOM(0),
RandomFields/src/operator.cc:   //		   OWNISO(0), SUBMODEL_DEP, EvaluationType))
RandomFields/src/operator.cc:  VDIM0 = next->vdim[0];
RandomFields/src/operator.cc:  VDIM1 = next->vdim[1];
RandomFields/src/operator.cc:  if (hasGaussMethodFrame(cov) || hasEvaluationFrame(cov)) {
RandomFields/src/operator.cc:  else if (hasMaxStableFrame(cov) || hasAnyPoissonFrame(cov)) {
RandomFields/src/operator.cc:  else ILLEGAL_FRAME;
RandomFields/src/operator.cc:    dim = OWNLOGDIM(0);
RandomFields/src/operator.cc:  TBM2CALL(&y, info, next, v)
RandomFields/src/operator.cc:  assert(VDIM0 == 1 && VDIM1 == 1 );
RandomFields/src/operator.cc:  if ((err = CHECK_PASSTF(next,  ShapeType, SUBMODEL_DEP, cov->frame)) != NOERROR)
RandomFields/src/operator.cc:  //		   OWNDOM(0), OWNISO(0),
RandomFields/src/operator.cc:  //		   SUBMODEL_DEP, cov->frame)) != NOERROR) RETURN_ERR(err);
RandomFields/src/operator.cc:  assert(SETPARAM_LOCAL == 0);
RandomFields/src/operator.cc:  addModel(newmodel, nr, remote);
RandomFields/src/operator.cc:  kdefault(*newmodel, SET_PERFORMDO, performdo);
RandomFields/src/operator.cc:  NEWSTOMODEL;
RandomFields/src/operator.cc:  GETSTOMODEL;
RandomFields/src/operator.cc:  STOMODEL->remote = remote;
RandomFields/src/operator.cc:  addSetParam(newmodel, remote, set, performdo, variant, SETPARAM);
RandomFields/src/operator.cc:  COV(x, info, cov->sub[SETPARAM_LOCAL], v);
RandomFields/src/operator.cc:  NONSTATCOV(x, y, info, cov->sub[SETPARAM_LOCAL], v);
RandomFields/src/operator.cc:  Abl1(x, info, cov->sub[SETPARAM_LOCAL], v);
RandomFields/src/operator.cc:  Abl2(x, info, cov->sub[SETPARAM_LOCAL], v);
RandomFields/src/operator.cc:  Abl3(x, info, cov->sub[SETPARAM_LOCAL], v);
RandomFields/src/operator.cc:  Abl4(x, info, cov->sub[SETPARAM_LOCAL], v);
RandomFields/src/operator.cc:  model *next = cov->sub[SETPARAM_LOCAL];
RandomFields/src/operator.cc:  model *next = cov->sub[SETPARAM_LOCAL];
RandomFields/src/operator.cc:  model *next = cov->sub[SETPARAM_LOCAL];
RandomFields/src/operator.cc:  kdefault(cov, SET_PERFORMDO, true);
RandomFields/src/operator.cc:  ASSERT_ONESYSTEM;
RandomFields/src/operator.cc:   //		   SUBMODEL_DEP, frame)) != NOERROR) RETURN_ERR(err);
RandomFields/src/operator.cc:  VDIM0 = next->vdim[0];
RandomFields/src/operator.cc:  VDIM1 = next->vdim[1];
RandomFields/src/operator.cc:  // ACHTUNG ! weder SETPARAM_FROM (da nur link) noch SETPARAM_SET (da 
RandomFields/src/operator.cc:  //           i.a. keine echten Modelle) werden ueberprueft!
RandomFields/src/operator.cc:  return TypeConsistency(required, cov->sub[SETPARAM_LOCAL], i);
RandomFields/src/operator.cc:   SPECTRAL(cov->sub[SETPARAM_LOCAL], s, e);  // nicht gatternr
RandomFields/src/operator.cc:  model *next= cov->sub[SETPARAM_LOCAL];
RandomFields/src/operator.cc:  GETSTOMODEL;
RandomFields/src/operator.cc:    vdim = VDIM0;
RandomFields/src/operator.cc:  if (VDIM0 != VDIM1) BUG;
RandomFields/src/operator.cc:  if (STOMODEL->remote != NULL) {
RandomFields/src/operator.cc:    X->set(cov->sub[0], STOMODEL->remote, X->variant);
RandomFields/src/operator.cc:  int maxv = MIN(vdim, MAXMPPVDIM);
RandomFields/src/operator.cc:  bool performDo = P0INT(SET_PERFORMDO);
RandomFields/src/operator.cc:  if (performDo) DO(cov->sub[SETPARAM_LOCAL], s); 
RandomFields/src/operator.cc:  model *next = cov->sub[SETPARAM_LOCAL];
RandomFields/src/operator.cc:  model *next = cov->sub[SETPARAM_LOCAL];
RandomFields/src/operator.cc:  booleanRange(SET_PERFORMDO);
RandomFields/src/operator.cc:  *nr =  (i == TRAFO_ISO) ? SIZE_NOT_DETERMINED : -1;
RandomFields/src/operator.cc:  // if (zaehler1 ++ == 0 || zaehler1==10) PMI(cov->calling);
RandomFields/src/operator.cc:  ASSERT_ONESYSTEM;
RandomFields/src/operator.cc:  if (cov->nsub == 0) addModel(cov, 0, IDCOORD);
RandomFields/src/operator.cc:  //PMI(cov);
RandomFields/src/operator.cc:  else set_xdim(OWN, 0, isSpaceIsotropic(iso) ? 2 : GATTERXDIM(0));
RandomFields/src/operator.cc:  set_logdim(OWN, 0, GATTERLOGDIM(0));
RandomFields/src/operator.cc:      newiso = SYMMETRIC;
RandomFields/src/operator.cc:    addModel(cov, 0, IDCOORD);
RandomFields/src/operator.cc:    //PMI(cov->calling);
RandomFields/src/operator.cc:  if (VDIM0 == SUBMODEL_DEP || VDIM0 == PARAM_DEP) {
RandomFields/src/operator.cc:    VDIM0 = next->vdim[0];
RandomFields/src/operator.cc:    VDIM1 = next->vdim[1];
RandomFields/src/operator.cc:    if (VDIM0 != next->vdim[0] || VDIM1 != next->vdim[1]) {
RandomFields/src/operator.cc:      PMI(cov); //
RandomFields/src/operator.cc:    ERR2("argument '%.50s' in '%.50s' not given.", KNAME(TRAFO_ISO), NICK(cov));
RandomFields/src/operator.cc:  if (cov->nsub == 0 || MODELNR(cov->sub[0]) == IDCOORD) {
RandomFields/src/operator.cc:    VDIM0 = SUBMODEL_DEP; // OWNTOTALXDIM ist noch nicht definiert bei Aufruf
RandomFields/src/operator.cc:    VDIM1 = 1;
RandomFields/src/operator.cc:    VDIM1 = VDIM0 = SUBMODEL_DEP;
RandomFields/src/operator.cc:  set_dom(OWN, 0, isAnyIsotropic(newiso) ? XONLY : PREVDOM(0));
RandomFields/src/operator.cc:  if (equalsIsoMismatch(previso)) {
RandomFields/src/operator.cc:    // for (int i=FIRST_DOMAIN; i<=LAST_DOMAINUSER; D[i++]=false);
RandomFields/src/operator.cc:    for (int i=FIRST_DOMAIN; i<=LAST_DOMAINUSER; D[i++]=false);
RandomFields/src/operator.cc:  MEMSET(I, 0, sizeof(allowedI_type)); // default is false
RandomFields/src/operator.cc:      I[SYMMETRIC] = false;
RandomFields/src/operator.cc:      I[EARTH_SYMMETRIC] = isSymmetric(iso);
RandomFields/src/operator.cc:  FRAME_ASSERT_GAUSS;
RandomFields/src/operator.cc:  ASSERT_ONESYSTEM;
RandomFields/src/operator.cc:		     SUBMODEL_DEP, cov->frame)) != NOERROR) RETURN_ERR(err);
RandomFields/src/operator.cc:    if ((err = CHECK(next, OWNLOGDIM(0), OWNXDIM(0), OWNTYPE(0), OWNDOM(0), 
RandomFields/src/operator.cc:  VDIM0 = next->vdim[0];
RandomFields/src/operator.cc:  VDIM1 = next->vdim[1];
RandomFields/src/operator.cc:    n = OWNSYSTEMS;
RandomFields/src/operator.cc:  FRAME_ASSERT_GAUSS;
RandomFields/src/operator.cc:    *y = (double *) MALLOC(sizeof(double) * newdim * spatialpts);
RandomFields/src/operator.cc:  if (y == NULL) RETURN_ERR(ERRORMEMORYALLOCATION);
RandomFields/src/operator.cc:  if (Time) MEMCOPY(T, LocT(cov), sizeof(double) * 3);
RandomFields/src/operator.cc:  if (STRCMP(global->coords.newunits[0], UNITS_NAMES[units_km]) == 0) {
RandomFields/src/operator.cc:  addModelKey(cov, GAUSSPROC);
RandomFields/src/operator.cc:#if MAXSYSTEMS > 1
RandomFields/src/operator.cc:		   SUBMODEL_DEP, cov->frame)) != NOERROR) goto ErrorHandling;
RandomFields/src/operator.cc:  if (VDIM0 != 1) NotProgrammedYet("");
RandomFields/src/operator.cc:    dim = OWNXDIM(0),
RandomFields/src/operator.cc:    addModel(cov, 0, IDCOORD);
RandomFields/src/operator.cc:  if ((err = CHECK(next, OWNLOGDIM(0), OWNXDIM(0), ShapeType, XONLY, OWNISO(0),
RandomFields/src/operator.cc:		   SUBMODEL_DEP, EvaluationType)) !=NOERROR) RETURN_ERR(err);
RandomFields/src/operator.cc:  assert((OWNDOM(0) == KERNEL) xor (COVNR == PROD_PROC));
RandomFields/src/operator.cc:  VDIM0 = next->vdim[0]; 
RandomFields/src/operator.cc:  VDIM1 = next->vdim[1];
RandomFields/src/operator.cc:  if (VDIM0 != 1) NotProgrammedYet("");
RandomFields/src/operator.cc:  if (cov->q == NULL) {QALLOC(1); cov->q[PRODPROC_RANDOM] = (double) true;}
RandomFields/src/operator.cc:  if (VDIM0 != 1) NotProgrammedYet("");
RandomFields/src/operator.cc:  FRAME_ASSERT_GAUSS;
RandomFields/src/operator.cc:  if (PL>= PL_STRUCTURE) {PRINTF("\n'%s' is now initialized.\n", NAME(cov));}
RandomFields/src/operator.cc:    vdim = VDIM0,
RandomFields/src/operator.cc:  if (cov->q[PRODPROC_RANDOM]) {
RandomFields/src/operator.cc:    double g = GAUSS_RANDOM(1.0);  
RandomFields/src/operator.cc:    dim = OWNXDIM(0),
RandomFields/src/operator.cc:    addModel(cov, 0, IDCOORD);
RandomFields/src/operator.cc:  if ((err = CHECK(next, OWNLOGDIM(0), OWNXDIM(0), ShapeType, XONLY, OWNISO(0),
RandomFields/src/operator.cc:		   SUBMODEL_DEP, cov->frame)) != NOERROR) RETURN_ERR(err);
RandomFields/src/operator.cc:  if (VDIM0 != VDIM1) 
RandomFields/src/operator.cc:  *nc = *nr = i <= VAR2COV_C ? SIZE_NOT_DETERMINED : -1;
RandomFields/src/operator.cc:  int vdim = VDIM0,
RandomFields/src/operator.cc:    dim = OWNLOGDIM(0),
RandomFields/src/operator.cc:    dim = ANYOWNDIM; // ANOWNTOTALDIM
RandomFields/src/operator.cc:	  RETURN_ERR(ERRORMEMORYALLOCATION); 
RandomFields/src/operator.cc:	    RETURN_ERR(ERRORMEMORYALLOCATION); 
RandomFields/src/operator.cc:		RMCOV_X[method], C->kappanames[VAR2COV_X]);
RandomFields/src/operator.cc:	    RETURN_ERR(ERRORMEMORYALLOCATION);
RandomFields/src/operator.cc:		RMCOV_X[method], C->kappanames[VAR2COV_X]);
RandomFields/src/operator.cc:      if (loc->timespacedim != OWNLOGDIM(0))  {
RandomFields/src/operator.cc:	      KNAME(VAR2COV_X));
RandomFields/src/operator.cc:	SERR1("currently, components of '%.50s' cannot be estimated by MLE, so NA's are not allowed.", C->kappanames[VAR2COV_C]);
RandomFields/src/operator.cc:  if ((err = CHECK_PASSTF(next, VariogramType, VDIM0, EvaluationType))
RandomFields/src/operator.cc:  range->max[VAR2COV_C] = nVAR2COV_METHODS + 1;
RandomFields/src/operator.cc:    RETURN_ERR(ERRORNOTPROGRAMMEDYET);
RandomFields/src/operator.cc:  if (!isGaussMethod(cov->key)) addModelKey(cov, GAUSSPROC);
RandomFields/src/operator.cc:  ASSERT_ONESYSTEM;
RandomFields/src/operator.cc:  if ((err = CHECK_NO_TRAFO(cov->key, OWNLOGDIM(0), OWNXDIM(0),
RandomFields/src/operator.cc:			    OWNISO(0), VDIM0, GaussMethodType)) != NOERROR) {
RandomFields/src/operator.cc:  FRAME_ASSERT_GAUSS;
RandomFields/src/operator.cc:  if (PL>= PL_STRUCTURE) {PRINTF("\n'%s' is now initialized.\n", NAME(cov));}
RandomFields/src/operator.cc:  int dim = OWNXDIM(0);
RandomFields/src/operator.cc:     ERR1("'%.50s' must be a positive function", KNAME(DSCALE));
RandomFields/src/operator.cc:  ASSERT_ONESYSTEM;
RandomFields/src/operator.cc:    dim = OWNXDIM(0);
RandomFields/src/operator.cc:  ASSERT_QUASIONESYSTEM;
RandomFields/src/operator.cc:  if ((err = CHECK(next, OWNLOGDIM(0) + 1, 1, PosDefType,
RandomFields/src/operator.cc:  if ((err = CHECK(scale, dim, dim, TrendType, XONLY, SYMMETRIC, SCALAR,
RandomFields/src/operator.cc:      (err = CHECK(penalty, 1, 1, TrendType, XONLY, SYMMETRIC, SCALAR,
RandomFields/src/operator.cc:  *nr = SIZE_NOT_DETERMINED;
RandomFields/src/operator.cc:		      *multi = cov->sub[BLEND_MULTI];
RandomFields/src/operator.cc:		      dim = OWNXDIM(0),
RandomFields/src/operator.cc:  // printf("vdim=%d %d\n", vdim, VDIM0);
RandomFields/src/operator.cc: ASSERT_ONESYSTEM;
RandomFields/src/operator.cc:    *multi = cov->sub[BLEND_MULTI];
RandomFields/src/operator.cc:    dim = OWNXDIM(0);
RandomFields/src/operator.cc:  if ((err = CHECK(multi, dim, dim, PosDefType, KERNEL, SYMMETRIC,
RandomFields/src/operator.cc:		   SUBMODEL_DEP, GaussMethodType)) != NOERROR) RETURN_ERR(err);
RandomFields/src/operator.cc:    *nc = SIZE_NOT_DETERMINED;
RandomFields/src/operator.cc:    *nr = OWNXDIM(0);
RandomFields/src/operator.cc:  } else if (i == BUBBLE_MINSCALE || i == BUBBLE_WEIGHT) {
RandomFields/src/operator.cc:      *nr = SIZE_NOT_DETERMINED;
RandomFields/src/operator.cc:    dim = OWNXDIM(0),
RandomFields/src/operator.cc: //  PMI0(cov);
RandomFields/src/operator.cc:  ASSERT_ONESYSTEM;
RandomFields/src/operator.cc:     dim = OWNXDIM(0);
RandomFields/src/operator.cc:  ASSERT_QUASIONESYSTEM;
RandomFields/src/operator.cc:  if ((err = CHECK(next, INFDIM, 1, PosDefType,
RandomFields/src/operator.cc:    double *tau = (double*) MALLOC(sizeof(double) * total);
RandomFields/src/operator.cc:    s->tau = (double*) MALLOC(sizeof(double) * total); // kann viel zu viel sein
RandomFields/src/operator.cc:    //  int *rk = (int*) MALLOC(sizeof(int) * total);
RandomFields/src/operator.cc:    s->rank = (int*) MALLOC(sizeof(int) * total);
RandomFields/src/operator.cc:    int *ordr = (int*) MALLOC(sizeof(int) * (total + 1));
RandomFields/src/operator.cc:      if (!PisNULL(BUBBLE_WEIGHT) || !PisNULL(BUBBLE_MINSCALE)) {
RandomFields/src/operator.cc:	     KNAME(BUBBLE_WEIGHT), KNAME(BUBBLE_MINSCALE), KNAME(BUBBLE_Z) );
RandomFields/src/operator.cc:	    KNAME(BUBBLE_Z))
RandomFields/src/operator.cc:      PALLOC(BUBBLE_MINSCALE, total, 1);
RandomFields/src/operator.cc:	*len = (int*) MALLOC(sizeof(int) * dim), // grid len
RandomFields/src/operator.cc:	*ix = (int*) MALLOC(sizeof(int) * dim), // grid coordinates
RandomFields/src/operator.cc:	*cumlen = (int*) MALLOC(sizeof(int) * (dim + 1));
RandomFields/src/operator.cc:	*ms = P(BUBBLE_MINSCALE),
RandomFields/src/operator.cc:	*left = (double*) MALLOC(sizeof(double) * dim), // grid start
RandomFields/src/operator.cc:	*step = (double*) MALLOC(sizeof(double) * dim); // grid step
RandomFields/src/operator.cc:	    gradient = MAX(gradient, delta_tau);
RandomFields/src/operator.cc:	       CONTACT, KNAME(BUBBLE_Z));
RandomFields/src/operator.cc:	cov->nrow[BUBBLE_MINSCALE] = points;
RandomFields/src/operator.cc:      //APMI(cov);      
RandomFields/src/operator.cc:      if (PisNULL(BUBBLE_MINSCALE)) {
RandomFields/src/operator.cc:	double *minscale = P(BUBBLE_MINSCALE);
RandomFields/src/operator.cc:	if (cov->nrow[BUBBLE_MINSCALE] != cov->ncol[BUBBLE_Z])
RandomFields/src/operator.cc:	  ERR2("lengths of '%.50s' and '%.50s' do not match.", KNAME(BUBBLE_MINSCALE),
RandomFields/src/operator.cc:	       KNAME(BUBBLE_Z));
RandomFields/src/operator.cc:	  len = cov->nrow[BUBBLE_MINSCALE];
RandomFields/src/operator.cc:		 KNAME(BUBBLE_MINSCALE));
RandomFields/src/operator.cc:	      ERR1("'%.50s' not in descending order.", KNAME(BUBBLE_MINSCALE));
RandomFields/src/operator.cc:      //      PMI0(cov);
RandomFields/src/operator.cc:	       KNAME(BUBBLE_WEIGHT), KNAME(BUBBLE_Z));
RandomFields/src/operator.cc:  //  PMI0(cov);
RandomFields/src/operator.cc:  range->min[BUBBLE_MINSCALE] = 0;
RandomFields/src/operator.cc:  range->max[BUBBLE_MINSCALE] = RF_INF;
RandomFields/src/operator.cc:  range->pmin[BUBBLE_MINSCALE] = 1e-5;
RandomFields/src/operator.cc:  range->pmax[BUBBLE_MINSCALE] = 10;
RandomFields/src/operator.cc:  range->openmin[BUBBLE_MINSCALE] = true;
RandomFields/src/operator.cc:  range->openmax[BUBBLE_MINSCALE] = true;
RandomFields/src/operator.cc:  *nr = i == DERIV_WHICH ? SIZE_NOT_DETERMINED : -1;
RandomFields/src/operator.cc:    dim = OWNLOGDIM(0), 
RandomFields/src/operator.cc:    dim = OWNLOGDIM(0);
RandomFields/src/operator.cc:  // statt STATIONARY : VARIOGRAM ?? s. Paper mit Scheuerer
RandomFields/src/operator.cc:  if ((err = CHECK(next, dim, 1, PosDefType, OWNDOM(0), ISOTROPIC,
RandomFields/src/operator.cc:    //if ((err =CHECK(next, dim, 1, PosDefType, OWNDOM(0), DOUBLEISOTROPIC,
RandomFields/src/operator.cc:  int diffpref = MIN(2, PREF_BEST - cov->pref[CircEmbed]);
RandomFields/src/operator.cc:	      KNAME(i), i+1, PINT(DERIV_WHICH)[i], components);
RandomFields/src/operator.cc:  int maxv = MIN(dim, MAXMPPVDIM);
RandomFields/src/operator.cc:  VDIM0 = VDIM1 = nwhich;
RandomFields/src/operator.cc:  int dim = OWNLOGDIM(0),
RandomFields/src/direct.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/direct.cc: Copyright (C) 2001 -- 2017 Martin Schlather, 
RandomFields/src/direct.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/direct.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/direct.cc:    err; // taken[MAX DIM],
RandomFields/src/direct.cc:  FRAME_ASSERT_GAUSS_INTERFACE;
RandomFields/src/direct.cc:  if ((OWNLOGDIM(0) != PREVXDIM(0) || OWNLOGDIM(0) != OWNXDIM(0)) &&
RandomFields/src/direct.cc:      (!loc->distances || PREVXDIM(0) != 1)) {
RandomFields/src/direct.cc:    if ((err = CHECK(next, OWNLOGDIM(0), OWNXDIM(0), type, dom, iso,
RandomFields/src/direct.cc:		     SUBMODEL_DEP, GaussMethodType)) == NOERROR) break;
RandomFields/src/direct.cc:    vdim = VDIM0,
RandomFields/src/direct.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/direct.cc:  if ((err = alloc_fctn(cov, OWNLOGDIM(0), vdim * vdim)) != NOERROR)
RandomFields/src/direct.cc:	  NICK(cov), direct[DIRECT_MAXVAR_PARAM],maxvariab, vdimtot,
RandomFields/src/direct.cc:	  direct[DIRECT_MAXVAR_PARAM]);
RandomFields/src/direct.cc:  //  PMI(cov->calling);
RandomFields/src/direct.cc:  if ((Cov =(double *) MALLOC(bytes))==NULL) {
RandomFields/src/direct.cc:    err=ERRORMEMORYALLOCATION;  
RandomFields/src/direct.cc:  //  TREE0(cov);  PMI(cov->calling->calling);
RandomFields/src/direct.cc:  //  PMI0(next);
RandomFields/src/direct.cc:  CovarianceMatrix(next, true, Cov); 
RandomFields/src/direct.cc:  //PMI(cov->calling->calling->calling->calling);   
RandomFields/src/direct.cc:	C = (double*) MALLOC(bytes);
RandomFields/src/direct.cc:	MEMCOPY(C, Cov, bytes);
RandomFields/src/direct.cc:    err = ERRORNOVARIOGRAM;
RandomFields/src/direct.cc:      err=ERRORMEMORYALLOCATION; goto ErrorHandling; 
RandomFields/src/direct.cc:    vdim = VDIM0,
RandomFields/src/direct.cc:  //  PMI(cov);
RandomFields/src/direct.cc:  for (int i=0; i<vdimtot; i++) G[i] = GAUSS_RANDOM(1.0);  
RandomFields/src/MachineOthers.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/MachineOthers.h: Copyright (C) 2017 -- 2017 Martin Schlather
RandomFields/src/MachineOthers.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/MachineOthers.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/MachineOthers.h:#ifndef RF_MACHINE_OTHERS
RandomFields/src/MachineOthers.h:#define RF_MACHINE_OTHERS 1
RandomFields/src/MachineOthers.h:#include "Machine.h"
RandomFields/src/MachineOthers.h:#define LASTSYSTEM(sys) LASTi((sys)[0])
RandomFields/src/MachineOthers.h:#define CUMXOHNE(sys, s) ((s==0) ? 0 : CUMXMITi((sys)[(s)-1]))
RandomFields/src/MachineOthers.h:#define CUMXMIT(sys, s) CUMXMITi((sys)[s])
RandomFields/src/MachineOthers.h:#define TOTALXDIM(sys) CUMXMITi((sys)[LASTSYSTEM(sys)])
RandomFields/src/MachineOthers.h:#define XDIM(sys, s) XDIMi((sys)[s]) // OK
RandomFields/src/MachineOthers.h:#define LOGDIM(sys, s) LOGDIMi((sys)[s])
RandomFields/src/MachineOthers.h:#define MAXDIM(sys, s) MAXDIMi((sys)[s])
RandomFields/src/MachineOthers.h:#define DOM(sys, s) DOMi((sys)[s])
RandomFields/src/MachineOthers.h:#define COPYSYS(to, from) MEMCOPY(to, from, sizeof(system_type))
RandomFields/src/MachineOthers.h:#define COPYALLSYSTEMS(to, from, keepnr) {		\
RandomFields/src/MachineOthers.h:    if (keepnr) nr_ = SYSMODEL(to);			\
RandomFields/src/MachineOthers.h:    MEMCOPY(to, from, sizeof(Systems_type));		\
RandomFields/src/MachineOthers.h:#define COPYALLSYSTEMS_COND(to, from, keepnr) { 			\
RandomFields/src/MachineOthers.h:    int nr_ = MISMATCH; if (gatter_set_ && keepnr) nr_= SYSMODEL(to);	\
RandomFields/src/MachineOthers.h:    MEMCOPY(to, from, sizeof(Systems_type));				\
RandomFields/src/MachineOthers.h:#define ANYOWNDIM OWNTOTALXDIM
RandomFields/src/MachineOthers.h:#define ANYDIMOF(cov) OWNTOTALXDIM
RandomFields/src/MachineOthers.h:#define SYSMODEL(sys) NRi((sys)[0])
RandomFields/src/MachineOthers.h:#define STRUCT(Cov, NM) DefList[FIRSTGATTER].Struct(Cov, NM)
RandomFields/src/MachineOthers.h:#define PARAM(Cov, IDX) ((double *) (Cov)->px[IDX])
RandomFields/src/MachineOthers.h:#define PARAMINT(Cov, IDX) ((int *) (Cov)->px[IDX])
RandomFields/src/MachineOthers.h:#define PARAMCHAR(Cov, IDX) ((char **) (Cov)->px[IDX])
RandomFields/src/MachineOthers.h:#define PARAMVEC(Cov, IDX) ((sexp_type *) (Cov)->px[IDX])->sexp
RandomFields/src/MachineOthers.h:#define PARAMENV(Cov, IDX) ((sexp_type *) (Cov)->px[IDX])
RandomFields/src/MachineOthers.h:#define PARAMLANG(Cov, IDX) ((sexp_type *) (Cov)->px[IDX])
RandomFields/src/MachineOthers.h:#define PARAMLIST(Cov, IDX) ((listoftype *) (Cov)->px[IDX])
RandomFields/src/MachineOthers.h:#define LPARAM(Cov, IDX) ((double *) (PARAMLIST(Cov, IDX)->lpx[SET_IDX(Cov, IDX)]))
RandomFields/src/MachineOthers.h:#define LPARAMINT(Cov, IDX) ((int *) (PARAMLIST(Cov, IDX)->lpx[SET_IDX(Cov, IDX)]))
RandomFields/src/MachineOthers.h:#define PARAM0(Cov, IDX) PARAM(Cov, IDX)[0]
RandomFields/src/MachineOthers.h:#define PARAM0INT(Cov, IDX) PARAMINT(Cov, IDX)[0]
RandomFields/src/MachineOthers.h:#define LPARAM0(Cov, IDX) LPARAM(Cov, IDX)[0]
RandomFields/src/MachineOthers.h:#define LPARAM0INT(Cov, IDX) LPARAMINT(Cov, IDX)[0]
RandomFields/src/MachineOthers.h:#define PARAM0CHAR(Cov, IDX) PARAMCHAR(Cov, IDX)[0]
RandomFields/src/MachineOthers.h:#define PCOPY(TO, FROM, IDX) 						\
RandomFields/src/MachineOthers.h:  MEMCOPY((TO)->px[IDX], (FROM)->px[IDX],				\
RandomFields/src/MachineOthers.h:	  ((FROM)->nrow[IDX]) * ((FROM)->ncol[IDX]) *			\
RandomFields/src/MachineOthers.h:	  (DefList[MODELNR(FROM)].kappatype[IDX]==REALSXP ? sizeof(double) : \
RandomFields/src/MachineOthers.h:	   DefList[MODELNR(FROM)].kappatype[IDX]==INTSXP ? sizeof(int) : -1))
Binary file RandomFields/src/Options.o matches
RandomFields/src/extremes.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/extremes.cc: Copyright (C) 2001 -- 2017 Martin Schlather, 
RandomFields/src/extremes.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURSE.  See the
RandomFields/src/extremes.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/extremes.cc:#define RANDOMCOIN_INTENSITY (COMMON_GAUSS + 1) 
RandomFields/src/extremes.cc:#define RANDOMCOIN_METHOD (COMMON_GAUSS + 2) 
RandomFields/src/extremes.cc:	double *r = (double*) MALLOC(cov->xdimown * sizeof(double));
RandomFields/src/extremes.cc:	  DORANDOM(cov, r);
RandomFields/src/extremes.cc:  range->min[GEV_MU] = RF_NEGINF;
RandomFields/src/extremes.cc:  range->max[GEV_MU] = RF_INF;
RandomFields/src/extremes.cc:  range->pmin[GEV_MU] = - 1000;
RandomFields/src/extremes.cc:  range->pmax[GEV_MU] = 1000;
RandomFields/src/extremes.cc:  range->openmin[GEV_MU] = true;
RandomFields/src/extremes.cc:  range->openmax[GEV_MU] = true; 
RandomFields/src/extremes.cc:    maxstable = hasMaxStableFrame(sub);
RandomFields/src/extremes.cc:  if (!maxstable && !poisson) ILLEGAL_FRAME;
RandomFields/src/extremes.cc:    if (!R_FINITE(sub->mpp.mMplus[1]) || sub->mpp.mMplus[1] <= 0.0) {
RandomFields/src/extremes.cc:    if (ISNAN(sub->mpp.mM[2]) || !R_FINITE(sub->mpp.mM[2] || sub->mpp.mM[2] <=0.0)){
RandomFields/src/extremes.cc:    dim = ANYOWNDIM,
RandomFields/src/extremes.cc:    nthreshold = (every>0) ? every : MAXINT,	
RandomFields/src/extremes.cc:    //M1 = RF_NA,
RandomFields/src/extremes.cc:    logM2 = RF_NA,
RandomFields/src/extremes.cc:    Minimum = global->extreme.min_shape_gumbel, // -10 // TO DO; -1e150
RandomFields/src/extremes.cc:    maxstable = hasMaxStableFrame(key),
RandomFields/src/extremes.cc:     randomcoin = cov->method == RandomCoin //only for FRAME_ POISSON_ GAUSS
RandomFields/src/extremes.cc:  Long zaehler, nn, cumgridlen[MAXMPPDIM +1], Total_n,			
RandomFields/src/extremes.cc:    vdim = VDIM0,
RandomFields/src/extremes.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/extremes.cc:  // A  PMI0(sub); 
RandomFields/src/extremes.cc:  if (!loggiven) Minimum =EXP(Minimum);
RandomFields/src/extremes.cc:    if (sub->mpp.moments < 1 || !R_FINITE(sub->mpp.mMplus[1]) || 
RandomFields/src/extremes.cc:      sub->mpp.mMplus[1] == 0.0)
RandomFields/src/extremes.cc:    //    M1 = sub->mpp.mMplus[1];
RandomFields/src/extremes.cc:    pgs->globalmin = Minimum;
RandomFields/src/extremes.cc:    logM2 =LOG(sub->mpp.mM[2]);
RandomFields/src/extremes.cc:    //APMI0(sub);
RandomFields/src/extremes.cc:    // MARCO: hattest Du dies reingenommen?
RandomFields/src/extremes.cc:    //   if (subf rame == BrMethodType) {
RandomFields/src/extremes.cc:      summand = -0.5 * (logdens + logM2);
RandomFields/src/extremes.cc:      assert(hasMaxStableFrame(sub));
RandomFields/src/extremes.cc:      summand = gumbel - logdens; //@MARCO: summand ist eine rein
RandomFields/src/extremes.cc:	pgs->globalmin = min < Minimum ? Minimum : min;     
RandomFields/src/extremes.cc:      //   printf("xxx = %10e %10e %10e Min=%10e \n",pgs->globalmin,  gumbel, pgs->currentthreshold, Minimum);
RandomFields/src/extremes.cc:  // printf("factor %4.4f sumd=%4.4f logdens=%4.4f logM2=%4.4f th=%4.4f %d<%d \n", factor, summand, logdens, logM2, threshold, (int) control, (int) total);  //  assert(false);
RandomFields/src/extremes.cc:	// 	printf("window [%10g %10g] [%d %d] %d %d\n", pgs->supportmin[d], pgs->supportmax[d], start[d], end[d], gridlen[d], partialfield);  //assert(n < 150); //APMI(cov);
RandomFields/src/extremes.cc:#define STANDARDINKREMENT_ZAEHLER			\
RandomFields/src/extremes.cc:#define RFMAX(OP) {				\
RandomFields/src/extremes.cc:#define RFSUM(OP) {				\
RandomFields/src/extremes.cc:#define MAXAPPLY(GET, OP)						\
RandomFields/src/extremes.cc:      /* if (zaehler<0 || zaehler>=total) { PMI(cov);  printf("//z=%d n=%d\n", zaehler, n); } */ \
RandomFields/src/extremes.cc:#define SUMAPPLY(GET,OP) GET; res[zaehler] += OP;
RandomFields/src/extremes.cc:	  STANDARDINKREMENT_ZAEHLER;				\
RandomFields/src/extremes.cc:#define OG_MAXAPPLY(NONE, OP)						\
RandomFields/src/extremes.cc:#define OG_SUMAPPLY(NONE, OP)				\
RandomFields/src/extremes.cc:    //   OWNGRIDAPPLY(OP, OG_SUMAPPLY_BASIC)
RandomFields/src/extremes.cc:#define	ALL_APPLY(APPLY, MGET, MAPPLY, SGET, SAPPLY, NONLOGGET)		\
RandomFields/src/extremes.cc:      if (maxstable) APPLY(MGET, (*value) += summand, MAPPLY)		\
RandomFields/src/extremes.cc:	  APPLY(MGET, *value=Sign[0] *EXP(*value+summand), MAPPLY)	\
RandomFields/src/extremes.cc:	if (maxstable) APPLY(NONLOGGET, (*value) *= factor, MAPPLY)	\
RandomFields/src/extremes.cc:	  STANDARDINKREMENT_ZAEHLER;					\
RandomFields/src/extremes.cc:    // TO DO: OMP: use parallel and SIMD max-operators
RandomFields/src/extremes.cc:      assert(hasMaxStableFrame(sub) || hasAnyPoissonFrame(sub)); // reicht das?
RandomFields/src/extremes.cc:	ALL_APPLY(OWNGRIDAPPLY, NULL, OG_MAXAPPLY, NULL, OG_SUMAPPLY, NULL);
RandomFields/src/extremes.cc:	  ALL_APPLY(APPLY, GETRF, MAXAPPLY, GETRF, SUMAPPLY, GETRF);
RandomFields/src/extremes.cc:	    if (maxstable) RFMAX(rf[i] + summand)
RandomFields/src/extremes.cc:	    else RFSUM(EXP(rf[i] + summand));	  
RandomFields/src/extremes.cc:	    if (maxstable) RFMAX(rf[i] * factor)
RandomFields/src/extremes.cc:	    else RFSUM(rf[i] * factor);
RandomFields/src/extremes.cc:	ALL_APPLY(APPLY, LOGGETPOS, MAXAPPLY, LOGGET, SUMAPPLY, GET);
RandomFields/src/extremes.cc:    vdim = VDIM0,
RandomFields/src/extremes.cc:    // mean /= M1;
RandomFields/src/extremes.cc:      // @MARCO unten ein s/xi statt nur s wie erwartet
RandomFields/src/extremes.cc:      ERR1("'%.50s' cannot be chosen as a function yet.", KNAME(GEV_S));
RandomFields/src/extremes.cc:    if (cov->kappasub[GEV_MU] != NULL) {
RandomFields/src/extremes.cc:      ERR1("'%.50s' cannot be chosen as a function yet.", KNAME(GEV_MU));
RandomFields/src/extremes.cc:      double mu = P0(GEV_MU);
RandomFields/src/extremes.cc:  ASSERT_ONESYSTEM;
RandomFields/src/extremes.cc:    dim = XDIM(PREVSYSOF(next), 0),
RandomFields/src/extremes.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/extremes.cc:  addModel(Cov, STANDARD_SHAPE, cov);
RandomFields/src/extremes.cc:  // PMI(key);
RandomFields/src/extremes.cc:    addModel(key, PGS_LOC, UNIF);
RandomFields/src/extremes.cc:    PARAMALLOC(key->sub[PGS_LOC], UNIF_MIN, dim, 1);
RandomFields/src/extremes.cc:    PARAMALLOC(key->sub[PGS_LOC], UNIF_MAX, dim, 1);
RandomFields/src/extremes.cc:    //    printf("structh %ld %.50s\n", key->sub + PGS_LOC, TYPE_NAMES[cov->frame]);
RandomFields/src/extremes.cc:    dim = OWNXDIM(0); // taken[MAX DIM],
RandomFields/src/extremes.cc:  ASSERT_ONE_SUBMODEL(cov);
RandomFields/src/extremes.cc:		     SUBMODEL_DEP, PoissonGaussType)) // to trigger search for coin in STRUCt
RandomFields/src/extremes.cc:		     SUBMODEL_DEP, PoissonType)) != NOERROR) RETURN_ERR(err);
RandomFields/src/extremes.cc:  VDIM0 = sub->vdim[0];
RandomFields/src/extremes.cc:  VDIM1 = 1;
RandomFields/src/extremes.cc:  ASSERT_NEWMODEL_NULL;
RandomFields/src/extremes.cc:    addModelKey(cov, TRUNCSUPPORT);
RandomFields/src/extremes.cc:  int dim = OWNXDIM(0);
RandomFields/src/extremes.cc:		     SUBMODEL_DEP, PoissonType)) != NOERROR)
RandomFields/src/extremes.cc:  if (hasGaussMethodFrame(next)) *v = 1.0 - SQRT(0.5 * (1.0 - *v));
RandomFields/src/extremes.cc://#define MPP_SHAPE 0
RandomFields/src/extremes.cc://#define MPP_TCF 1
RandomFields/src/extremes.cc:  if (cov->sub[MPP_TCF] != NULL && cov->sub[MPP_SHAPE]!=NULL)
RandomFields/src/extremes.cc:	  SNAME(MPP_TCF), SNAME(MPP_SHAPE));
RandomFields/src/extremes.cc:  kdefault(cov, GEV_MU, P0(GEV_XI) == 0.0 ? 0.0 : 1.0);
RandomFields/src/extremes.cc:  // print("xi s mu %10g %10g %10g\n",  P0(GEV_XI), P0(GEV_S), P0(GEV_MU)); assert(false);
RandomFields/src/extremes.cc:  if ((cov->sub[MPP_TCF] != NULL) xor (cov->sub[MPP_SHAPE] == NULL))
RandomFields/src/extremes.cc:    *next = cov->sub[cov->sub[MPP_TCF] != NULL ? MPP_TCF : MPP_SHAPE];
RandomFields/src/extremes.cc:    dim = OWNXDIM(0); // taken[MAX DIM],
RandomFields/src/extremes.cc:  ASSERT_ONE_SUBMODEL(cov);
RandomFields/src/extremes.cc:      SERR1("'%.50s' does not work with Bernoulli processes", NAME(cov));
RandomFields/src/extremes.cc:      //isGaussMethod(sub) ? GaussMethodType
RandomFields/src/extremes.cc:    //  printf(">>> %.50s %d %.50s\n", TYPE_NAMES[frame], isProcess(sub), NAME(sub));
RandomFields/src/extremes.cc:    assert(VDIM0 == VDIM1);
RandomFields/src/extremes.cc:		     SUBMODEL_DEP, SchlatherType)) != NOERROR) {
RandomFields/src/extremes.cc:    *sub = cov->sub[cov->sub[MPP_TCF] != NULL ? MPP_TCF : MPP_SHAPE];
RandomFields/src/extremes.cc:  ASSERT_NEWMODEL_NULL;
RandomFields/src/extremes.cc:  if (cov->sub[MPP_TCF] != NULL) {
RandomFields/src/extremes.cc:  if (MODELNR(cov->key) != GAUSSPROC && !equalsBernoulliProcess(cov->key) &&
RandomFields/src/extremes.cc:      MODELNR(cov->key) != BRNORMED
RandomFields/src/extremes.cc:    if (isnowVariogram(cov->key)) addModelKey(cov, GAUSSPROC); 
RandomFields/src/extremes.cc:      if (isGaussMethod(cov->key)) {
RandomFields/src/extremes.cc:  //    MODELNR(cov->key) == GAUSSPROC ? GaussMethodType   //Marco, 29.5.13
RandomFields/src/extremes.cc:  //		     OWNDOM(0),
RandomFields/src/extremes.cc:   if ((err = CHECK_PASSTF(cov->key, ProcessType, VDIM0, frame)) != NOERROR)
RandomFields/src/extremes.cc:  addModelKey(cov, STATIONARY_SHAPE);
RandomFields/src/extremes.cc:  //		     OWNDOM(0),
RandomFields/src/extremes.cc:   if ((err = CHECK_PASSTF(cov->key, PointShapeType, VDIM0,
RandomFields/src/extremes.cc:#define OPITZ_ALPHA (LAST_MAXSTABLE + 1)
RandomFields/src/extremes.cc:  key->mpp.mMplus[1] = INVSQRTTWOPI *POW(2, 0.5 * alpha - 0.5) * 
RandomFields/src/extremes.cc:  pgs->zhou_c = 1.0 / key->mpp.mMplus[1];
RandomFields/src/extremes.cc:  assert(STRCMP(NICK(from), NICK(to)) == 0); // minimal check
RandomFields/src/extremes.cc:  if (from->q != NULL) MEMCOPY(to->q, from->q, sizeof(double) * from->qlen);
RandomFields/src/extremes.cc:  for (i=0; i<MAXPARAM; i++) { PCOPY(to, from, i); }
RandomFields/src/extremes.cc:    for (i=0; i<MAXSUB; i++) {
RandomFields/src/extremes.cc:  ASSERT_ONESYSTEM;
RandomFields/src/extremes.cc:    dim = XDIM(SYSOF(shape), 0),
RandomFields/src/extremes.cc:    if (hasPoissonGaussFrame(shape) //|| hasMaxStableFrame(shape)
RandomFields/src/extremes.cc:      assert(dim > 0 && dim <= MAXMPPDIM);
RandomFields/src/extremes.cc:      addModel(cov, PGS_LOC, POW);
RandomFields/src/extremes.cc:      addModel(cov, PGS_LOC, SCATTER);
RandomFields/src/extremes.cc:      // PMI0(scatter); printf("sm=%d %d %d\n", SCATTER_MAX, dim,SCATTER_STEP);
RandomFields/src/extremes.cc:      PARAMALLOC(scatter, SCATTER_MAX, dim, 1);
RandomFields/src/extremes.cc:	PARAMINT(scatter, SCATTER_MAX)[i] = global->mpp.scatter_max[i];
RandomFields/src/extremes.cc:      PARAMALLOC(scatter, SCATTER_STEP, dim, 1);
RandomFields/src/extremes.cc:	PARAM(scatter, SCATTER_STEP)[i] = global->mpp.scatter_step[i];
RandomFields/src/extremes.cc:      addModel(cov, PGS_FCT, RANDOMSIGN); 
RandomFields/src/extremes.cc:		  param_set_identical, true, MAXINT);
RandomFields/src/extremes.cc:    addModel(cov, PGS_LOC, RECTANGULAR);
RandomFields/src/extremes.cc:      addModel(cov, PGS_LOC, LOC);
RandomFields/src/extremes.cc:    // APMI(cov->sub[PGS_LOC]); 25.6.19
RandomFields/src/extremes.cc:    RETURN_ERR(ERRORNOTPROGRAMMEDYET);
RandomFields/src/extremes.cc:  // SEE ALSO addPGSLocal in RMS.cc !!!!!!
RandomFields/src/extremes.cc:  bool maxstable = hasMaxStableFrame(shape);
RandomFields/src/extremes.cc:  char msg[nPOISSON_SCATTER - 1][LENERRMSG];
RandomFields/src/extremes.cc:      errorMSG(err, msg[i-1]);
RandomFields/src/extremes.cc:    addModel(Key, pgs[i], shape->calling);
RandomFields/src/extremes.cc:      if (i == POISSON_SCATTER_OPTIM) {
RandomFields/src/extremes.cc:	addModel(cov->sub + PGS_LOC, UNIF, cov);
RandomFields/src/extremes.cc:    // APMI(cov);
RandomFields/src/extremes.cc:      maxstableCov = hasMaxStableFrame(cov);
RandomFields/src/extremes.cc:  // APMI(*Key);
RandomFields/src/extremes.cc:    // errorMSG(err, xx, cov->base, msg[i-1]);
RandomFields/src/extremes.cc:  // MAIN FUNCTION FOR CREATING THE POINT-SHAP_OBJECT FOR
RandomFields/src/extremes.cc:  // SMITH AND RANDOM COIN
RandomFields/src/extremes.cc:    logdim = LOGDIM(PREVSYSOF(shape), 0),
RandomFields/src/extremes.cc:    xdim = XDIM(PREVSYSOF(shape), 0);
RandomFields/src/extremes.cc:#ifdef RANDOMFIELDS_DEBUGGING
RandomFields/src/extremes.cc:  //  PMI(*Key);
RandomFields/src/extremes.cc:  // PMI(shape);
RandomFields/src/extremes.cc:  //  PMI(shape);
RandomFields/src/extremes.cc:  //PMI(*Key); 
RandomFields/src/extremes.cc:		       DOM(PREVSYSOF(shape), 0), ISO(PREVSYSOF(shape), 0),
RandomFields/src/extremes.cc:#ifdef RANDOMFIELDS_DEBUGGING
RandomFields/src/extremes.cc:      //PMI(*Key);
RandomFields/src/extremes.cc:      cov = *Key; ASSERT_ONESYSTEM;
RandomFields/src/extremes.cc:	assert(CALLINGNR != SMITHPROC); // i.e. random coin
RandomFields/src/extremes.cc:    *shape = cov->sub[MPP_SHAPE],
RandomFields/src/extremes.cc:    *TCF =  cov->sub[MPP_TCF],
RandomFields/src/extremes.cc:    dim = OWNXDIM(0); // taken[MAX DIM],
RandomFields/src/extremes.cc:  ASSERT_ONE_SUBMODEL(cov);
RandomFields/src/extremes.cc:		       SUBMODEL_DEP, SmithType)) != NOERROR) RETURN_ERR(err);
RandomFields/src/extremes.cc:      //: isGaussMethod(sub) ? GaussMethodType
RandomFields/src/extremes.cc:    *shape = cov->sub[MPP_SHAPE],
RandomFields/src/extremes.cc:    *tcf =  cov->sub[MPP_TCF],
RandomFields/src/extremes.cc:    logdim = LOGDIM(PREVSYSOF(sub), 0),
RandomFields/src/extremes.cc:    xdim = XDIM(PREVSYSOF(sub), 0);
RandomFields/src/extremes.cc:  ASSERT_NEWMODEL_NULL;
RandomFields/src/extremes.cc:    addModelX(&tcf_shape, STROKORB_MONO);
RandomFields/src/extremes.cc:		     DOM(PREVSYSOF(tcf), 0), ISO(PREVSYSOF(tcf), 0), tcf->vdim, 
RandomFields/src/extremes.cc:			    OWNXDIM(0), VDIM0, SmithType))
RandomFields/src/extremes.cc:#define LL_COMPOSITE 2
RandomFields/src/extremes.cc:void loglikelihoodMaxstable(double *data,
RandomFields/src/extremes.cc:  // DARF JA NICHT DURCH MEHRERE CORES AUFGERUFEN WERDEN!!
RandomFields/src/extremes.cc:  ASSERT_ONESYSTEM;
RandomFields/src/extremes.cc:  int dim = OWNTOTALXDIM;
RandomFields/src/extremes.cc:      mu = P0(GEV_MU),
RandomFields/src/extremes.cc:  case LL_AUTO: case LL_COMPOSITE: {
RandomFields/src/extremes.cc:  case LL_FULL: ERR("full MLE not available for Brown Resnick");
RandomFields/src/extremes.cc:  loglikelihoodMaxstable(data, info, cov, HueslerReisslogD, v);
RandomFields/src/extremes.cc:  loglikelihoodMaxstable(data, info, cov, schlatherlogD, v);
RandomFields/src/extremes.cc:    dim = OWNXDIM(0); // taken[MAX DIM],
RandomFields/src/extremes.cc:  ASSERT_ONESYSTEM;
RandomFields/src/extremes.cc:  // PMI0(cov);
RandomFields/src/extremes.cc:  //FRAME_ASSERT_GAUSS_INTERFACE;
RandomFields/src/extremes.cc:  ASSERT_ONE_SUBMODEL(cov);
RandomFields/src/extremes.cc:  //  if ((!hasPoissonGaussFrame(next) && !hasGaussMethodFrame(next) &&
RandomFields/src/extremes.cc:  //  || cov->key!=NULL) ILLEGAL_FRAME;
RandomFields/src/extremes.cc:  kdefault(cov, RANDOMCOIN_INTENSITY, gp->intensity[dim]);
RandomFields/src/extremes.cc:  kdefault(cov, RANDOMCOIN_METHOD, 0);
RandomFields/src/extremes.cc:    //  printf("\n check random coin : key=%d %s %s Method=%d %d: %s key=%s\n", key!=NULL, TYPE_NAMES[cov->f rame], TYPE_NAMES[next->f rame],hasGaussMethodFrame(key), hasPoissonGaussFrame(key), NAME(next), key != NULL ? NAME(key) : "none" );
RandomFields/src/extremes.cc:  /// while (intern != NULL && MODELNR(intern) != AVERAGE_INTERN &&
RandomFields/src/extremes.cc:    // PMI0(intern);
RandomFields/src/extremes.cc:    //    PMI0(next);
RandomFields/src/extremes.cc:    //    PMI0(key);
RandomFields/src/extremes.cc:    if (hasGaussMethodFrame(key))
RandomFields/src/extremes.cc:		  SUBMODEL_DEP, PoissonGaussType);
RandomFields/src/extremes.cc:		  SUBMODEL_DEP, PoissonGaussType);
RandomFields/src/extremes.cc:		       SYMMETRIC, SCALAR, PoissonGaussType)) != NOERROR)  {
RandomFields/src/extremes.cc:  case RANDOMCOIN_INTENSITY :
RandomFields/src/extremes.cc:  case RANDOMCOIN_METHOD :
RandomFields/src/extremes.cc:    dim = OWNXDIM(0); // taken[MAX DIM],
RandomFields/src/extremes.cc:  ASSERT_NEWMODEL_NULL;
RandomFields/src/extremes.cc:		     SYMMETRIC, SCALAR, PoissonGaussType)) != NOERROR) {
RandomFields/src/extremes.cc:    // (PMI(pdf);
RandomFields/src/extremes.cc:    // PMI(tmp_shape);
RandomFields/src/extremes.cc:    // PMI(tmp_shape);
RandomFields/src/extremes.cc:  // printf("XXXXXXX %d\n", P0INT(RANDOMCOIN_METHOD));
RandomFields/src/extremes.cc:  switch(P0INT(RANDOMCOIN_METHOD)) {
RandomFields/src/extremes.cc:    if ((err = struct_ppp_pts(&(cov->key), tmp_shape, cov, dim, VDIM0,
RandomFields/src/extremes.cc:    addModel(&(cov->key), RANDOMSIGN, cov); 
RandomFields/src/extremes.cc:    addModel(&(cov->key), MCMC_PGS, cov);
RandomFields/src/extremes.cc:    addModel(key, PGS_LOC, POW);
RandomFields/src/extremes.cc:    addModel(key, PGS_LOC, SCATTER);
RandomFields/src/extremes.cc:    PARAMALLOC(scatter, SCATTER_MAX, dim, 1);
RandomFields/src/extremes.cc:    for (int i=0; i<dim; i++) PARAM(scatter, SCATTER_MAX)[i] = NA_INTEGER;
RandomFields/src/extremes.cc:    PARAMALLOC(scatter, SCATTER_STEP, dim, 1);
RandomFields/src/extremes.cc:    for (int i=0; i<dim; i++) PARAM(scatter, SCATTER_STEP)[i] = RF_NA;
RandomFields/src/extremes.cc:    addModel(&(cov->key), MCMC, cov);
RandomFields/src/extremes.cc:  //  APMI(cov->key);
RandomFields/src/extremes.cc:		   VDIM0, PoissonGaussType)) != NOERROR) goto ErrorHandling;
RandomFields/src/extremes.cc:    int idx[MAXMPPDIM];
RandomFields/src/extremes.cc:    assert(loc->timespacedim <= MAXMPPDIM);
RandomFields/src/extremes.cc:    sub->Spgs->totalmass * P0(RANDOMCOIN_INTENSITY); 
RandomFields/src/extremes.cc:  sub->Spgs->log_density =LOG(P0(RANDOMCOIN_INTENSITY));
RandomFields/src/extremes.cc:  if (!R_FINITE(sub->Spgs->totalmass) || !R_FINITE(sub->mpp.mM[2]))
RandomFields/src/extremes.cc:    SERR("Moments of submodels not known");
Binary file RandomFields/src/Gneiting.o matches
Binary file RandomFields/src/rf_interfaces.o matches
Binary file RandomFields/src/direct.o matches
RandomFields/src/auxiliary2.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/auxiliary2.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/src/auxiliary2.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/auxiliary2.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/init.cov.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/init.cov.cc: Copyright (C) 2001 -- 2017 Martin Schlather
RandomFields/src/init.cov.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/init.cov.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/init.cov.cc:// to do: MLE: random parameters einsammeln
RandomFields/src/init.cov.cc:  MATRIX,
RandomFields/src/init.cov.cc:  MULT,
RandomFields/src/init.cov.cc:  TBM_OP,
RandomFields/src/init.cov.cc:  TBM2NR,
RandomFields/src/init.cov.cc:  VARIOGRAM2COV,
RandomFields/src/init.cov.cc:void includeCovModels() {
RandomFields/src/init.cov.cc:  IncludeModel("ave",  PosDefType, 1, 1, 3, kappa_ave, XONLY, SYMMETRIC,
RandomFields/src/init.cov.cc:	       false, SCALAR, AveMaxDim, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:    IncludeModel("shape.ave", ShapeType, 1, 2, 3, kappa_ave,
RandomFields/src/init.cov.cc:		 true, SCALAR, INFDIM-1, (ext_bool) true, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  //                CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:	       INFDIM, (ext_bool) false, NORMAL_MIXTURE); // todo part is even
RandomFields/src/init.cov.cc:	       checklsfbm, rangelsfbm, PREF_ALL, INFDIM, (ext_bool) false,
RandomFields/src/init.cov.cc:	       MONOTONE); 
RandomFields/src/init.cov.cc:  //            CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:	      pbessel, SCALAR, INFDIM, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  addTBM(initBessel, spectralBessel);	       
RandomFields/src/init.cov.cc:  IncludeModel("bigneiting", PosDefType, 0, 0, 8, kappa_biGneiting, XONLY,
RandomFields/src/init.cov.cc:	       false, 2, PARAM_DEP, (ext_bool) true, NOT_MONOTONE);
RandomFields/src/init.cov.cc:    //                  CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:            pBiCoshShift, 2, 1, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  //             CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:  IncludeModel("bernoulli", TcfType, 1, 1, 3, NULL, SUBMODEL_D, SUBMODEL_I,
RandomFields/src/init.cov.cc:	       false, SCALAR, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP, MON_SUB_DEP);
RandomFields/src/init.cov.cc:  IncludeModel("biWM",  PosDefType, 0, 0, 8, kappa_biWM, XONLY, ISOTROPIC,
RandomFields/src/init.cov.cc:	       checkbiWM2, rangebiWM2, PREF_ALL,
RandomFields/src/init.cov.cc:	       false, 2, INFDIM, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  addCov(biWM2, biWM2D, biWM2DD, biWM2D3, biWM2D4,  inverseErr);
RandomFields/src/init.cov.cc:  addLocal(coinitbiWM2, NULL);
RandomFields/src/init.cov.cc:  RandomShape(0, struct_failed, initbiWM2, do_failed, false, true, false);
RandomFields/src/init.cov.cc:  //IncludeModel("bistable", PosDefType, 0,0, 4, kappa_biStable, XONLY, ISOTROPIC,
RandomFields/src/init.cov.cc:  IncludeModel("bistable", PosDefType, 0,0, 7, kappa_biStable, XONLY, ISOTROPIC,
RandomFields/src/init.cov.cc:	       false, 2, 3, (ext_bool) false, MONOTONE);
RandomFields/src/init.cov.cc:  //                   CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:  IncludeModel("blend", PosDefType, 2, 2, 1, kappablend, KERNEL, SYMMETRIC,
RandomFields/src/init.cov.cc:	       false, SCALAR, SUBMODEL_DEP, falsch, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  //                CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:    IncludeModel("brownresnick", TcfType, 1, 1, 0, NULL, XONLY, SUBMODEL_I,
RandomFields/src/init.cov.cc:		 SCALAR, SUBMODEL_DEP, (ext_bool) false, MON_SUB_DEP);
RandomFields/src/init.cov.cc:  IncludeScalar("br2bg",  PosDefType, 1, 1, 0, XONLY, SUBMODEL_I, 
RandomFields/src/init.cov.cc:		 check_BR2BG, NULL, PREF_ALL, SUBMODEL_DEP,
RandomFields/src/init.cov.cc:		(ext_bool) false, MON_SUB_DEP);
RandomFields/src/init.cov.cc:  IncludeScalar("br2eg", PosDefType, 1, 1, 0,  XONLY, SUBMODEL_I, 
RandomFields/src/init.cov.cc:		check_BR2EG, NULL, PREF_ALL, SUBMODEL_DEP,
RandomFields/src/init.cov.cc:		(ext_bool) false, MON_SUB_DEP);
RandomFields/src/init.cov.cc:  //                   CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:    IncludeModel("bubble", PosDefType, 1, 2, 4, kappabubble, KERNEL, UNREDUCED,
RandomFields/src/init.cov.cc:		 false, SCALAR, INFDIM - 1, falsch, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  change_sortof(BUBBLE_MINSCALE, ONLYRETURN);
RandomFields/src/init.cov.cc:  //                   CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:	      SCALAR, INFDIM, (ext_bool) false, NORMAL_MIXTURE);
RandomFields/src/init.cov.cc:  addTBM(TBM2Cauchy);
RandomFields/src/init.cov.cc:  addGaussMixture(DrawMixCauchy, LogMixDensCauchy);
RandomFields/src/init.cov.cc:  RandomShape(SUBMODEL_DEP, initCauchy, doCauchy);
RandomFields/src/init.cov.cc:    //                CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:    IncludePrim("cauchyUnif1", PosDefType, 2, XONLY, SYMMETRIC, checkOK, rangeCauchyUnif1, pCauchyUnif1, 2, INFDIM, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:    //                CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:    IncludePrim("cauchyUnif2", PosDefType, 2, XONLY, SYMMETRIC, checkOK, rangeCauchyUnif2, pCauchyUnif2, 2, INFDIM, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:    //                CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:    IncludePrim("cauchyUnif3", PosDefType, 2, XONLY, SYMMETRIC, checkOK, rangeCauchyUnif3, pCauchyUnif3, 2, INFDIM, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:    //                CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:    IncludePrim("latentCauchy1", PosDefType, 2, XONLY, SYMMETRIC, checkOK, rangelatentCauchy1, pCauchyUnif3, 2, INFDIM, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:    //                CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:    IncludePrim("latentCauchy2", PosDefType, 2, XONLY, SYMMETRIC, checkOK, rangelatentCauchy2, platentCauchy2, 2, INFDIM, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:    //                CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:    IncludePrim("latentCauchy3", PosDefType, 2, XONLY, SYMMETRIC, checkOK, rangelatentCauchy3, platentCauchy3, 2, INFDIM, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:    //                CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:    IncludePrim("latentCauchy4", PosDefType, 3, XONLY, SYMMETRIC, checkOK, rangelatentCauchy4, platentCauchy4, 2, INFDIM, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc: // todo : WARUM HABE ICH DIESES MODELL CODIERT, ABER NICHT ONLINE??     
RandomFields/src/init.cov.cc:  //     //           CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:  //	      rangeCauchytbm, pctbm, SCALAR, INFDIM, (ext_bool) false);
RandomFields/src/init.cov.cc:	      checkOK, NULL, 2, (ext_bool) false, GNEITING_MON);
RandomFields/src/init.cov.cc:  // RandomShape(init_cone, mppget_cone, sd_standard, MPP_POISS);
RandomFields/src/init.cov.cc:	      SCALAR, INFDIM, (ext_bool) false, MONOTONE); 
RandomFields/src/init.cov.cc:  IncludeModelR("constant", PosDefType, 0, 0, 1, kappaconstant, XONLY,
RandomFields/src/init.cov.cc:		PREVMODEL_I,
RandomFields/src/init.cov.cc:		//  PREVMODEL_D, PREVMODEL_I, 
RandomFields/src/init.cov.cc:		false, PARAM_DEP, INFDIM, (ext_bool) false, MON_SUB_DEP);
RandomFields/src/init.cov.cc:  kappanames("M", REALSXP);  
RandomFields/src/init.cov.cc:  //  AddVariant(TcfType, PREVMODEL_I);
RandomFields/src/init.cov.cc:  //              CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:    IncludeModel("fixcov", PosDefType, 0, 0, 4, kappa_fix,
RandomFields/src/init.cov.cc:	       INTERN_SHOW, PARAM_DEP, INFDIM-1, (ext_bool) false,
RandomFields/src/init.cov.cc:	       NOT_MONOTONE);
RandomFields/src/init.cov.cc:  kappanames("M", LISTOF + REALSXP,
RandomFields/src/init.cov.cc:	     COVARIATE_X_NAME, VECSXP,
RandomFields/src/init.cov.cc:	     COVARIATE_RAW_NAME, INTSXP,
RandomFields/src/init.cov.cc:	     "givenM", LISTOF + REALSXP);
RandomFields/src/init.cov.cc:  change_sortof(COVARIATE_X, DONOTVERIFYPARAM);
RandomFields/src/init.cov.cc:  //              CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:  IncludeModelR("coxisham",  PosDefType, 1, 1, 3, kappa_cox, 
RandomFields/src/init.cov.cc:	       XONLY, SYMMETRIC,
RandomFields/src/init.cov.cc:	       false, SCALAR, CoxMaxDim, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  addTBM(initcox, spectralcox);
RandomFields/src/init.cov.cc:	      checkOK, NULL, 3, (ext_bool) false, MONOTONE);
RandomFields/src/init.cov.cc:  //           CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:  IncludeModel("curlfree",  PosDefType, 1, 1, 1, kappadivcurl, XONLY,
RandomFields/src/init.cov.cc:	       false, PARAM_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  //            CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:    IncludeModel("cutoff",  PosDefType, 1, 1,2, NULL, XONLY, ISOTROPIC,
RandomFields/src/init.cov.cc:		 false, SUBMODEL_DEP, MAXCEDIM,  (ext_bool) true, MONOTONE);
RandomFields/src/init.cov.cc:  //  warning("siehe Primitive.cc/biWM: cutoff funktioniert nicht bei MLE, vereinheitlichung mit natsc und verbesserung von biWM notwendig");
RandomFields/src/init.cov.cc:  IncludeModel("dagum",  PosDefType, 0, 0, 3, NULL, XONLY, ISOTROPIC,
RandomFields/src/init.cov.cc:	       checkdagum, rangedagum, PREF_ALL, false, 1, INFDIM, (ext_bool) false,
RandomFields/src/init.cov.cc:	       MON_PARAMETER);
RandomFields/src/init.cov.cc:  kappanames("beta", REALSXP, "gamma", REALSXP, INTERNAL_PARAM, REALSXP);
RandomFields/src/init.cov.cc:	      checkdampedcosine, rangedampedcosine, PARAM_DEP,
RandomFields/src/init.cov.cc:	      (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  //           CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:  IncludeModel("deriv", PosDefType, 1, 1, 1, kappaderivative,
RandomFields/src/init.cov.cc:	       false, PARAM_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.cov.cc:	       NOT_MONOTONE);
RandomFields/src/init.cov.cc:  //                     CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:  	      SCALAR, INFDIM, (ext_bool) false, MONOTONE);
RandomFields/src/init.cov.cc:  //               CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:  IncludeModel("divfree", PosDefType, 1, 1, 1, kappadivcurl, XONLY,
RandomFields/src/init.cov.cc:	       false, PARAM_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.cov.cc:	       NOT_MONOTONE);
RandomFields/src/init.cov.cc:  //           CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:  IncludeModel("epsC",  PosDefType, 0, 0, 3, NULL, XONLY, ISOTROPIC,
RandomFields/src/init.cov.cc:	       false, SCALAR, INFDIM, (ext_bool) false, NORMAL_MIXTURE);
RandomFields/src/init.cov.cc:	      checkexponential, NULL, INFDIM, (ext_bool) false, COMPLETELY_MON);
RandomFields/src/init.cov.cc:  addGaussMixture(DrawMixExp, LogMixDensExp);
RandomFields/src/init.cov.cc:  addTBM(TBM2exponential, NULL, spectralexponential);
RandomFields/src/init.cov.cc:		PosDefType, 1, 1, 2, SUBMODEL_D, SUBMODEL_I, checkExp,
RandomFields/src/init.cov.cc:		rangeExp, PREF_ALL, SUBMODEL_DEP, (ext_bool) false,
RandomFields/src/init.cov.cc:		NOT_MONOTONE);
RandomFields/src/init.cov.cc:  //             CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:  IncludeModel("extremalgauss", TcfType, 1, 1, 0, NULL,
RandomFields/src/init.cov.cc:	       XONLY, SUBMODEL_I,
RandomFields/src/init.cov.cc:	       SCALAR, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP, NOT_MONOTONE);
RandomFields/src/init.cov.cc:	      checkFD, rangeFD, 1, (ext_bool) false, NOT_MONOTONE); 
RandomFields/src/init.cov.cc:   // same as RMcovariate, ausser dass RMcovariate interpoliert
RandomFields/src/init.cov.cc:		checkoesting, rangeoesting, INFDIM, (ext_bool) false,
RandomFields/src/init.cov.cc:		checkfractalBrownian, rangefractalBrownian, INFDIM, (ext_bool) false,
RandomFields/src/init.cov.cc:	      checkOK, rangefractGauss, 1, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  //                CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:		SCALAR, INFDIM, (ext_bool) false, NORMAL_MIXTURE);
RandomFields/src/init.cov.cc:  addTBM(NULL, spectralGauss);
RandomFields/src/init.cov.cc:  addGaussMixture(DrawMixGauss, LogMixDensGauss);
RandomFields/src/init.cov.cc:  //                      CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:  IncludePrim("gaussgauss", PosDefType, 1, XONLY, SYMMETRIC, checkOK, rangegaussgauss, pgaussgauss, 2, INFDIM, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  //                CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:  IncludePrim("gaussGammalike", PosDefType, 1, XONLY, SYMMETRIC, checkOK,
RandomFields/src/init.cov.cc:	      INFDIM, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:	      checkOK, rangegenBrownian, INFDIM, (ext_bool) false, MONOTONE);
RandomFields/src/init.cov.cc:  //                CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:	      SCALAR, INFDIM, (ext_bool) false, MON_PARAMETER); // todo part is even
RandomFields/src/init.cov.cc:           2, 3, (ext_bool) false, MONOTONE);
RandomFields/src/init.cov.cc:	      checkgenGneiting, rangegenGneiting, INFDIM-1, (ext_bool) true,
RandomFields/src/init.cov.cc:	      MONOTONE); // GNEITING_MON ??
RandomFields/src/init.cov.cc:  // not INFDIM, also not normalscale mixture and alpha will be void
RandomFields/src/init.cov.cc:    IncludeModel("gengneit_intern", PosDefType, 0, 0, 2, NULL, 
RandomFields/src/init.cov.cc:		 true, SCALAR, PARAM_DEP, (ext_bool) true, MONOTONE);  
RandomFields/src/init.cov.cc:	      PARAM_DEP, (ext_bool) true, MONOTONE);  // GNEITING_MON ??
RandomFields/src/init.cov.cc:  //                 CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:  IncludeScalar("gennsst",  PosDefType, 2, 2, 1, SUBMODEL_D,
RandomFields/src/init.cov.cc:	       SYMMETRIC, //SUBMODEL_I,
RandomFields/src/init.cov.cc:	       SUBMODEL_DEP, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  IncludeModel("gennsst_intern", 
RandomFields/src/init.cov.cc:	       2, 2, 1, kappa_gennsst_intern, XONLY, SYMMETRIC,
RandomFields/src/init.cov.cc:	       true, SCALAR, SUBMODEL_DEP, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  //           CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:  IncludeModel("helmholtz",  PosDefType, 1, 1, 2, kappamixed, XONLY, SYMMETRIC,
RandomFields/src/init.cov.cc:           true, PARAM_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  //           CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:	      SCALAR, INFDIM, (ext_bool) false, NORMAL_MIXTURE);
RandomFields/src/init.cov.cc:	      checkOK, rangeIacoCesare, INFDIM, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  IncludeModel("identity", ManifoldType, 1,1, 1, NULL, PREVMODEL_D, PREVMODEL_I,
RandomFields/src/init.cov.cc:	       false, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.cov.cc:	       MON_SUB_DEP);
RandomFields/src/init.cov.cc:  addTBM(TBM2Id, initId, spectralId);
RandomFields/src/init.cov.cc:	      checkKolmogorov, NULL, 3, 3, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  //           CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:	      SCALAR, PARAM_DEP, (ext_bool) false, MONOTONE);
RandomFields/src/init.cov.cc:  //  IncludeModel("lp", PosDefType,  1, 1, 1, XONLY, SYMMETRIC, 
RandomFields/src/init.cov.cc:  //	       //          CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:	       check_MaStein, range_MaStein, PREF_ALL, 
RandomFields/src/init.cov.cc:	       SUBMODEL_DEP, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  addCov(MaStein);
RandomFields/src/init.cov.cc:  IncludeScalar("ma1", PosDefType,  1, 1, 2, XONLY, SYMMETRIC,
RandomFields/src/init.cov.cc:	       SUBMODEL_DEP, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  IncludeScalar("ma2",  PosDefType, 1, 1, 0, XONLY, SYMMETRIC, checkma2, NULL,
RandomFields/src/init.cov.cc:		PREF_ALL, SUBMODEL_DEP, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  //                  CE CO CI TBM Sp di sq Tr av n mpp Hy spf any
RandomFields/src/init.cov.cc:  MATRIX=
RandomFields/src/init.cov.cc:    IncludeModelR("M",  ManifoldType, 1, MAXSUB, 2, kappaM, PREV_SUB_D,
RandomFields/src/init.cov.cc:		 checkM, rangeM, pmatrix, false, PARAM_DEP, SUBMODEL_DEP,
RandomFields/src/init.cov.cc:		 (ext_bool) SUBMODEL_DEP, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  kappanames("M", REALSXP, "vdim", INTSXP); // vdim ist das interne!
RandomFields/src/init.cov.cc:  change_typeof(M_M, ShapeType);
RandomFields/src/init.cov.cc:  addCov(Matrix);
RandomFields/src/init.cov.cc:  addCov(nonstatM);
RandomFields/src/init.cov.cc:  add_sortof(sortof_M);
RandomFields/src/init.cov.cc:  addTypeFct(TypeM);
RandomFields/src/init.cov.cc:  RandomShape(0, struct_failed, initM, do_failed, false, true, false);
RandomFields/src/init.cov.cc:  setDI(allowedDM, allowedIM, NULL);
RandomFields/src/init.cov.cc:  IncludeScalar("matern", ManifoldType, 0, 0, 2, PARAMDEP_D, PARAMDEP_I,
RandomFields/src/init.cov.cc:	       checkMatern, rangeWM, PREF_ALL, INFDIM, (ext_bool) false,
RandomFields/src/init.cov.cc:	       MON_SUB_DEP);
RandomFields/src/init.cov.cc:  change_sortof(WM_NU, CRITICALPARAM); 
RandomFields/src/init.cov.cc:  change_typeof(WM_NU, RandomOrShapeType);
RandomFields/src/init.cov.cc:  change_sortof(WM_NOTINV, ONLYRETURN);
RandomFields/src/init.cov.cc:  addCov(Matern, DMatern, DDMatern, D3Matern, D4Matern, InverseMatern,
RandomFields/src/init.cov.cc:	 inversenonstatMatern);
RandomFields/src/init.cov.cc:  addCov(NonStMatern);
RandomFields/src/init.cov.cc:  addlogCov(logMatern, logNonStMatern, NULL);
RandomFields/src/init.cov.cc:  addTBM(initMatern, spectralMatern);
RandomFields/src/init.cov.cc:  addLocal(coinitWM, ieinitWM);
RandomFields/src/init.cov.cc:  setDI(allowedDWM, allowedIWM, setWM);
RandomFields/src/init.cov.cc:  addTypeFct(TypeWM);
RandomFields/src/init.cov.cc:  RandomShape(0, struct_failed, initWM, do_failed, false, true, false);
RandomFields/src/init.cov.cc:  //  addGaussMixture(DrawMixWM, LogMixDensWM);
RandomFields/src/init.cov.cc:  IncludeModel("mqam", PosDefType,
RandomFields/src/init.cov.cc:  	       2, 10, 1, kappamqam, XONLY, SYMMETRIC,
RandomFields/src/init.cov.cc:	       false, PARAM_DEP, SUBMODEL_DEP, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  change_sortof(QAM_THETA, CRITICALPARAM); 
RandomFields/src/init.cov.cc:  //        CE CO CI TBM Sp di sq Ma av  n mpp Hy spf any
RandomFields/src/init.cov.cc:	      pmultiquad, SCALAR, 2, (ext_bool) false, MONOTONE);
RandomFields/src/init.cov.cc:    IncludeModel("natsc", PosDefType,  1, 1, 0, NULL, XONLY, ISOTROPIC,
RandomFields/src/init.cov.cc:		 false, 1, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP, MON_SUB_DEP);
RandomFields/src/init.cov.cc:  addTBM(tbm2natsc, initnatsc, spectralnatsc);
RandomFields/src/init.cov.cc:  // NATSC_INTERN = CopyModel("natsc_intern", NATSC_USER);
RandomFields/src/init.cov.cc:  //                 CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:	       SUBMODEL_DEP, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  change_sortof(NSST_DELTA, CRITICALPARAM);
RandomFields/src/init.cov.cc:  addTBM(TBM2nsst);
RandomFields/src/init.cov.cc:  //                  CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:    IncludeModel("nugget", TcfType, 0, 0, 2, NULL,
RandomFields/src/init.cov.cc:		 PARAMDEP_D, PARAMDEP_I,
RandomFields/src/init.cov.cc:		 false, PREVMODEL_DEP, INFDIM, (ext_bool) true, MONOTONE);
RandomFields/src/init.cov.cc:  change_sortof(NUGGET_TOL, FORBIDDENPARAM);
RandomFields/src/init.cov.cc:  change_sortof(NUGGET_VDIM, FORBIDDENPARAM);
RandomFields/src/init.cov.cc:  IncludeModel("parsWM", PosDefType, 0, 0, 1, kappa_parsWM, 
RandomFields/src/init.cov.cc:	       checkparsWM, rangeparsWM, PREF_ALL,
RandomFields/src/init.cov.cc:	       false, PARAM_DEP, INFDIM, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  addCov(parsWM, parsWMD);
RandomFields/src/init.cov.cc:  change_sortof(PARSnudiag, CRITICALPARAM);
RandomFields/src/init.cov.cc:  RandomShape(0, struct_failed, initparsWM, do_failed, false, true, false);
RandomFields/src/init.cov.cc:	      checkOK, NULL, 3, (ext_bool) true, MONOTONE);
RandomFields/src/init.cov.cc:	      checkpower, rangepower, INFDIM-1, (ext_bool) true, MONOTONE);
RandomFields/src/init.cov.cc:  // FORMERLY DIFFERENR DEFs OF PARAMs
RandomFields/src/init.cov.cc:  POW = IncludeScalar("Pow", ShapeType, 1, 1, 1, XONLY, SUBMODEL_I,
RandomFields/src/init.cov.cc:		     checkPow, rangePow, PREF_ALL, SUBMODEL_DEP,
RandomFields/src/init.cov.cc:		     Submodeldep, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  AddVariant(NegDefType, SUBMODEL_I);
RandomFields/src/init.cov.cc:  AddVariant(PosDefType, SUBMODEL_I);
RandomFields/src/init.cov.cc:  //                  CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:     IncludeModel("prod",  PosDefType, 1, 1, 0, NULL,
RandomFields/src/init.cov.cc:	       false, SUBMODEL_DEP, INFDIM-1, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  IncludeModel("qam",  PosDefType, 2, MAXSUB, 1, kappaqam, XONLY, ISOTROPIC,
RandomFields/src/init.cov.cc:	       false, SCALAR, SUBMODEL_DEP, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  change_sortof(QAM_THETA, CRITICALPARAM);
RandomFields/src/init.cov.cc:	      checkOK, rangeqexponential, INFDIM, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  //                   CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:  SCALEMODEL =
RandomFields/src/init.cov.cc:    IncludeModel("scale", PosDefType, 2, 3, 0, NULL, KERNEL, SYMMETRIC,
RandomFields/src/init.cov.cc:		 checkscale, NULL, pscale, false, SCALAR, INFDIM - 1, falsch,
RandomFields/src/init.cov.cc:		 NOT_MONOTONE);
RandomFields/src/init.cov.cc:  IncludeModelR("schur",  PosDefType, 1, 1, 3, kappaSchur, 
RandomFields/src/init.cov.cc:	       PREVMODEL_D, PREVMODEL_I, 
RandomFields/src/init.cov.cc:	       false, SUBMODEL_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  kappanames("M", REALSXP, "diag", REALSXP, "rhored", REALSXP);
RandomFields/src/init.cov.cc:  add_sortof(sortof_M); 
RandomFields/src/init.cov.cc:  IncludeModel("shift", PosDefType, 1, 1, 1, kappashift, XONLY, CARTESIAN_COORD,
RandomFields/src/init.cov.cc:	       false, PARAM_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.cov.cc:	       NOT_MONOTONE);
RandomFields/src/init.cov.cc:  //             CE CO CI TBM Sp di sq Ma av  n mpp Hy spf any
RandomFields/src/init.cov.cc:	      psinepower, SCALAR, 2, (ext_bool) false, MONOTONE);
RandomFields/src/init.cov.cc:	      checkOK, NULL, 3, (ext_bool) true, GNEITING_MON);
RandomFields/src/init.cov.cc:  addTBM(TBM2spherical);
RandomFields/src/init.cov.cc:	      checkstable, rangestable, INFDIM, (ext_bool) false,
RandomFields/src/init.cov.cc:	      MON_PARAMETER);
RandomFields/src/init.cov.cc:    IncludeModel("Stein", PosDefType,  1, 1, 2, NULL, XONLY, ISOTROPIC,
RandomFields/src/init.cov.cc:		 false, SCALAR, MAXCEDIM, (ext_bool) true, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  nickname(METHOD_NAMES[CircEmbedIntrinsic]);
RandomFields/src/init.cov.cc:  change_sortof(pLOC_DIAM, FORBIDDENPARAM);
RandomFields/src/init.cov.cc:  change_sortof(pLOC_A, FORBIDDENPARAM);
RandomFields/src/init.cov.cc:  IncludePrim("steinst1",  PosDefType, 2, kappaSteinST1, XONLY, SYMMETRIC,
RandomFields/src/init.cov.cc:	      checkSteinST1, rangeSteinST1, INFDIM, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  addTBM(initSteinST1, spectralSteinST1);
RandomFields/src/init.cov.cc:  IncludeModel("stp", PosDefType, 1, 2, 3, kappa_stp, KERNEL, SYMMETRIC,
RandomFields/src/init.cov.cc:	       false, SCALAR, StpMaxDim, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  kappanames("S", REALSXP, "z", REALSXP, "M", REALSXP);
RandomFields/src/init.cov.cc:    IncludeModel("shape.stp",  ShapeType, 1, 4, 3, kappa_stp, KERNEL, 
RandomFields/src/init.cov.cc:		 true, SCALAR, StpMaxDim, (ext_bool) true, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  kappanames("S", REALSXP, "z", REALSXP, "M", REALSXP); 
RandomFields/src/init.cov.cc:  TBM_OP = // old RandomFields tbm2, tbm3
RandomFields/src/init.cov.cc:    IncludeModel("tbm", ManifoldType, 1, 1, 3, NULL, XONLY, PARAMDEP_I,
RandomFields/src/init.cov.cc:		 SUBMODEL_DEP, PARAM_DEP, (ext_bool) PARAM_DEP, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  change_sortof(TBMOP_LAYERS, ONLYRETURN); // NA will not be estimated
RandomFields/src/init.cov.cc:  //                  CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:   IncludeModel("sum",  NegDefType, 0, 1, 0, NULL,
RandomFields/src/init.cov.cc:	       false, SUBMODEL_DEP, INFDIM-1, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:    IncludeModel("U", ManifoldType, 0, 0, 16, kappaUser, 
RandomFields/src/init.cov.cc:		 PARAMDEP_D, PARAMDEP_I,
RandomFields/src/init.cov.cc:		 true,// FREEVARIABLE vorhanden. Muss extra in SpecialRMmodel.R
RandomFields/src/init.cov.cc:		 PARAM_DEP, INFDIM, (ext_bool) false, // per default.
RandomFields/src/init.cov.cc:		 NOT_MONOTONE);
RandomFields/src/init.cov.cc:        //           CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:  VARIOGRAM2COV = // intern ok  
RandomFields/src/init.cov.cc:    IncludeModel("cov", PosDefType, 1, 1, 2, kappavariogram2cov,
RandomFields/src/init.cov.cc:		 INTERN_SHOW, SCALAR, INFDIM-1, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  kappanames(COVARIATE_X_NAME, VECSXP, "a", REALSXP);
RandomFields/src/init.cov.cc:  // change_typeof(VAR2COV_X, MixedInputType, RMCOV_X); 
RandomFields/src/init.cov.cc:  change_sortof(VAR2COV_X, DONOTVERIFYPARAM);
RandomFields/src/init.cov.cc:    IncludeModel("vector",  PosDefType, 1, 1, 2, NULL, XONLY, CARTESIAN_COORD,
RandomFields/src/init.cov.cc:		 false, PARAM_DEP, SUBMODEL_DEP, (ext_bool) SUBMODEL_DEP,
RandomFields/src/init.cov.cc:		 NOT_MONOTONE);
RandomFields/src/init.cov.cc:  //                CE CO CI TBM Sp di sq Ma av n mpp Hy spf any
RandomFields/src/init.cov.cc:	      checkOK, NULL, pwave, SCALAR, 3, (ext_bool) false, NOT_MONOTONE);
RandomFields/src/init.cov.cc:  addTBM(initwave, spectralwave);
RandomFields/src/init.cov.cc:  IncludeScalar("whittle", ManifoldType, 0,0, 2, PARAMDEP_D, PARAMDEP_I,  
RandomFields/src/init.cov.cc:	       checkWM, rangeWM, PREF_ALL, INFDIM, (ext_bool) false,
RandomFields/src/init.cov.cc:	       NORMAL_MIXTURE);
RandomFields/src/init.cov.cc:  change_typeof(WM_NU, RandomOrShapeType);
RandomFields/src/init.cov.cc:  change_sortof(WM_NU, CRITICALPARAM); 
RandomFields/src/init.cov.cc:  addTBM(initWhittle, spectralWhittle);
RandomFields/src/init.cov.cc:  addLocal(coinitWM, ieinitWM);
RandomFields/src/init.cov.cc:  addGaussMixture(DrawMixWM, LogMixDensW);
RandomFields/src/init.cov.cc:  setDI(allowedDWM, allowedIWM, setWM);
RandomFields/src/init.cov.cc:  addTypeFct(TypeWM);
RandomFields/src/init.cov.cc:  RandomShape(0, struct_failed, initWM, do_failed, false, true, false);
RandomFields/src/init.cov.cc:      C->pref[i] *= C->implemented[i]==IMPLEMENTED;
RandomFields/src/init.cov.cc:      //      if (old != C->pref[i] && i!=Nugget) printf("%.50s:%d%d ", METHOD_NAMES[i], old, C->pref[i]); // && i!=Specific
RandomFields/src/Brown.cc: Marco Oesting,
RandomFields/src/Brown.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/Brown.cc: Copyright (C) 2009 -- 2010 Martin Schlather 
RandomFields/src/Brown.cc: Copyright (C) 2011 -- 2017 Marco Oesting & Martin Schlather 
RandomFields/src/Brown.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURSE.  See the
RandomFields/src/Brown.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/Brown.cc:#define BR_MESHSIZE (LAST_MAXSTABLE + 1)
RandomFields/src/Brown.cc:#define BR_VERTNUMBER (LAST_MAXSTABLE + 2)
RandomFields/src/Brown.cc:#define BR_OPTIM (LAST_MAXSTABLE + 3)
RandomFields/src/Brown.cc:#define BR_OPTIMTOL (LAST_MAXSTABLE + 4)
RandomFields/src/Brown.cc:#define BR_LAMBDA (LAST_MAXSTABLE + 5)
RandomFields/src/Brown.cc:#define BR_OPTIMAREA (LAST_MAXSTABLE + 6)
RandomFields/src/Brown.cc:#define BR_VARIOBOUND (LAST_MAXSTABLE + 7)
RandomFields/src/Brown.cc:  addModel(localcov, modelnr, NULL, true);
RandomFields/src/Brown.cc:  //  PMI(neu);
RandomFields/src/Brown.cc:    if ((err = CHECK(neu, OWNLOGDIM(0), PREVXDIM(0),
RandomFields/src/Brown.cc:		     // DefList[COVNR].t ype,Martin:changed 27.11.13 
RandomFields/src/Brown.cc:		     type == InterfaceType ? XONLY : PREVDOM(0), 
RandomFields/src/Brown.cc:            cov->sub[cov->sub[MPP_SHAPE] != NULL ? MPP_SHAPE: MPP_TCF];
RandomFields/src/Brown.cc:  ASSERT_ONESYSTEM;
RandomFields/src/Brown.cc:  ASSERT_ONE_SUBMODEL(cov);
RandomFields/src/Brown.cc:  frame = isVariogram(type) ? EvaluationType : BrMethodType;     
RandomFields/src/Brown.cc:  isoprev = equalsVariogram(frame) ? SYMMETRIC : CARTESIAN_COORD;
RandomFields/src/Brown.cc:  if ((err = CHECK(sub, OWNLOGDIM(0), OWNXDIM(0),
RandomFields/src/Brown.cc:		   type,//Martin: changed 27.11.13 DefList[COVNR].Type,
RandomFields/src/Brown.cc:  GETSTOMODEL;
RandomFields/src/Brown.cc:    dim = OWNXDIM(0); // ownxdim(0)
RandomFields/src/Brown.cc:  if ((err = INIT(key, COVNR != BRNORMED, s)) != NOERROR) {
RandomFields/src/Brown.cc:  // PMI(cov);
RandomFields/src/Brown.cc:    RETURN_ERR(ERRORMEMORYALLOCATION);
RandomFields/src/Brown.cc:    if ((sBR->trend[j] =  (double*) MALLOC(total * sizeof(double)))==NULL) 
RandomFields/src/Brown.cc:      RETURN_ERR(ERRORMEMORYALLOCATION);
RandomFields/src/Brown.cc:  //  PMI(key);
RandomFields/src/Brown.cc:		     LocDist(key), STOMODEL->vario)) > NOERROR)
RandomFields/src/Brown.cc:  if (STOMODEL->vario->sub[0] != NULL) 
RandomFields/src/Brown.cc:    SetLoc2NewLoc(STOMODEL->vario->sub[0], LocP(STOMODEL->vario));
RandomFields/src/Brown.cc:    dim = OWNXDIM(0);
RandomFields/src/Brown.cc: GETSTOMODEL;
RandomFields/src/Brown.cc:  //PMI(cov->calling->calling);
RandomFields/src/Brown.cc:  Variogram(STOMODEL->vario, sBR->trend[ORIG_IDX]);
RandomFields/src/Brown.cc:   assert(MODELNR(key) == GAUSSPROC);
RandomFields/src/Brown.cc:  cov->mpp.mM[0] = cov->mpp.mMplus[0] = 1.0;
RandomFields/src/Brown.cc:  cov->mpp.mM[1] = cov->mpp.mMplus[1] = 1.0;
RandomFields/src/Brown.cc:    DELSTOMODEL;
RandomFields/src/Brown.cc:    dim = OWNXDIM(0);
RandomFields/src/Brown.cc:    trendlenneeded = MIN(keytotal, cov->simu.expected_number_simu);
RandomFields/src/Brown.cc:  if ((err = general_init(cov, MIN(trendlenmax, trendlenneeded), s))
RandomFields/src/Brown.cc:  assert(MODELNR(key) == GAUSSPROC);
RandomFields/src/Brown.cc:  cov->mpp.mM[0] = cov->mpp.mMplus[0] = 1.0;
RandomFields/src/Brown.cc:  cov->mpp.mM[1] = cov->mpp.mMplus[1] = 1.0;
RandomFields/src/Brown.cc:       MALLOC(dim*shiftedloclen*sizeof(double))) == NULL ||
RandomFields/src/Brown.cc:      (sBR->shift.locindex = (int*) MALLOC(sizeof(int) * dim))==NULL
RandomFields/src/Brown.cc:    err=ERRORMEMORYALLOCATION; goto ErrorHandling;
RandomFields/src/Brown.cc:  trendlenneeded = MIN(keytotal, cov->simu.expected_number_simu);
RandomFields/src/Brown.cc:  if ((sBR->shift.loc2mem=(int*) MALLOC(sizeof(int)*keytotal))==NULL) {
RandomFields/src/Brown.cc:    err = ERRORMEMORYALLOCATION; goto ErrorHandling;
RandomFields/src/Brown.cc:       (int*) MALLOC(sizeof(int)*sBR->trendlen)) == NULL) {
RandomFields/src/Brown.cc:    err = ERRORMEMORYALLOCATION; goto ErrorHandling;
RandomFields/src/Brown.cc:    DELSTOMODEL;
RandomFields/src/Brown.cc: GETSTOMODEL;
RandomFields/src/Brown.cc:  Long i, k, zeropos, zeroposMdim,
RandomFields/src/Brown.cc:    dim = OWNXDIM(0),
RandomFields/src/Brown.cc:  zeropos = (Long) FLOOR(UNIFORM_RANDOM * keytotal);
RandomFields/src/Brown.cc:      zeroposMdim = zeropos*dim;
RandomFields/src/Brown.cc:	  shiftedlocation[k] = keyloc->x[k] - keyloc->x[zeroposMdim+d];
RandomFields/src/Brown.cc:    partial_loc_set(Loc(STOMODEL->vario), shiftedlocation, NULL, 
RandomFields/src/Brown.cc:    if (STOMODEL->vario->sub[0] != NULL) 
RandomFields/src/Brown.cc:        SetLoc2NewLoc(STOMODEL->vario->sub[0], LocP(STOMODEL->vario));
RandomFields/src/Brown.cc:    Variogram(STOMODEL->vario, sBR->trend[trendindex]);
RandomFields/src/Brown.cc:  kdefault(cov, BR_MESHSIZE, bp->BRmeshsize);
RandomFields/src/Brown.cc:  kdefault(cov, BR_VERTNUMBER, bp->BRvertnumber);
RandomFields/src/Brown.cc:  kdefault(cov, BR_OPTIM, bp->BRoptim);
RandomFields/src/Brown.cc:  kdefault(cov, BR_OPTIMTOL, bp->BRoptimtol);
RandomFields/src/Brown.cc:  if (COVNR == BRMIXED_USER && cov->key == NULL && P0INT(BR_OPTIM) > 0) {
RandomFields/src/Brown.cc:    if (!PisNULL(BR_LAMBDA)) {
RandomFields/src/Brown.cc:      if (PisNULL(BR_OPTIMAREA)) SERR1("'%.50s' not given", KNAME(BR_OPTIMAREA));
RandomFields/src/Brown.cc:      if (PL > 0) { PRINTF("'%s' set to '0'", KNAME(BR_OPTIM));}
RandomFields/src/Brown.cc:      PINT(BR_OPTIM)[0] = 0;
RandomFields/src/Brown.cc:    } else if (P0INT(BR_OPTIM) == 2 && !PisNULL(BR_OPTIMAREA))
RandomFields/src/Brown.cc:      if (PL > 0) {PRINTF("'%s' set to '1'", KNAME(BR_OPTIM));}
RandomFields/src/Brown.cc:  if (cov->key != NULL && P0INT(BR_OPTIM) == 2) {
RandomFields/src/Brown.cc:      //     PMI(cov->key);     
RandomFields/src/Brown.cc:      SERR("area optimisation implemented for the isotropic case only"); //@MARTIN: das scheint nicht zu funktionieren, wenn ich ein Variogramm eingebe
RandomFields/src/Brown.cc:  kdefault(cov, BR_LAMBDA, RF_NA);
RandomFields/src/Brown.cc:  if (PisNULL(BR_OPTIMAREA)) kdefault(cov, BR_OPTIMAREA, 0.0);
RandomFields/src/Brown.cc:  if (VDIM0 != 1) SERR("BR only works in the univariate case");
RandomFields/src/Brown.cc:    case GEV_XI: case GEV_MU: case GEV_S: case BR_MESHSIZE:
RandomFields/src/Brown.cc:    case BR_VERTNUMBER: case BR_OPTIM: case BR_OPTIMTOL: 
RandomFields/src/Brown.cc:    case BR_LAMBDA: case BR_VARIOBOUND:
RandomFields/src/Brown.cc:    case BR_OPTIMAREA:
RandomFields/src/Brown.cc:      *nc = SIZE_NOT_DETERMINED;
RandomFields/src/Brown.cc:  // side effect auf P(BR_OPTIMAREA) !!
RandomFields/src/Brown.cc:    Errortol = P0(BR_OPTIMTOL),
RandomFields/src/Brown.cc:    step = P0(BR_MESHSIZE),
RandomFields/src/Brown.cc:    vertnumber = P0INT(BR_VERTNUMBER),
RandomFields/src/Brown.cc:    dim = OWNXDIM(0),
RandomFields/src/Brown.cc:  if ((cellcounter = (int*) MALLOC((minradius+1) * sizeof(int))) == NULL)
RandomFields/src/Brown.cc:    if ((am[j] = (double*) MALLOC((minradius+1) * sizeof(double))) == NULL)
RandomFields/src/Brown.cc:      am[j][d] = FMIN(am[j][d], lambda/vertnumber); //cutoff
RandomFields/src/Brown.cc:      maxErrorbound = FMAX(maxErrorbound, am[j][d]);
RandomFields/src/Brown.cc:	  Errorboundtmp = FMIN(Errorboundtmp, am[j][d]); 
RandomFields/src/Brown.cc:  PFREE(BR_OPTIMAREA);
RandomFields/src/Brown.cc:  PALLOC(BR_OPTIMAREA, 1, minradius+1);
RandomFields/src/Brown.cc:  optimarea = P(BR_OPTIMAREA);
RandomFields/src/Brown.cc:  double step = P0(BR_MESHSIZE),
RandomFields/src/Brown.cc:    *optimarea = P(BR_OPTIMAREA);    
RandomFields/src/Brown.cc:    dim = OWNXDIM(0),
RandomFields/src/Brown.cc:  double  step = P0(BR_MESHSIZE),
RandomFields/src/Brown.cc:    vertnumber = P0INT(BR_VERTNUMBER),
RandomFields/src/Brown.cc:    dim = OWNXDIM(0),
RandomFields/src/Brown.cc:  switch(P0INT(BR_OPTIM)) {
RandomFields/src/Brown.cc:    if (ISNAN(P0(BR_LAMBDA))) P(BR_LAMBDA)[0] = 1.0;
RandomFields/src/Brown.cc:        (sBR->m3.logvertnumber = (double *) MALLOC(vertnumber * sizeof(double)))
RandomFields/src/Brown.cc:      RETURN_ERR(ERRORMEMORYALLOCATION);
RandomFields/src/Brown.cc:        RETURN_ERR(ERRORMEMORYALLOCATION);
RandomFields/src/Brown.cc:  if ((sBR->m3.areamatrix  = (double *) MALLOC((minradius + 1)* sizeof(double))) 
RandomFields/src/Brown.cc:    RETURN_ERR(ERRORMEMORYALLOCATION);
RandomFields/src/Brown.cc:      if (i <= cov->ncol[BR_OPTIMAREA]) {
RandomFields/src/Brown.cc:        sBR->m3.areamatrix[i] = P(BR_OPTIMAREA)[i-1];  
RandomFields/src/Brown.cc:  PFREE(BR_OPTIMAREA);
RandomFields/src/Brown.cc:  PALLOC(BR_OPTIMAREA, 1, minradius + 1);
RandomFields/src/Brown.cc:  double *optimarea = P(BR_OPTIMAREA);
RandomFields/src/Brown.cc:  GETSTOMODEL;
RandomFields/src/Brown.cc:    dim = OWNXDIM(0),
RandomFields/src/Brown.cc:    step = P0(BR_MESHSIZE);
RandomFields/src/Brown.cc:  Variogram(STOMODEL->vario, sBR->trend[0]);
RandomFields/src/Brown.cc:  if ((sBR->m3.suppmin = (double*) MALLOC(bytes))==NULL ||
RandomFields/src/Brown.cc:      (sBR->m3.suppmax = (double*) MALLOC(bytes))==NULL ||      
RandomFields/src/Brown.cc:      (sBR->m3.loccentre = (double*) MALLOC(bytes))==NULL 
RandomFields/src/Brown.cc:      //     (sBR->shift.locindex = (int*) MALLOC(sizeof(int) * dim))==NULL ||
RandomFields/src/Brown.cc:    err = ERRORMEMORYALLOCATION; goto ErrorHandling;
RandomFields/src/Brown.cc:    cov->mpp.mM[d] = cov->mpp.mMplus[d] = 1.0;
RandomFields/src/Brown.cc:  assert(MODELNR(key) == GAUSSPROC);
RandomFields/src/Brown.cc:  key->mpp.mM[0] = key->mpp.mMplus[0] = 1.0;
RandomFields/src/Brown.cc:  key->mpp.mM[1] = key->mpp.mMplus[1] = 1.0;
RandomFields/src/Brown.cc:  if ((sBR->m3.lowerbounds = (double*) MALLOC(keytotal*sizeof(double))) == NULL) { 
RandomFields/src/Brown.cc:    err=ERRORMEMORYALLOCATION; 
RandomFields/src/Brown.cc:  pgs->estimated_zhou_c = (bool) ISNAN(P0(BR_LAMBDA));
RandomFields/src/Brown.cc:  pgs->zhou_c =  pgs->estimated_zhou_c ? 0.0 : P0(BR_LAMBDA)*area; //@MARTIN: area kann weg, falls in logdens
RandomFields/src/Brown.cc:  sBR->m3.next_am_check = global->br.deltaAM;
RandomFields/src/Brown.cc:    DELSTOMODEL;
RandomFields/src/Brown.cc:    dim = OWNXDIM(0),
RandomFields/src/Brown.cc:    vertnumber = P0INT(BR_VERTNUMBER);
RandomFields/src/Brown.cc:  double step = P0(BR_MESHSIZE),
RandomFields/src/Brown.cc:    uplusmaxval , maxval, u[MAXMPPDIM], 
RandomFields/src/Brown.cc:    area=1.0, *lgres = key->rf, //@MARTIN: area obsolet, falls in logdens
RandomFields/src/Brown.cc:  if (P0INT(BR_OPTIM) == 2 &&  pgs->n_zhou_c >= sBR->m3.next_am_check) {      
RandomFields/src/Brown.cc:    sBR->m3.next_am_check += global->br.deltaAM; 
RandomFields/src/Brown.cc:    u[d] = ROUND((UNIFORM_RANDOM*(sBR->m3.suppmax[d] - sBR->m3.suppmin[d]) +
RandomFields/src/Brown.cc:      pgs->sq_zhou_c += area * invstepdim * area * invstepdim; // @MARTIN: s.o
RandomFields/src/Brown.cc:    uplusmaxval = maxval - lgres[zeropos] - LOG(UNIFORM_RANDOM);
RandomFields/src/Brown.cc:    if (P0INT(BR_OPTIM) == 2) {
RandomFields/src/Brown.cc:  range->min[BR_MESHSIZE] = 0;
RandomFields/src/Brown.cc:  range->max[BR_MESHSIZE] = RF_INF;
RandomFields/src/Brown.cc:  range->pmin[BR_MESHSIZE] = 0;
RandomFields/src/Brown.cc:  range->pmax[BR_MESHSIZE] = RF_INF;
RandomFields/src/Brown.cc:  range->openmin[BR_MESHSIZE] = true;
RandomFields/src/Brown.cc:  range->openmax[BR_MESHSIZE] = true; 
RandomFields/src/Brown.cc:  range->min[BR_VERTNUMBER] = 1;
RandomFields/src/Brown.cc:  range->max[BR_VERTNUMBER] = RF_INF;
RandomFields/src/Brown.cc:  range->pmin[BR_VERTNUMBER] = 1;
RandomFields/src/Brown.cc:  range->pmax[BR_VERTNUMBER] = 50;
RandomFields/src/Brown.cc:  range->openmin[BR_VERTNUMBER] = false;
RandomFields/src/Brown.cc:  range->openmax[BR_VERTNUMBER] = false;
RandomFields/src/Brown.cc:  range->min[BR_OPTIM] = 0;
RandomFields/src/Brown.cc:  range->max[BR_OPTIM] = 2;
RandomFields/src/Brown.cc:  range->pmin[BR_OPTIM] = 0;
RandomFields/src/Brown.cc:  range->pmax[BR_OPTIM] = 2;
RandomFields/src/Brown.cc:  range->openmin[BR_OPTIM] = false;
RandomFields/src/Brown.cc:  range->openmax[BR_OPTIM] = false;
RandomFields/src/Brown.cc:  range->min[BR_OPTIMTOL] = 0;
RandomFields/src/Brown.cc:  range->max[BR_OPTIMTOL] = 1;
RandomFields/src/Brown.cc:  range->pmin[BR_OPTIMTOL] = 0;
RandomFields/src/Brown.cc:  range->pmax[BR_OPTIMTOL] = 0.1;
RandomFields/src/Brown.cc:  range->openmin[BR_OPTIMTOL] = true;
RandomFields/src/Brown.cc:  range->openmax[BR_OPTIMTOL] = true;
RandomFields/src/Brown.cc:  range->min[BR_LAMBDA] = 0;
RandomFields/src/Brown.cc:  range->max[BR_LAMBDA] = RF_INF;
RandomFields/src/Brown.cc:  range->pmin[BR_LAMBDA] = 0;
RandomFields/src/Brown.cc:  range->pmax[BR_LAMBDA] = RF_INF;
RandomFields/src/Brown.cc:  range->openmin[BR_LAMBDA] = true;
RandomFields/src/Brown.cc:  range->openmax[BR_LAMBDA] = true;
RandomFields/src/Brown.cc:  range->min[BR_OPTIMAREA] = 0;
RandomFields/src/Brown.cc:  range->max[BR_OPTIMAREA] = 1;
RandomFields/src/Brown.cc:  range->pmin[BR_OPTIMAREA] = 0;
RandomFields/src/Brown.cc:  range->pmax[BR_OPTIMAREA] = 1;
RandomFields/src/Brown.cc:  range->openmin[BR_OPTIMAREA] = false;
RandomFields/src/Brown.cc:  range->openmax[BR_OPTIMAREA] = false;
RandomFields/src/Brown.cc:  model *sub = cov->sub[cov->sub[MPP_SHAPE] != NULL ? MPP_SHAPE: MPP_TCF];
RandomFields/src/Brown.cc:    dim = SUBXDIM(0),
RandomFields/src/Brown.cc:  double centrelocation[MAXMPPDIM], minlocation[MAXMPPDIM], maxlocation[MAXMPPDIM],
RandomFields/src/Brown.cc:  ASSERT_NEWMODEL_NULL;
RandomFields/src/Brown.cc:  assert(isBrMethod(cov));  
RandomFields/src/Brown.cc:               : (COVNR == BRMIXED_USER) ? BRMIXED_INTERN
RandomFields/src/Brown.cc:  if ((newx = (double*) MALLOC(dim * newxlen * sizeof(double))) == NULL) {
RandomFields/src/Brown.cc:     GERR("Memory allocation failed.\n"); 
RandomFields/src/Brown.cc:  if (cov->sub[MPP_TCF] != NULL) {
RandomFields/src/Brown.cc:  addModelKey(cov, model_intern);
RandomFields/src/Brown.cc:  kdefault(cov->key, GEV_MU, P0(GEV_MU));
RandomFields/src/Brown.cc:  if (COVNR == BRMIXED_USER) {
RandomFields/src/Brown.cc:    kdefault(cov->key, BR_MESHSIZE, P0(BR_MESHSIZE));
RandomFields/src/Brown.cc:    kdefault(cov->key, BR_VERTNUMBER, P0INT(BR_VERTNUMBER));
RandomFields/src/Brown.cc:    kdefault(cov->key, BR_OPTIM, P0INT(BR_OPTIM));
RandomFields/src/Brown.cc:    kdefault(cov->key, BR_OPTIMTOL, P0(BR_OPTIMTOL));
RandomFields/src/Brown.cc:    kdefault(cov->key, BR_LAMBDA, P0(BR_LAMBDA));
RandomFields/src/Brown.cc:    if (!PisNULL(BR_OPTIMAREA)) {
RandomFields/src/Brown.cc:      PARAMALLOC(cov->key, BR_OPTIMAREA, cov->nrow[BR_OPTIMAREA],
RandomFields/src/Brown.cc:                 cov->ncol[BR_OPTIMAREA]);
RandomFields/src/Brown.cc:      PCOPY(cov->key, cov, BR_OPTIMAREA);
RandomFields/src/Brown.cc:  if ((err = CHECK(cov->key, OWNLOGDIM(0), OWNXDIM(0), PointShapeType,
RandomFields/src/Brown.cc:		   OWNDOM(0), OWNISO(0), 1, BrMethodType)) == NOERROR) {
RandomFields/src/Brown.cc:      err = CHECK(cov->key, OWNLOGDIM(0), OWNXDIM(0),
RandomFields/src/Brown.cc:		  PointShapeType, OWNDOM(0), OWNISO(0), 1, BrMethodType);
RandomFields/src/Brown.cc:  model *sub = cov->sub[cov->sub[MPP_SHAPE] != NULL ? MPP_SHAPE: MPP_TCF];
RandomFields/src/Brown.cc:    dim = OWNXDIM(0), // sub->ts dim, 
RandomFields/src/Brown.cc:  ASSERT_NEWMODEL_NULL;
RandomFields/src/Brown.cc:  NEWSTOMODEL;
RandomFields/src/Brown.cc:  GETSTOMODEL;
RandomFields/src/Brown.cc:  if (cov->sub[MPP_TCF] != NULL) {
RandomFields/src/Brown.cc:  if ((err = CHECK(cov->key,OWNLOGDIM(0), OWNXDIM(0), VariogramType, OWNDOM(0),
RandomFields/src/Brown.cc:		   SYMMETRIC, 1, EvaluationType)) != NOERROR)
RandomFields/src/Brown.cc:  if ((err = newmodel_covcpy(&(STOMODEL->vario), VARIOGRAM_CALL, cov->key))!=NOERROR)
RandomFields/src/Brown.cc:  if ((err = alloc_pgs(STOMODEL->vario)) != NOERROR) goto ErrorHandling;
RandomFields/src/Brown.cc:  addModel(&(cov->key), GAUSSPROC, cov);
RandomFields/src/Brown.cc:      if ((newx = (double*) MALLOC(dim*newtotpoints*sizeof(double))) == NULL) {
RandomFields/src/Brown.cc:        err=ERRORMEMORYALLOCATION; goto ErrorHandling;
RandomFields/src/Brown.cc:  } else if (COVNR == BRMIXED_INTERN) {
RandomFields/src/Brown.cc:    step = P0(BR_MESHSIZE);
RandomFields/src/Brown.cc:      P(BR_MESHSIZE)[0] = step = mindist;
RandomFields/src/Brown.cc:    if (!PisNULL(BR_OPTIMAREA)) {
RandomFields/src/Brown.cc:      sBR->m3.minradius =  cov->ncol[BR_OPTIMAREA] * step;
RandomFields/src/Brown.cc:    sBR->m3.minradius = FMAX(sBR->m3.minradius, xx); 
RandomFields/src/Brown.cc:    if ((newx = (double*) MALLOC(newxlen*dim*sizeof(double))) == NULL) {
RandomFields/src/Brown.cc:      err = ERRORMEMORYALLOCATION; goto ErrorHandling;
RandomFields/src/Brown.cc:    if ((err = CHECK(sBR->m3.sub[0], OWNLOGDIM(0), OWNXDIM(0), ProcessType,
RandomFields/src/Brown.cc:		     OWNDOM(0), OWNISO(0), 1, GaussMethodType)) == NOERROR) {
RandomFields/src/Brown.cc:         err = CHECK(sBR->m3.sub[0], OWNLOGDIM(0), OWNXDIM(0),  ProcessType,
RandomFields/src/Brown.cc:		     OWNDOM(0), OWNISO(0), 1, GaussMethodType); 
RandomFields/src/Brown.cc:  } else { //  END BRMIXED;  START SHIFTED    
RandomFields/src/Brown.cc:  if (COVNR != BRMIXED_INTERN && grid) {
RandomFields/src/Brown.cc:  if ((err = CHECK(cov->key, OWNLOGDIM(0), OWNXDIM(0), ProcessType, OWNDOM(0),
RandomFields/src/Brown.cc:		   OWNISO(0), 1, GaussMethodType)) == NOERROR) {
RandomFields/src/Brown.cc:      err = CHECK(cov->key, OWNLOGDIM(0), OWNXDIM(0), ProcessType, OWNDOM(0),
RandomFields/src/Brown.cc:		  OWNISO(0), 1, GaussMethodType); 
RandomFields/src/Brown.cc:    dim = OWNXDIM(0);
RandomFields/src/Brown.cc:      minlocation[MAXMPPDIM], maxlocation[MAXMPPDIM],
RandomFields/src/Brown.cc:      centrelocation[MAXMPPDIM], maxdist[MAXMPPDIM];      
RandomFields/src/Brown.cc:      SERR2("'%.50s' requires a variogram model as submodel that tends to infinity with rate of at least 4log(h) for being compatible with '%.50s'", NICK(cov), DefList[SMITHPROC].nick);
RandomFields/src/Brown.cc:    ASSERT_NEWMODEL_NULL;
RandomFields/src/Brown.cc:      addModel(&(cov->key), FIRSTDOLLAR, cov);
RandomFields/src/Brown.cc:      if (!PARAMisNULL(next, DSCALE) ) newscale *= PARAM0(next, DSCALE);
RandomFields/src/Brown.cc:      if (!PARAMisNULL(next, DVAR) )  newscale /= SQRT(PARAM0(next, DVAR));
RandomFields/src/Brown.cc:      RETURN_ERR(ERRORNOTPROGRAMMEDYET);
RandomFields/src/Brown.cc:    if (cov->sub[MPP_TCF] != NULL) {
RandomFields/src/Brown.cc:      RETURN_ERR(ERRORNOTPROGRAMMEDYET);
RandomFields/src/Brown.cc:    if (NEXTNR == BROWNIAN && PARAM0(next, BROWN_ALPHA) == 2.0) {
RandomFields/src/Brown.cc:      addModel(&(cov->key), GAUSS, cov);   // ?? 
RandomFields/src/Brown.cc:	addModel(&(cov->key), FIRSTDOLLAR, cov);
RandomFields/src/Brown.cc:  } else if (hasBrMethodFrame(cov) || hasInterfaceFrame(cov) ||
RandomFields/src/Brown.cc:    if (hasBrMethodFrame(next)) {
RandomFields/src/Brown.cc:      ASSERT_FRAME_DEFINED(next);  
RandomFields/src/Brown.cc:	  || ((err = CHECK(cov->key, OWNLOGDIM(0), OWNXDIM(0),
RandomFields/src/Brown.cc:			  SYMMETRIC, 1, frame)) != NOERROR)) {
RandomFields/src/Brown.cc:      for (d=0; d<MAXMPPDIM; d++) maxdist[d] = 0.5*(maxlocation[d] - minlocation[d]);
RandomFields/src/Brown.cc:      if ((err = newmodel_covcpy(&K, VARIOGRAM_CALL, cov->key, maxdist, NULL,
RandomFields/src/Brown.cc:	meth = BRMIXED_USER;
RandomFields/src/Brown.cc:      addModel(&(cov->key), meth, cov);
RandomFields/src/Brown.cc:      kdefault(key, GEV_MU, P0(GEV_MU));
RandomFields/src/Brown.cc:      if ((err =  CHECK(key, OWNLOGDIM(0), OWNXDIM(0), BrMethodType,
RandomFields/src/Brown.cc:			OWNDOM(0), OWNISO(0),
RandomFields/src/Brown.cc:	                1, BrMethodType)) == NOERROR) {
RandomFields/src/Brown.cc:        err = CHECK(key, OWNLOGDIM(0), OWNXDIM(0), BrMethodType,
RandomFields/src/Brown.cc:		    OWNDOM(0), OWNISO(0),
RandomFields/src/Brown.cc:		    1, BrMethodType);
RandomFields/src/Brown.cc:    ILLEGAL_FRAME;
RandomFields/src/Brown.cc:    sub = cov->sub[cov->sub[MPP_SHAPE] != NULL ? MPP_SHAPE: MPP_TCF]; 
RandomFields/src/Brown.cc:    sub = cov->sub[cov->sub[MPP_SHAPE] != NULL ? MPP_SHAPE: MPP_TCF];
RandomFields/src/Brown.cc:  assert(isBrMethod(cov));
RandomFields/src/Brown.cc:    sub->simu.expected_number_simu = (int) MIN(ens, (double) MAXINT);
RandomFields/src/Brown.cc:#define NORMED_PROB 0 
RandomFields/src/Brown.cc:#define NORMED_OPTIMP 1 // true/false
RandomFields/src/Brown.cc:#define NORMED_NTH 2
RandomFields/src/Brown.cc:#define NORMED_BURNIN 3
RandomFields/src/Brown.cc:#define NORMED_REJECTION 4
RandomFields/src/Brown.cc:#define NORMED_MAX 0
RandomFields/src/Brown.cc:#define NORMED_VALUES 4
RandomFields/src/Brown.cc:  if (i == NORMED_PROB) *nr = SIZE_NOT_DETERMINED;
RandomFields/src/Brown.cc:  else if (i > NORMED_REJECTION) *nr = *nc = OUT_OF_RANGE;
RandomFields/src/Brown.cc:  ASSERT_ONESYSTEM;
RandomFields/src/Brown.cc:  kdefault(cov, NORMED_REJECTION, true);
RandomFields/src/Brown.cc:  kdefault(cov, NORMED_OPTIMP, false);
RandomFields/src/Brown.cc:  kdefault(cov, NORMED_NTH, NA_INTEGER); // i.e. adaptive
RandomFields/src/Brown.cc:  kdefault(cov, NORMED_BURNIN, NA_INTEGER);// i.e. adaptive
RandomFields/src/Brown.cc:  if (!PisNULL(NORMED_PROB)) SERR1("'%.50s' must be given.", KNAME(NORMED_PROB));
RandomFields/src/Brown.cc:  if (NROW(NORMED_PROB) !=1 && NROW(NORMED_PROB) != total)
RandomFields/src/Brown.cc:	  KNAME(NORMED_PROB));
RandomFields/src/Brown.cc:  if (NROW(NORMED_PROB) == total && !global_utils->basic.skipchecks) {
RandomFields/src/Brown.cc:    double *p = P(NORMED_PROB);
RandomFields/src/Brown.cc:      SERR1("Values of '%.50s' do not sum up to 1.", KNAME(NORMED_PROB));
RandomFields/src/Brown.cc:  // printf("normed null%d\n",PisNULL(NORMED_PROB));
RandomFields/src/Brown.cc:    frame = isVariogram(type) ? EvaluationType : BrMethodType;
RandomFields/src/Brown.cc:  isotropy_type isoprev = isVariogram(type) ? SYMMETRIC : CARTESIAN_COORD;
RandomFields/src/Brown.cc:  assert( OWNXDIM(0) *  OWNLOGDIM(0) ==1);
RandomFields/src/Brown.cc:  if ((err = CHECK(sub, OWNLOGDIM(0), OWNXDIM(0),
RandomFields/src/Brown.cc:		   type,//Martin: changed 27.11.13 DefList[COVNR].Type,
RandomFields/src/Brown.cc:  ASSERT_NEWMODEL_NULL;
RandomFields/src/Brown.cc:				     NAME(cov), DefList[SCHLATHERPROC].name);
RandomFields/src/Brown.cc:    centreidx[MAXMPPDIM],
RandomFields/src/Brown.cc:    dim = NEXTXDIM(0);
RandomFields/src/Brown.cc:  double centrelocation[MAXMPPDIM], minlocation[MAXMPPDIM], maxlocation[MAXMPPDIM],
RandomFields/src/Brown.cc:  NEWSTOMODEL;
RandomFields/src/Brown.cc:  GETSTOMODEL;
RandomFields/src/Brown.cc:  if ((newx = (double*) MALLOC(dim * newxlen * sizeof(double))) == NULL) {
RandomFields/src/Brown.cc:     GERR("Memory allocation failed.\n"); 
RandomFields/src/Brown.cc:  if ((err = newmodel_covcpy(&(STOMODEL->vario), VARIOGRAM_CALL, cov->key))!=NOERROR)
RandomFields/src/Brown.cc:  if ((err = alloc_pgs(STOMODEL->vario)) != NOERROR) goto ErrorHandling;
RandomFields/src/Brown.cc:  if (isnowVariogram(next)) addModel(&(cov->key), GAUSSPROC, cov);
RandomFields/src/Brown.cc:  //  PMI(cov);
RandomFields/src/Brown.cc:  if ((err = CHECK(STOMODEL->vario->sub[0], 1, 1, VariogramType, XONLY, 
RandomFields/src/Brown.cc:			  GaussMethodType)) != NOERROR)
RandomFields/src/Brown.cc:   GETSTOMODEL;
RandomFields/src/Brown.cc:    *Ci = (double*) MALLOC(sBR->normed.total * sizeof(double));
RandomFields/src/Brown.cc:    CovarianceMatrixCols(STOMODEL->vario->sub[0], true, i, *Ci);
RandomFields/src/Brown.cc:    *p = P(NORMED_PROB),
RandomFields/src/Brown.cc:  if (P0INT(NORMED_REJECTION)) {
RandomFields/src/Brown.cc:      double u = UNIFORM_RANDOM;
RandomFields/src/Brown.cc:      // der Mittelwert ueber alle endfor Fehlder zu sum_zhou addiert.
RandomFields/src/Brown.cc:      if (ratio >= 1.0 || UNIFORM_RANDOM < ratio) {
RandomFields/src/Brown.cc:  GETSTOMODEL;
RandomFields/src/Brown.cc:    dim = OWNXDIM(0),
RandomFields/src/Brown.cc:    burnin = P0INT(NORMED_BURNIN),
RandomFields/src/Brown.cc:    nth = P0INT(NORMED_NTH),
RandomFields/src/Brown.cc:  Variogram(STOMODEL->vario, trend);
RandomFields/src/Brown.cc:    (double*) MALLOC(sBR->normed.total * sizeof(double));
RandomFields/src/Brown.cc:  //  sBR->normed.field = (double*) MALLOC(sBR->normed.total * sizeof(double));
RandomFields/src/Brown.cc:  if (NROW(NORMED_PROB) == 1) {
RandomFields/src/Brown.cc:    int start = (int) P0(NORMED_PROB);
RandomFields/src/Brown.cc:    PFREE(NORMED_PROB);
RandomFields/src/Brown.cc:    PALLOC(NORMED_PROB, total, 1);
RandomFields/src/Brown.cc:     if (start != P0INT(NORMED_PROB) && PL >=  PL_IMPORTANT ) {
RandomFields/src/Brown.cc:	       KNAME(NORMED_PROB), (int) P0(NORMED_PROB), start);
RandomFields/src/Brown.cc:      for (int i=0; i<total; P(NORMED_PROB)[i++] = unif);
RandomFields/src/Brown.cc:	*p = P(NORMED_PROB),
RandomFields/src/Brown.cc:	*c  =  sBR->normed.C[0] = (double*) MALLOC(totalSq * sizeof(double));
RandomFields/src/Brown.cc:      double *one = (double *) MALLOC(total * sizeof(double));   
RandomFields/src/Brown.cc:	CovarianceMatrix(STOMODEL->vario->sub[0], true, c);
RandomFields/src/Brown.cc:  cov->mpp.mM[0] = cov->mpp.mMplus[0] = 1.0; // 1.0 is import dummy value 
RandomFields/src/Brown.cc:  cov->mpp.mM[1] = cov->mpp.mMplus[1] = 1.0;
RandomFields/src/Brown.cc:  if (P0(NORMED_REJECTION)) {
RandomFields/src/Brown.cc:	SERR1("'%.50s' cannot be determined without burnin", KNAME(NORMED_NTH));
RandomFields/src/Brown.cc:	WARN2("'%.50s'=%d is very large", KNAME(NORMED_NTH), nth);
RandomFields/src/Brown.cc:  double *p = P(NORMED_PROB);
RandomFields/src/Brown.cc:  int totalM1 = sBR->normed.total - 1;
RandomFields/src/Brown.cc:  for (int k=1; k<totalM1; k++)
RandomFields/src/Brown.cc:  sBR->normed.current_cumprob[totalM1] = 1.0;
RandomFields/src/Brown.cc:#define NORMED_EACH 100
RandomFields/src/Brown.cc:  unsigned int each = NORMED_EACH * sBR->normed.nth;
RandomFields/src/Brown.cc:    if (P0INT(NORMED_OPTIMP) && true) {
RandomFields/src/Brown.cc:  range->min[NORMED_PROB] = 0;
RandomFields/src/Brown.cc:  range->max[NORMED_PROB] = 1;
RandomFields/src/Brown.cc:  range->pmin[NORMED_PROB] = 0;
RandomFields/src/Brown.cc:  range->pmax[NORMED_PROB] = 1;
RandomFields/src/Brown.cc:  range->openmin[NORMED_PROB] = true;
RandomFields/src/Brown.cc:  range->openmax[NORMED_PROB] = true;
RandomFields/src/Brown.cc:  booleanRange(NORMED_OPTIMP);
RandomFields/src/Brown.cc:  range->min[NORMED_NTH] = 1;
RandomFields/src/Brown.cc:  range->max[NORMED_NTH] = RF_INF;
RandomFields/src/Brown.cc:  range->pmin[NORMED_NTH] = 1;
RandomFields/src/Brown.cc:  range->pmax[NORMED_NTH] = 1e4;
RandomFields/src/Brown.cc:  range->openmin[NORMED_NTH] = false;
RandomFields/src/Brown.cc:  range->openmax[NORMED_NTH] = true;
RandomFields/src/Brown.cc:  range->min[NORMED_BURNIN] = 0;
RandomFields/src/Brown.cc:  range->max[NORMED_BURNIN] = RF_INF;
RandomFields/src/Brown.cc:  range->pmin[NORMED_BURNIN] = 1;
RandomFields/src/Brown.cc:  range->pmax[NORMED_BURNIN] = 1e6;
RandomFields/src/Brown.cc:  range->openmin[NORMED_BURNIN] = false;
RandomFields/src/Brown.cc:  range->openmax[NORMED_BURNIN] = true;
RandomFields/src/Brown.cc:  booleanRange(NORMED_REJECTION);
RandomFields/src/gauss.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/gauss.cc: Copyright (C) 2005 -- 2017 Martin Schlather
RandomFields/src/gauss.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/gauss.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/gauss.cc:void GetInternalMeanI(double *x, int *info, model *cov, int vdim, double *v,
RandomFields/src/gauss.cc:      GetInternalMeanI(x, info, cov->sub[i], vdim, v, mean);
RandomFields/src/gauss.cc:void GetInternalMean(model *sub, int vdim, double *mean){
RandomFields/src/gauss.cc:  //  PMI0(cov);
RandomFields/src/gauss.cc:  assert(isGaussMethod(cov) || COVNR == GAUSSPROC || COVNR == BINARYPROC);
RandomFields/src/gauss.cc:    MEMCOPY(x, Locx(cov), sizeof(double) * spatialdim);
RandomFields/src/gauss.cc:  GetInternalMeanI(x, info, sub, vdim, v, mean);
RandomFields/src/gauss.cc:  Methods Standard[Nothing] = {
RandomFields/src/gauss.cc:     CircEmbed, CircEmbedIntrinsic, CircEmbedCutoff, SpectralTBM, TBM,
RandomFields/src/gauss.cc:   pref[TBM] = pref[SpectralTBM] = pref[Average] = pref[RandomCoin] = 
RandomFields/src/gauss.cc:  if (loc->timespacedim == 1) pref[TBM] -= 2 * PREF_PENALTY;
RandomFields/src/gauss.cc:    max_variab= MAX(global->direct.maxvariables,
RandomFields/src/gauss.cc:    vdim = VDIM0;
RandomFields/src/gauss.cc:    if (max_variab <= DIRECT_ORIG_MAXVAR)
RandomFields/src/gauss.cc:    //printf("pref[direct] = %d %d %d\n", pref[Direct],max_variab, DIRECT_ORIG_MAXVAR );
RandomFields/src/gauss.cc:    if (isAnySpherical(OWNISO(0)) && OWNTOTALXDIM < 3)
RandomFields/src/gauss.cc:    vdim = VDIM0,
RandomFields/src/gauss.cc:    vdimMax = MIN(vdim, MAXBOXCOXVDIM);					
RandomFields/src/gauss.cc:	vdimMax_2 = 2 * vdimMax;
RandomFields/src/gauss.cc:      for (; i<vdimMax_2; i++) P(BC)[i] = global->gauss.boxcox[i];
RandomFields/src/gauss.cc:      for (int i=0; i<vdimMax; i++) {
RandomFields/src/gauss.cc:  for (int i=0; i<vdimMax; i++) {				
RandomFields/src/gauss.cc:  *nc = i == GAUSS_BOXCOX ? SIZE_NOT_DETERMINED : 1;
RandomFields/src/gauss.cc:  ASSERT_ONESYSTEM;
RandomFields/src/gauss.cc:    xdim = OWNXDIM(0), // could differ from logicaldim in case of distances!
RandomFields/src/gauss.cc:    dim = OWNLOGDIM(0);
RandomFields/src/gauss.cc:    ILLEGAL_FRAME;
RandomFields/src/gauss.cc:  if (MAX(global->direct.maxvariables, cov->base->global_utils.solve.max_chol)
RandomFields/src/gauss.cc:  set_maxdim(OWN, 0, INFDIM);
RandomFields/src/gauss.cc:    if (isGaussMethod(next)) {// waere GaussMethodType 
RandomFields/src/gauss.cc:	//GaussMethodType;
RandomFields/src/gauss.cc:				 SUBMODEL_DEP, frame)) == NOERROR)
RandomFields/src/gauss.cc:	//	if (NEXTTYPE(0)!=TrendType) {APMI(cov);BUG} else printf("jetzt C HECK_GEN\n");
RandomFields/src/gauss.cc:	if ((err = CHECK_GEN(next,  SUBMODEL_DEP, // err mocht verwemdet
RandomFields/src/gauss.cc:			     SUBMODEL_DEP, TrendType, false)) != NOERROR) {
RandomFields/src/gauss.cc:      // PMI0(next);
RandomFields/src/gauss.cc:	Sy mmetricOf(OWNISO(0)),// Jan 2015 S YMMETRIC,
RandomFields/src/gauss.cc:	SUBMODEL_DEP, frame))
RandomFields/src/gauss.cc:	SUBMODEL_DEP, frame)) RETURN_ERR(err); // previous error
RandomFields/src/gauss.cc:    Types frame = hasAnyEvaluationFrame(cov) ? cov->frame : GaussMethodType;
RandomFields/src/gauss.cc:		     SUBMODEL_DEP, frame)) != NOERROR) RETURN_ERR(err);
RandomFields/src/gauss.cc:  //PMI(cov);
RandomFields/src/gauss.cc:  if ((variance = (double*) MALLOC(sizeof(double) * vdimSq)) == NULL ||
RandomFields/src/gauss.cc:  GetInternalMean(next, vdim, mean);
RandomFields/src/gauss.cc:  if (ISNAN(mean[0])) // GetInternalMean currently only allows ...
RandomFields/src/gauss.cc:    GERR("Mean equals NA. Did you try a multivariate model or an incomplete (mixed) model?");
RandomFields/src/gauss.cc:  //    err = CHECK(next, OWNLOGDIM(0), OWNXDIM(0),  PosDefType, KERNEL,
RandomFields/src/gauss.cc:  if ((err = alloc_mpp_M(cov, 2)) != NOERROR) goto ErrorHandling;
RandomFields/src/gauss.cc:    if (v < MAXMPPVDIM)
RandomFields/src/gauss.cc:    cov->mpp.mM[idx + 0] = cov->mpp.mMplus[idx + 0] = 1.0;       
RandomFields/src/gauss.cc:    cov->mpp.mMplus[idx + 1] = 
RandomFields/src/gauss.cc:    cov->mpp.mM[idx + 1] = 0.0;
RandomFields/src/gauss.cc:    cov->mpp.mM[idx + 2] = variance[w];
RandomFields/src/gauss.cc:    // todo: cov->mpp.mMplus[2] berechnen
RandomFields/src/gauss.cc:  SPRINTF(cov->base->error_location, "simulation procedure for %.50s", NAME(next));
RandomFields/src/gauss.cc:  ASSERT_ONESYSTEM;
RandomFields/src/gauss.cc:    err = ERROROUTOFMETHODLIST,
RandomFields/src/gauss.cc:    xdim = OWNXDIM(0), // could differ from logicaldim in case of distances!
RandomFields/src/gauss.cc:    logicaldim = OWNLOGDIM(0);
RandomFields/src/gauss.cc:  ASSERT_NEWMODEL_NULL;
RandomFields/src/gauss.cc:  if ((logicaldim != PREVXDIM(0) || logicaldim != xdim) &&
RandomFields/src/gauss.cc:      (!loc->distances || PREVXDIM(0)!=1)) {
RandomFields/src/gauss.cc:    BUG; // RETURN_ERR(ERRORDIM);
RandomFields/src/gauss.cc:  if ((err = CHECK_PASSTF(cov->key, // 11.1.19 cov WARUM ??
RandomFields/src/gauss.cc:			  GaussMethodType, VDIM0, 
RandomFields/src/gauss.cc:			  // WARUM ??
RandomFields/src/gauss.cc:			  GaussMethodType)) != NOERROR && !isAnyDollar(sub)) {
RandomFields/src/gauss.cc:  //  if ((err = CHECK( c o v, dim, xdim, GaussMethodType, OWNDOM(0),
RandomFields/src/gauss.cc:    *lastmethod= equalsnowGaussMethod(sub) ? sub : firstmethod;
RandomFields/src/gauss.cc:    lastmethod->sub[idx] = dollar->sub[0]; // eigentl. Modell jetzt anhaengen
RandomFields/src/gauss.cc:      nr == AVERAGE_USER || nr == RANDOMCOIN_USER
RandomFields/src/gauss.cc:      : GaussMethodType;
RandomFields/src/gauss.cc:    if ((err = CHECK_PASSTF(cov->key, // 11.1.19 cov WARUM ??
RandomFields/src/gauss.cc:			    GaussMethodType, //?! 8.12.17
RandomFields/src/gauss.cc:			    VDIM0, frame)) != NOERROR) {
RandomFields/src/gauss.cc:  Methods m;
RandomFields/src/gauss.cc:  for (m=CircEmbed; m <= Hyperplane; m = (Methods) ((int) (m + 1))) {
RandomFields/src/gauss.cc:    if (gaussmethod[(Methods) m] == COVNR) break;
RandomFields/src/gauss.cc:  SPRINTF(error_location, "simulation method for %.50s", NAME(next));
RandomFields/src/gauss.cc:  ASSERT_NEWMODEL_NULL;
RandomFields/src/gauss.cc:    xdim = OWNXDIM(0), // could differ from tsdgetim in case of distances!
RandomFields/src/gauss.cc:    logicaldim = OWNLOGDIM(0);
RandomFields/src/gauss.cc:#define  MAXFAILMSG 9
RandomFields/src/gauss.cc:  char FailureMsg[MAXFAILMSG][80] = {"unknown reason",
RandomFields/src/gauss.cc:  Methods unimeth = Forbidden;
RandomFields/src/gauss.cc:  ASSERT_ONESYSTEM;
RandomFields/src/gauss.cc:  if( (logicaldim != PREVXDIM(0) || logicaldim != xdim) &&
RandomFields/src/gauss.cc:      (!loc->distances || PREVXDIM(0) !=1)) {
RandomFields/src/gauss.cc:    BUG; //RETURN_ERR(ERRORDIM);
RandomFields/src/gauss.cc:  // GaussMethodType; cov->key not given
RandomFields/src/gauss.cc:    LPRINT("\n%s:%s\n", NAME(cov), NAME(next));
RandomFields/src/gauss.cc:	     METHOD_NAMES[i], N->pref[i], next->pref[i], 
RandomFields/src/gauss.cc:    err = pref[Nothing] == PREF_NONE ? ERRORINVALIDMODEL : ERRORODDMODEL;
RandomFields/src/gauss.cc:  err = CERROROUTOFMETHODLIST; // in case none of the methods are available 
RandomFields/src/gauss.cc:	     CAT_TYPE_NAMES[GaussMethodType], METHOD_NAMES[unimeth],NICK(next));
RandomFields/src/gauss.cc:    unimeth = (Methods) order[i];
RandomFields/src/gauss.cc:	     CAT_TYPE_NAMES[GaussMethodType], METHOD_NAMES[unimeth],NICK(next));
RandomFields/src/gauss.cc:    //   printf("METH=%d %d %d\n", meth, CE_INTRINPROC_USER, CE_INTRINPROC_INTERN);
RandomFields/src/gauss.cc:    addModelKey(cov, meth);
RandomFields/src/gauss.cc:      MODELNR(key) == AVERAGE_INTERN ? PoissonGaussType :      
RandomFields/src/gauss.cc:      hasAnyEvaluationFrame(cov) ? cov->frame : GaussMethodType;
RandomFields/src/gauss.cc:    if ((err = CHECK(key, logicaldim, xdim, GaussMethodType, OWNDOM(0),
RandomFields/src/gauss.cc:	  if ((err = CHECK(key, logicaldim, xdim, GaussMethodType, OWNDOM(0),
RandomFields/src/gauss.cc:	       METHOD_NAMES[unimeth], err, unimeth, METHOD_NAMES[unimeth]);     
RandomFields/src/gauss.cc:	  char msg[LENERRMSG]; errorMSG(err, msg);
RandomFields/src/gauss.cc:      } // else if (PL >= PL_BRANCHING) M ERR(err);
RandomFields/src/gauss.cc:	char msg[LENERRMSG]; errorMSG(err,msg);
RandomFields/src/gauss.cc:#define NMAX 14
RandomFields/src/gauss.cc:    char lpd[255], pd[255], names[NMAX];
RandomFields/src/gauss.cc:    names[NMAX-1] = '\0';
RandomFields/src/gauss.cc:	SPRINTF(lpd, "%.50s (locp) ", FailureMsg[MAX(0, MIN(MAXFAILMSG-1, 1-lp))]);
RandomFields/src/gauss.cc:	SPRINTF(pd, "%.50s (pref)", FailureMsg[MAX(0, MIN(MAXFAILMSG-1, 1-p))]);
RandomFields/src/gauss.cc:      strcopyN(names, METHOD_NAMES[i], NMAX-1);
RandomFields/src/gauss.cc:#ifdef SCHLATHERS_MACHINE    
RandomFields/src/gauss.cc:    SPRINTF(error_location, "Only 1 method found for '%.50s', namely '%.50s', which failed (err=%d)", NICK(next), METHOD_NAMES[unimeth], err);
RandomFields/src/gauss.cc:    SPRINTF(error_location, "Only 1 method found for '%.50s', namely '%.50s', which failed", NICK(next), METHOD_NAMES[unimeth]);   
RandomFields/src/gauss.cc:  RETURN_ERR(ERROROUTOFMETHODLIST);
RandomFields/src/gauss.cc:    vdimtot = Loctotalpoints(cov) * VDIM0 ;
RandomFields/src/gauss.cc:  if (i == BINARY_THRESHOLD) *nr = SIZE_NOT_DETERMINED;
RandomFields/src/gauss.cc:    if ((err = CHECK_PASSTF(sub, ProcessType, SUBMODEL_DEP,
RandomFields/src/gauss.cc:    //		     OWNDOM(0), OWNISO(0),
RandomFields/src/gauss.cc:    //		     SUBMODEL_DEP, 
RandomFields/src/gauss.cc:  VDIM0 = sub->vdim[0];
RandomFields/src/gauss.cc:  VDIM1 = sub->vdim[1];
RandomFields/src/gauss.cc:    if (cov->key != NULL && !PARAMisNULL(cov->key, BINARY_THRESHOLD)) {
RandomFields/src/gauss.cc:      PARAMFREE(cov->key, BINARY_THRESHOLD);
RandomFields/src/gauss.cc:      PARAMtoNULL(cov->key, BINARY_THRESHOLD);
RandomFields/src/gauss.cc:    err = CHECK_PASSTF(cov->key, ProcessType, SUBMODEL_DEP, GaussMethodType);
RandomFields/src/gauss.cc:    //		OWNDOM(0), OWNISO(0), SUBMODEL_DEP, GaussMethodType);
RandomFields/src/gauss.cc:  if ((variance = (double*) MALLOC(sizeof(double) * vdimSq)) == NULL ||
RandomFields/src/gauss.cc:    GetInternalMean(next, vdim, mean);
RandomFields/src/gauss.cc:    if (ISNAN(mean[0])) // GetInternalMean currently only allows ...
RandomFields/src/gauss.cc:      if (v < MAXMPPVDIM) cov->mpp.maxheights[v] = 1.0; // maxv
RandomFields/src/gauss.cc:	assert(cov->mpp.mM != NULL);
RandomFields/src/gauss.cc:	cov->mpp.mM[idx + 0] = cov->mpp.mMplus[idx + 0] = 1.0; 
RandomFields/src/gauss.cc:	  cov->mpp.mM[idx + 1] = cov->mpp.mMplus[idx + 1] = 
RandomFields/src/gauss.cc:	    cov->mpp.mM[idx + i] = cov->mpp.mMplus[idx + i] = cov->mpp.mM[idx + 1];
RandomFields/src/gauss.cc:    vdim = VDIM0;
RandomFields/src/gauss.cc:  assert(VDIM0 == VDIM1);
RandomFields/src/gauss.cc:  ASSERT_ONESYSTEM;
RandomFields/src/gauss.cc:   xdim = OWNXDIM(0), // could differ from logicaldim in case of distances!
RandomFields/src/gauss.cc:    logicaldim = OWNLOGDIM(0);
RandomFields/src/gauss.cc:    //    if (!isGaussMethod(next) && !isVariogram(next))
RandomFields/src/gauss.cc:		     SUBMODEL_DEP, GaussMethodType)) != NOERROR) {
RandomFields/src/gauss.cc:		       SUBMODEL_DEP, GaussMethodType)) != NOERROR) {
RandomFields/src/gauss.cc:    if ((v = (double*) MALLOC(sizeof(double) * vdimSq)) == NULL)
RandomFields/src/gauss.cc:      RETURN_ERR(ERRORMEMORYALLOCATION);
RandomFields/src/gauss.cc:    VDIM0 = sub->vdim[0];
RandomFields/src/gauss.cc:    VDIM1 = sub->vdim[1];
RandomFields/src/gauss.cc:    if ((err = CHECK_PASSTF(key, ProcessType, SUBMODEL_DEP, GaussMethodType))
RandomFields/src/gauss.cc:    //		       OWNDOM(0), OWNISO(0),
RandomFields/src/gauss.cc:    //		       SUBMODEL_DEP, cov->frame)) != NOERROR) RETURN_ERR(err);
RandomFields/src/gauss.cc:    addModelKey(cov, GAUSSPROC);
RandomFields/src/gauss.cc:    if ((err = CHECK_PASSFRAME(cov->key, GaussMethodType)) != NOERROR) RETURN_ERR(err);
RandomFields/src/gauss.cc:    //		     SUBMODEL_DEP, GaussMethodType)) != NOERROR) RETURN_ERR(err);
RandomFields/src/gauss.cc:    vdim = VDIM0;
RandomFields/src/gauss.cc:    mean = sub->mpp.mM[idxsub + 1];
RandomFields/src/gauss.cc:    m2 = sub->mpp.mM[idxsub + 2];
RandomFields/src/gauss.cc:    if (ISNAN(mean)) // GetInternalMean currently only allows ...
RandomFields/src/gauss.cc:    if (v < MAXMPPVDIM) cov->mpp.maxheights[v] =  // maxv
RandomFields/src/gauss.cc:      assert(cov->mpp.mM != NULL);
RandomFields/src/gauss.cc:      cov->mpp.mM[idx + 0] = cov->mpp.mMplus[idx + 0] = 1.0; 
RandomFields/src/gauss.cc:	cov->mpp.mMplus[idx + 1] = 		  
RandomFields/src/gauss.cc:	cov->mpp.mM[idx + 1] = RF_NA; // to do: richtiger Wert
RandomFields/src/gauss.cc:	  cov->mpp.mM[idx + 2] = 3 * variance * RF_NA;//check the 4th moment of a Gaussian, to do
RandomFields/src/gauss.cc:    totvdim = Loc(cov)->totalpoints * VDIM0;
RandomFields/src/gauss.cc:    n = Loc(cov)->totalpoints * VDIM0;
Binary file RandomFields/src/startGetNset.o matches
RandomFields/src/Coordinate_systems.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/Coordinate_systems.h: Copyright (C) 2015 -- 2017  Martin Schlather
RandomFields/src/Coordinate_systems.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/Coordinate_systems.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/Coordinate_systems.h:#define piD180 (M_PI * 0.00555555555555555555555)
RandomFields/src/Coordinate_systems.h:void EarthKM2CartStat(double *x, int *,  model *cov, double *v);
RandomFields/src/Coordinate_systems.h:void EarthKM2Cart(double *x, double *y, int *, model *cov, double *v, double *);
RandomFields/src/Coordinate_systems.h:void EarthMiles2CartStat(double *x, int *, model *cov, double *v);
RandomFields/src/Coordinate_systems.h:void EarthMiles2Cart(double *x, double *y, int *, model *cov, double *v, double *);
RandomFields/src/Coordinate_systems.h:void EarthKM2OrthogStat(double *x, int *, model *cov, double *v);
RandomFields/src/Coordinate_systems.h:void EarthKM2Orthog(double *x, double *y, int *, model *cov, double *v, double *);
RandomFields/src/Coordinate_systems.h:void EarthMiles2OrthogStat(double *x, int *, model *cov, double *v);
RandomFields/src/Coordinate_systems.h:void EarthMiles2Orthog(double *x, double *y, int *, model *cov, double *v, double *);
RandomFields/src/Coordinate_systems.h:#define STATMOD_BASE(X, Z, lon, lat)				\
RandomFields/src/Coordinate_systems.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/Coordinate_systems.cc: Copyright (C) 2014 -- 2017 Martin Schlather
RandomFields/src/Coordinate_systems.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/Coordinate_systems.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/Coordinate_systems.cc:#define MAXEARTHXDIM 6
RandomFields/src/Coordinate_systems.cc:  for (i=0; i<MAXSUB; i++) {
RandomFields/src/Coordinate_systems.cc:  return LASTSYSTEM(sys) > 0 && isLogCart(sys, 1) && LOGDIM(sys, 1) == 1;
RandomFields/src/Coordinate_systems.cc:  return modulus - FABS(Mod(x, twomodulus) - modulus);
RandomFields/src/Coordinate_systems.cc:  return FABS(Mod(y, twomodulus) - modulus) - halfmodulus;
RandomFields/src/Coordinate_systems.cc:#define STATMOD(Z, X, lon, lat)				\
RandomFields/src/Coordinate_systems.cc:    STATMOD_BASE(X, Z, lon, lat);				\
RandomFields/src/Coordinate_systems.cc:  //STATMOD(y, x, lon, lat);
RandomFields/src/Coordinate_systems.cc:  STATMOD_BASE(x, y, lon, lat);
RandomFields/src/Coordinate_systems.cc:#define ISOMOD(Z, X, maxangle)				\
RandomFields/src/Coordinate_systems.cc:  int dim=PREVTOTALXDIM;					\
RandomFields/src/Coordinate_systems.cc:  int last=PREVLASTSYSTEM;						\
RandomFields/src/Coordinate_systems.cc:      int dim = PREVXDIM(s),						\
RandomFields/src/Coordinate_systems.cc:	base = PREVCUMXOHNE(s);					\
RandomFields/src/Coordinate_systems.cc:void Earth2Earth(double *x) { STATMOD_BASE(x, x, 360, 180); }
RandomFields/src/Coordinate_systems.cc:  int dim=PREVTOTALXDIM;					
RandomFields/src/Coordinate_systems.cc:  STATMOD(x, X, 360, 180);					
RandomFields/src/Coordinate_systems.cc:  STATMOD(y, Y, 360, 180);
RandomFields/src/Coordinate_systems.cc:  int dim=PREVTOTALXDIM;			       
RandomFields/src/Coordinate_systems.cc:  STATMOD(H80Dpi * x, X, 360, 180);
RandomFields/src/Coordinate_systems.cc:  ISOMOD(piD180 * x, X, M_PI);
RandomFields/src/Coordinate_systems.cc:  int dim=PREVTOTALXDIM;			       
RandomFields/src/Coordinate_systems.cc:  STATMOD_BASE(X, piD180 * x, M_2_PI, M_PI);
RandomFields/src/Coordinate_systems.cc:  int dim=PREVTOTALXDIM;	
RandomFields/src/Coordinate_systems.cc:  STATMOD(piD180 * x, X, M_2_PI, M_PI);
RandomFields/src/Coordinate_systems.cc:  STATMOD(piD180 * y, Y, M_2_PI, M_PI);
RandomFields/src/Coordinate_systems.cc:void SphereIso2SphereIso(double *x) {x[0]=isomod(x[0], M_PI); }
RandomFields/src/Coordinate_systems.cc:void Sphere2Sphere(double *x) { STATMOD_BASE(x, x, M_2_PI, M_PI); }
RandomFields/src/Coordinate_systems.cc:  int dim=PREVTOTALXDIM;			       
RandomFields/src/Coordinate_systems.cc:  STATMOD(x, X, M_2_PI, M_PI);
RandomFields/src/Coordinate_systems.cc:  STATMOD(y, Y, M_2_PI, M_PI); 
RandomFields/src/Coordinate_systems.cc:#if MAXSYSTEMS == 1
RandomFields/src/Coordinate_systems.cc:assert(PREVXDIM(0) == 2 || PREVXDIM(0) == 3);	\
RandomFields/src/Coordinate_systems.cc:   assert(GATTERLASTSYSTEM == 0)
RandomFields/src/Coordinate_systems.cc:#define ASSERT_EARTH  assert(PREVXDIM(0) == 2 || PREVXDIM(0) == 3); \
RandomFields/src/Coordinate_systems.cc:   assert(GATTERLASTSYSTEM == 0)
RandomFields/src/Coordinate_systems.cc:    dim = PREVTOTALXDIM,						\
RandomFields/src/Coordinate_systems.cc:    dim = PREVTOTALXDIM,						\
RandomFields/src/Coordinate_systems.cc:      MEMCOPY(yy, X, 3 *sizeof(double));
RandomFields/src/Coordinate_systems.cc:	MEMCOPY(yy, x + base, bytes);
RandomFields/src/Coordinate_systems.cc:      MEMCOPY(yy, X, 3 *sizeof(double));
RandomFields/src/Coordinate_systems.cc:	MEMCOPY(yy, x + base, bytes);
RandomFields/src/Coordinate_systems.cc:void EarthKM2CartStat(double *x, INFO, model *cov, double *X) {
RandomFields/src/Coordinate_systems.cc:void EarthKM2Cart(double *x, double *y, INFO, model *cov, double *X, double *Y){
RandomFields/src/Coordinate_systems.cc:void EarthMiles2CartStat(double *x, INFO, model *cov, double *X) {
RandomFields/src/Coordinate_systems.cc:void EarthMiles2Cart(double *x, double *y, INFO,
RandomFields/src/Coordinate_systems.cc:   // printf("checkEarch %d %d %d %f %f %ld %ld\n", TRAFONR, EARTHKM2GNOMONIC, EARTHMILES2GNOMONIC, global->coords.zenit[0], global->coords.zenit[1], global, GLOBAL);
RandomFields/src/Coordinate_systems.cc:  if (equalsXonly(PREVDOM(0)) // 20.2.14: warum war es vorher OWNDOM(0) == X ONLY?
RandomFields/src/Coordinate_systems.cc:    assert(GATTERXDIM(0) == 2 && GATTERXDIM(0) == GATTERLOGDIM(0));
RandomFields/src/Coordinate_systems.cc:    if (TRAFONR == EARTHKM2GNOMONIC || 
RandomFields/src/Coordinate_systems.cc:	TRAFONR == EARTHMILES2GNOMONIC) {
RandomFields/src/Coordinate_systems.cc:     if (TRAFONR == EARTHKM2GNOMONIC) {
RandomFields/src/Coordinate_systems.cc:    assert(TRAFONR >= EARTHKM2CART && TRAFONR <= EARTHMILES2CART);
RandomFields/src/Coordinate_systems.cc:  if (GATTERTOTALXDIM > MAXEARTHXDIM) SERR("dimension exceeded");
RandomFields/src/Coordinate_systems.cc:  double X[MAXEARTHXDIM + 1];					\
RandomFields/src/Coordinate_systems.cc:  double Y[MAXEARTHXDIM + 1];
RandomFields/src/Coordinate_systems.cc:void EarthKM2OrthogStat(double *x, INFO, model *cov, double *U) {
RandomFields/src/Coordinate_systems.cc:  assert(TRAFONR == EARTHKM2ORTHOGRAPHIC);
RandomFields/src/Coordinate_systems.cc:void EarthKM2Orthog(double *x, double *y, INFO, model *cov, double *U, 
RandomFields/src/Coordinate_systems.cc:  assert(TRAFONR == EARTHKM2ORTHOGRAPHIC);
RandomFields/src/Coordinate_systems.cc:void EarthMiles2OrthogStat(double *x, INFO, model *cov, double *U) {
RandomFields/src/Coordinate_systems.cc:  assert(TRAFONR == EARTHMILES2ORTHOGRAPHIC);
RandomFields/src/Coordinate_systems.cc:void EarthMiles2Orthog(double *x, double *y, INFO, model *cov, 
RandomFields/src/Coordinate_systems.cc:  assert(TRAFONR == EARTHMILES2ORTHOGRAPHIC);
RandomFields/src/Coordinate_systems.cc:  assert(TRAFONR == EARTHKM2GNOMONIC || TRAFONR == EARTHMILES2GNOMONIC);
RandomFields/src/Coordinate_systems.cc:  assert(TRAFONR == EARTHKM2GNOMONIC || TRAFONR == EARTHMILES2GNOMONIC);
RandomFields/src/Coordinate_systems.cc:  if (knr>=0 && knr <= MODEL_MAX && key[knr] != NULL) {
RandomFields/src/Coordinate_systems.cc:				    COORD_SYS_NAMES, nr_coord_sys, coord_auto),
RandomFields/src/Coordinate_systems.cc:				    COORD_SYS_NAMES, nr_coord_sys, coord_keep);
RandomFields/src/Coordinate_systems.cc:      WARN1("the covariance model relies on at least two different coordinate systems. Use RFgetModelInfo(level=6) and check that this is not due to misspecification of the covariance model. To avoid this warning set 'RFoptions(%.50s=FALSE)'", // OK
RandomFields/src/Coordinate_systems.cc:	    messages[MESSAGES_COORD_CHANGE]);
RandomFields/src/Coordinate_systems.cc:	      COORD_SYS_NAMES[os], COORD_SYS_NAMES[n_s], 
RandomFields/src/Coordinate_systems.cc:      SET_STRING_ELT(res, 0, mkChar(COORD_SYS_NAMES[os]));    
RandomFields/src/Coordinate_systems.cc:      SET_STRING_ELT(res, 1, mkChar(COORD_SYS_NAMES[n_s]));    
RandomFields/src/Coordinate_systems.cc:  return isSpherical(iso) ? SPHERICAL_COORD : ISO_MISMATCH;
RandomFields/src/Coordinate_systems.cc:  return isAnySpherical(iso) ? SPHERICAL_COORD : ISO_MISMATCH;
RandomFields/src/Coordinate_systems.cc:  if (isCartesian(iso)) return SYMMETRIC;
RandomFields/src/Coordinate_systems.cc:  if (isEarth(iso)) return EARTH_SYMMETRIC;
RandomFields/src/Coordinate_systems.cc:  return isSpherical(iso) ? SPHERICAL_SYMMETRIC : ISO_MISMATCH;
RandomFields/src/Coordinate_systems.cc:  return isSpherical(iso) ? SPHERICAL_ISOTROPIC : ISO_MISMATCH;
Binary file RandomFields/src/fft.o matches
Binary file RandomFields/src/empvario.o matches
RandomFields/src/AutoRandomFields.cc:*DOMAIN_NAMES[LAST_DOMAIN + 1] = { //RC
RandomFields/src/AutoRandomFields.cc:  *OPTIMISER_NAMES[nOptimiser] = { // RC
RandomFields/src/AutoRandomFields.cc:  *NLOPTR_NAMES[nNLOPTR] = { // RC
RandomFields/src/AutoRandomFields.cc:    "NLOPT_LN_PRAXIS", "NLOPT_GN_CRS2_LM",
RandomFields/src/AutoRandomFields.cc:    "NLOPT_LN_COBYLA", "NLOPT_LN_NELDERMEAD", 
RandomFields/src/AutoRandomFields.cc:  *LIKELIHOOD_NAMES[nLikelihood] = { // RC 
RandomFields/src/AutoRandomFields.cc:  *DUPLICATEDLOC_NAMES[nDuplicatedloc] = { // RC 
RandomFields/src/AutoRandomFields.cc:  *ISO_NAMES[LAST_ISO + 1] =  { // RC
RandomFields/src/AutoRandomFields.cc:  *TYPE_NAMES[LASTTYPE + 1] = { // RC
RandomFields/src/AutoRandomFields.cc:  *NEGATIVE_NAMES[-UNSET] = {
RandomFields/src/AutoRandomFields.cc:  "PARAM_DEP", "PREVMODEL_DEP", "SUBMODEL_DEP", "MISMATCH", "UNSET"
RandomFields/src/AutoRandomFields.cc:  *MONOTONE_NAMES[MONOTONE_TOTAL] = { // RC
RandomFields/src/AutoRandomFields.cc:  *SORT_ORIGIN_NAMES[1 + (int) all_origins] = {
RandomFields/src/AutoRandomFields.cc:    "original model", "MLE conform", "all"
RandomFields/src/AutoRandomFields.cc:  *MODE_NAMES[nr_modes] = {
RandomFields/src/AutoRandomFields.cc:  *OUTPUTMODE_NAMES[nr_output_modes] = {
RandomFields/src/AutoRandomFields.cc:  *ANGLE_NAMES[last_angle_mode + 1] = {
RandomFields/src/AutoRandomFields.cc:  *REPORTCOORD_NAMES[nr_reportcoord_modes] = {
RandomFields/src/AutoRandomFields.cc:  *UNITS_NAMES[nr_units] = {
RandomFields/src/AutoRandomFields.cc:  *COORD_SYS_NAMES[nr_coord_sys] = {
RandomFields/src/AutoRandomFields.cc:  *COORD_NAMES_GENERAL[2] = {
RandomFields/src/AutoRandomFields.cc:  *CARTESIAN_SYS_NAMES[3] = {
RandomFields/src/AutoRandomFields.cc:  *TYPEOF_PARAM_NAMES[LASTSORTOF + 1] = {
RandomFields/src/AutoRandomFields.cc:    "critical to estimate (used internally)", "only used by MLE", 
RandomFields/src/AutoRandomFields.cc:    "neither used by MLE nor returned",
RandomFields/src/AutoRandomFields.cc:  *EQ_NAMES[nEQ_NAMES] = {"==", "!=", "<=", "<", ">=", ">"},
RandomFields/src/AutoRandomFields.cc:  *NAMES_OF_NAMES[nNamesOfNames] = {// see also LIST_OF_NAMES in init.general.cc
RandomFields/src/AutoRandomFields.cc:    "EQ_NAMES", "ISO_NAMES", // never change ordering !!, see also userinterface.cc  
RandomFields/src/AutoRandomFields.cc:    "DOMAIN_NAMES","TYPE_NAMES", 
RandomFields/src/AutoRandomFields.cc:    "MONOTONE_NAMES",
RandomFields/src/AutoRandomFields.cc:    "MODE_NAMES", "OUTPUTMODE_NAMES", "REPORTCOORD_NAMES",
RandomFields/src/AutoRandomFields.cc:    "UNITS_NAMES", "COORD_SYS_NAMES", "CARTESIAN_SYS_NAMES",
RandomFields/src/AutoRandomFields.cc:    "TYPEOF_PARAM_NAMES"},
RandomFields/src/AutoRandomFields.cc:  *PROJECTION_NAMES[nProjections] = {
RandomFields/src/AutoRandomFields.cc:  *RMCOV_X[nVAR2COV_METHODS] = { // c ==  COVARIATE_C_NAME 
RandomFields/src/AutoRandomFields.cc:  *FCTN_TYPE_NAMES[TOTAL_FCTN_TYPE] = {
RandomFields/src/AutoRandomFields.cc:  "Variogram", "Madogram", "Covariance", "Pseudomadogram", "Pseudovariogram"},
RandomFields/src/AutoRandomFields.cc:  *METHOD_NAMES[Forbidden+1]={"circulant", // RC
RandomFields/src/AutoRandomFields.cc:  *POISSON_SCATTER_NAMES[nPOISSON_SCATTER] = {// must be in the ordering of
RandomFields/src/AutoRandomFields.cc:  "optimized", "standard", "any"}; // addPGS/local in extremes.cc and RMS.cc
RandomFields/src/tbm.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/tbm.cc: Copyright (C) 2001 -- 2017 Martin Schlather, 
RandomFields/src/tbm.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/tbm.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFields/src/tbm.cc:#define MAXNN 100000000.0 /* max number of points simulated on a line */
RandomFields/src/tbm.cc:#define TBM_LINES (COMMON_GAUSS + 4)
RandomFields/src/tbm.cc:#define TBM_LINESIMUFACTOR (COMMON_GAUSS + 5)
RandomFields/src/tbm.cc:#define TBM_LINESIMUSTEP (COMMON_GAUSS + 6)
RandomFields/src/tbm.cc:#define TBM_CENTER (COMMON_GAUSS + 7)
RandomFields/src/tbm.cc:#define TBM_POINTS (COMMON_GAUSS + 8)
RandomFields/src/tbm.cc:#define TBM_COV 0
RandomFields/src/tbm.cc:    *deltax= 2.0 * UNIFORM_RANDOM - 1.0;
RandomFields/src/tbm.cc:    *deltax= 2.0 *UNIFORM_RANDOM - 1.0;// see Martin's tech rep for details
RandomFields/src/tbm.cc:    *deltay= SQRT(1.0 - *deltax * *deltax) * SIN(UNIFORM_RANDOM*TWOPI);
RandomFields/src/tbm.cc:    *deltaz = 2.0 * UNIFORM_RANDOM - 1.0; // ir case of multivariate
RandomFields/src/tbm.cc:    *deltay = UNIFORM_RANDOM * TWOPI;
RandomFields/src/tbm.cc:  model *next = cov->sub[TBM_COV];
RandomFields/src/tbm.cc:  int fulldim = P0INT(TBM_FULLDIM),
RandomFields/src/tbm.cc:    layers = P0INT(TBM_LAYERS);
RandomFields/src/tbm.cc:  *effectivedim = ANYDIM; 
RandomFields/src/tbm.cc:      SERR1("value of '%.50s' does not match the situation", KNAME(TBM_LAYERS))
RandomFields/src/tbm.cc:  if (*effectivedim > fulldim) RETURN_ERR(ERRORWRONGDIM);
RandomFields/src/tbm.cc:  int dim = ANYDIM; 
RandomFields/src/tbm.cc:  //  printf("tbm kappas %d %d %d\n", i, TBM_CENTER, dim);
RandomFields/src/tbm.cc:  if (i==TBM_CENTER) *nr = dim;
RandomFields/src/tbm.cc:  case TBM_FULLDIM :
RandomFields/src/tbm.cc:  case TBM_TBMDIM :
RandomFields/src/tbm.cc:    BooleanRange(TBM_LAYERS);
RandomFields/src/tbm.cc:  case TBM_LINES :
RandomFields/src/tbm.cc:  case TBM_LINESIMUFACTOR :
RandomFields/src/tbm.cc:  case TBM_LINESIMUSTEP :
RandomFields/src/tbm.cc:  case TBM_CENTER :
RandomFields/src/tbm.cc:  case TBM_POINTS :
RandomFields/src/tbm.cc:  FRAME_ASSERT_GAUSS_INTERFACE;
RandomFields/src/tbm.cc:  // TO DO : split TBM in a RPmodel that expects
RandomFields/src/tbm.cc:    *next=cov->sub[TBM_COV],
RandomFields/src/tbm.cc:  int  err = NOERROR;  // taken[MAX DIM],
RandomFields/src/tbm.cc:  ASSERT_ONESYSTEM;
RandomFields/src/tbm.cc:  if (global->general.vdim_close_together && VDIM0 > 1)
RandomFields/src/tbm.cc:    SERR1("TBM only allowed if '%.50s=FALSE'", general[GENERAL_CLOSE]);
RandomFields/src/tbm.cc:  kdefault(cov, TBM_FULLDIM, gp->fulldim);
RandomFields/src/tbm.cc:  kdefault(cov, TBM_FULLDIM, PisNULL(TBM_TBMDIM) || gp->tbmdim >= 0
RandomFields/src/tbm.cc:	   ? gp->fulldim : P0INT(TBM_TBMDIM) - gp->tbmdim);
RandomFields/src/tbm.cc:  kdefault(cov, TBM_TBMDIM, gp->tbmdim > 0 
RandomFields/src/tbm.cc:	   ? gp->tbmdim : P0INT(TBM_FULLDIM) + gp->tbmdim);
RandomFields/src/tbm.cc:  kdefault(cov, TBM_LAYERS, (int) gp->layers);
RandomFields/src/tbm.cc:    tbmdim = P0INT(TBM_TBMDIM),
RandomFields/src/tbm.cc:    fulldim = P0INT(TBM_FULLDIM);
RandomFields/src/tbm.cc:	   KNAME(TBMOP_TBMDIM), tbmdim, KNAME(TBM_FULLDIM), fulldim);
RandomFields/src/tbm.cc:  kdefault(cov, TBM_LINES, gp->lines[fulldim-1]);
RandomFields/src/tbm.cc:  kdefault(cov, TBM_LINESIMUFACTOR, gp->linesimufactor); 
RandomFields/src/tbm.cc:  kdefault(cov, TBM_LINESIMUSTEP, gp->linesimustep);
RandomFields/src/tbm.cc:  //  kdefault(cov, TBM_GRID, gp->grid);
RandomFields/src/tbm.cc:  // if ( P0INT(TBM_GRID))
RandomFields/src/tbm.cc:  if (PisNULL(TBM_CENTER)) {    
RandomFields/src/tbm.cc:    int Dim = OWNTOTALXDIM;
RandomFields/src/tbm.cc:      PALLOC(TBM_CENTER, Dim, 1);
RandomFields/src/tbm.cc:      P(TBM_CENTER)[d] = gp->center[d];
RandomFields/src/tbm.cc:    if (cov->nrow[TBM_CENTER] < OWNTOTALXDIM) 
RandomFields/src/tbm.cc:      SERR1("vector for '%.50s' too short", KNAME(TBM_CENTER));
RandomFields/src/tbm.cc:  kdefault(cov, TBM_POINTS, gp->points);
RandomFields/src/tbm.cc:    // Abfolge Tbm $(Aniso) iso-model braucht Moeglichkeit des 
RandomFields/src/tbm.cc:    // anisotropen Modells
RandomFields/src/tbm.cc:    if (hasInterfaceFrame(cov)) { // || COVNR == TBM_PROC_USER) nsel++;
RandomFields/src/tbm.cc:      // PMI(cov);
RandomFields/src/tbm.cc:      //      if (COVNR != TBM_PROC_USER) crash();
RandomFields/src/tbm.cc:      assert(COVNR == TBM_PROC_USER);
RandomFields/src/tbm.cc:      err = CHECK(sub, OWNLOGDIM(0), OWNXDIM(0), VariogramType, 
RandomFields/src/tbm.cc:		       SYMMETRIC, SUBMODEL_DEP, GaussMethodType);
RandomFields/src/tbm.cc:      assert(COVNR != TBM_PROC_USER);
RandomFields/src/tbm.cc:	if ((err = CHECK(sub, OWNLOGDIM(0), OWNXDIM(0), VariogramType, XONLY, 
RandomFields/src/tbm.cc:			 isoselect[i], SUBMODEL_DEP, GaussMethodType))
RandomFields/src/tbm.cc:      // falls hier gelandet, so ruft TBMINTERN TBM auf!!
RandomFields/src/tbm.cc:      if (COVNR == TBM_PROC_USER) { 
RandomFields/src/tbm.cc:	while (intern != NULL && //MODELNR(intern) != TBM_PROC_INTERN &&
RandomFields/src/tbm.cc:	       (isAnyDollar(intern) || MODELNR(intern) == TBM_PROC_USER  // 
RandomFields/src/tbm.cc:    if (COVNR == TBM_PROC_USER) newdim = OWNXDIM(0); 
RandomFields/src/tbm.cc:		     SUBMODEL_DEP, 
RandomFields/src/tbm.cc:		     GaussMethodType))
RandomFields/src/tbm.cc:  VDIM0 = next->vdim[0];
RandomFields/src/tbm.cc:  VDIM1 = next->vdim[1];
RandomFields/src/tbm.cc:    *next = cov->sub[TBM_COV];
RandomFields/src/tbm.cc:  ASSERT_NEWMODEL_NULL;
RandomFields/src/tbm.cc:  if (next->pref[TBM] == PREF_NONE) {
RandomFields/src/tbm.cc:  assert(COVNR == TBM_PROC_INTERN);
RandomFields/src/tbm.cc:    tbm_linesimustep = P0(TBM_LINESIMUSTEP),
RandomFields/src/tbm.cc:    tbm_linesimufactor = P0(TBM_LINESIMUFACTOR);
RandomFields/src/tbm.cc:    //  tbm_lines = P0INT(TBM_LINES),
RandomFields/src/tbm.cc:    fulldim = P0INT(TBM_FULLDIM), 
RandomFields/src/tbm.cc:    tbmdim = P0INT(TBM_TBMDIM),
RandomFields/src/tbm.cc:    *points = PINT(TBM_POINTS),
RandomFields/src/tbm.cc:  if (!hasGaussMethodFrame(cov) && !hasInterfaceFrame(cov)) {
RandomFields/src/tbm.cc:	  NICK(cov), KNAME(TBM_TBMDIM), KNAME(TBM_FULLDIM), tbmdim, fulldim);
RandomFields/src/tbm.cc:  if (ANYDIM > MAXTBMSPDIM) RETURN_ERR(ERRORMAXDIMMETH);
RandomFields/src/tbm.cc:  if(!isVariogram(NEXTTYPE(0)) || !isXonly(NEXT)) RETURN_ERR(ERRORNOVARIOGRAM);
RandomFields/src/tbm.cc:    SERR("dimension must currently be at least 2 and at most 4 for TBM");
RandomFields/src/tbm.cc:  // PrintMethodInfo(meth);
RandomFields/src/tbm.cc:	SERR1("too many points to determine smallest distance between the points in a reasonable time; try '%.50s' with a positive value", KNAME(TBM_LINESIMUSTEP));
RandomFields/src/tbm.cc:      SERR("if linesimufactor and linesimustep are naught then TBM.points must be at least 4 (better between 100 and 10000)");
RandomFields/src/tbm.cc:  // auf der TBM-Geraden mit Abstand 1 der Punkte simuliert werden kann
RandomFields/src/tbm.cc:  double diameter, min[MAXTBMSPDIM], max[MAXTBMSPDIM], Center[MAXTBMSPDIM],
RandomFields/src/tbm.cc:      SERR( "given number of points to simulate on the TBM line is too small");
RandomFields/src/tbm.cc:  if (diameter > MAXNN) {
RandomFields/src/tbm.cc:	  KNAME(TBM_LINESIMUFACTOR), KNAME(TBM_LINESIMUSTEP));
RandomFields/src/tbm.cc:     *tbm_center = P(TBM_CENTER);
RandomFields/src/tbm.cc:      SERR1("'%.50s' can be set only for isotropic fields", KNAME(TBM_CENTER));
RandomFields/src/tbm.cc:  while (isGaussMethod(modelB1)) modelB1 = modelB1->sub[0];
RandomFields/src/tbm.cc:    addModelKey(cov, GAUSSPROC);
RandomFields/src/tbm.cc:  addModel(modelB1, 0, FIRSTDOLLAR);
RandomFields/src/tbm.cc:  if (MODELNR(modelB1)==BROWNIAN){
RandomFields/src/tbm.cc:    kdefault(cov, DVAR, 1.0 + PARAM0(next, BROWN_ALPHA) / tbmdim);
RandomFields/src/tbm.cc:    PARAMALLOC(dollar, DANISO, s->ce_dim, s->ce_dim);
RandomFields/src/tbm.cc:    PARAM(dollar, DANISO)[0] = 1.0 / linesimufactor;
RandomFields/src/tbm.cc:      PARAM(dollar, DANISO)[1] = PARAM(dollar, DANISO)[2] = 0.0;
RandomFields/src/tbm.cc:      PARAM(dollar, DANISO)[3] = T[XSTEP];
RandomFields/src/tbm.cc:    addModel(modelB1, 0, TBM_OP);
RandomFields/src/tbm.cc:    if (!PisNULL(TBMOP_TBMDIM))
RandomFields/src/tbm.cc:      kdefault(modelB1->sub[0], TBMOP_TBMDIM, P0INT(TBM_TBMDIM));
RandomFields/src/tbm.cc:    if (!PisNULL(TBMOP_FULLDIM))
RandomFields/src/tbm.cc:      kdefault(modelB1->sub[0], TBMOP_FULLDIM, P0INT(TBM_FULLDIM));
RandomFields/src/tbm.cc:    if (!PisNULL(TBMOP_LAYERS))
RandomFields/src/tbm.cc:      kdefault(modelB1->sub[0], TBMOP_LAYERS, P0INT(TBM_LAYERS));
RandomFields/src/tbm.cc:  // xline[XEND]: number of points on the TBM line
RandomFields/src/tbm.cc:  s->xline_length  = xline[XLENGTH] = (double) diameter;// diameter > MAXNN must be first since
RandomFields/src/tbm.cc:		   cov->vdim, GaussMethodType)) != NOERROR) {
RandomFields/src/tbm.cc:  assert(XDIM(SYSOF(key), 0) == s->ce_dim);
RandomFields/src/tbm.cc:		     PosDefType, XONLY, SYMMETRIC,
RandomFields/src/tbm.cc:		     SUBMODEL_DEP, GaussMethodType)) != NOERROR) {
RandomFields/src/tbm.cc:      PRINTF("\n\nCheckModel Internal (%s, #=%d), after 2nd check:", 
RandomFields/src/tbm.cc:	     NICK(key), MODELNR(key)); // ok
RandomFields/src/tbm.cc:  SPRINTF(error_location, "%.500s %.50s", errorloc_save, NAME(cov));
RandomFields/src/tbm.cc:  cov->method = TBM;
RandomFields/src/tbm.cc:  FRAME_ASSERT_GAUSS;
RandomFields/src/tbm.cc:  if (PL>= PL_STRUCTURE) {PRINTF("\n'%s' is now initialized.\n", NAME(cov));}
RandomFields/src/tbm.cc:  double sube[MAXTBMSPDIM], e[MAXTBMSPDIM];
RandomFields/src/tbm.cc:  for(d=0; d<MAXTBMSPDIM; d++) sube[d] = e[d] = RF_NEGINF;
RandomFields/src/tbm.cc:    else (*phi) = UNIFORM_RANDOM * M_2_PI; // not pi, when multivariate
RandomFields/src/tbm.cc: int vdim = VDIM0;
RandomFields/src/tbm.cc:    origdim = loc->caniso == NULL ? ANYDIM : loc->cani_nrow,
RandomFields/src/tbm.cc:    tbm_lines = P0INT(TBM_LINES);
RandomFields/src/tbm.cc:    fulldim = P0INT(TBM_FULLDIM);
RandomFields/src/tbm.cc:  phi = deltaphi * UNIFORM_RANDOM;     // only used for tbm2
RandomFields/src/tbm.cc:      inittoffset += UNIFORM_RANDOM - 0.5;
RandomFields/src/tbm.cc:#define TBMSTART {							\
RandomFields/src/tbm.cc:        offsetinit += UNIFORM_RANDOM - 0.5;				\
RandomFields/src/tbm.cc:#define TBMEND }} break
RandomFields/src/tbm.cc:#define TBMFOR								\
RandomFields/src/tbm.cc:#define TBMFOREND }}  
RandomFields/src/tbm.cc:#define TBMFOR0							\
RandomFields/src/tbm.cc:#define TBMST(INDEX,ZAEHLER)						\
RandomFields/src/tbm.cc:    case 1 : //see Martin's techrep f. details
RandomFields/src/tbm.cc:      TBMSTART;
RandomFields/src/tbm.cc:	TBMFOR0;
RandomFields/src/tbm.cc: 	TBMST(loc->x[xi] * incx, zaehler);
RandomFields/src/tbm.cc:	TBMFOR;
RandomFields/src/tbm.cc:	TBMST(loc->x[xi] * incx, zaehler++);
RandomFields/src/tbm.cc:        TBMFOREND
RandomFields/src/tbm.cc:      TBMEND;
RandomFields/src/tbm.cc:      TBMSTART;
RandomFields/src/tbm.cc:	TBMFOR0;
RandomFields/src/tbm.cc: 	TBMST(loc->x[xi] * incx + loc->x[xi+1] * incy, zaehler);
RandomFields/src/tbm.cc:	TBMFOR;
RandomFields/src/tbm.cc:	TBMST(loc->x[xi] * incx + loc->x[xi+1] * incy, zaehler++);
RandomFields/src/tbm.cc:	TBMFOREND
RandomFields/src/tbm.cc:      TBMEND;
RandomFields/src/tbm.cc:      TBMSTART;
RandomFields/src/tbm.cc:	TBMFOR0;
RandomFields/src/tbm.cc: 	TBMST(INC3, zaehler);	
RandomFields/src/tbm.cc:	TBMFOR;
RandomFields/src/tbm.cc:	TBMST(INC3, zaehler++);
RandomFields/src/tbm.cc:	TBMFOREND
RandomFields/src/tbm.cc:      TBMEND;
RandomFields/src/RandomFields.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFields/src/RandomFields.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFields/src/RandomFields.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFields/src/RandomFields.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFields/src/RandomFields.h://#define NATSCALE_ORNUMERIC 2
RandomFields/src/RandomFields.h://#define NATSCALE_MLE 3 /* check fitvario when changing; best NOT to change !!! */
RandomFields/src/RandomFields.h:  void GetCurrentNrOfModels(int *nr);
RandomFields/src/RandomFields.h:  void GetModelNr(char **name, int *n); /* transforms string "covfct" 
RandomFields/src/RandomFields.h:  void GetModelName(int *nr, char **name, char **nick); /* transforms covnr into string */
RandomFields/src/RandomFields.h:  void PrintModelList(int *local, int *operat, int *nick); // used in Roger's book
RandomFields/src/RandomFields.h:  //  void GetModelList(int* idx, int*internal); // used in generate.R
RandomFields/src/RandomFields.h:  SEXP GetAllModelNames(SEXP Newnames);
RandomFields/src/RandomFields.h:  SEXP GetModelInfo(SEXP keynr, SEXP level, SEXP spconform, SEXP whichSub,
RandomFields/src/RandomFields.h:  SEXP GetModel(SEXP keynr, SEXP modus, SEXP spconform, SEXP whichSub,
RandomFields/src/RandomFields.h:  // PROCESSES_NAMES
RandomFields/src/RandomFields.h:  SEXP Init(SEXP Model_reg, SEXP Model, SEXP x, SEXP NA_OK);
RandomFields/src/RandomFields.h:  SEXP EvaluateModel(SEXP X, SEXP I, SEXP Covnr);
RandomFields/src/RandomFields.h:  // SEXP EvaluateModelXX();
RandomFields/src/RandomFields.h:  SEXP GetProcessType(SEXP Model_reg, SEXP Model);
RandomFields/src/RandomFields.h:     In case, only MAXKEYS different parameter sets are used, but after 
RandomFields/src/RandomFields.h:		  SEXP Vdim, SEXP Method, SEXP distgiven);
RandomFields/src/RandomFields.h:  //  SEXP CovMatrixSelectedLoc(SEXP reg, SEXP x, SEXP dist, SEXP xdim, SEXP lx,
RandomFields/src/RandomFields.h:  //  SEXP CovMatrixSelected(SEXP reg, SEXP selected, SEXP nsel, SEXP result,
RandomFields/src/RandomFields.h:  SEXP GetNAPositions(SEXP model_reg, SEXP Model, SEXP x, SEXP values,
RandomFields/src/RandomFields.h:  SEXP SetAndGetModelFacts(SEXP Model_reg, SEXP Model, 
RandomFields/src/RandomFields.h:  SEXP SetAndGetModelLikelihood(SEXP Model_reg, SEXP Model, SEXP x,
RandomFields/src/RandomFields.h:  void expliciteDollarMLE(int * modelnr, double *values);
RandomFields/src/RandomFields.h:  SEXP Take2ndAtNaOf1st(SEXP Model_reg, SEXP Model, SEXP Model_bound,
RandomFields/src/RandomFields.h:  void GetMaxDims(int *maxints);
RandomFields/src/RandomFields.h:  void GetModelRegister(char **name, int* nr);
RandomFields/src/RandomFields.h:  void MultiDimRange(int *model_nr, int *set, double *natscale);
RandomFields/src/RandomFields.h:		       SEXP cumgridlen, SEXP boxes, SEXP MAXN);
RandomFields/src/RandomFields.h:   SEXP get_likeliinfo(SEXP Model_reg);
RandomFields/src/RandomFields.h:  SEXP simple_residuals(SEXP Model_reg);
RandomFields/src/RandomFields.h:  SEXP get_linearpart(SEXP Model_reg, SEXP Set);
RandomFields/src/RandomFields.h:  SEXP MomentsIntern(SEXP reg, SEXP alpha);
RandomFields/NAMESPACE:exportPattern("^RM")
RandomFields/NAMESPACE:importMethodsFrom("sp", "dimensions")  #"gridded"gibts nicht!
RandomFields/NAMESPACE:    rfGenerateModels, rfGenerateConstants, rfGenerateTest, rfGenerateMaths,
RandomFields/NAMESPACE:#    CondSimu, Covariance, CovarianceFct, CovMatrix,
RandomFields/NAMESPACE:#    InitSimulateRF, InitGaussRF, InitMaxStableRF, 
RandomFields/NAMESPACE:#    Kriging, MaxStableRF, RFparameters, Variogram,
RandomFields/NAMESPACE:    ## never delete PrintModelList as it is used in Roger's book!
RandomFields/NAMESPACE:    PrintModelList,
RandomFields/NAMESPACE:exportMethods("[", "[<-", "+", "*", "/", "-", "^", c, 
RandomFields/NAMESPACE:exportMethods(RFspDataFrame2conventional,
RandomFields/NAMESPACE:## S3 Methods
RandomFields/NAMESPACE:S3method(print, RFgetModelInfo)
RandomFields/NAMESPACE:S3method(lines, RMmodel)
RandomFields/NAMESPACE:S3method(points,RMmodel)
RandomFields/NAMESPACE:S3method(print, RMmodel)
RandomFields/NAMESPACE:S3method(str, RMmodel)
RandomFields/NAMESPACE:S3method(summary, RMmodel)
RandomFields/NAMESPACE:S3method(as.list, RMmodel)
RandomFields/NAMESPACE:S3method(print, summary.RMmodel)
RandomFields/NAMESPACE:S3method(print, RMmodelgenerator)
RandomFields/NAMESPACE:#S3method(anova, RMmodelFit)
RandomFields/NAMESPACE:S3method(print, RMmodelFit)
RandomFields/NAMESPACE:S3method(summary, RMmodelFit)
RandomFields/NAMESPACE:S3method(print, summary.RMmodelFit)
RandomFieldsUtils/config.log:hostname = afreuden-OMEN-by-HP-Laptop-17-cb1xxx
RandomFieldsUtils/config.log:uname -v = #64-Ubuntu SMP Wed Dec 9 08:16:25 UTC 2020
RandomFieldsUtils/config.log:warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
RandomFieldsUtils/config.log:OFFLOAD_TARGET_NAMES=nvptx-none:hsa
RandomFieldsUtils/config.log:Configured with: ../src/configure -v --with-pkgversion='Ubuntu 9.3.0-17ubuntu1~20.04' --with-bugurl=file:///usr/share/doc/gcc-9/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++,gm2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-9 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-9-HskZEa/gcc-9-9.3.0/debian/tmp-nvptx/usr,hsa --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
RandomFieldsUtils/config.log:configure:2320: checking which SIMD flags can be recognized
RandomFieldsUtils/config.log:configure:2360: checking whether CUDA_HOME is set
RandomFieldsUtils/config.log:configure:2363: result: CUDA_HOME not set; using /usr/local/cuda
RandomFieldsUtils/config.log:  CONFIG_COMMANDS = 
RandomFieldsUtils/config.log:on afreuden-OMEN-by-HP-Laptop-17-cb1xxx
RandomFieldsUtils/config.log:config.status:723: creating src/Makevars
RandomFieldsUtils/config.log:CUDA_HOME='/usr/local/cuda'
RandomFieldsUtils/config.log:DEFS='-DPACKAGE_NAME=\"RandomFieldsUtils\" -DPACKAGE_TARNAME=\"randomfieldsutils\" -DPACKAGE_VERSION=\"0.5\" -DPACKAGE_STRING=\"RandomFieldsUtils\ 0.5\" -DPACKAGE_BUGREPORT=\"\" -DPACKAGE_URL=\"\"'
RandomFieldsUtils/config.log:PACKAGE_NAME='RandomFieldsUtils'
RandomFieldsUtils/config.log:PACKAGE_TARNAME='randomfieldsutils'
RandomFieldsUtils/config.log:RANDOMFIELDSUTILS_CXXFLAGS='-mavx2 -DUSEGPU  -msse2 -mssse3 -mavx2'
RandomFieldsUtils/config.log:RANDOMFIELDSUTILS_LIBFLAGS=''
RandomFieldsUtils/config.log:docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
RandomFieldsUtils/config.log:#define PACKAGE_NAME "RandomFieldsUtils"
RandomFieldsUtils/config.log:#define PACKAGE_TARNAME "randomfieldsutils"
RandomFieldsUtils/config.status:## M4sh Initialization. ##
RandomFieldsUtils/config.status:DUALCASE=1; export DUALCASE # for MKS sh
RandomFieldsUtils/config.status:  NULLCMD=:
RandomFieldsUtils/config.status:# We did not find ourselves, most probably we were run as `sh COMMAND'
RandomFieldsUtils/config.status:for as_var in BASH_ENV ENV MAIL MAILPATH
RandomFieldsUtils/config.status:as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
RandomFieldsUtils/config.status:    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
RandomFieldsUtils/config.status:## Main body of $CONFIG_STATUS script. ##
RandomFieldsUtils/config.status:  CONFIG_COMMANDS = $CONFIG_COMMANDS
RandomFieldsUtils/config.status:config_files=" src/Makevars"
RandomFieldsUtils/config.status:      --file=FILE[:TEMPLATE]
RandomFieldsUtils/config.status:    "src/Makevars") CONFIG_FILES="$CONFIG_FILES src/Makevars" ;;
RandomFieldsUtils/config.status:# Have a temporary directory for convenience.  Make it in the build tree
RandomFieldsUtils/config.status:  tmp=./conf$$-$RANDOM
RandomFieldsUtils/config.status:S["CUDA_HOME"]="/usr/local/cuda"
RandomFieldsUtils/config.status:S["RANDOMFIELDSUTILS_LIBFLAGS"]=""
RandomFieldsUtils/config.status:S["RANDOMFIELDSUTILS_CXXFLAGS"]="-mavx2 -DUSEGPU  -msse2 -mssse3 -mavx2"
RandomFieldsUtils/config.status:S["DEFS"]="-DPACKAGE_NAME=\\\"RandomFieldsUtils\\\" -DPACKAGE_TARNAME=\\\"randomfieldsutils\\\" -DPACKAGE_VERSION=\\\"0.5\\\" -DPACKAGE_STRING=\\\"RandomFieldsUtils\\ 0.5\\\" -"\
RandomFieldsUtils/config.status:S["docdir"]="${datarootdir}/doc/${PACKAGE_TARNAME}"
RandomFieldsUtils/config.status:S["PACKAGE_TARNAME"]="randomfieldsutils"
RandomFieldsUtils/config.status:S["PACKAGE_NAME"]="RandomFieldsUtils"
RandomFieldsUtils/config.status:# FIXME: This hack should be removed a few years after 2.60.
RandomFieldsUtils/config.status:  s&@docdir@&${datarootdir}/doc/${PACKAGE_TARNAME}&g
RandomFieldsUtils/inst/include/kleinkram.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/inst/include/kleinkram.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFieldsUtils/inst/include/kleinkram.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/inst/include/kleinkram.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/inst/include/kleinkram.h:#define LAST_R_TYPE_NAME 32
RandomFieldsUtils/inst/include/kleinkram.h:extern const char *RTYPE_NAMES[LAST_R_TYPE_NAME + 1];
RandomFieldsUtils/inst/include/kleinkram.h:#define R_TYPE_NAME(X) RTYPE_NAMES[MIN(X, LAST_R_TYPE_NAME)]
RandomFieldsUtils/inst/include/kleinkram.h:typedef char name_type[][MAXCHAR];
RandomFieldsUtils/inst/include/kleinkram.h:#define NUM Real(el, name, 0)
RandomFieldsUtils/inst/include/kleinkram.h:#define POS0NUM NonNegReal(el, name)
RandomFieldsUtils/inst/include/kleinkram.h:#define NEG0NUM NonPosReal(el, name)
RandomFieldsUtils/inst/include/kleinkram.h:#define POSNUM PositiveReal(el, name)
RandomFieldsUtils/inst/include/kleinkram.h://SEXP String(char V[][MAXCHAR], int n, int max);
RandomFieldsUtils/inst/include/kleinkram.h:SEXP Mat(double* V, int row, int col, int max);
RandomFieldsUtils/inst/include/kleinkram.h:SEXP Mat_t(double* V, int row, int col, int max);
RandomFieldsUtils/inst/include/kleinkram.h:SEXP MatInt(int* V, int row, int col, int max) ;
RandomFieldsUtils/inst/include/kleinkram.h:SEXP MatString(char **V, int row, int col, int max);
RandomFieldsUtils/inst/include/kleinkram.h:SEXP Mat(double* V, int row, int col);
RandomFieldsUtils/inst/include/kleinkram.h:SEXP Mat_t(double* V, int row, int col);
RandomFieldsUtils/inst/include/kleinkram.h:SEXP MatInt(int* V, int row, int col) ;
RandomFieldsUtils/inst/include/kleinkram.h:SEXP MatString(char** V, int row, int col);
RandomFieldsUtils/inst/include/kleinkram.h:SEXP String(char V[][MAXCHAR], int n);
RandomFieldsUtils/inst/include/kleinkram.h:void String(SEXP el, char *name, char names[][MAXCHAR], int maxlen);
RandomFieldsUtils/inst/include/kleinkram.h:#define MULTIPLEMATCHING -2
RandomFieldsUtils/inst/include/kleinkram.h:#define NOMATCHING -1
RandomFieldsUtils/inst/include/kleinkram.h:#define MATCHESINTERNAL -3
RandomFieldsUtils/inst/include/kleinkram.h:int Match(char *name, const char * List[], int n);
RandomFieldsUtils/inst/include/kleinkram.h:int Match(char *name, name_type List, int n);
RandomFieldsUtils/inst/include/kleinkram.h:#define Mod(Z, modulus) ((Z) - FLOOR((Z) / (modulus)) * (modulus))
RandomFieldsUtils/inst/include/AutoRandomFieldsUtils.h:#define MAXUNITS 4
RandomFieldsUtils/inst/include/AutoRandomFieldsUtils.h:#define MAXCHAR 18 // max number of characters for (covariance) names  
RandomFieldsUtils/inst/include/scalar.h:#define SCALAR_NEARFMA 5  // never change number, see haplogeno.R !!
RandomFieldsUtils/inst/include/Utils.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/inst/include/Utils.h: Copyright (C) 2018 -- 2018 Martin Schlather
RandomFieldsUtils/inst/include/Utils.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/inst/include/Utils.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/inst/include/zzz_calls.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/inst/include/zzz_calls.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFieldsUtils/inst/include/zzz_calls.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/inst/include/zzz_calls.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/inst/include/zzz_calls.h:    if (fun == NULL) fun = (V (*) ()) R_GetCCallable(MY_PACKAGE, #N);	\
RandomFieldsUtils/inst/include/zzz_calls.h:  if (fun == NULL) fun = (N##_type) R_GetCCallable(MY_PACKAGE, #N);	\
RandomFieldsUtils/inst/include/zzz_calls.h:  if (fun == NULL) fun = (N##_type) R_GetCCallable(MY_PACKAGE, #N);	\
RandomFieldsUtils/inst/include/zzz_calls.h:  if (fun == NULL) fun = (N##_type) R_GetCCallable(MY_PACKAGE, #N);	\
RandomFieldsUtils/inst/include/zzz_calls.h:  if (fun == NULL) fun = (N##_type) R_GetCCallable(MY_PACKAGE, #N);	\
RandomFieldsUtils/inst/include/zzz_calls.h:  if (fun == NULL) fun = (N##_type) R_GetCCallable(MY_PACKAGE, #N);	\
RandomFieldsUtils/inst/include/zzz_calls.h:      if (fun == NULL) fun = (N##_type) R_GetCCallable(MY_PACKAGE, #N);	\
RandomFieldsUtils/inst/include/zzz_calls.h:      if (fun == NULL) fun = (N##_type) R_GetCCallable(MY_PACKAGE, #N);	\
RandomFieldsUtils/inst/include/zzz_calls.h:  if (fun == NULL) fun = (N##_type) R_GetCCallable(MY_PACKAGE, #N);	\
RandomFieldsUtils/inst/include/zzz_calls.h:  if (fun == NULL) fun = (N##_type) R_GetCCallable(MY_PACKAGE, #N);	\
RandomFieldsUtils/inst/include/zzz_calls.h:  if (fun == NULL) fun = (N##_type) R_GetCCallable(MY_PACKAGE, #N);	\
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:#define MY_PACKAGE "RandomFieldsUtils"
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:#define MY_ACRONYM XX
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:!!!!! auch kein mit MALLOC kreiertes Objekt  !!!!
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:  DECLARE7(int, solvePosDef, double*, M, int, size, bool, posdef, 
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:  DECLARE8(int, solvePosDefSp, double *, M, int, size, bool, posdef,
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:  //  DECLARE8(int, solvePosDefResult, double*, M, int, size, bool, posdef, 
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:  DECLARE4(int, sqrtPosDefFree, double *, M, int, size, solve_storage *, pt,
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:  DECLARE2(int, invertMatrix, double *, M, int, size)
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:  DECLARE3(double, WM, double, x, double, nu, double, factor)
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:  DECLARE3(double, DWM, double, x, double, nu, double, factor)
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:  DECLARE3(double, DDWM, double, x, double, nu, double, factor)
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:  DECLARE3(double, D3WM, double, x, double, nu, double, factor)
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:  DECLARE3(double, D4WM, double, x, double, nu, double, factor)
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:  DECLARE4(double, logWM, double, x, double, nu1, double, nu2, double, factor)
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:  DECLARE2(double, detPosDef, double *, M, int, size) // destroys M!
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:  DECLARE8(int, XCinvXdet,double*, M, int, size, double *,X, int, X_cols,
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:  DECLARE10(int, XCinvYdet,double*, M, int, size, bool, posdef,
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:  //  DECLARE5(double, XCinvXlogdet, double *, M, int, size, double *, X,
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:  DECLARE2(void, chol2inv, double *, MPT, int, size)
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:  DECLARE2(int, chol, double *, MPT, int, size)
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:  DECLARE1(void, sleepMicro, int *, i)
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:  // DECLARE7(int, cholGPU, bool, copy, double*, M, int, size, double*, rhs, int, rhs_cols, double *, LogDet, double *, RESULT); // entkommentieren
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:#define MISS_AVX2 (!HAS_AVX2 && NEED_AVX2)
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:#define MISS_AVX (!HAS_AVX && NEED_AVX)
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:#define MISS_ANY_SIMD (MISS_AVX2 || MISS_AVX || !HAS_SSE2)
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:#define MISS_SSSE3 (!HAS_SSSE3 && NEED_SSSE3)
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:#define MISS_SSE2 (!HAS_SSE2 && NEED_SSE2)
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:#define MISS_SSE (!HAS_SSE && NEED_SSE)
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:#define AttachMessageN 1000
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:#define HAS_ALL_RELEVANT (HAS_PARALLEL && !MISS_AVX2 && !MISS_AVX && !MISS_SSSE3 &&  !MISS_SSE2 && !MISS_SSE)
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:    HAS_PARALLEL ? "OMP" : "",						\
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:    !HAS_PARALLEL ? "OMP, " : "",					\
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:    MISS_AVX2 ? "AVX2" : "",				\
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:    MISS_AVX ? ", AVX" : "",						\
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:    MISS_SSSE3 ? ", SSSE3" : "",				\
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:    MISS_SSE2 ? ", SSE2" : "",				\
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:    MISS_SSE ? ", SSE" : ""
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:#define AttachMessageX(PKG, HINT, AND, OMP)				\
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:    HINT && MISS_ANY_SIMD ? "\nBy default '"#PKG"' is compiled with flag '-mavx' under your OS.\nIf you are sure that AVX2 is available, consider adding the flag '-march=native'\nto 'PKG_CXXFLAGS' in the file src/Makefile.win and then recompile\n'"#PKG"' "#AND"." : "", \
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:    HINT && MISS_AVX2 ?							\
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:    HINT && (!HAS_PARALLEL) ? "\nFor OMP alone, try adding the flags -Xpreprocessor -fopenmp -pthread to PKG_LIBS and PKG_CXXFLAGS" : ""
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:#define AttachMessageX(PKG, HINT, AND, OMP) 				\
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:    HINT && MISS_ANY_SIMD ? "\nWithout appropriate SIMD instruction set, the calculations might be slow.\nConsider recompiling '"#PKG"' "#AND" with flags e.g.,\n\n   install.packages(\""#PKG"\", configure.args=\"CXX_FLAGS='-march=native "#OMP"'\")" : "", \
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:    HINT && MISS_AVX2 ?					\
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:    "\n\n   install.packages(\""#PKG"\", configure.args=\"CXX_FLAGS='-mavx2 "#OMP"'\")" \
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:    HINT && MISS_AVX ?					\
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:    "\n\n   install.packages(\""#PKG"\", configure.args=\"CXX_FLAGS='-mavx "#OMP"'\")"\
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:    HINT && MISS_ANY_SIMD ? "\n\nAlternatively consider installing '"#PKG"'\nfrom https://github.com/schlather/"#PKG", i.e.,\n   install.packages(\"devtools\")\n   library(devtools)\n   devtools::install_github(\"schlather/"#PKG"/pkg\")" : "",\
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:    HINT && !HAS_PARALLEL ? "\n\nFor OMP alone try\n   install.packages(\""#PKG"\", configure.args=\"CXX_FLAGS='"#OMP"'\")" : ""
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:#    define AttachMessage(PKG, HINT) AttachMessageX(PKG, HINT, , )
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:#    define AttachMessage(PKG, HINT)  \
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:     AttachMessageX(PKG, HINT, ,\
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:#  define AttachMessage(PKG, HINT)				\
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:     AttachMessageX(PKG, HINT, and 'RandomFieldsUtils',		\
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:#  define AttachMessage(PKG, HINT)			\
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:     AttachMessageX(PKG, HINT, and 'RandomFieldsUtils', )
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:#define ReturnAttachMessage(PKG,HINT) 	\
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:  char simd_msg[AttachMessageN];			\
RandomFieldsUtils/inst/include/zzz_RandomFieldsUtils.h:  SPRINTF(simd_msg, AttachMessage(PKG,HINT)); \
RandomFieldsUtils/inst/include/AutoRandomFieldsUtilsLocal.h:#define PIVOTSPARSE_MMD 1 // for spam
RandomFieldsUtils/inst/include/AutoRandomFieldsUtilsLocal.h:#define PIVOTSPARSE_RCM 2 // for spam
RandomFieldsUtils/inst/include/General_utils.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/inst/include/General_utils.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFieldsUtils/inst/include/General_utils.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/inst/include/General_utils.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/inst/include/General_utils.h:// not SCHLATHERS_MACHINE
RandomFieldsUtils/inst/include/General_utils.h:#ifndef SCHLATHERS_MACHINE
RandomFieldsUtils/inst/include/General_utils.h://#define MEMCOPY(A,B,C) {MEMCPY(A,B,C); printf("memcpy %.50s %d\n", __FILE__, __LINE__);}
RandomFieldsUtils/inst/include/General_utils.h:#define MEMCOPY(A,B,C) MEMCOPYX(A,B,C)
RandomFieldsUtils/inst/include/General_utils.h:#define AMALLOC(ELEMENTS, SIZE) AALLOC(SIZE, (SIZE) * (ELEMENTS))
RandomFieldsUtils/inst/include/General_utils.h:#define MALLOC MALLOCX
RandomFieldsUtils/inst/include/General_utils.h:#endif // not SCHLATHERS_MACHINE
RandomFieldsUtils/inst/include/General_utils.h:// SCHLATHERS_MACHINE
RandomFieldsUtils/inst/include/General_utils.h:#ifdef SCHLATHERS_MACHINE 
RandomFieldsUtils/inst/include/General_utils.h:#define MAXALLOC 1000000000L
RandomFieldsUtils/inst/include/General_utils.h:#define MEMCOPY(A,B,C) __extension__ ({ assert((A)!=NULL && (B)!=NULL && (C)>0 && (C)<=MAXALLOC); MEMCOPYX(A,B,C); })
RandomFieldsUtils/inst/include/General_utils.h://#define MEMCOPY(A,B,C) memory_copy(A, B, C)
RandomFieldsUtils/inst/include/General_utils.h:#define MALLOC(X) __extension__ ({assert((X)>0 && (X)<=MAXALLOC); MALLOCX(X);})
RandomFieldsUtils/inst/include/General_utils.h:#define CALLOC(X, Y) __extension__({assert((X)>0 && (Y)>0 && ((X) * (Y))<MAXALLOC); CALLOCX(X,Y);})
RandomFieldsUtils/inst/include/General_utils.h:#define XCALLOC(X, Y) __extension__({assert((X)>0 && (Y)>0 && ((X) * (Y))<MAXALLOC); CALLOCX(X,Y);})
RandomFieldsUtils/inst/include/General_utils.h:#endif // SCHLATHERS_MACHINE
RandomFieldsUtils/inst/include/General_utils.h:#ifdef RANDOMFIELDS_DEBUGGING
RandomFieldsUtils/inst/include/General_utils.h:#undef MALLOC
RandomFieldsUtils/inst/include/General_utils.h:#define MALLOC(X) __extension__({DOPRINTF("(MLLC %s, line %d)\n", __FILE__, __LINE__);assert((X)>0 && (X)<=3e9); MALLOCX(X);})
RandomFieldsUtils/inst/include/General_utils.h:#define CALLOC(X, Y) __extension__({DOPRINTF("(CLLC %s, line %d)\n",__FILE__, __LINE__);assert((X)>0 && (Y)>0 && ((X) * (Y)) <MAXALLOC); CALLOCX(X,Y);})
RandomFieldsUtils/inst/include/General_utils.h:#define XCALLOC(X, Y) __extension__({DOPRINTF("(CLLC %s, line %d)\n",__FILE__, __LINE__);assert((X)>0 && (Y)>0 && ((X) * (Y)) <MAXALLOC); CALLOCX(X,Y);})
RandomFieldsUtils/inst/include/General_utils.h://#define MALLOC malloc
RandomFieldsUtils/inst/include/General_utils.h:// note that DEBUGINDOERR is redefined in MachineDebugging.h
RandomFieldsUtils/inst/include/General_utils.h:#define PL_IMPORTANT 1 
RandomFieldsUtils/inst/include/General_utils.h:#define PL_STRUCTURE 5 // see also initNerror.ERROROUTOFMETHOD
RandomFieldsUtils/inst/include/General_utils.h:#define MATERN_NU_THRES 100
RandomFieldsUtils/inst/include/General_utils.h:#define LOW_MATERN 1e-20
RandomFieldsUtils/inst/include/General_utils.h:#ifdef SCHLATHERS_MACHINE 
RandomFieldsUtils/inst/include/Options_utils.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/inst/include/Options_utils.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFieldsUtils/inst/include/Options_utils.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/inst/include/Options_utils.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/inst/include/Options_utils.h:#ifdef SCHLATHERS_MACHINE
RandomFieldsUtils/inst/include/Options_utils.h:#define LEN_OPTIONNAME 201
RandomFieldsUtils/inst/include/Options_utils.h:// IMPORTANT: all names of basic must be have least 3 letters !!!
RandomFieldsUtils/inst/include/Options_utils.h:extern const char * InversionNames[nr_InversionMethods];
RandomFieldsUtils/inst/include/Options_utils.h:  InversionMethod Methods[SOLVE_METHODS];
RandomFieldsUtils/inst/include/Options_utils.h:#ifdef SCHLATHERS_MACHINE
RandomFieldsUtils/inst/include/Options_utils.h:  {NoInversionMethod,  NoFurtherInversionMethod},			\
RandomFieldsUtils/inst/include/Options_utils.h:    {400, 10000}, 500, 4294967, PIVOTSPARSE_MMD, 16384,			\
RandomFieldsUtils/inst/include/Basic_utils.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/inst/include/Basic_utils.h: Copyright (C) 2015 -- 2019  Martin Schlather
RandomFieldsUtils/inst/include/Basic_utils.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/inst/include/Basic_utils.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/inst/include/Basic_utils.h:#ifdef _OPENMP
RandomFieldsUtils/inst/include/Basic_utils.h:#define MULTIMINSIZE(S) ((S) > 20)
RandomFieldsUtils/inst/include/Basic_utils.h:// #define MULTIMINSIZE(S) false
RandomFieldsUtils/inst/include/Basic_utils.h:// #define MULTIMINSIZE(S) true
RandomFieldsUtils/inst/include/Basic_utils.h:  Nan=INT_MIN
RandomFieldsUtils/inst/include/Basic_utils.h:#define T_PI M_2_PI
RandomFieldsUtils/inst/include/Basic_utils.h:#define OBSOLETENAME "obsolete" 
RandomFieldsUtils/inst/include/Basic_utils.h:#define MAXINT 2147483647
RandomFieldsUtils/inst/include/Basic_utils.h:#define MININT -2147483647
RandomFieldsUtils/inst/include/Basic_utils.h:#define MAXUNSIGNED (MAXINT * 2) + 1
RandomFieldsUtils/inst/include/Basic_utils.h:#define INFDIM MAXINT
RandomFieldsUtils/inst/include/Basic_utils.h:#define INFTY INFDIM
RandomFieldsUtils/inst/include/Basic_utils.h:#define GAUSS_RANDOM(SIGMA) rnorm(0.0, SIGMA)
RandomFieldsUtils/inst/include/Basic_utils.h:#define UNIFORM_RANDOM unif_rand()
RandomFieldsUtils/inst/include/Basic_utils.h:#define POISSON_RANDOM(x) rpois(x)
RandomFieldsUtils/inst/include/Basic_utils.h:#define SQRT2 M_SQRT2
RandomFieldsUtils/inst/include/Basic_utils.h:#define SQRTPI M_SQRT_PI
RandomFieldsUtils/inst/include/Basic_utils.h:#define INVPI M_1_PI
RandomFieldsUtils/inst/include/Basic_utils.h:#define PIHALF M_PI_2 
RandomFieldsUtils/inst/include/Basic_utils.h:#define LOG2 M_LN2
RandomFieldsUtils/inst/include/Basic_utils.h:#define MIN(A,B) ((A) < (B) ? (A) : (B))
RandomFieldsUtils/inst/include/Basic_utils.h:#define MAX(A,B) ((A) > (B) ? (A) : (B))
RandomFieldsUtils/inst/include/Basic_utils.h:#define FMIN fmin2
RandomFieldsUtils/inst/include/Basic_utils.h:#define FMAX fmax2
RandomFieldsUtils/inst/include/Basic_utils.h:#define EXPM1 std::expm1
RandomFieldsUtils/inst/include/Basic_utils.h:#define STRCMP(A, B) std::strcmp(A, B)
RandomFieldsUtils/inst/include/Basic_utils.h:#define STRNCMP(A, B, C) std::strncmp(A, B, C)
RandomFieldsUtils/inst/include/Basic_utils.h:#define MEMCOPYX std::memcpy
RandomFieldsUtils/inst/include/Basic_utils.h:#define MEMMOVE std::memmove
RandomFieldsUtils/inst/include/Basic_utils.h:#define MEMSET std::memset  
RandomFieldsUtils/inst/include/Basic_utils.h:#define MALLOCX std::malloc
RandomFieldsUtils/inst/include/Basic_utils.h:#ifdef SCHLATHERS_MACHINE
RandomFieldsUtils/inst/include/Basic_utils.h:#define HELPINFO(M) if (GLOBAL.basic.helpinfo) { PRINTF("%s\n(Note that you can unable this information by 'RFoptions(helpinfo=FALSE)'.)\n", M); } //
RandomFieldsUtils/inst/include/Basic_utils.h:#define UTILSINFO(M) if (GLOBAL_UTILS->basic.helpinfo) { PRINTF("%s\n(Note that you can unable this information by 'RFoptions(helpinfo=FALSE)'.)\n", M); } //
RandomFieldsUtils/inst/include/own.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/inst/include/own.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFieldsUtils/inst/include/own.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/inst/include/own.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/inst/include/RandomFieldsUtils.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/inst/include/RandomFieldsUtils.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFieldsUtils/inst/include/RandomFieldsUtils.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/inst/include/RandomFieldsUtils.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/inst/include/RandomFieldsUtils.h:  SEXP I0ML0(SEXP X);
RandomFieldsUtils/inst/include/RandomFieldsUtils.h:  SEXP WMr(SEXP X, SEXP Nu, SEXP Derivative, SEXP Factor);
RandomFieldsUtils/inst/include/RandomFieldsUtils.h:  SEXP logWMr(SEXP X, SEXP Nu1, SEXP Nu2, SEXP Factor);
RandomFieldsUtils/inst/include/RandomFieldsUtils.h:  SEXP SolvePosDef(SEXP M, SEXP rhs, SEXP logdet);
RandomFieldsUtils/inst/include/RandomFieldsUtils.h:  SEXP Chol(SEXP M);
RandomFieldsUtils/inst/include/RandomFieldsUtils.h:  void sleepMicro(int *micro);
RandomFieldsUtils/inst/include/RandomFieldsUtils.h:  void sleepMilli(int *milli);
RandomFieldsUtils/inst/include/RandomFieldsUtils.h:  SEXP colMaxs(SEXP M);
RandomFieldsUtils/inst/include/RandomFieldsUtils.h:  SEXP rowMeansX(SEXP M, SEXP Factor);
RandomFieldsUtils/inst/include/RandomFieldsUtils.h:  SEXP rowProd(SEXP M);
RandomFieldsUtils/inst/include/RandomFieldsUtils.h:  SEXP DivByRow(SEXP M, SEXP V);
RandomFieldsUtils/inst/include/RandomFieldsUtils.h:  SEXP dotXV(SEXP M, SEXP V);
RandomFieldsUtils/inst/include/solve_gpu.h:#define PADDIM 4L
RandomFieldsUtils/inst/include/intrinsics.h:// PKG_CXXFLAGS =  $(SHLIB_OPENMP_CXXFLAGS) -mavx ODER -march=native 
RandomFieldsUtils/inst/include/intrinsics.h:#define SSEMODE 30
RandomFieldsUtils/inst/include/intrinsics.h:#define SSEMODE 20
RandomFieldsUtils/inst/include/intrinsics.h:#define SSEMODE 10
RandomFieldsUtils/inst/include/intrinsics.h:#define SSEMODE 0
RandomFieldsUtils/inst/include/intrinsics.h:// #define FMA_AVAILABLE __FMA__
RandomFieldsUtils/inst/include/intrinsics.h:  (__GNUC__ == 4 && (__GNUC_MINOR__ > 9 ||				\
RandomFieldsUtils/inst/include/intrinsics.h:		     (__GNUC_MINOR__ == 9 &&  __GNUC_PATCHLEVEL__ >= 1)))
RandomFieldsUtils/inst/include/intrinsics.h://#define OpenMP4 1
RandomFieldsUtils/inst/include/intrinsics.h:#define MAXDOUBLE _mm256_max_pd
RandomFieldsUtils/inst/include/intrinsics.h:#define MAXINTEGER _mm256_max_epi32
RandomFieldsUtils/inst/include/intrinsics.h:#define MULTDOUBLE _mm256_mul_pd 
RandomFieldsUtils/inst/include/intrinsics.h:#define MAXDOUBLE _mm_max_pd
RandomFieldsUtils/inst/include/intrinsics.h:#define MAXINTEGER _mm_max_epi32
RandomFieldsUtils/inst/include/intrinsics.h:#define MULTDOUBLE _mm_mul_pd 
RandomFieldsUtils/inst/include/intrinsics.h:#define SCALAR_DEFAULT SCALAR_NEARFMA
RandomFieldsUtils/inst/include/errors_messages.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/inst/include/errors_messages.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFieldsUtils/inst/include/errors_messages.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/inst/include/errors_messages.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/inst/include/errors_messages.h:#define ERRORMEMORYALLOCATION 1 
RandomFieldsUtils/inst/include/errors_messages.h:#define ERRORNOTPROGRAMMEDYET 3
RandomFieldsUtils/inst/include/errors_messages.h:#define ERRORM 4          /* a single error message */
RandomFieldsUtils/inst/include/errors_messages.h:#define ERRORMEND 12      /* a single error message -- und alles dazwischen */
RandomFieldsUtils/inst/include/errors_messages.h:#define LENMSG 1000
RandomFieldsUtils/inst/include/errors_messages.h:#define MAXERRORSTRING 1000
RandomFieldsUtils/inst/include/errors_messages.h:#define LENERRMSG 1000
RandomFieldsUtils/inst/include/errors_messages.h:typedef char errorstring_type[MAXERRORSTRING];
RandomFieldsUtils/inst/include/errors_messages.h:  #define LOCAL_ERRMSG2 char MSG2[LENERRMSG]
RandomFieldsUtils/inst/include/errors_messages.h:  #ifndef LOCAL_ERRLOC_MSG
RandomFieldsUtils/inst/include/errors_messages.h:    #define LOCAL_ERRLOC_MSG errorloc_type ERROR_LOC=""; char ERRMSG[LENERRMSG];
RandomFieldsUtils/inst/include/errors_messages.h:  #define LOCAL_ERRMSG2
RandomFieldsUtils/inst/include/errors_messages.h:  #ifndef LOCAL_ERRLOC_MSG
RandomFieldsUtils/inst/include/errors_messages.h:    #define LOCAL_ERRLOC_MSG
RandomFieldsUtils/inst/include/errors_messages.h:  extern char ERRMSG[LENERRMSG], // used by Error_utils.h. Never use elsewhere
RandomFieldsUtils/inst/include/errors_messages.h:    MSG2[LENERRMSG];// used at the same time with MSG and ERR()
RandomFieldsUtils/inst/include/errors_messages.h:  extern errorstring_type ERRORSTRING; // used by ERRORM in RandomFields
RandomFieldsUtils/inst/include/errors_messages.h://  extern char   MSG[LENERRMSG]; // used by RandomFields in intermediate steps
RandomFieldsUtils/inst/include/errors_messages.h:#ifdef SCHLATHERS_MACHINE
RandomFieldsUtils/inst/include/errors_messages.h:  #define ERRLINE0 PRINTF("(ERROR in %s, line %d)\n", __FILE__, __LINE__); LOCAL_ERRLOC_MSG
RandomFieldsUtils/inst/include/errors_messages.h://#define ERRLINE ERRLINE0; LOCAL_ERRMSG2
RandomFieldsUtils/inst/include/errors_messages.h:  #define ERRLINE0 LOCAL_ERRLOC_MSG
RandomFieldsUtils/inst/include/errors_messages.h:#define ERRLINE ERRLINE0; LOCAL_ERRMSG2
RandomFieldsUtils/inst/include/errors_messages.h:#define W_ERRLINE0 char W_ERRMSG[LENERRMSG]
RandomFieldsUtils/inst/include/errors_messages.h:#define W_ERRLINE  char W_MSG2[LENERRMSG]
RandomFieldsUtils/inst/include/errors_messages.h:#define ERR(X) {ERRLINE0;SPRINTF(ERRMSG, "%.90s %.790s",ERROR_LOC,X);RFERROR(ERRMSG);}
RandomFieldsUtils/inst/include/errors_messages.h:#define ERR00(X) ERRLINE;SPRINTF(ERRMSG, "%.90s %.790s", ERROR_LOC, X)
RandomFieldsUtils/inst/include/errors_messages.h:#define ERR1(X, Y) {ERR00(X); SPRINTF(MSG2, ERRMSG, Y); RFERROR(MSG2);}
RandomFieldsUtils/inst/include/errors_messages.h:#define ERR2(X, Y, Z) {ERR00(X); SPRINTF(MSG2, ERRMSG, Y, Z); RFERROR(MSG2);}
RandomFieldsUtils/inst/include/errors_messages.h:#define ERR3(X, Y, Z, A) {ERR00(X); SPRINTF(MSG2, ERRMSG,Y,Z,A); RFERROR(MSG2);}
RandomFieldsUtils/inst/include/errors_messages.h:#define ERR4(X, Y, Z, A, B) {ERR00(X); SPRINTF(MSG2,ERRMSG,Y,Z,A,B);	\
RandomFieldsUtils/inst/include/errors_messages.h:    RFERROR(MSG2);}
RandomFieldsUtils/inst/include/errors_messages.h:#define ERR5(X, Y, Z, A, B, C) {ERR00(X); SPRINTF(MSG2, ERRMSG,Y,Z,A,B,C); \
RandomFieldsUtils/inst/include/errors_messages.h:    RFERROR(MSG2);}
RandomFieldsUtils/inst/include/errors_messages.h:#define ERR6(X, Y, Z, A, B,C,D) {ERR00(X); SPRINTF(MSG2, ERRMSG,Y,Z,A,B,C,D); \
RandomFieldsUtils/inst/include/errors_messages.h:    RFERROR(MSG2);}
RandomFieldsUtils/inst/include/errors_messages.h:#define ERR7(X, Y, Z,A,B,C,D,E) {ERR00(X); SPRINTF(MSG2,ERRMSG,Y,Z,A,B,C,D,E); \
RandomFieldsUtils/inst/include/errors_messages.h:    RFERROR(MSG2);}
RandomFieldsUtils/inst/include/errors_messages.h:#define ERR8(X,Y,Z,A,B,C,D,E,F){ERR00(X);SPRINTF(MSG2,ERRMSG,Y,Z,A,B,C,D,E,F); \
RandomFieldsUtils/inst/include/errors_messages.h:    RFERROR(MSG2);}
RandomFieldsUtils/inst/include/errors_messages.h:#define SERR(X) NERR(ERRORM, X)
RandomFieldsUtils/inst/include/errors_messages.h:#define SERR1(X,Y) NERR1(ERRORM, X, Y)
RandomFieldsUtils/inst/include/errors_messages.h:#define SERR2(X,Y,Z) NERR2(ERRORM, X, Y, Z)
RandomFieldsUtils/inst/include/errors_messages.h:#define SERR3(X,Y,Z, A) NERR3(ERRORM, X, Y, Z, A)
RandomFieldsUtils/inst/include/errors_messages.h:#define SERR4(X,Y,Z, A, B) NERR4(ERRORM, X, Y, Z, A, B)
RandomFieldsUtils/inst/include/errors_messages.h:#define SERR5(X,Y,Z, A, B, C) NERR5(ERRORM, X, Y, Z, A, B, C)
RandomFieldsUtils/inst/include/errors_messages.h:#define SERR6(X,Y,Z, A, B, C, D) NERR6(ERRORM, X, Y, Z, A, B, C, D)
RandomFieldsUtils/inst/include/errors_messages.h:#define SERR7(X,Y,Z, A, B, C, D, E) NERR7(ERRORM, X, Y, Z, A, B, C, D, E)
RandomFieldsUtils/inst/include/errors_messages.h:#define CERR00 err=ERRORM; continue;
RandomFieldsUtils/inst/include/errors_messages.h:#define GERR00 LOCAL_ERROR(ERRORM); err = ERRORM; goto ErrorHandling;
RandomFieldsUtils/inst/include/errors_messages.h:    SPRINTF(W_MSG2, X, Y); RFWARNING(W_MSG2);}
RandomFieldsUtils/inst/include/errors_messages.h:    SPRINTF(W_MSG2, X, Y, Z); RFWARNING(W_MSG2);}
RandomFieldsUtils/inst/include/errors_messages.h:    SPRINTF(W_MSG2, X, Y, Z, A); RFWARNING(W_MSG2);}
RandomFieldsUtils/inst/include/errors_messages.h:    SPRINTF(W_MSG2, X, Y, Z, A, B); RFWARNING(W_MSG2);}
RandomFieldsUtils/inst/include/errors_messages.h:    SPRINTF(W_MSG2, X, Y, Z, A, B, C); RFWARNING(W_MSG2);}
RandomFieldsUtils/inst/include/errors_messages.h:    SPRINTF(W_MSG2, X, Y, Z, A, B, C, D); RFWARNING(W_MSG2);}
RandomFieldsUtils/inst/include/errors_messages.h:    SPRINTF(W_MSG2, X, Y, Z, A, B, C, D, E); RFWARNING(W_MSG2);}
RandomFieldsUtils/inst/include/errors_messages.h:#define RFERROR1(M,A) {errorstring_type ERR_STR; \
RandomFieldsUtils/inst/include/errors_messages.h:    SPRINTF(ERR_STR, M, A); RFERROR(ERR_STR);}
RandomFieldsUtils/inst/include/errors_messages.h:#define RFERROR2(M,A,B) {errorstring_type ERR_STR; \
RandomFieldsUtils/inst/include/errors_messages.h:    SPRINTF(ERR_STR, M, A,B); RFERROR(ERR_STR);}
RandomFieldsUtils/inst/include/errors_messages.h:#define RFERROR3(M,A,B,C) {errorstring_type ERR_STR;\
RandomFieldsUtils/inst/include/errors_messages.h:    SPRINTF(ERR_STR, M, A,B,C); RFERROR(ERR_STR);}
RandomFieldsUtils/inst/include/errors_messages.h:#define RFERROR4(M,A,B,C,D) {errorstring_type ERR_STR; \
RandomFieldsUtils/inst/include/errors_messages.h:    SPRINTF(ERR_STR, M, A,B,C,D); RFERROR(ERR_STR);}
RandomFieldsUtils/inst/include/errors_messages.h:#define RFERROR5(M,A,B,C,D,E) {errorstring_type ERR_STR; \
RandomFieldsUtils/inst/include/errors_messages.h:    SPRINTF(ERR_STR, M, A,B,C,D,E); RFERROR(ERR_STR);}
RandomFieldsUtils/inst/include/errors_messages.h:#define RFERROR6(M,A,B,C,D,E,F) {errorstring_type ERR_STR;\
RandomFieldsUtils/inst/include/errors_messages.h:    SPRINTF(ERR_STR, M, A,B,C,D,E,F); RFERROR(ERR_STR);}
RandomFieldsUtils/inst/include/errors_messages.h:#define RFERROR7(M,A,B,C,D,E,F,G) {errorstring_type ERR_STR;\
RandomFieldsUtils/inst/include/errors_messages.h:    SPRINTF(ERR_STR, M, A,B,C,D,E,F,G); RFERROR(ERR_STR);}
RandomFieldsUtils/inst/include/Solve.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/inst/include/Solve.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFieldsUtils/inst/include/Solve.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/inst/include/Solve.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/inst/include/Solve.h:typedef enum InversionMethod { 
RandomFieldsUtils/inst/include/Solve.h:  NoInversionMethod, // 4, last user available method
RandomFieldsUtils/inst/include/Solve.h:  NoFurtherInversionMethod, // 7, local values
RandomFieldsUtils/inst/include/Solve.h:} InversionMethod;
RandomFieldsUtils/inst/include/Solve.h:#define nr_InversionMethods ((int) Diagonal + 1)
RandomFieldsUtils/inst/include/Solve.h:#define nr_user_InversionMethods ((int) NoFurtherInversionMethod + 1)
RandomFieldsUtils/inst/include/Solve.h:#define SOLVE_METHODS 3
RandomFieldsUtils/inst/include/Solve.h:  InversionMethod method, newMethods[SOLVE_METHODS];
RandomFieldsUtils/inst/include/Solve.h:  //   SICH_n, MM_n, VT_n, U_n, D_n, 
RandomFieldsUtils/inst/include/Solve.h:#define MATRIXSQRT 1
RandomFieldsUtils/inst/include/Solve.h:#define DETERMINANT 2
RandomFieldsUtils/inst/include/win_linux_aux.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/inst/include/win_linux_aux.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFieldsUtils/inst/include/win_linux_aux.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/inst/include/win_linux_aux.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/inst/include/win_linux_aux.h:extern "C" void sleepMilli(int *milli);
RandomFieldsUtils/inst/include/win_linux_aux.h:extern "C" void sleepMicro(int *milli);
RandomFieldsUtils/inst/CITATION:bibentry(bibtype="Manual",
RandomFieldsUtils/inst/CITATION:         author = c(person("Martin", "Schlather", role=c("cre", "aut")),
RandomFieldsUtils/inst/CITATION:                    person("Martin", "Kroll", role="ctb")),
RandomFieldsUtils/DESCRIPTION:Author: Martin Schlather [aut, cre], Reinhard Furrer [ctb], Martin Kroll [ctb], Brian D. Ripley [ctb]
RandomFieldsUtils/DESCRIPTION:Maintainer: Martin Schlather <schlather@math.uni-mannheim.de>
RandomFieldsUtils/DESCRIPTION:Description: Various utilities are provided that might be used in spatial statistics and elsewhere. It delivers a method for solving linear equations that checks the sparsity of the matrix before any algorithm is used. In particular the following algorithms are implemented: the pivotised Cholesky decomposition by Harbrecht, Peter and Schneider (2012) <doi:10.1016/j.apnum.2011.10.001>, the Struve functions by MacLeod (1993) <doi:10.1090/S0025-5718-1993-1176713-8>, and a precise algorithm for evaluating the Matern covariance function.
RandomFieldsUtils/man/Struve.Rd:\alias{I0ML0}
RandomFieldsUtils/man/Struve.Rd:\title{Modified Struve functions and related functions}
RandomFieldsUtils/man/Struve.Rd:    MacLeod, A.J. (1993)
RandomFieldsUtils/man/Struve.Rd:    related functions, \emph{Mathematics of Computation}, \bold{60},
RandomFieldsUtils/man/Struve.Rd:    Abramowitz, M., and Stegun, I.A. (1984)
RandomFieldsUtils/man/Struve.Rd:    \emph{Pocketbook of Mathematical Functions}, Verlag Harry Deutsch
RandomFieldsUtils/man/nonstwm.Rd:  The non-stationary Whittle-Matern model
RandomFieldsUtils/man/nonstwm.Rd: \item Stein, M. (2005)
RandomFieldsUtils/man/nonstwm.Rd: For more details see \command{\link[RandomFields]{RMnonstwm}}.
RandomFieldsUtils/man/sortx.Rd:\author{Martin Schlather, \email{schlather@math.uni-mannheim.de}
RandomFieldsUtils/man/matern.Rd:\title{Whittle-Matern Model}
RandomFieldsUtils/man/matern.Rd: \command{matern} calculates the Whittle-Matern covariance function
RandomFieldsUtils/man/matern.Rd: The Matern model is given by
RandomFieldsUtils/man/matern.Rd:    \emph{Geostatistics. Modeling Spatial Uncertainty.}
RandomFieldsUtils/man/matern.Rd:    \item Gelfand, A. E., Diggle, P., Fuentes, M. and Guttorp,
RandomFieldsUtils/man/matern.Rd:    history of probability and statistics. XLIX. On the Matern
RandomFieldsUtils/man/matern.Rd:    \item Handcock, M. S. and Wallis, J. R. (1994) An approach to
RandomFieldsUtils/man/matern.Rd:    \item Stein, M. L. (1999) \emph{Interpolation of Spatial Data --
RandomFieldsUtils/man/matern.Rd: For more details see also \command{\link[RandomFields]{RMmatern}}.
RandomFieldsUtils/man/solvePosDef.Rd:\title{Solve a System of Equations for Positive Definite Matrices}
RandomFieldsUtils/man/solvePosDef.Rd:## FIRST EXAMPLE: full rank matrix
RandomFieldsUtils/man/solvePosDef.Rd:M <- exp(-as.matrix(dist(x) / n)) 
RandomFieldsUtils/man/solvePosDef.Rd:b <- M \%*\% b0 + runif(n)
RandomFieldsUtils/man/solvePosDef.Rd:print(system.time(z <- solve(M, b)))
RandomFieldsUtils/man/solvePosDef.Rd:print(range(b - M \%*\% z))
RandomFieldsUtils/man/solvePosDef.Rd:stopifnot(all(abs((b - M \%*\% z)) < 2e-11))
RandomFieldsUtils/man/solvePosDef.Rd:print(system.time(z <- solvex(M, b)))
RandomFieldsUtils/man/solvePosDef.Rd:print(range(b - M \%*\% z))
RandomFieldsUtils/man/solvePosDef.Rd:stopifnot(all(abs((b - M \%*\% z)) < 2e-11))
RandomFieldsUtils/man/solvePosDef.Rd:print(system.time(z <- solvex(M, b)))
RandomFieldsUtils/man/solvePosDef.Rd:print(range(b - M \%*\% z))
RandomFieldsUtils/man/solvePosDef.Rd:stopifnot(all(abs((b - M \%*\% z)) < 2e-11))
RandomFieldsUtils/man/solvePosDef.Rd:## SECOND EXAMPLE: low rank matrix
RandomFieldsUtils/man/solvePosDef.Rd:M <- x \%*\% t(x) + rev(x) \%*\% t(rev(x)) + y \%*\% t(y)
RandomFieldsUtils/man/solvePosDef.Rd:b1 <- M \%*\% b0
RandomFieldsUtils/man/solvePosDef.Rd:#try(solve(M, b1))
RandomFieldsUtils/man/solvePosDef.Rd:#try(solvex(M, b1))
RandomFieldsUtils/man/solvePosDef.Rd:print(system.time(z1 <- solvex(M, b1)))
RandomFieldsUtils/man/solvePosDef.Rd:print(range(b1 - M \%*\% z1))
RandomFieldsUtils/man/solvePosDef.Rd:stopifnot(all(abs((b1 - M \%*\% z1)) < 2e-6))
RandomFieldsUtils/man/solvePosDef.Rd:b2 <- M + runif(n)
RandomFieldsUtils/man/solvePosDef.Rd:#try(solvex(M, b2))
RandomFieldsUtils/man/internal.Rd:dep.packages <- c( #"DSpat","lgcp", "constrainedKriging", "MarkedPointProcess",
RandomFieldsUtils/man/internal.Rd:    checkExamples(path=paste("~/TMP/dep.packages", dep.packages[.i], sep="/"),
RandomFieldsUtils/man/cholPosDef.Rd:\title{Cholesky Decomposition of Positive Definite Matrices}
RandomFieldsUtils/man/cholPosDef.Rd:  Harbrecht, H., Peters, M., Schneider, R. (2012)
RandomFieldsUtils/man/cholPosDef.Rd:  \emph{Appl. Num. Math.} \bold{62}, 428--440.
RandomFieldsUtils/man/cholPosDef.Rd:M <- covmatrix((1 - x) * (x < 1) , x) ## Askey's model of covariance
RandomFieldsUtils/man/cholPosDef.Rd:system.time(C2 <- chol(M))
RandomFieldsUtils/man/cholPosDef.Rd:system.time(C1 <- cholx(M))
RandomFieldsUtils/man/cholPosDef.Rd:M <- matrix(nc=n, runif(n^2))
RandomFieldsUtils/man/cholPosDef.Rd:M <- M \%*\% t(M) + diag(n)
RandomFieldsUtils/man/cholPosDef.Rd:C <- cholx(M)
RandomFieldsUtils/man/cholPosDef.Rd:M <- x \%*\% t(x) + rev(x) \%*\% t(rev(x)) + y \%*\% t(y)
RandomFieldsUtils/man/cholPosDef.Rd:print(system.time(C <- cholx(M)))
RandomFieldsUtils/man/cholPosDef.Rd:print(range(crossprod(C) - M))
RandomFieldsUtils/man/cholPosDef.Rd:M2 <- M +  n * diag(1:n)
RandomFieldsUtils/man/cholPosDef.Rd:print(system.time(C2 <- cholx(M2)))
RandomFieldsUtils/man/cholPosDef.Rd:print(range(crossprod(C2) - M2))
RandomFieldsUtils/man/cholPosDef.Rd:range((crossprod(C2) - M2) / M2)
RandomFieldsUtils/man/gauss.Rd:\title{Gaussian Covariance Model}
RandomFieldsUtils/man/gauss.Rd: Gelfand, A. E., Diggle, P., Fuentes, M. and Guttorp,
RandomFieldsUtils/man/gauss.Rd: Stein, M. L. (1999) \emph{Interpolation of Spatial Data.} New York: Springer-Verlag 
RandomFieldsUtils/man/gauss.Rd: For more details see \command{\link[RandomFields]{RMgauss}}.
RandomFieldsUtils/man/rowMeansx.Rd:\name{rowMeansx}
RandomFieldsUtils/man/rowMeansx.Rd:\alias{rowMeans}
RandomFieldsUtils/man/rowMeansx.Rd:\alias{rowMeansx}
RandomFieldsUtils/man/rowMeansx.Rd:\alias{colMax}
RandomFieldsUtils/man/rowMeansx.Rd:  The function \command{rowMeansx} returns weighted row means;\cr
RandomFieldsUtils/man/rowMeansx.Rd:  the function \command{colMax} returns column maxima;\cr
RandomFieldsUtils/man/rowMeansx.Rd:rowMeansx(x, weight=NULL)
RandomFieldsUtils/man/rowMeansx.Rd:colMax(x)
RandomFieldsUtils/man/rowMeansx.Rd:  \command{rowMeansx} returns a vector of length\code{nrow(x)}.
RandomFieldsUtils/man/rowMeansx.Rd:  \command{colMax} returns a vector of length \code{ncol(x)}.
RandomFieldsUtils/man/rowMeansx.Rd:M <- matrix(nr=r, 1:(c * r))
RandomFieldsUtils/man/rowMeansx.Rd:## unweighted means, compare to rowMeans
RandomFieldsUtils/man/rowMeansx.Rd:print(system.time(m1 <- rowMeans(M)))
RandomFieldsUtils/man/rowMeansx.Rd:print(system.time(m2 <- rowMeansx(M)))
RandomFieldsUtils/man/rowMeansx.Rd:## weighted row means, compare to rowMeans
RandomFieldsUtils/man/rowMeansx.Rd:W <- 1 / (ncol(M) : 1)
RandomFieldsUtils/man/rowMeansx.Rd:print(system.time({M0 <- t(W * t(M)); m1 <- rowMeans(M0)}))
RandomFieldsUtils/man/rowMeansx.Rd:print(system.time(m2 <- rowMeansx(M, W)))
RandomFieldsUtils/man/rowMeansx.Rd:print(system.time(m1 <- apply(M, 2, max)))
RandomFieldsUtils/man/rowMeansx.Rd:print(system.time(m2 <- colMax(M)))
RandomFieldsUtils/man/macros/allg_defn.Rd:\newcommand{\martin}{Martin Schlather, \email{schlather@math.uni-mannheim.de}, \url{http://ms.math.uni-mannheim.de}}
RandomFieldsUtils/man/macros/allg_defn.Rd:\newcommand{\marco}{Marco Oesting, \email{marco.oesting@mathematik.uni-stuttgart.de}, \url{https://www.isa.uni-stuttgart.de/institut/team/Oesting/}}
RandomFieldsUtils/man/macros/allg_defn.Rd:\newcommand{\KMM}{\author{\kirstin \marco, \martin}}
RandomFieldsUtils/man/RFoptions.Rd:\alias{PIVOTSPARSE_MMD}
RandomFieldsUtils/man/RFoptions.Rd:\alias{PIVOTSPARSE_RCM}
RandomFieldsUtils/man/RFoptions.Rd:      %RFsimulate(RPschlather(RMmatern(nu=2), xi=1, mu=1, s=1), x, grid=F, n=5)@data
RandomFieldsUtils/man/RFoptions.Rd:      %RFsimulate(RPschlather(RMmatern(nu=2.01), xi=1, mu=1, s=1), x,grid=F,n=5)@data
RandomFieldsUtils/man/RFoptions.Rd:      %RFsimulate(RPschlather(RMmatern(nu=2), xi=1, mu=1, s=1), x, grid=F, n=5)@data
RandomFieldsUtils/man/RFoptions.Rd:      %RFsimulate(RPschlather(RMmatern(nu=2.01), xi=1, mu=1, s=1), x, grid=F,n=5)@data
RandomFieldsUtils/man/RFoptions.Rd:    \item{\code{max_chol}}{integer. Maximum number of rows of a matrix in
RandomFieldsUtils/man/RFoptions.Rd:    \item{\code{max_svd}}{integer. Maximum number of rows of a matrix in
RandomFieldsUtils/man/RFoptions.Rd:	  an upper triangular matrix L, but still L^t L = M holds true.
RandomFieldsUtils/man/RFoptions.Rd:	\item{PIVOTSPARSE_MMD}{}
RandomFieldsUtils/man/RFoptions.Rd:	\item{PIVOTSPARSE_RCM}{}
RandomFieldsUtils/man/RFoptions.Rd:      Default: PIVOTSPARSE_MMD
RandomFieldsUtils/man/RFoptions.Rd:  M <- matrix(rnorm(n * n), nc=n)
RandomFieldsUtils/man/RFoptions.Rd:  M <- M \%*\% t(M)
RandomFieldsUtils/man/RFoptions.Rd:  system.time(chol(M))
RandomFieldsUtils/man/RFoptions.Rd:  system.time(cholesky(M))
RandomFieldsUtils/man/RFoptions.Rd:  system.time(cholesky(M))
RandomFieldsUtils/configure.ac:CXX=`"${R_HOME}/bin/R" CMD config CXX`
RandomFieldsUtils/configure.ac:AC_MSG_CHECKING([which SIMD flags can be recognized])
RandomFieldsUtils/configure.ac:     AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]])], [ FX="$FX $AUTOCPPFLAGS" ], [ ])
RandomFieldsUtils/configure.ac:  AC_MSG_RESULT([$AUTOCPPFLAGS])
RandomFieldsUtils/configure.ac:  AC_MSG_RESULT([none])
RandomFieldsUtils/configure.ac:      AC_MSG_CHECKING([whether CUDA_HOME is set])
RandomFieldsUtils/configure.ac:      if test -z "${CUDA_HOME}"; then
RandomFieldsUtils/configure.ac:          AC_MSG_RESULT(CUDA_HOME not set; using /usr/local/cuda)
RandomFieldsUtils/configure.ac:          CUDA_HOME="/usr/local/cuda"
RandomFieldsUtils/configure.ac:          AC_MSG_RESULT(using CUDA_HOME=${CUDA_HOME})
RandomFieldsUtils/configure.ac:      AC_CHECK_FILE([${CUDA_HOME}/bin/nvcc], CUDA_INSTALLED=true,)
RandomFieldsUtils/configure.ac:          AC_MSG_RESULT([No CUDA installation found, install CUDA or specify CUDA_HOME.])
RandomFieldsUtils/configure.ac:          AC_MSG_CHECKING(whether this is the 64 bit linux version of CUDA)
RandomFieldsUtils/configure.ac:          AC_CHECK_FILE([${CUDA_HOME}/lib64/libcublas.so], , 
RandomFieldsUtils/configure.ac:          AC_MSG_ERROR([this package only works with 64 bit installations of CUDA]))
RandomFieldsUtils/configure.ac:RANDOMFIELDSUTILS_CXXFLAGS="$CXX_FLAGS $AUTOCPPFLAGS"
RandomFieldsUtils/configure.ac:RANDOMFIELDSUTILS_LIBFLAGS="$LIB_FLAGS"
RandomFieldsUtils/configure.ac:#AC_MSG_CHECKING([HuHu])
RandomFieldsUtils/configure.ac:#AC_MSG_RESULT([$RANDOMFIELDSUTILS_CXXFLAGS])
RandomFieldsUtils/configure.ac:#AC_MSG_RESULT([$RANDOMFIELDSUTILS_LIBFLAGS])
RandomFieldsUtils/configure.ac:AC_SUBST(RANDOMFIELDSUTILS_CXXFLAGS)
RandomFieldsUtils/configure.ac:AC_SUBST(RANDOMFIELDSUTILS_LIBFLAGS)
RandomFieldsUtils/configure.ac:AC_SUBST(CUDA_HOME)
RandomFieldsUtils/configure.ac:AC_CONFIG_FILES([src/Makevars])
RandomFieldsUtils/configure:# Guess values for system-dependent variables and create Makefiles.
RandomFieldsUtils/configure:## M4sh Initialization. ##
RandomFieldsUtils/configure:DUALCASE=1; export DUALCASE # for MKS sh
RandomFieldsUtils/configure:  NULLCMD=:
RandomFieldsUtils/configure:# We did not find ourselves, most probably we were run as `sh COMMAND'
RandomFieldsUtils/configure:for as_var in BASH_ENV ENV MAIL MAILPATH
RandomFieldsUtils/configure:  NULLCMD=:
RandomFieldsUtils/configure:## M4sh Shell Functions. ##
RandomFieldsUtils/configure:as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
RandomFieldsUtils/configure:  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)
RandomFieldsUtils/configure:    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
RandomFieldsUtils/configure:MFLAGS=
RandomFieldsUtils/configure:MAKEFLAGS=
RandomFieldsUtils/configure:PACKAGE_NAME='RandomFieldsUtils'
RandomFieldsUtils/configure:PACKAGE_TARNAME='randomfieldsutils'
RandomFieldsUtils/configure:CUDA_HOME
RandomFieldsUtils/configure:RANDOMFIELDSUTILS_LIBFLAGS
RandomFieldsUtils/configure:RANDOMFIELDSUTILS_CXXFLAGS
RandomFieldsUtils/configure:PACKAGE_TARNAME
RandomFieldsUtils/configure:PACKAGE_NAME
RandomFieldsUtils/configure:docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
RandomFieldsUtils/configure:    # FIXME: should be removed in autoconf 3.0.
RandomFieldsUtils/configure:# FIXME: To remove some day.
RandomFieldsUtils/configure:# FIXME: To remove some day.
RandomFieldsUtils/configure:# mess up M-x gdb in Emacs.
RandomFieldsUtils/configure:for instance \`--prefix=\$HOME'.
RandomFieldsUtils/configure:cat <<_ASUNAME
RandomFieldsUtils/configure:_ASUNAME
RandomFieldsUtils/configure:# Make two passes to allow for proper duplicate-argument suppression.
RandomFieldsUtils/configure:#define PACKAGE_NAME "$PACKAGE_NAME"
RandomFieldsUtils/configure:#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
RandomFieldsUtils/configure:## Main body of script. ##
RandomFieldsUtils/configure:CXX=`"${R_HOME}/bin/R" CMD config CXX`
RandomFieldsUtils/configure:ac_clean_files="$ac_clean_files a.out a.out.dSYM a.exe b.out"
RandomFieldsUtils/configure:    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
RandomFieldsUtils/configure:# in a Makefile.  We should not override ac_cv_exeext if it was cached,
RandomFieldsUtils/configure:    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj )
RandomFieldsUtils/configure:rm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out
RandomFieldsUtils/configure:    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
RandomFieldsUtils/configure:    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM ) ;;
RandomFieldsUtils/configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: checking which SIMD flags can be recognized" >&5
RandomFieldsUtils/configure:$as_echo_n "checking which SIMD flags can be recognized... " >&6; }
RandomFieldsUtils/configure:      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether CUDA_HOME is set" >&5
RandomFieldsUtils/configure:$as_echo_n "checking whether CUDA_HOME is set... " >&6; }
RandomFieldsUtils/configure:      if test -z "${CUDA_HOME}"; then
RandomFieldsUtils/configure:          { $as_echo "$as_me:${as_lineno-$LINENO}: result: CUDA_HOME not set; using /usr/local/cuda" >&5
RandomFieldsUtils/configure:$as_echo "CUDA_HOME not set; using /usr/local/cuda" >&6; }
RandomFieldsUtils/configure:          CUDA_HOME="/usr/local/cuda"
RandomFieldsUtils/configure:          { $as_echo "$as_me:${as_lineno-$LINENO}: result: using CUDA_HOME=${CUDA_HOME}" >&5
RandomFieldsUtils/configure:$as_echo "using CUDA_HOME=${CUDA_HOME}" >&6; }
RandomFieldsUtils/configure:      as_ac_File=`$as_echo "ac_cv_file_${CUDA_HOME}/bin/nvcc" | $as_tr_sh`
RandomFieldsUtils/configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${CUDA_HOME}/bin/nvcc" >&5
RandomFieldsUtils/configure:$as_echo_n "checking for ${CUDA_HOME}/bin/nvcc... " >&6; }
RandomFieldsUtils/configure:if test -r "${CUDA_HOME}/bin/nvcc"; then
RandomFieldsUtils/configure:          { $as_echo "$as_me:${as_lineno-$LINENO}: result: No CUDA installation found, install CUDA or specify CUDA_HOME." >&5
RandomFieldsUtils/configure:$as_echo "No CUDA installation found, install CUDA or specify CUDA_HOME." >&6; }
RandomFieldsUtils/configure:          as_ac_File=`$as_echo "ac_cv_file_${CUDA_HOME}/lib64/libcublas.so" | $as_tr_sh`
RandomFieldsUtils/configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${CUDA_HOME}/lib64/libcublas.so" >&5
RandomFieldsUtils/configure:$as_echo_n "checking for ${CUDA_HOME}/lib64/libcublas.so... " >&6; }
RandomFieldsUtils/configure:if test -r "${CUDA_HOME}/lib64/libcublas.so"; then
RandomFieldsUtils/configure:RANDOMFIELDSUTILS_CXXFLAGS="$CXX_FLAGS $AUTOCPPFLAGS"
RandomFieldsUtils/configure:RANDOMFIELDSUTILS_LIBFLAGS="$LIB_FLAGS"
RandomFieldsUtils/configure:#AC_MSG_CHECKING([HuHu])
RandomFieldsUtils/configure:#AC_MSG_RESULT([$RANDOMFIELDSUTILS_CXXFLAGS])
RandomFieldsUtils/configure:#AC_MSG_RESULT([$RANDOMFIELDSUTILS_LIBFLAGS])
RandomFieldsUtils/configure:ac_config_files="$ac_config_files src/Makevars"
RandomFieldsUtils/configure:# Protect against shell expansion while executing Makefile rules.
RandomFieldsUtils/configure:# Protect against Makefile macro expansion.
RandomFieldsUtils/configure:## M4sh Initialization. ##
RandomFieldsUtils/configure:DUALCASE=1; export DUALCASE # for MKS sh
RandomFieldsUtils/configure:  NULLCMD=:
RandomFieldsUtils/configure:# We did not find ourselves, most probably we were run as `sh COMMAND'
RandomFieldsUtils/configure:for as_var in BASH_ENV ENV MAIL MAILPATH
RandomFieldsUtils/configure:as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
RandomFieldsUtils/configure:    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
RandomFieldsUtils/configure:## Main body of $CONFIG_STATUS script. ##
RandomFieldsUtils/configure:  CONFIG_COMMANDS = $CONFIG_COMMANDS
RandomFieldsUtils/configure:      --file=FILE[:TEMPLATE]
RandomFieldsUtils/configure:    "src/Makevars") CONFIG_FILES="$CONFIG_FILES src/Makevars" ;;
RandomFieldsUtils/configure:# Have a temporary directory for convenience.  Make it in the build tree
RandomFieldsUtils/configure:  tmp=./conf$$-$RANDOM
RandomFieldsUtils/configure:# FIXME: This hack should be removed a few years after 2.60.
RandomFieldsUtils/configure:# FIXME: do we really want to maintain this feature?
RandomFieldsUtils/R/zzz.R:  packageStartupMessage(.Call("attachRandomFieldsUtils"))
RandomFieldsUtils/R/utils.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/R/utils.R:## Copyright (C) 2015 Martin Schlather
RandomFieldsUtils/R/utils.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/R/utils.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/R/utils.R:  .C(C_sleepMilli, as.integer(n))
RandomFieldsUtils/R/utils.R:  .C(C_sleepMicro, as.integer(n))
RandomFieldsUtils/R/utils.R:  maxint <- .Machine$integer.max
RandomFieldsUtils/R/utils.R:colMax <- function(x) .Call(C_colMaxs, x)
RandomFieldsUtils/R/utils.R:rowMeansx <- function(x, weight=NULL) .Call(C_rowMeansX, x, weight)
RandomFieldsUtils/R/aaa_auto.R: MAXUNITS 	<- as.integer(4)
RandomFieldsUtils/R/aaa_auto.R: MAXCHAR 	<- as.integer(18)
RandomFieldsUtils/R/aaa_auto.R: PIVOTSPARSE_MMD 	<- as.integer(1)
RandomFieldsUtils/R/aaa_auto.R: PIVOTSPARSE_RCM 	<- as.integer(2)
RandomFieldsUtils/R/internal_use.R:    ## importMethodsFrom <- exportMethods <- S3method <-
RandomFieldsUtils/R/internal_use.R:  exportPattern <- function(p) { ## necessary to read NAMESPACE??!!
RandomFieldsUtils/R/internal_use.R:  import <- importClassesFrom <- importMethodsFrom <- importFrom <- useDynLib <-
RandomFieldsUtils/R/internal_use.R:    exportClasses <- S3method <- exportMethods <-
RandomFieldsUtils/R/internal_use.R:  .content <- readLines(paste(.path, "NAMESPACE", sep="/"), -1)
RandomFieldsUtils/R/internal_use.R:  if (exists("RMexp")) RFoptions(graphics.close_screen = TRUE, graphics.split_screen = TRUE)
RandomFieldsUtils/R/internal_use.R:       if (exists("RMexp")) RFoptions(storing = FALSE)
RandomFieldsUtils/R/internal_use.R:    db <- db[pos, c("Package", "Version", "Maintainer")]
RandomFieldsUtils/R/internal_use.R:	command <- paste("(cd ", dir, "; time R CMD check --as-cran", PKGS[i],")")
RandomFieldsUtils/R/maths.R:## Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/R/maths.R:## Copyright (C) 2015 Martin Schlather
RandomFieldsUtils/R/maths.R:## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/R/maths.R:## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/R/maths.R:  .Call(C_I0ML0, x)
RandomFieldsUtils/R/maths.R:  .Call(C_WMr, as.double(x), as.double(nu), as.integer(derivative),
RandomFieldsUtils/R/maths.R:  L <- .Call(C_logWMr, sqrt(sum((x - y)^2)), as.double(nu1), as.double(nu2),
RandomFieldsUtils/cleanup:rm -rf config.* src/Makevars
RandomFieldsUtils/src/utils.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/src/utils.cc: Copyright (C) 2001 -- 2017 Martin Schlather, 
RandomFieldsUtils/src/utils.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURSE.  See the
RandomFieldsUtils/src/utils.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFieldsUtils/src/utils.cc:  s = (char*) MALLOC(sizeof(char) * maxGetChar);
RandomFieldsUtils/src/utils.cc:SEXP DivByRow(SEXP M, SEXP V) {
RandomFieldsUtils/src/utils.cc:    r = nrows(M),
RandomFieldsUtils/src/utils.cc:    c = ncols(M);
RandomFieldsUtils/src/utils.cc:  double *m = REAL(M),
RandomFieldsUtils/src/utils.cc:  return M;
RandomFieldsUtils/src/utils.cc:void colMaxsIint(int *M, int r, int c, int *ans) {
RandomFieldsUtils/src/utils.cc:      int *m = M + r * i,
RandomFieldsUtils/src/utils.cc:      for (int j=1; j<r; j++) dummy = MAX(dummy, m[j]);
RandomFieldsUtils/src/utils.cc:      *m = M + r * i;
RandomFieldsUtils/src/utils.cc:	Dummy = MAXINTEGER(Dummy, LOAD(m0));
RandomFieldsUtils/src/utils.cc:      dummy = MAX(dummy, d[1]);
RandomFieldsUtils/src/utils.cc:      dummy = MAX(dummy, d[2]);
RandomFieldsUtils/src/utils.cc:      dummy = MAX(dummy, d[3]);
RandomFieldsUtils/src/utils.cc:      dummy = MAX(dummy, d[4]);
RandomFieldsUtils/src/utils.cc:      dummy = MAX(dummy, d[5]);
RandomFieldsUtils/src/utils.cc:      dummy = MAX(dummy, d[6]);
RandomFieldsUtils/src/utils.cc:      dummy = MAX(dummy, d[7]);
RandomFieldsUtils/src/utils.cc:      for ( ; m<start; m++) dummy = MAX(dummy, *m);
RandomFieldsUtils/src/utils.cc:      for ( ; m<end; m++) dummy = MAX(dummy, *m);
RandomFieldsUtils/src/utils.cc:      for (int j=1; j<r; j++) dummy = MAX(dummy, m[j]);
RandomFieldsUtils/src/utils.cc:    for (int j=1; j<r; j++) dummy = MAX(dummy, m[j]);
RandomFieldsUtils/src/utils.cc:void colMaxsI(double *M, int r, int c, double *ans) {
RandomFieldsUtils/src/utils.cc:      double *m = M + r * i,
RandomFieldsUtils/src/utils.cc:      for (int j=1; j<r; j++) dummy = MAX(dummy, m[j]);
RandomFieldsUtils/src/utils.cc:      *m = M + r * i;
RandomFieldsUtils/src/utils.cc:	Dummy = MAXDOUBLE(Dummy, (Double) LOAD((BlockType0*) m0));
RandomFieldsUtils/src/utils.cc:      dummy = MAX(dummy, d[1]);
RandomFieldsUtils/src/utils.cc:      dummy = MAX(dummy, d[2]);
RandomFieldsUtils/src/utils.cc:      dummy = MAX(dummy, d[3]);
RandomFieldsUtils/src/utils.cc:      for ( ; m<start; m++) dummy = MAX(dummy, *m);
RandomFieldsUtils/src/utils.cc:      for ( ; m<end; m++) dummy = MAX(dummy, *m);
RandomFieldsUtils/src/utils.cc:      for (int j=1; j<r; j++) dummy = MAX(dummy, m[j]);
RandomFieldsUtils/src/utils.cc:    for (int j=1; j<r; j++) dummy = MAX(dummy, m[j]);
RandomFieldsUtils/src/utils.cc:SEXP colMaxs(SEXP M) {
RandomFieldsUtils/src/utils.cc:    r = nrows(M),
RandomFieldsUtils/src/utils.cc:    c = ncols(M);
RandomFieldsUtils/src/utils.cc:  if (TYPEOF(M) == REALSXP) {
RandomFieldsUtils/src/utils.cc:    colMaxsI(REAL(M), r, c, REAL(Ans));
RandomFieldsUtils/src/utils.cc:    bool i = TYPEOF(M) == INTSXP;
RandomFieldsUtils/src/utils.cc:      m = INTEGER(M);
RandomFieldsUtils/src/utils.cc:      m = LOGICAL(M);
RandomFieldsUtils/src/utils.cc:    colMaxsIint(m, r, c, a);
RandomFieldsUtils/src/utils.cc:SEXP rowProd(SEXP M) {
RandomFieldsUtils/src/utils.cc:    r = nrows(M),
RandomFieldsUtils/src/utils.cc:    c = ncols(M);
RandomFieldsUtils/src/utils.cc:  if (TYPEOF(M) == REALSXP) {
RandomFieldsUtils/src/utils.cc:      *m = REAL(M);
RandomFieldsUtils/src/utils.cc:    MEMCOPY(ans, m, sizeof(double) * r);
RandomFieldsUtils/src/utils.cc:    // printf("type = %d", TYPEOF(M));
RandomFieldsUtils/src/utils.cc:SEXP rowMeansX(SEXP M, SEXP Weight) {
RandomFieldsUtils/src/utils.cc:    r = nrows(M),
RandomFieldsUtils/src/utils.cc:    c = ncols(M);
RandomFieldsUtils/src/utils.cc:    if (TYPEOF(M) == REALSXP) { double *m = REAL(M); for1; }
RandomFieldsUtils/src/utils.cc:      if (TYPEOF(M) == INTSXP) m = INTEGER(M); else m = LOGICAL(M);
RandomFieldsUtils/src/utils.cc:      double dummy = weight[i]; /* load1(weight); MULTDOUBLE */ \
RandomFieldsUtils/src/utils.cc:    if (TYPEOF(M) == REALSXP) { double *m = REAL(M); for2; }
RandomFieldsUtils/src/utils.cc:      if (TYPEOF(M) == INTSXP) m = INTEGER(M); else m = LOGICAL(M);
RandomFieldsUtils/src/utils.cc:    if (isMatrix(X)) {
RandomFieldsUtils/src/utils.cc:      x4 = MULTDOUBLE(x4, x4);
RandomFieldsUtils/src/utils.cc:	y4 = MULTDOUBLE(y4, y4);
RandomFieldsUtils/src/utils.cc:      x4 = MULTDOUBLE(minushalf4, x4);
RandomFieldsUtils/src/utils.cc:      x4 = MULTDOUBLE(x4, invtwopi4);
RandomFieldsUtils/src/utils.cc:SEXP dotXV(SEXP M, SEXP V) {
RandomFieldsUtils/src/utils.cc:    r = nrows(M),
RandomFieldsUtils/src/utils.cc:    c = ncols(M),
RandomFieldsUtils/src/utils.cc:  PROTECT(Ans = allocMatrix(REALSXP, r, c));
RandomFieldsUtils/src/utils.cc:      *m = REAL(M) + r * i,
RandomFieldsUtils/src/utils.cc:      STOREuDOUBLE(ans, MULTDOUBLE(LOADuDOUBLE(m), LOADuDOUBLE(v)));
RandomFieldsUtils/src/utils.cc:      *m = REAL(M) + r * i;
RandomFieldsUtils/src/Makevars.win:PKG_LIBS = $(LAPACK_LIBS) $(BLAS_LIBS) $(SHLIB_OPENMP_CXXFLAGS) $(FLIBS) 
RandomFieldsUtils/src/Makevars.win:PKG_CXXFLAGS = $(SHLIB_OPENMP_CXXFLAGS) -mavx
Binary file RandomFieldsUtils/src/brdomain.o matches
RandomFieldsUtils/src/Makevars.in:NVCC=@CUDA_HOME@/bin/nvcc
RandomFieldsUtils/src/Makevars.in:CUDA_LINKS = -L@CUDA_HOME@/lib64 -lcudart -lcublas -lcusolver -lcusolverMg
RandomFieldsUtils/src/Makevars.in:PKG_LIBS =  $(LAPACK_LIBS) $(BLAS_LIBS)  $(SHLIB_OPENMP_CXXFLAGS) @RANDOMFIELDSUTILS_LIBFLAGS@ $(FLIBS) $(CUDA_LINKS)
RandomFieldsUtils/src/Makevars.in:PKG_CXXFLAGS = $(SHLIB_OPENMP_CXXFLAGS) @RANDOMFIELDSUTILS_CXXFLAGS@ 
RandomFieldsUtils/src/Makevars.in:	 $(CLINK_CPPFLAGS) -I $(R_INCLUDE_DIR) -I@CUDA_HOME@/include -I$(CUTLASS_PATH)/include -I$(CUTLASS_PATH)/tools/util/include -Xcompiler -fpic\
RandomFieldsUtils/src/Makevars.in:	rm -r -f s*.o Makevars
RandomFieldsUtils/src/kleinkram.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/src/kleinkram.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFieldsUtils/src/kleinkram.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/src/kleinkram.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/src/kleinkram.h:#define LAST_R_TYPE_NAME 32
RandomFieldsUtils/src/kleinkram.h:extern const char *RTYPE_NAMES[LAST_R_TYPE_NAME + 1];
RandomFieldsUtils/src/kleinkram.h:#define R_TYPE_NAME(X) RTYPE_NAMES[MIN(X, LAST_R_TYPE_NAME)]
RandomFieldsUtils/src/kleinkram.h:typedef char name_type[][MAXCHAR];
RandomFieldsUtils/src/kleinkram.h:#define NUM Real(el, name, 0)
RandomFieldsUtils/src/kleinkram.h:#define POS0NUM NonNegReal(el, name)
RandomFieldsUtils/src/kleinkram.h:#define NEG0NUM NonPosReal(el, name)
RandomFieldsUtils/src/kleinkram.h:#define POSNUM PositiveReal(el, name)
RandomFieldsUtils/src/kleinkram.h://SEXP String(char V[][MAXCHAR], int n, int max);
RandomFieldsUtils/src/kleinkram.h:SEXP Mat(double* V, int row, int col, int max);
RandomFieldsUtils/src/kleinkram.h:SEXP Mat_t(double* V, int row, int col, int max);
RandomFieldsUtils/src/kleinkram.h:SEXP MatInt(int* V, int row, int col, int max) ;
RandomFieldsUtils/src/kleinkram.h:SEXP MatString(char **V, int row, int col, int max);
RandomFieldsUtils/src/kleinkram.h:SEXP Mat(double* V, int row, int col);
RandomFieldsUtils/src/kleinkram.h:SEXP Mat_t(double* V, int row, int col);
RandomFieldsUtils/src/kleinkram.h:SEXP MatInt(int* V, int row, int col) ;
RandomFieldsUtils/src/kleinkram.h:SEXP MatString(char** V, int row, int col);
RandomFieldsUtils/src/kleinkram.h:SEXP String(char V[][MAXCHAR], int n);
RandomFieldsUtils/src/kleinkram.h:void String(SEXP el, char *name, char names[][MAXCHAR], int maxlen);
RandomFieldsUtils/src/kleinkram.h:#define MULTIPLEMATCHING -2
RandomFieldsUtils/src/kleinkram.h:#define NOMATCHING -1
RandomFieldsUtils/src/kleinkram.h:#define MATCHESINTERNAL -3
RandomFieldsUtils/src/kleinkram.h:int Match(char *name, const char * List[], int n);
RandomFieldsUtils/src/kleinkram.h:int Match(char *name, name_type List, int n);
RandomFieldsUtils/src/kleinkram.h:#define Mod(Z, modulus) ((Z) - FLOOR((Z) / (modulus)) * (modulus))
Binary file RandomFieldsUtils/src/beskf.o matches
RandomFieldsUtils/src/scalar.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/src/scalar.cc: Copyright (C) 2001 -- 2017 Martin Schlather, 
RandomFieldsUtils/src/scalar.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURSE.  See the
RandomFieldsUtils/src/scalar.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFieldsUtils/src/scalar.cc:Makefile must be:
RandomFieldsUtils/src/scalar.cc:PKG_LIBS =  $(SHLIB_OPENMP_CXXFLAGS) $(LAPACK_LIBS) $(BLAS_LIBS) $(FLIBS)  -march=native  -mssse3 
RandomFieldsUtils/src/scalar.cc:PKG_CXXFLAGS =  $(SHLIB_OPENMP_CXXFLAGS)  -march=native -mssse3 
RandomFieldsUtils/src/scalar.cc:#define SUMUP(NR, nr) sum##NR = ADDDOUBLE(sum##NR, sum##nr)
RandomFieldsUtils/src/scalar.cc:  prod##NR = MULTDOUBLE(LOADuDOUBLE(x + i + NR * vectorlen),		\
RandomFieldsUtils/src/scalar.cc:#ifdef FMA_AVAILABLE
RandomFieldsUtils/src/scalar.cc:    lenM = len - (atonce - 1);  
RandomFieldsUtils/src/scalar.cc:   for (; i < lenM; i += atonce) { 
RandomFieldsUtils/src/scalar.cc:   SUMUP(0, 1); SUMUP(2, 3); SUMUP(4, 5); SUMUP(6, 7);
RandomFieldsUtils/src/scalar.cc:   SUMUP(0, 2); SUMUP(4, 6); SUMUP(0, 4);
RandomFieldsUtils/src/scalar.cc:  lenM = len - vectorlen + 1;
RandomFieldsUtils/src/scalar.cc:  for (; i < lenM; i += vectorlen) { ADDF(0);  }
RandomFieldsUtils/src/scalar.cc:     lenM = len - (atonce - 1);  
RandomFieldsUtils/src/scalar.cc:    for (; i < lenM; i += atonce) {
RandomFieldsUtils/src/scalar.cc:    SUMUP(0, 1); SUMUP(2, 3); SUMUP(4, 5); SUMUP(6, 7);
RandomFieldsUtils/src/scalar.cc:    SUMUP(0, 2); SUMUP(4, 6); SUMUP(0, 4);
RandomFieldsUtils/src/scalar.cc:  lenM = len - vectorlen + 1;
RandomFieldsUtils/src/scalar.cc:  for (; i < lenM; i += vectorlen) {  ADDN(0);  }
RandomFieldsUtils/src/scalar.cc:#define ADDM(NR)								\
RandomFieldsUtils/src/scalar.cc:  prod0 = MULTDOUBLE(LOADuDOUBLE(x + i + NR * vectorlen),		\
RandomFieldsUtils/src/scalar.cc:    lenM = len - (atonce - 1);  
RandomFieldsUtils/src/scalar.cc:  for (; i < lenM; i += atonce) {
RandomFieldsUtils/src/scalar.cc:    ADDM(0); ADDM(1); ADDM(2); ADDM(3); ADDM(4); ADDM(5); ADDM(6); ADDM(7); 
RandomFieldsUtils/src/scalar.cc:  lenM = len - vectorlen + 1;
RandomFieldsUtils/src/scalar.cc:  for (; i < lenM; i += vectorlen) { ADDM(0); } 
RandomFieldsUtils/src/scalar.cc://#p r a g m a   o m p declare reduction(minabs : int :  omp_out = a bs(omp_in) > omp_out ? omp_out : a bs(omp_in)   initializer (omp_priv=LARGENUM)
RandomFieldsUtils/src/scalar.cc:#if defined OpenMP4
RandomFieldsUtils/src/scalar.cc:    lenM = len - (atonce - 1);  
RandomFieldsUtils/src/scalar.cc:    for (i=0; i < lenM; i += atonce) {
RandomFieldsUtils/src/scalar.cc:      ADDM(0); ADDM(1); ADDM(2); ADDM(3); ADDM(4); ADDM(5); ADDM(6); ADDM(7); 
RandomFieldsUtils/src/scalar.cc:  lenM = len - vectorlen + 1;
RandomFieldsUtils/src/scalar.cc:  for (; i < lenM; i += vectorlen) { ADDM(0); }
RandomFieldsUtils/src/scalar.cc:     lenM = len - (atonce - 1);  
RandomFieldsUtils/src/scalar.cc:    for (; i < lenM; ) {
RandomFieldsUtils/src/scalar.cc:      int lenMM = i + vectorlen * (repet * 10 + 1);
RandomFieldsUtils/src/scalar.cc:      if (lenMM > lenM) lenMM = lenM;
RandomFieldsUtils/src/scalar.cc:      sum0 = MULTDOUBLE(LOADuDOUBLE(x + i), LOADuDOUBLE(y + i));
RandomFieldsUtils/src/scalar.cc:      for (; i < lenMM; i += atonce) {
RandomFieldsUtils/src/scalar.cc:	ADDM(0); ADDM(1); ADDM(2); ADDM(3); ADDM(4); ADDM(5); ADDM(6); ADDM(7); 
RandomFieldsUtils/src/scalar.cc: lenM = len - vectorlen + 1;
RandomFieldsUtils/src/scalar.cc: for (; i < lenM; i += vectorlen) { 
RandomFieldsUtils/src/scalar.cc:    prod0 = MULTDOUBLE(LOADuDOUBLE(x + i), LOADuDOUBLE(y + i));
RandomFieldsUtils/src/scalar.cc:  prod0 = MULTDOUBLE(LOADuDOUBLE(x + i + NR * vectorlen),		\
RandomFieldsUtils/src/scalar.cc:    lenM = len - (atonce - 1);  
RandomFieldsUtils/src/scalar.cc:    for (; i < lenM; i += atonce) {
RandomFieldsUtils/src/scalar.cc:  lenM = len - vectorlen + 1;
RandomFieldsUtils/src/scalar.cc:  for (; i < lenM; i += vectorlen) { ADDK(0); }
RandomFieldsUtils/src/scalar.cc:#ifdef FMA_AVAILABLE
RandomFieldsUtils/src/scalar.cc:  case SCALAR_NEARFMA : return avx_scalarprodDnearfma(x, y, len); 
RandomFieldsUtils/src/scalar.cc:#if defined AVX && defined OpenMP
RandomFieldsUtils/src/scalar.cc:    n = Match((char*) CHAR(STRING_ELT(mode, 0)), modi, Nmodi);
RandomFieldsUtils/src/scalar.cc:  if (isMatrix(X)) {
RandomFieldsUtils/src/scalar.cc:  if (isMatrix(Y)) {
RandomFieldsUtils/src/scalar.cc:  PROTECT(Ans = allocMatrix(REALSXP, nrow, ncol));
RandomFieldsUtils/src/AutoRandomFieldsUtils.h:#define MAXUNITS 4
RandomFieldsUtils/src/AutoRandomFieldsUtils.h:#define MAXCHAR 18 // max number of characters for (covariance) names  
RandomFieldsUtils/src/scalar.h:#define SCALAR_NEARFMA 5  // never change number, see haplogeno.R !!
RandomFieldsUtils/src/Utils.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/src/Utils.h: Copyright (C) 2018 -- 2018 Martin Schlather
RandomFieldsUtils/src/Utils.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/src/Utils.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/src/own.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/src/own.cc: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFieldsUtils/src/own.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/src/own.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/src/own.cc:char ERRMSG[LENERRMSG], MSG[LENERRMSG], MSG2[LENERRMSG];
RandomFieldsUtils/src/own.cc:  ReturnAttachMessage(RandomFieldsUtils, true);  
RandomFieldsUtils/src/own.cc:    y = (double *) MALLOC(sizeof(double) * len);
RandomFieldsUtils/src/own.cc:    y = (int *) MALLOC(sizeof(int) * len);    
Binary file RandomFieldsUtils/src/linear.o matches
RandomFieldsUtils/src/options.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/src/options.cc: Copyright (C) 2016 -- 2017  Martin Schlather
RandomFieldsUtils/src/options.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/src/options.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/src/options.cc:// IMPORTANT: all names of general must have at least 3 letters !!!
RandomFieldsUtils/src/options.cc:#if defined (__unix__) || (defined (__APPLE__) && defined (__MACH__))
RandomFieldsUtils/src/options.cc:int numCPU = MAXINT;
RandomFieldsUtils/src/options.cc:void setparameterUtils(int i, int j, SEXP el, char name[LEN_OPTIONNAME], 
RandomFieldsUtils/src/options.cc:	PRINTF("The system does not allow for OpenMP: the value 1 is kept for 'cores'.");
RandomFieldsUtils/src/options.cc:	if (v > -3) gp->warn_unknown_option = MIN(v, 3);
RandomFieldsUtils/src/options.cc:	  gp->warn_unknown_option = MIN(v, 3);
RandomFieldsUtils/src/options.cc:    case 1: so->spam_tol = POS0NUM; break;      
RandomFieldsUtils/src/options.cc:    case SOLVE_SVD_TOL: so->svd_tol = POS0NUM; break;        
RandomFieldsUtils/src/options.cc:    case 4: so->eigen2zero = POS0NUM; break;        
RandomFieldsUtils/src/options.cc:      GetName(el, name, InversionNames, nr_user_InversionMethods,
RandomFieldsUtils/src/options.cc:		    (int) NoInversionMethod, (int) NoFurtherInversionMethod, 
RandomFieldsUtils/src/options.cc:		    (int *)so->Methods, SOLVE_METHODS);
RandomFieldsUtils/src/options.cc:	  so->pivot_idx = (int*) MALLOC(len * sizeof(int));
RandomFieldsUtils/src/options.cc:    case 14: so->pivot_relerror = POS0NUM; break;    
RandomFieldsUtils/src/options.cc:    case 15: so->max_deviation = POSNUM; break;    
RandomFieldsUtils/src/options.cc:    case 16: so->max_reldeviation = POS0NUM; break;    
RandomFieldsUtils/src/options.cc:    case 18: so->actual_size = POS0NUM; break;    
RandomFieldsUtils/src/options.cc:		   String((int*) p->Methods, InversionNames, SOLVE_METHODS,
RandomFieldsUtils/src/options.cc:			  (int) NoFurtherInversionMethod));	
RandomFieldsUtils/src/options.cc:  MEMCOPY(S, &GLOBAL, sizeof(utilsparam));
RandomFieldsUtils/src/options.cc:  strcopyN(errorstring, ERRORSTRING, MAXERRORSTRING);
RandomFieldsUtils/src/linear.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/src/linear.cc: Copyright (C) 2001 -- 2017 Martin Schlather, 
RandomFieldsUtils/src/linear.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURSE.  See the
RandomFieldsUtils/src/linear.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFieldsUtils/src/linear.cc:Makefile must be:
RandomFieldsUtils/src/linear.cc:PKG_LIBS =  $(SHLIB_OPENMP_CXXFLAGS) $(LAPACK_LIBS) $(BLAS_LIBS) $(FLIBS)  -march=native  -mssse3 
RandomFieldsUtils/src/linear.cc:PKG_CXXFLAGS =  $(SHLIB_OPENMP_CXXFLAGS)  -march=native -mssse3 
RandomFieldsUtils/src/linear.cc:#define SUMUP(NR, nr) sum##NR = _mm256_add_pd(sum##NR, sum##nr)
RandomFieldsUtils/src/linear.cc:     lenM = len - (atonce - 1);  
RandomFieldsUtils/src/linear.cc:    for (; i < lenM; i += atonce) {
RandomFieldsUtils/src/linear.cc:    SUMUP(0, 1); SUMUP(2, 3); SUMUP(4, 5); SUMUP(6, 7);
RandomFieldsUtils/src/linear.cc:    SUMUP(0, 2); SUMUP(4, 6); SUMUP(0, 4);
RandomFieldsUtils/src/linear.cc:  lenM = len - vectorlen + 1;
RandomFieldsUtils/src/linear.cc:  for (; i < lenM; i += vectorlen) { 
RandomFieldsUtils/src/linear.cc:#define MUL(NR)								\
RandomFieldsUtils/src/linear.cc:    lenM = len - (atonce - 1);  
RandomFieldsUtils/src/linear.cc:  for (; i < lenM; i += atonce) {
RandomFieldsUtils/src/linear.cc:    MUL(0); MUL(1); MUL(2); MUL(3); MUL(4); MUL(5); MUL(6); MUL(7);
RandomFieldsUtils/src/linear.cc:  lenM = len - vectorlen + 1;
RandomFieldsUtils/src/linear.cc:  for (; i < lenM; i += vectorlen) {
RandomFieldsUtils/src/linear.cc:    MUL(0);
RandomFieldsUtils/src/linear.cc:    lenM = len - (atonce - 1);  
RandomFieldsUtils/src/linear.cc:  for (i=0; i < lenM; i += atonce) {
RandomFieldsUtils/src/linear.cc:  lenM = len - vectorlen + 1;
RandomFieldsUtils/src/linear.cc:  for (; i < lenM; i += vectorlen) { 
RandomFieldsUtils/src/linear.cc:     lenM = len - (atonce - 1);  
RandomFieldsUtils/src/linear.cc:    for (; i < lenM; ) {
RandomFieldsUtils/src/linear.cc:      int lenMM = i + vectorlen * (repet * 10 + 1);
RandomFieldsUtils/src/linear.cc:      if (lenMM > lenM) lenMM = lenM;
RandomFieldsUtils/src/linear.cc:      for (; i < lenMM; i += atonce) {
RandomFieldsUtils/src/linear.cc: lenM = len - vectorlen + 1;
RandomFieldsUtils/src/linear.cc: for (; i < lenM; i += vectorlen) { 
RandomFieldsUtils/src/linear.cc:     lenM = len - (atonce - 1);  
RandomFieldsUtils/src/linear.cc:  for (; i < lenM; i += atonce) {
RandomFieldsUtils/src/linear.cc: lenM = len - vectorlen + 1;
RandomFieldsUtils/src/linear.cc: for (; i < lenM; i += vectorlen) { 
RandomFieldsUtils/src/linear.cc:#ifdef FMA_AVAILABLE
RandomFieldsUtils/src/maths.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/src/maths.cc: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFieldsUtils/src/maths.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/src/maths.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/src/maths.cc://void I0ML0(double *x, int *n) {
RandomFieldsUtils/src/maths.cc:  /* see J. MacLeod, Chebyshev expansions for modified {S}truve and 
RandomFieldsUtils/src/maths.cc:     related functions, Mathematics of Computation, 60, 735-747, 1993 */
RandomFieldsUtils/src/maths.cc:SEXP I0ML0(SEXP X) {
RandomFieldsUtils/src/maths.cc:/* Whittle-Matern or Whittle or Besset ---- rescaled form of Whittle-Matern,
RandomFieldsUtils/src/maths.cc:#define LOW_MATERN 1e-20
RandomFieldsUtils/src/maths.cc:double logWM(double x, double nu1, double nu2, double factor) {
RandomFieldsUtils/src/maths.cc:    nuThres = nu < MATERN_NU_THRES ? nu : MATERN_NU_THRES,
RandomFieldsUtils/src/maths.cc:  bool simple = nu1 == nu2 || nu > MATERN_NU_THRES;
RandomFieldsUtils/src/maths.cc:  double bk[MATERN_NU_THRES + 1L];
RandomFieldsUtils/src/maths.cc:  if (x > LOW_MATERN && nu < RF_INF) {
RandomFieldsUtils/src/maths.cc:  if (nu > MATERN_NU_THRES) { // factor!=0.0 && 
RandomFieldsUtils/src/maths.cc:      g = MATERN_NU_THRES / nu;
RandomFieldsUtils/src/maths.cc:double WM(double x, double nu, double factor) {
RandomFieldsUtils/src/maths.cc:  return EXP(logWM(x, nu, nu, factor));
RandomFieldsUtils/src/maths.cc:double DWM(double x, double nu, double factor) { 
RandomFieldsUtils/src/maths.cc:    nuThres = nu < MATERN_NU_THRES ? nu : MATERN_NU_THRES,
RandomFieldsUtils/src/maths.cc:  double bk[MATERN_NU_THRES + 1L];
RandomFieldsUtils/src/maths.cc:  if (x > LOW_MATERN && nu < RF_INF) {
RandomFieldsUtils/src/maths.cc:  if (nu > MATERN_NU_THRES) {
RandomFieldsUtils/src/maths.cc:      g = MATERN_NU_THRES / nu;
RandomFieldsUtils/src/maths.cc:double DDWM(double x, double nu, double factor) { 
RandomFieldsUtils/src/maths.cc:    nuThres = nu < MATERN_NU_THRES ? nu : MATERN_NU_THRES,
RandomFieldsUtils/src/maths.cc:		   bk[MATERN_NU_THRES + 1L];
RandomFieldsUtils/src/maths.cc:  if (x > LOW_MATERN && nu < RF_INF) {
RandomFieldsUtils/src/maths.cc:  if (nu > MATERN_NU_THRES) {
RandomFieldsUtils/src/maths.cc:      g = MATERN_NU_THRES / nu;
RandomFieldsUtils/src/maths.cc:double D3WM(double x, double nu, double factor) { 
RandomFieldsUtils/src/maths.cc:    nuThres = nu < MATERN_NU_THRES ? nu : MATERN_NU_THRES,
RandomFieldsUtils/src/maths.cc:   double bk[MATERN_NU_THRES + 1L];
RandomFieldsUtils/src/maths.cc:  if (x > LOW_MATERN && nu < RF_INF) {
RandomFieldsUtils/src/maths.cc:  if (nu > MATERN_NU_THRES) {
RandomFieldsUtils/src/maths.cc:      g = MATERN_NU_THRES / nu;
RandomFieldsUtils/src/maths.cc:double D4WM(double x,  double nu, double factor) { 
RandomFieldsUtils/src/maths.cc:    nuThres = nu < MATERN_NU_THRES ? nu : MATERN_NU_THRES,
RandomFieldsUtils/src/maths.cc:  double bk[MATERN_NU_THRES + 1L];
RandomFieldsUtils/src/maths.cc:  if (x > LOW_MATERN && nu < RF_INF) {
RandomFieldsUtils/src/maths.cc:  if (nu > MATERN_NU_THRES) {
RandomFieldsUtils/src/maths.cc:      g = MATERN_NU_THRES / nu;
RandomFieldsUtils/src/maths.cc:#define CALCULATE(PRIMFCTN)			\
RandomFieldsUtils/src/maths.cc:  PRIMFCTN F = fctns[deriv];						\
RandomFieldsUtils/src/maths.cc:SEXP WMr(SEXP X, SEXP Nu, SEXP Derivative, SEXP Factor) {  
RandomFieldsUtils/src/maths.cc:  static primfct3 fctns[] = {WM, DWM, DDWM, D3WM, D4WM };
RandomFieldsUtils/src/maths.cc:SEXP logWMr(SEXP X, SEXP Nu1, SEXP Nu2, SEXP Factor) {  
RandomFieldsUtils/src/maths.cc:  ans[0] = logWM(FABS(x[0]), nu1, nu2, factor);
Binary file RandomFieldsUtils/src/win_linux_aux.o matches
RandomFieldsUtils/src/solve_gpu.cu:#include <cusolverMg.h>
RandomFieldsUtils/src/solve_gpu.cu:    cublasFillMode_t uplo = CUBLAS_FILL_MODE_LOWER;
RandomFieldsUtils/src/solve_gpu.cu:    cudaMalloc(&info, sizeof(int));
RandomFieldsUtils/src/solve_gpu.cu:    cudaMalloc(&buffer, sizeof(double) * bufferSize);
RandomFieldsUtils/src/solve_gpu.cu:    cudaMalloc((void**)&d_matrix, sizeof(double) * size * size);
RandomFieldsUtils/src/solve_gpu.cu:    cudaMalloc((void **)&d_B, sizeof(double) * size * rhs_cols);
RandomFieldsUtils/src/solve_gpu.cu:    cudaMemset(info, 0, sizeof(int));
RandomFieldsUtils/src/solve_gpu.cu:    cudaMemcpy(d_matrix, matrix, sizeof(double) * size * size, cudaMemcpyHostToDevice);
RandomFieldsUtils/src/solve_gpu.cu:    cudaMemcpy(d_B, B, sizeof(double) * size * rhs_cols, cudaMemcpyHostToDevice);
RandomFieldsUtils/src/solve_gpu.cu:    cudaMemcpy(&h_info, info, sizeof(int), cudaMemcpyDeviceToHost);
RandomFieldsUtils/src/solve_gpu.cu:        cudaMalloc((void**)&d_logdet, sizeof(double));
RandomFieldsUtils/src/solve_gpu.cu:        cudaMalloc((void**)&d_size, sizeof(Uint));
RandomFieldsUtils/src/solve_gpu.cu:        cudaMemcpy(d_size, &size, sizeof(Uint), cudaMemcpyHostToDevice);
RandomFieldsUtils/src/solve_gpu.cu:        cudaMemcpy(LogDet, d_logdet, sizeof(double), cudaMemcpyDeviceToHost);
RandomFieldsUtils/src/solve_gpu.cu:    cudaMemcpy(RESULT, d_B, sizeof(double) * size * rhs_cols, cudaMemcpyDeviceToHost);
RandomFieldsUtils/src/solve_gpu.cu:    if (err != cudaSuccess) PRINTF("Memcpy: %s\n", cudaGetErrorString(err));
RandomFieldsUtils/src/solve_gpu.cu:        on an MULTIPLE GPUs and writes the solution to the original memory of b
RandomFieldsUtils/src/solve_gpu.cu:    cusolverMgHandle_t handle = NULL;
RandomFieldsUtils/src/solve_gpu.cu:    const int max_devices = 8; // Maximum number of devices to be used
RandomFieldsUtils/src/solve_gpu.cu:    cudaLibMgMatrixDesc_t descrA, descrB;
RandomFieldsUtils/src/solve_gpu.cu:    cudaLibMgGrid_t grid;
RandomFieldsUtils/src/solve_gpu.cu:    cusolverStatus_t status = cusolverMgCreate(&handle);
RandomFieldsUtils/src/solve_gpu.cu:    status = cusolverMgDeviceSelect(
RandomFieldsUtils/src/solve_gpu.cu:    status = cusolverMgCreateDeviceGrid(&grid, 1, nbGpus, &deviceList[0], CUDALIBMG_GRID_MAPPING_COL_MAJOR );
RandomFieldsUtils/src/solve_gpu.cu:    status = cusolverMgCreateMatrixDesc(
RandomFieldsUtils/src/solve_gpu.cu:    if(CUSOLVER_STATUS_SUCCESS != status)PRINTF("Matrix descriptions couldn't be created.");
RandomFieldsUtils/src/solve_gpu.cu:    status = cusolverMgCreateMatrixDesc(
RandomFieldsUtils/src/solve_gpu.cu:    if(CUSOLVER_STATUS_SUCCESS != status)PRINTF("Matrix description B couldn't be created.");
RandomFieldsUtils/src/solve_gpu.cu:        cudaStat = cudaMalloc( &(array_d_A[p]), sizeof(double)*lda*T_A*A_blks_per_device );
RandomFieldsUtils/src/solve_gpu.cu:        if(cudaSuccess != cudaStat)PRINTF("Memory for matrix A couldn't be allocated on device %d.",deviceList[p]);
RandomFieldsUtils/src/solve_gpu.cu:        cudaStat = cudaMalloc( &(array_d_B[p]), sizeof(double)*ldb*T_B*B_blks_per_device );
RandomFieldsUtils/src/solve_gpu.cu:        if(cudaSuccess != cudaStat)PRINTF("Memory for matrix B couldn't be allocated on device %d.",deviceList[p]);
RandomFieldsUtils/src/solve_gpu.cu:        const int width = MIN( T_A, (N - T_A*k) );
RandomFieldsUtils/src/solve_gpu.cu:        cudaStat = cudaMemcpy(d_Ak, h_Ak, sizeof(double)*lda*width, cudaMemcpyHostToDevice);
RandomFieldsUtils/src/solve_gpu.cu:        if(cudaSuccess != cudaStat)PRINTF("Matrix A couldn't be copied at block (%d, %d).", p,ibx);
RandomFieldsUtils/src/solve_gpu.cu:        cudaStat = cudaMemcpy(d_Bk, h_Bk, sizeof(double)*T_B, cudaMemcpyHostToDevice);
RandomFieldsUtils/src/solve_gpu.cu:        if(cudaSuccess != cudaStat)PRINTF("Matrix B couldn't be copied at block (%d, %d).", p,ibx);
RandomFieldsUtils/src/solve_gpu.cu:    status = cusolverMgPotrf_bufferSize(
RandomFieldsUtils/src/solve_gpu.cu:		CUBLAS_FILL_MODE_LOWER,
RandomFieldsUtils/src/solve_gpu.cu:    status = cusolverMgPotrs_bufferSize(
RandomFieldsUtils/src/solve_gpu.cu:		CUBLAS_FILL_MODE_LOWER,
RandomFieldsUtils/src/solve_gpu.cu:        cudaStat = cudaMalloc(&d_workspace, sizeof(double)*lwork);
RandomFieldsUtils/src/solve_gpu.cu:    status = cusolverMgPotrf(
RandomFieldsUtils/src/solve_gpu.cu:		CUBLAS_FILL_MODE_LOWER,
RandomFieldsUtils/src/solve_gpu.cu:    status = cusolverMgPotrs(
RandomFieldsUtils/src/solve_gpu.cu:		CUBLAS_FILL_MODE_LOWER,
RandomFieldsUtils/src/solve_gpu.cu:        cudaStat = cudaMemcpy(h_Bk, d_Bk, sizeof(double)*T_B, cudaMemcpyDeviceToHost);
RandomFieldsUtils/src/solve_gpu.cu:        if(cudaSuccess != cudaStat)PRINTF("Matrix B couldn't be copied at block (%d, %d).", p,ibx);
RandomFieldsUtils/src/solve_gpu.cu:void gpu_relmat_cublas(Uint* M, double* A, Uint snps, Uint individuals){
RandomFieldsUtils/src/solve_gpu.cu:        Calculates the crossproduct of M with cublas and stores the result in A.
RandomFieldsUtils/src/solve_gpu.cu:            M: non-encoded matrix of dimension snps x indiv (k x n) storing genomic information
RandomFieldsUtils/src/solve_gpu.cu:            A: matrix containing the type-casted result of M^T * M
RandomFieldsUtils/src/solve_gpu.cu:        Note: cublas is fortran based and therefore assumes M is column-major. Therefore to calculate
RandomFieldsUtils/src/solve_gpu.cu:            A we instruct cublasgemmex to calculate M * M^T and adjust its parameters.
RandomFieldsUtils/src/solve_gpu.cu:            Furthermore, gemmex requires the matrix M to have a row number that is a multiple of four
RandomFieldsUtils/src/solve_gpu.cu:        Uint k_pad_diff = (PADDIM - k % PADDIM) % PADDIM;
RandomFieldsUtils/src/solve_gpu.cu:        int8_t *d_M, *h_M;
RandomFieldsUtils/src/solve_gpu.cu:        cudaMalloc(&d_M, sizeof(int8_t) * dim);
RandomFieldsUtils/src/solve_gpu.cu:        cudaMalloc(&d_C, sizeof(int32_t) * n * m );
RandomFieldsUtils/src/solve_gpu.cu:        cudaMallocHost((void **)&h_M, sizeof(int8_t) * dim);
RandomFieldsUtils/src/solve_gpu.cu:        cudaMallocHost((void **)&h_C, sizeof(int32_t) * n * m);
RandomFieldsUtils/src/solve_gpu.cu:    //Type-cast matrix M to int8 and store the result in page-locked memory
RandomFieldsUtils/src/solve_gpu.cu:            h_M[j + i * k_pad] = (int8_t) (j< k ?  M[j + i * k] : 0 );
RandomFieldsUtils/src/solve_gpu.cu:    cudaMemcpy(d_M, h_M, sizeof(int8_t) * dim, cudaMemcpyHostToDevice);  
RandomFieldsUtils/src/solve_gpu.cu:            d_M,
RandomFieldsUtils/src/solve_gpu.cu:            d_M,
RandomFieldsUtils/src/solve_gpu.cu:            CUDA_R_32I, //CUBLAS_COMPUTE_32I,
RandomFieldsUtils/src/solve_gpu.cu:            CUBLAS_GEMM_DEFAULT
RandomFieldsUtils/src/solve_gpu.cu:        cudaMemcpy(h_C, d_C, sizeof(int32_t) * n * m, cudaMemcpyDeviceToHost);
RandomFieldsUtils/src/solve_gpu.cu:        cudaFree(d_M);
RandomFieldsUtils/src/solve_gpu.cu:        cudaFreeHost(h_M);
RandomFieldsUtils/src/zzz_calls.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/src/zzz_calls.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFieldsUtils/src/zzz_calls.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/src/zzz_calls.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/src/zzz_calls.h:    if (fun == NULL) fun = (V (*) ()) R_GetCCallable(MY_PACKAGE, #N);	\
RandomFieldsUtils/src/zzz_calls.h:  if (fun == NULL) fun = (N##_type) R_GetCCallable(MY_PACKAGE, #N);	\
RandomFieldsUtils/src/zzz_calls.h:  if (fun == NULL) fun = (N##_type) R_GetCCallable(MY_PACKAGE, #N);	\
RandomFieldsUtils/src/zzz_calls.h:  if (fun == NULL) fun = (N##_type) R_GetCCallable(MY_PACKAGE, #N);	\
RandomFieldsUtils/src/zzz_calls.h:  if (fun == NULL) fun = (N##_type) R_GetCCallable(MY_PACKAGE, #N);	\
RandomFieldsUtils/src/zzz_calls.h:  if (fun == NULL) fun = (N##_type) R_GetCCallable(MY_PACKAGE, #N);	\
RandomFieldsUtils/src/zzz_calls.h:      if (fun == NULL) fun = (N##_type) R_GetCCallable(MY_PACKAGE, #N);	\
RandomFieldsUtils/src/zzz_calls.h:      if (fun == NULL) fun = (N##_type) R_GetCCallable(MY_PACKAGE, #N);	\
RandomFieldsUtils/src/zzz_calls.h:  if (fun == NULL) fun = (N##_type) R_GetCCallable(MY_PACKAGE, #N);	\
RandomFieldsUtils/src/zzz_calls.h:  if (fun == NULL) fun = (N##_type) R_GetCCallable(MY_PACKAGE, #N);	\
RandomFieldsUtils/src/zzz_calls.h:  if (fun == NULL) fun = (N##_type) R_GetCCallable(MY_PACKAGE, #N);	\
Binary file RandomFieldsUtils/src/zzz.o matches
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:#define MY_PACKAGE "RandomFieldsUtils"
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:#define MY_ACRONYM XX
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:!!!!! auch kein mit MALLOC kreiertes Objekt  !!!!
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:  DECLARE7(int, solvePosDef, double*, M, int, size, bool, posdef, 
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:  DECLARE8(int, solvePosDefSp, double *, M, int, size, bool, posdef,
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:  //  DECLARE8(int, solvePosDefResult, double*, M, int, size, bool, posdef, 
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:  DECLARE4(int, sqrtPosDefFree, double *, M, int, size, solve_storage *, pt,
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:  DECLARE2(int, invertMatrix, double *, M, int, size)
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:  DECLARE3(double, WM, double, x, double, nu, double, factor)
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:  DECLARE3(double, DWM, double, x, double, nu, double, factor)
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:  DECLARE3(double, DDWM, double, x, double, nu, double, factor)
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:  DECLARE3(double, D3WM, double, x, double, nu, double, factor)
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:  DECLARE3(double, D4WM, double, x, double, nu, double, factor)
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:  DECLARE4(double, logWM, double, x, double, nu1, double, nu2, double, factor)
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:  DECLARE2(double, detPosDef, double *, M, int, size) // destroys M!
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:  DECLARE8(int, XCinvXdet,double*, M, int, size, double *,X, int, X_cols,
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:  DECLARE10(int, XCinvYdet,double*, M, int, size, bool, posdef,
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:  //  DECLARE5(double, XCinvXlogdet, double *, M, int, size, double *, X,
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:  DECLARE2(void, chol2inv, double *, MPT, int, size)
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:  DECLARE2(int, chol, double *, MPT, int, size)
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:  DECLARE1(void, sleepMicro, int *, i)
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:  // DECLARE7(int, cholGPU, bool, copy, double*, M, int, size, double*, rhs, int, rhs_cols, double *, LogDet, double *, RESULT); // entkommentieren
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:#define MISS_AVX2 (!HAS_AVX2 && NEED_AVX2)
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:#define MISS_AVX (!HAS_AVX && NEED_AVX)
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:#define MISS_ANY_SIMD (MISS_AVX2 || MISS_AVX || !HAS_SSE2)
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:#define MISS_SSSE3 (!HAS_SSSE3 && NEED_SSSE3)
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:#define MISS_SSE2 (!HAS_SSE2 && NEED_SSE2)
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:#define MISS_SSE (!HAS_SSE && NEED_SSE)
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:#define AttachMessageN 1000
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:#define HAS_ALL_RELEVANT (HAS_PARALLEL && !MISS_AVX2 && !MISS_AVX && !MISS_SSSE3 &&  !MISS_SSE2 && !MISS_SSE)
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:    HAS_PARALLEL ? "OMP" : "",						\
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:    !HAS_PARALLEL ? "OMP, " : "",					\
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:    MISS_AVX2 ? "AVX2" : "",				\
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:    MISS_AVX ? ", AVX" : "",						\
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:    MISS_SSSE3 ? ", SSSE3" : "",				\
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:    MISS_SSE2 ? ", SSE2" : "",				\
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:    MISS_SSE ? ", SSE" : ""
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:#define AttachMessageX(PKG, HINT, AND, OMP)				\
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:    HINT && MISS_ANY_SIMD ? "\nBy default '"#PKG"' is compiled with flag '-mavx' under your OS.\nIf you are sure that AVX2 is available, consider adding the flag '-march=native'\nto 'PKG_CXXFLAGS' in the file src/Makefile.win and then recompile\n'"#PKG"' "#AND"." : "", \
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:    HINT && MISS_AVX2 ?							\
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:    HINT && (!HAS_PARALLEL) ? "\nFor OMP alone, try adding the flags -Xpreprocessor -fopenmp -pthread to PKG_LIBS and PKG_CXXFLAGS" : ""
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:#define AttachMessageX(PKG, HINT, AND, OMP) 				\
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:    HINT && MISS_ANY_SIMD ? "\nWithout appropriate SIMD instruction set, the calculations might be slow.\nConsider recompiling '"#PKG"' "#AND" with flags e.g.,\n\n   install.packages(\""#PKG"\", configure.args=\"CXX_FLAGS='-march=native "#OMP"'\")" : "", \
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:    HINT && MISS_AVX2 ?					\
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:    "\n\n   install.packages(\""#PKG"\", configure.args=\"CXX_FLAGS='-mavx2 "#OMP"'\")" \
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:    HINT && MISS_AVX ?					\
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:    "\n\n   install.packages(\""#PKG"\", configure.args=\"CXX_FLAGS='-mavx "#OMP"'\")"\
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:    HINT && MISS_ANY_SIMD ? "\n\nAlternatively consider installing '"#PKG"'\nfrom https://github.com/schlather/"#PKG", i.e.,\n   install.packages(\"devtools\")\n   library(devtools)\n   devtools::install_github(\"schlather/"#PKG"/pkg\")" : "",\
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:    HINT && !HAS_PARALLEL ? "\n\nFor OMP alone try\n   install.packages(\""#PKG"\", configure.args=\"CXX_FLAGS='"#OMP"'\")" : ""
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:#    define AttachMessage(PKG, HINT) AttachMessageX(PKG, HINT, , )
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:#    define AttachMessage(PKG, HINT)  \
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:     AttachMessageX(PKG, HINT, ,\
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:#  define AttachMessage(PKG, HINT)				\
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:     AttachMessageX(PKG, HINT, and 'RandomFieldsUtils',		\
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:#  define AttachMessage(PKG, HINT)			\
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:     AttachMessageX(PKG, HINT, and 'RandomFieldsUtils', )
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:#define ReturnAttachMessage(PKG,HINT) 	\
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:  char simd_msg[AttachMessageN];			\
RandomFieldsUtils/src/zzz_RandomFieldsUtils.h:  SPRINTF(simd_msg, AttachMessage(PKG,HINT)); \
RandomFieldsUtils/src/zzz.c: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/src/zzz.c: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFieldsUtils/src/zzz.c:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/src/zzz.c:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/src/zzz.c:static const R_CMethodDef cMethods[]  = {
RandomFieldsUtils/src/zzz.c:  CDEF(sleepMilli,  1, int_arg),
RandomFieldsUtils/src/zzz.c:  CDEF(sleepMicro, 1, int_arg),
RandomFieldsUtils/src/zzz.c:static R_CallMethodDef callMethods[]  = {
RandomFieldsUtils/src/zzz.c:  CALLDEF_DO(I0ML0, 1),
RandomFieldsUtils/src/zzz.c:  CALLDEF_DO(WMr, 4),
RandomFieldsUtils/src/zzz.c:  CALLDEF_DO(logWMr, 4),
RandomFieldsUtils/src/zzz.c:  CALLDEF_DO(colMaxs, 1),
RandomFieldsUtils/src/zzz.c:  CALLDEF_DO(rowMeansX, 2),
RandomFieldsUtils/src/zzz.c:static const R_ExternalMethodDef extMethods[] = {
RandomFieldsUtils/src/zzz.c:  CALLABLE(invertMatrix);
RandomFieldsUtils/src/zzz.c:  CALLABLE(WM);
RandomFieldsUtils/src/zzz.c:  CALLABLE(DWM);
RandomFieldsUtils/src/zzz.c:  CALLABLE(DDWM);
RandomFieldsUtils/src/zzz.c:  CALLABLE(D3WM);
RandomFieldsUtils/src/zzz.c:  CALLABLE(D4WM);
RandomFieldsUtils/src/zzz.c:  CALLABLE(logWM);
RandomFieldsUtils/src/zzz.c:  CALLABLE(sleepMicro);
RandomFieldsUtils/src/zzz.c:  R_registerRoutines(dll, cMethods, callMethods, NULL, // .Fortran
RandomFieldsUtils/src/zzz.c:		     extMethods);
RandomFieldsUtils/src/zzz.c:#ifdef SCHLATHERS_MACHINE  
RandomFieldsUtils/src/spamown.f:c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/src/spamown.f:c Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/src/spamown.f:c Multiplies a sparse matrix by a full matrix using consecutive dot 
RandomFieldsUtils/src/spamown.f:c Matrix A is stored in compressed sparse row storage.
RandomFieldsUtils/src/spamown.f:c a, ja, ia   = Matrix A in compressed sparse row format. Sorted.
RandomFieldsUtils/src/spamown.f:c a, ja, ia   = Matrix A in compressed sparse row format. Sorted.
RandomFieldsUtils/src/spamown.f:c a, ia   = Matrix A in compressed sparse row format.
RandomFieldsUtils/src/spamown.f:c b,jb,ib = Matrices A and B in compressed sparse row format with column
RandomFieldsUtils/src/spamown.f:c- Modified by P. T. Ng from sparsekit
RandomFieldsUtils/src/spamown.f:c Modified from amask by Pin T. Ng on 2/27/03 to perform 
RandomFieldsUtils/src/spamown.f:c ia   = Matrix A in compressed sparse row format with entries sorted
RandomFieldsUtils/src/spamown.f:c ib	=  Matrix B in compressed sparse row format with entries sorted
RandomFieldsUtils/src/spamown.f:c Modified from aplsb by Pin Ng on 2/27/03
RandomFieldsUtils/src/spamown.f:c ia   = Matrix A in compressed sparse row format.
RandomFieldsUtils/src/spamown.f:c ib	=  Matrix B in compressed sparse row format.
RandomFieldsUtils/src/spamown.f:c Modified from aplsb by Pin Ng on 2/27/03
RandomFieldsUtils/src/spamown.f:c ia   = Matrix A in compressed sparse row format.
RandomFieldsUtils/src/spamown.f:c ib	=  Matrix B in compressed sparse row format.
RandomFieldsUtils/src/spamown.f:      IMPLICIT NONE
RandomFieldsUtils/src/spamown.f:c      T R I A N G U L A R    S Y S T E M    S O L U T I O N S         c
RandomFieldsUtils/src/AutoRandomFieldsUtilsLocal.h:#define PIVOTSPARSE_MMD 1 // for spam
RandomFieldsUtils/src/AutoRandomFieldsUtilsLocal.h:#define PIVOTSPARSE_RCM 2 // for spam
Binary file RandomFieldsUtils/src/RFoptions.o matches
RandomFieldsUtils/src/General_utils.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/src/General_utils.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFieldsUtils/src/General_utils.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/src/General_utils.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/src/General_utils.h:// not SCHLATHERS_MACHINE
RandomFieldsUtils/src/General_utils.h:#ifndef SCHLATHERS_MACHINE
RandomFieldsUtils/src/General_utils.h://#define MEMCOPY(A,B,C) {MEMCPY(A,B,C); printf("memcpy %.50s %d\n", __FILE__, __LINE__);}
RandomFieldsUtils/src/General_utils.h:#define MEMCOPY(A,B,C) MEMCOPYX(A,B,C)
RandomFieldsUtils/src/General_utils.h:#define AMALLOC(ELEMENTS, SIZE) AALLOC(SIZE, (SIZE) * (ELEMENTS))
RandomFieldsUtils/src/General_utils.h:#define MALLOC MALLOCX
RandomFieldsUtils/src/General_utils.h:#endif // not SCHLATHERS_MACHINE
RandomFieldsUtils/src/General_utils.h:// SCHLATHERS_MACHINE
RandomFieldsUtils/src/General_utils.h:#ifdef SCHLATHERS_MACHINE 
RandomFieldsUtils/src/General_utils.h:#define MAXALLOC 1000000000L
RandomFieldsUtils/src/General_utils.h:#define MEMCOPY(A,B,C) __extension__ ({ assert((A)!=NULL && (B)!=NULL && (C)>0 && (C)<=MAXALLOC); MEMCOPYX(A,B,C); })
RandomFieldsUtils/src/General_utils.h://#define MEMCOPY(A,B,C) memory_copy(A, B, C)
RandomFieldsUtils/src/General_utils.h:#define MALLOC(X) __extension__ ({assert((X)>0 && (X)<=MAXALLOC); MALLOCX(X);})
RandomFieldsUtils/src/General_utils.h:#define CALLOC(X, Y) __extension__({assert((X)>0 && (Y)>0 && ((X) * (Y))<MAXALLOC); CALLOCX(X,Y);})
RandomFieldsUtils/src/General_utils.h:#define XCALLOC(X, Y) __extension__({assert((X)>0 && (Y)>0 && ((X) * (Y))<MAXALLOC); CALLOCX(X,Y);})
RandomFieldsUtils/src/General_utils.h:#endif // SCHLATHERS_MACHINE
RandomFieldsUtils/src/General_utils.h:#ifdef RANDOMFIELDS_DEBUGGING
RandomFieldsUtils/src/General_utils.h:#undef MALLOC
RandomFieldsUtils/src/General_utils.h:#define MALLOC(X) __extension__({DOPRINTF("(MLLC %s, line %d)\n", __FILE__, __LINE__);assert((X)>0 && (X)<=3e9); MALLOCX(X);})
RandomFieldsUtils/src/General_utils.h:#define CALLOC(X, Y) __extension__({DOPRINTF("(CLLC %s, line %d)\n",__FILE__, __LINE__);assert((X)>0 && (Y)>0 && ((X) * (Y)) <MAXALLOC); CALLOCX(X,Y);})
RandomFieldsUtils/src/General_utils.h:#define XCALLOC(X, Y) __extension__({DOPRINTF("(CLLC %s, line %d)\n",__FILE__, __LINE__);assert((X)>0 && (Y)>0 && ((X) * (Y)) <MAXALLOC); CALLOCX(X,Y);})
RandomFieldsUtils/src/General_utils.h://#define MALLOC malloc
RandomFieldsUtils/src/General_utils.h:// note that DEBUGINDOERR is redefined in MachineDebugging.h
RandomFieldsUtils/src/General_utils.h:#define PL_IMPORTANT 1 
RandomFieldsUtils/src/General_utils.h:#define PL_STRUCTURE 5 // see also initNerror.ERROROUTOFMETHOD
RandomFieldsUtils/src/General_utils.h:#define MATERN_NU_THRES 100
RandomFieldsUtils/src/General_utils.h:#define LOW_MATERN 1e-20
RandomFieldsUtils/src/General_utils.h:#ifdef SCHLATHERS_MACHINE 
RandomFieldsUtils/src/Options_utils.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/src/Options_utils.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFieldsUtils/src/Options_utils.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/src/Options_utils.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/src/Options_utils.h:#ifdef SCHLATHERS_MACHINE
RandomFieldsUtils/src/Options_utils.h:#define LEN_OPTIONNAME 201
RandomFieldsUtils/src/Options_utils.h:// IMPORTANT: all names of basic must be have least 3 letters !!!
RandomFieldsUtils/src/Options_utils.h:extern const char * InversionNames[nr_InversionMethods];
RandomFieldsUtils/src/Options_utils.h:  InversionMethod Methods[SOLVE_METHODS];
RandomFieldsUtils/src/Options_utils.h:#ifdef SCHLATHERS_MACHINE
RandomFieldsUtils/src/Options_utils.h:  {NoInversionMethod,  NoFurtherInversionMethod},			\
RandomFieldsUtils/src/Options_utils.h:    {400, 10000}, 500, 4294967, PIVOTSPARSE_MMD, 16384,			\
RandomFieldsUtils/src/Basic_utils.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/src/Basic_utils.h: Copyright (C) 2015 -- 2019  Martin Schlather
RandomFieldsUtils/src/Basic_utils.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/src/Basic_utils.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/src/Basic_utils.h:#ifdef _OPENMP
RandomFieldsUtils/src/Basic_utils.h:#define MULTIMINSIZE(S) ((S) > 20)
RandomFieldsUtils/src/Basic_utils.h:// #define MULTIMINSIZE(S) false
RandomFieldsUtils/src/Basic_utils.h:// #define MULTIMINSIZE(S) true
RandomFieldsUtils/src/Basic_utils.h:  Nan=INT_MIN
RandomFieldsUtils/src/Basic_utils.h:#define T_PI M_2_PI
RandomFieldsUtils/src/Basic_utils.h:#define OBSOLETENAME "obsolete" 
RandomFieldsUtils/src/Basic_utils.h:#define MAXINT 2147483647
RandomFieldsUtils/src/Basic_utils.h:#define MININT -2147483647
RandomFieldsUtils/src/Basic_utils.h:#define MAXUNSIGNED (MAXINT * 2) + 1
RandomFieldsUtils/src/Basic_utils.h:#define INFDIM MAXINT
RandomFieldsUtils/src/Basic_utils.h:#define INFTY INFDIM
RandomFieldsUtils/src/Basic_utils.h:#define GAUSS_RANDOM(SIGMA) rnorm(0.0, SIGMA)
RandomFieldsUtils/src/Basic_utils.h:#define UNIFORM_RANDOM unif_rand()
RandomFieldsUtils/src/Basic_utils.h:#define POISSON_RANDOM(x) rpois(x)
RandomFieldsUtils/src/Basic_utils.h:#define SQRT2 M_SQRT2
RandomFieldsUtils/src/Basic_utils.h:#define SQRTPI M_SQRT_PI
RandomFieldsUtils/src/Basic_utils.h:#define INVPI M_1_PI
RandomFieldsUtils/src/Basic_utils.h:#define PIHALF M_PI_2 
RandomFieldsUtils/src/Basic_utils.h:#define LOG2 M_LN2
RandomFieldsUtils/src/Basic_utils.h:#define MIN(A,B) ((A) < (B) ? (A) : (B))
RandomFieldsUtils/src/Basic_utils.h:#define MAX(A,B) ((A) > (B) ? (A) : (B))
RandomFieldsUtils/src/Basic_utils.h:#define FMIN fmin2
RandomFieldsUtils/src/Basic_utils.h:#define FMAX fmax2
RandomFieldsUtils/src/Basic_utils.h:#define EXPM1 std::expm1
RandomFieldsUtils/src/Basic_utils.h:#define STRCMP(A, B) std::strcmp(A, B)
RandomFieldsUtils/src/Basic_utils.h:#define STRNCMP(A, B, C) std::strncmp(A, B, C)
RandomFieldsUtils/src/Basic_utils.h:#define MEMCOPYX std::memcpy
RandomFieldsUtils/src/Basic_utils.h:#define MEMMOVE std::memmove
RandomFieldsUtils/src/Basic_utils.h:#define MEMSET std::memset  
RandomFieldsUtils/src/Basic_utils.h:#define MALLOCX std::malloc
RandomFieldsUtils/src/Basic_utils.h:#ifdef SCHLATHERS_MACHINE
RandomFieldsUtils/src/Basic_utils.h:#define HELPINFO(M) if (GLOBAL.basic.helpinfo) { PRINTF("%s\n(Note that you can unable this information by 'RFoptions(helpinfo=FALSE)'.)\n", M); } //
RandomFieldsUtils/src/Basic_utils.h:#define UTILSINFO(M) if (GLOBAL_UTILS->basic.helpinfo) { PRINTF("%s\n(Note that you can unable this information by 'RFoptions(helpinfo=FALSE)'.)\n", M); } //
Binary file RandomFieldsUtils/src/kleinkram.o matches
RandomFieldsUtils/src/beskf.cc:/*Modified Bessel Function*/
RandomFieldsUtils/src/beskf.cc:#include <float.h> /*DBL_MIN*/
RandomFieldsUtils/src/beskf.cc:#define M_SQRT_2dPI	0.797884560802865355879892119869 /*From Rmath.h*/
RandomFieldsUtils/src/beskf.cc:		x[i] = (double)rand()/RAND_MAX*5.0;
RandomFieldsUtils/src/solve.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/src/solve.cc: Copyright (C) 2015 -- 2017 Martin Schlather, Reinhard Furrer, Martin Kroll
RandomFieldsUtils/src/solve.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/src/solve.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/src/solve.cc:const char * InversionNames[nr_InversionMethods] = {
RandomFieldsUtils/src/solve.cc:#define CMALLOC(WHICH, N, TYPE)	{					\
RandomFieldsUtils/src/solve.cc:	return ERRORMEMORYALLOCATION;					\
RandomFieldsUtils/src/solve.cc:double Determinant(double *M, int size, bool log) {
RandomFieldsUtils/src/solve.cc:    for (int i=0; i<sizeSq; i+=sizeP1) tmp += LOG(M[i]);
RandomFieldsUtils/src/solve.cc:  for (int i=0; i<sizeSq; i+=sizeP1) tmp *= M[i];
RandomFieldsUtils/src/solve.cc:  MEMSET(x, 0, sizeof(solve_storage));  
RandomFieldsUtils/src/solve.cc:  x->method = NoInversionMethod;
RandomFieldsUtils/src/solve.cc:  for (int i=0; i<SOLVE_METHODS; x->newMethods[i++] = NoInversionMethod);
RandomFieldsUtils/src/solve.cc:double static inline det3(double *M, int size) {
RandomFieldsUtils/src/solve.cc:  switch(size){ // Abfrage nach Groesse der Matrix M + Berechnung der Determinante per Hand
RandomFieldsUtils/src/solve.cc:  case 1: det = M[0];
RandomFieldsUtils/src/solve.cc:  case 2: det = M[0] * M[3] - M[1] * M[2];
RandomFieldsUtils/src/solve.cc:      M[0] * (M[4] * M[8] - M[5] * M[7]) 
RandomFieldsUtils/src/solve.cc:      - M[1] * (M[3] * M[8] - M[5] * M[6]) 
RandomFieldsUtils/src/solve.cc:      + M[2] * (M[3] * M[7] - M[4] * M[6]); // Entwicklung nach 1. Spalte
RandomFieldsUtils/src/solve.cc:int solve3(double *M, int size, bool posdef,
RandomFieldsUtils/src/solve.cc:  double det = det3(M, size);
RandomFieldsUtils/src/solve.cc:  double detinv = 1.0 / det; // determinant of inverse of M
RandomFieldsUtils/src/solve.cc:    double a = M[0] * detinv,
RandomFieldsUtils/src/solve.cc:      d = M[3] * detinv;
RandomFieldsUtils/src/solve.cc:      result[1] = -M[1] * detinv;
RandomFieldsUtils/src/solve.cc:      result[2] = -M[2] * detinv;
RandomFieldsUtils/src/solve.cc:      if (M[1] != 0.0 || M[2] != 0.0) {
RandomFieldsUtils/src/solve.cc:	  b = M[1] * detinv,
RandomFieldsUtils/src/solve.cc:	  c = M[2] * detinv;
RandomFieldsUtils/src/solve.cc:    double swap0 = detinv * (M[4] * M[8] - M[5] * M[7]),
RandomFieldsUtils/src/solve.cc:      swap1 = detinv * (M[5] * M[6] - M[3] * M[8]),
RandomFieldsUtils/src/solve.cc:      swap2 = detinv * (M[3] * M[7] - M[4] * M[6]),
RandomFieldsUtils/src/solve.cc:      swap3 = detinv * (M[2] * M[7] - M[1] * M[8]),
RandomFieldsUtils/src/solve.cc:      swap4 = detinv * (M[0] * M[8] - M[2] * M[6]),
RandomFieldsUtils/src/solve.cc:      swap5 = detinv * (M[1] * M[6] - M[0] * M[7]),
RandomFieldsUtils/src/solve.cc:      swap6 = detinv * (M[1] * M[5] - M[2] * M[4]),
RandomFieldsUtils/src/solve.cc:      swap7 = detinv * (M[2] * M[3] - M[0] * M[5]),
RandomFieldsUtils/src/solve.cc:      swap8 = detinv * (M[0] * M[4] - M[1] * M[3]);
RandomFieldsUtils/src/solve.cc:    } else { // solve system given by M and rhs
RandomFieldsUtils/src/solve.cc:int chol3(double *M, int size, double *res, solve_storage *pt){
RandomFieldsUtils/src/solve.cc:  //  if (M[0] < 0) return ERRORFAILED;
RandomFieldsUtils/src/solve.cc:  res[0] = SQRT(M[0]);
RandomFieldsUtils/src/solve.cc:  res[size] = res[0] > 0.0 ? M[size] / res[0] : 0.0;
RandomFieldsUtils/src/solve.cc:  double dummy = M[size + 1] - res[size] * res[size];
RandomFieldsUtils/src/solve.cc:  res[size + 1] = SQRT(MAX(0.0, dummy));
RandomFieldsUtils/src/solve.cc:  res[6] = res[0] > 0.0 ? M[6] / res[0] : 0.0;
RandomFieldsUtils/src/solve.cc:  res[7] = res[4] > 0.0 ? (M[7] - res[3] * res[6]) / res[4] : 0.0;
RandomFieldsUtils/src/solve.cc:  dummy = M[8] - res[6] * res[6] - res[7] * res[7];
RandomFieldsUtils/src/solve.cc:  res[8] = SQRT(MAX(0.0, dummy));
RandomFieldsUtils/src/solve.cc:void chol2inv(double *MPT, int size) {
RandomFieldsUtils/src/solve.cc:  double *diagonal = (double *) MALLOC(sizeof(double) * size);
RandomFieldsUtils/src/solve.cc:    double *p_RESULT = MPT + k * sizeP1,
RandomFieldsUtils/src/solve.cc:      double *pM = p_RESULT + i * size;
RandomFieldsUtils/src/solve.cc:      p_RESULT[i] = (-diagK * pM[0] - SCALAR(pM + 1, p_RESULT + 1, i -1))
RandomFieldsUtils/src/solve.cc:	/ pM[i];
RandomFieldsUtils/src/solve.cc:    double *p_RESULT = MPT + k * size;
RandomFieldsUtils/src/solve.cc:      double *pM = MPT + i * size,
RandomFieldsUtils/src/solve.cc:	r = (p_RESULT[i] /= pM[i]);
RandomFieldsUtils/src/solve.cc:      diagonal[k] -= r *pM[k];
RandomFieldsUtils/src/solve.cc:      LINEAR(pM + k + 1, -r, i-k-1, p_RESULT + k + 1);
RandomFieldsUtils/src/solve.cc:      // for (int j=k+1; j<i; j++) p_RESULT[j] -= r * pM[j]; 
RandomFieldsUtils/src/solve.cc:    double *pM = MPT + k * size;	         
RandomFieldsUtils/src/solve.cc:    pM[k] = diagonal[k] / pM[k];
RandomFieldsUtils/src/solve.cc:      MPT[j] = MPT[i3++];
RandomFieldsUtils/src/solve.cc:int doPosDef(double *M0, int size, bool posdef,
RandomFieldsUtils/src/solve.cc:  //	 M0, size, posdef, rhs, rhs_cols, result, logdet, calculate, Pt,sp);
RandomFieldsUtils/src/solve.cc:    M0: (in/out) a square matrix (symmetry is not checked) of size x size;
RandomFieldsUtils/src/solve.cc:    NOTE THAT THE CONTENTS OF M0 IS DESTROYED IFF NO RHS IS GIVEN
RandomFieldsUtils/src/solve.cc:    In case rhs is not given, the inverse of M0 is returned 
RandomFieldsUtils/src/solve.cc:    In case of sqrtonly, M0 is expected to be a positive definite matrix
RandomFieldsUtils/src/solve.cc:    of size of the matrix on the right hand side);see also 'M0' and 'rhs'
RandomFieldsUtils/src/solve.cc:  assert(NA_LOGICAL == INT_MIN && NA_LOGICAL == NA_INTEGER); // nur zur sicherheit, wegen usr_bool
RandomFieldsUtils/src/solve.cc:  assert(calculate != DETERMINANT ||
RandomFieldsUtils/src/solve.cc:  assert(calculate != MATRIXSQRT || (rhs == NULL && posdef));
RandomFieldsUtils/src/solve.cc:  double *RESULT = result != NULL ? result : rhs_cols > 0 ? rhs0 : M0;
RandomFieldsUtils/src/solve.cc:  //	if (MPT == Morig || (rhs_cols > 0 && rhs == RESULT))
RandomFieldsUtils/src/solve.cc:  // !MATRIXSQRT &&  rhs_cols > 0
RandomFieldsUtils/src/solve.cc:    if (calculate == DETERMINANT)
RandomFieldsUtils/src/solve.cc:      return logdet3(det3(M0, size), posdef, logdet, sp->det_as_log);
RandomFieldsUtils/src/solve.cc:    else if (calculate  == MATRIXSQRT) return chol3(M0, size, RESULT, Pt);
RandomFieldsUtils/src/solve.cc:    else return solve3(M0, size, posdef, rhs0, rhs_cols, RESULT, logdet,
RandomFieldsUtils/src/solve.cc:  assert(SOLVE_METHODS >= 2);
RandomFieldsUtils/src/solve.cc:    pt = (solve_storage*) MALLOC(sizeof(solve_storage));
RandomFieldsUtils/src/solve.cc:				     calculate == DETERMINANT);
RandomFieldsUtils/src/solve.cc:  InversionMethod *Meth = pt->newMethods;
RandomFieldsUtils/src/solve.cc:  pt->method = NoFurtherInversionMethod;
RandomFieldsUtils/src/solve.cc:    for (int i=0; i<sizeSq; i += sizeP1) mean_diag += M0[i];
RandomFieldsUtils/src/solve.cc:	if ((notZero += !(FABS(M0[(i * sp->spam_factor) % sizeSq]) <=
RandomFieldsUtils/src/solve.cc:	// Achtung!!: !(FABS(M0[j++]) <= spam_tol) != FABS(M0[j++]) > spam_tol
RandomFieldsUtils/src/solve.cc:	for (j=i * size; j<end; nnzA += !(FABS(M0[j++]) <= spam_tol));
RandomFieldsUtils/src/solve.cc:	diag_nnzA += !(FABS(M0[j++]) <= spam_tol);
RandomFieldsUtils/src/solve.cc:	if (!posdef) for (; j<end; nnzA += !(FABS(M0[j++]) <= spam_tol));
RandomFieldsUtils/src/solve.cc:	//	printf("(%d %d %10g %d)\n", i, j, M0[j], size);
RandomFieldsUtils/src/solve.cc:	if (!(FABS(M0[j]) <= spam_tol)) {
RandomFieldsUtils/src/solve.cc:	  if (!(FABS(M0[j]) <= spam_tol)) {
RandomFieldsUtils/src/solve.cc:      *logdet = Determinant(M0, size, sp->det_as_log);
RandomFieldsUtils/src/solve.cc:      if (calculate == DETERMINANT) return NOERROR;
RandomFieldsUtils/src/solve.cc:      MEMCOPY(RESULT, M0, sizeSq * sizeof(double));
RandomFieldsUtils/src/solve.cc:      if (calculate == MATRIXSQRT) {
RandomFieldsUtils/src/solve.cc:	  RESULT[i] = M0[i] > 0.0 ? SQRT(M0[i]) : 0.0;	
RandomFieldsUtils/src/solve.cc:	  RESULT[i] = M0[i] <= 0.0 ? 0.0 : 1.0 / M0[i];
RandomFieldsUtils/src/solve.cc:      CMALLOC(main, size, double);
RandomFieldsUtils/src/solve.cc:	main[i] = M0[idx] == 0.0 ? 0.0 : 1.0 / M0[idx];
RandomFieldsUtils/src/solve.cc:  if ((to = sparse == True)) Meth[0] = Sparse;
RandomFieldsUtils/src/solve.cc:  while (from < SOLVE_METHODS &&
RandomFieldsUtils/src/solve.cc:	 to < SOLVE_METHODS &&
RandomFieldsUtils/src/solve.cc:	 sp->Methods[from] != NoFurtherInversionMethod &&
RandomFieldsUtils/src/solve.cc:	 sp->Methods[from] != NoInversionMethod) {
RandomFieldsUtils/src/solve.cc:    if (sp->Methods[from] == Sparse && sparse == True) from++;
RandomFieldsUtils/src/solve.cc:    else Meth[to++] = sp->Methods[from++];
RandomFieldsUtils/src/solve.cc:  //  printf("from = %d (%d %d) [%d %d %d] sparse=%d %d\n", from, sp->Methods[0], sp->Methods[1], Meth[0],  Meth[1], Meth[2], sparse == True, Sparse);
RandomFieldsUtils/src/solve.cc:      if (to < SOLVE_METHODS) {
RandomFieldsUtils/src/solve.cc:	Meth[to++] = useGPU ? GPUcholesky : Cholesky;
RandomFieldsUtils/src/solve.cc:	if (to < SOLVE_METHODS) {
RandomFieldsUtils/src/solve.cc:	  Meth[to++] = useGPU && sp->pivot != PIVOT_NONE ? Cholesky : Eigen;
RandomFieldsUtils/src/solve.cc:      Meth[to++] = LU;
RandomFieldsUtils/src/solve.cc:      for (int i=0; i<SOLVE_METHODS; i++)
RandomFieldsUtils/src/solve.cc:	if (Meth[i] == Cholesky || Meth[i] == GPUcholesky){
RandomFieldsUtils/src/solve.cc:	  Meth[i]=GPUcholesky;
RandomFieldsUtils/src/solve.cc:  // printf("to = %d (%d %d) %d %d\n", to, Meth[0], Meth[1], from, sparse);  assert(Meth[0] != 4);
RandomFieldsUtils/src/solve.cc:  for (; to<SOLVE_METHODS; Meth[to++]=NoFurtherInversionMethod);//save
RandomFieldsUtils/src/solve.cc:  // cholesky, QR, SVD, Eigen, LU always destroy original matrix M
RandomFieldsUtils/src/solve.cc:  int first_not_reading_M0;
RandomFieldsUtils/src/solve.cc:  double *MPT, *RHS;
RandomFieldsUtils/src/solve.cc:  MPT = M0;// pointer of M matrix, die zerstoert wird
RandomFieldsUtils/src/solve.cc:  first_not_reading_M0 = 0;
RandomFieldsUtils/src/solve.cc:  if (rhs_cols == 0 && result != NULL) MPT = result;
RandomFieldsUtils/src/solve.cc:    first_not_reading_M0 = sparse + (Meth[sparse] == GPUcholesky);
RandomFieldsUtils/src/solve.cc:    // printf("first_not_reading_M0 %d %d\n", first_not_reading_M0, Meth[first_not_reading_M0] != Meth[first_not_reading_M0 - 1] &&
RandomFieldsUtils/src/solve.cc:    //	 Meth[first_not_reading_M0] != NoFurtherInversionMethod);
RandomFieldsUtils/src/solve.cc:    if (first_not_reading_M0 == 0 ||
RandomFieldsUtils/src/solve.cc:	(Meth[first_not_reading_M0] != Meth[first_not_reading_M0 - 1] &&
RandomFieldsUtils/src/solve.cc:	 Meth[first_not_reading_M0] != NoFurtherInversionMethod)) {
RandomFieldsUtils/src/solve.cc:      int i=first_not_reading_M0;
RandomFieldsUtils/src/solve.cc:	  (SOLVE_METHODS > first_not_reading_M0 + 1 &&
RandomFieldsUtils/src/solve.cc:	   Meth[first_not_reading_M0 + 1] != Meth[first_not_reading_M0] &&
RandomFieldsUtils/src/solve.cc:	   Meth[first_not_reading_M0 + 1] != NoFurtherInversionMethod)
RandomFieldsUtils/src/solve.cc:	  (Meth[first_not_reading_M0] == SVD && sp->svd_tol > 0.0 &&
RandomFieldsUtils/src/solve.cc:	  ) { // at least two different Methods in the list
RandomFieldsUtils/src/solve.cc:	CMALLOC(main, sizeSq, double); // to pt->main, main local variable
RandomFieldsUtils/src/solve.cc:	MPT = pt->main;
RandomFieldsUtils/src/solve.cc:	  CMALLOC(rhs, sizeRHS, double); // to pt->main, main local variable
RandomFieldsUtils/src/solve.cc:  //  printf("Meth=%d %d Chol=%d %d posdef=%d\n", Meth[0], Meth[1], Cholesky, SOLVE_METHODS, posdef);
RandomFieldsUtils/src/solve.cc:  //   for (int j=0; j<size; j++)  printf("%e ", M0[i * size + j]);
RandomFieldsUtils/src/solve.cc:  for (int m=0; m<SOLVE_METHODS && (m==0 || Meth[m] != Meth[m-1]); m++) {
RandomFieldsUtils/src/solve.cc:    //    printf("m=%d %d %d %d\n", m,  Meth[m], sparse, sp->pivot);
RandomFieldsUtils/src/solve.cc:    pt->method = Meth[m];
RandomFieldsUtils/src/solve.cc:      if (pt->method == NoInversionMethod && m<=sparse) BUG;
RandomFieldsUtils/src/solve.cc:      if (pt->method == NoFurtherInversionMethod) break;
RandomFieldsUtils/src/solve.cc:    if (MPT != M0 && m >= first_not_reading_M0)
RandomFieldsUtils/src/solve.cc:      MEMCOPY(MPT, M0,  sizeSq * sizeof(double));
RandomFieldsUtils/src/solve.cc:    if (RHS != rhs0) MEMCOPY(RHS, rhs0,  sizeRHS * sizeof(double));
RandomFieldsUtils/src/solve.cc:		  M0,// in: this matrix is copied by Alex because
RandomFieldsUtils/src/solve.cc:		  rhs0, //in: if NULL the inverse of M is calculated;
RandomFieldsUtils/src/solve.cc:		  //               the sqare root(!) of the matrix M
RandomFieldsUtils/src/solve.cc:	  if (calculate == DETERMINANT) return NOERROR;
RandomFieldsUtils/src/solve.cc:#define C_GERR(X,G) {STRCPY(ErrStr, X); FERR(X); err = ERRORM; goto G;}
RandomFieldsUtils/src/solve.cc:#define C_GERR1(X,Y,G) {SPRINTF(ErrStr,X,Y); FERR(ErrStr);err = ERRORM; goto G;}
RandomFieldsUtils/src/solve.cc:#define C_GERR2(X,Y,Z,G){SPRINTF(ErrStr,X,Y,Z);FERR(ErrStr);err=ERRORM; goto G;}
RandomFieldsUtils/src/solve.cc:#define C_GERR3(X,Y,Z,A,G) {SPRINTF(ErrStr,X,Y,Z,A); FERR(ErrStr);err = ERRORM; goto G;}
RandomFieldsUtils/src/solve.cc:	CERR2("Matrix  is too large for Cholesky decomposition. Maximum ist currently a %d x %d matrix. Increase 'max_chol' in 'RFoption' if necessary.",
RandomFieldsUtils/src/solve.cc:      CMALLOC(D, size > rhs_cols ? size : rhs_cols, double);
RandomFieldsUtils/src/solve.cc:      for (int i=0; i<size; i++) D[i] = MPT[sizeP1 * i];
RandomFieldsUtils/src/solve.cc:	  double *A = MPT;
RandomFieldsUtils/src/solve.cc:#pragma omp parallel for num_threads(CORES) if (MULTIMINSIZE(size - i)) schedule(dynamic, 8) 
RandomFieldsUtils/src/solve.cc:	    //	    for (double *B=MPT + (i+1) * size; B<endB; B+=size) {
RandomFieldsUtils/src/solve.cc:	      double *B = MPT + j * size;
RandomFieldsUtils/src/solve.cc:	  if (calculate == MATRIXSQRT) {
RandomFieldsUtils/src/solve.cc:	    double *end = MPT + sizeSq;
RandomFieldsUtils/src/solve.cc:	    for (double *p=MPT + 1; p<end; p+=sizeP1, deltaend--)
RandomFieldsUtils/src/solve.cc:	      *logdet = Determinant(MPT, size, sp->det_as_log);
RandomFieldsUtils/src/solve.cc:	      if (calculate == DETERMINANT) return NOERROR;
RandomFieldsUtils/src/solve.cc:	    if (rhs_cols == 0) chol2inv(MPT, size);
RandomFieldsUtils/src/solve.cc:	      //if (result!=NULL) MEMCOPY(RESULT, rhs, sizeof(double)*totalRHS);
RandomFieldsUtils/src/solve.cc:		  double *pM = MPT + i * size;
RandomFieldsUtils/src/solve.cc:		  p_RESULT[i] = (p_rhs[i] - SCALAR(pM, p_RESULT, i)) / pM[i];
RandomFieldsUtils/src/solve.cc:		  double *pM = MPT + i * size,
RandomFieldsUtils/src/solve.cc:		    r = (p_RESULT[i] /= pM[i]);
RandomFieldsUtils/src/solve.cc:		  LINEAR(pM, -r, i, p_RESULT);
RandomFieldsUtils/src/solve.cc:		  // for (int j=0; j<i; j++)  p_RESULT[j] -= r * pM[j];
RandomFieldsUtils/src/solve.cc:	// code according to Helmut Harbrecht,Michael Peters,Reinhold Schneider
RandomFieldsUtils/src/solve.cc:	  for (int i=0; i<size; i++) MPT[sizeP1 * i] = D[i];
RandomFieldsUtils/src/solve.cc: 	  FREE(pt->pivot_idx); // ALWAYS FREE IT!!! cp Chol(SEXP M)
RandomFieldsUtils/src/solve.cc:	  pt->pivot_idx = (int*) MALLOC(size * sizeof(int));
RandomFieldsUtils/src/solve.cc:	  pt->pivot_idx = (int*) MALLOC(bytes);
RandomFieldsUtils/src/solve.cc:	  MEMCOPY(pt->pivot_idx, sp->pivot_idx, bytes);
RandomFieldsUtils/src/solve.cc:	  //	  *M00 = M0,
RandomFieldsUtils/src/solve.cc:	//printf("MTP %d %d %d\n", MPT == M0, rhs_cols,  RHS == RESULT);
RandomFieldsUtils/src/solve.cc:	if (MPT == M0 || (rhs_cols > 0 && RHS == RESULT))
RandomFieldsUtils/src/solve.cc:	if (MPT == M0) {
RandomFieldsUtils/src/solve.cc:	  CMALLOC(main, sizeSq, double);
RandomFieldsUtils/src/solve.cc:	  MEMCOPY(main, M0, sizeSq * sizeof(double));
RandomFieldsUtils/src/solve.cc:	  M00 = main;	  
RandomFieldsUtils/src/solve.cc:	  CMALLOC(U, totalRHS, double);
RandomFieldsUtils/src/solve.cc:	  MEMCOPY(U, rhs, totalRHS * sizeof(double));
RandomFieldsUtils/src/solve.cc:		  double *mpt = MPT + pi[i] * size;
RandomFieldsUtils/src/solve.cc:		  SPRINTF(msg, "Matrix has a numerically zero, leading value at the %d-th pivoted line, but the largest deviation %10e from zero in the rest of the matrix is greater than the tolerance %10e. %.50s.",
RandomFieldsUtils/src/solve.cc:			  MAX(max_deviation, dev),
RandomFieldsUtils/src/solve.cc:	  double lqpq = MPT[q + col_q] = SQRT(D[pqq]);	    
RandomFieldsUtils/src/solve.cc:#pragma omp parallel for num_threads(CORES) if (MULTIMINSIZE(size - q)) schedule(dynamic, 8) 
RandomFieldsUtils/src/solve.cc:	    double scalar = SCALAR(MPT + col_q, MPT + col_i, q);
RandomFieldsUtils/src/solve.cc:	    MPT[q + col_i] = (M0[pqq + col_i] - scalar) / lqpq;
RandomFieldsUtils/src/solve.cc:	    D[pii] -=  MPT[q + col_i] *  MPT[q + col_i];
RandomFieldsUtils/src/solve.cc:	    // in Harbrecht: lqpq * MPT[q + col_i];
RandomFieldsUtils/src/solve.cc:		  p rintf("%10g ", MPT[size * j + k]);
RandomFieldsUtils/src/solve.cc:	  if (calculate == MATRIXSQRT) {
RandomFieldsUtils/src/solve.cc:	      FILL_IN(MPT + i + 1 + size * pi[i], size - 1 - i, 0.0);
RandomFieldsUtils/src/solve.cc:	      FILL_IN(MPT + actual_size + size*pi[i], size - actual_size, 0.0);
RandomFieldsUtils/src/solve.cc:	  } else { // ! MATRIXSQRT
RandomFieldsUtils/src/solve.cc:		for (int i=0; i < size; i++) logD += LOG(MPT[i + pi[i] * size]);
RandomFieldsUtils/src/solve.cc:		for (int i=0; i < size; i++) logD *= MPT[i + pi[i] * size];
RandomFieldsUtils/src/solve.cc:	      if (calculate == DETERMINANT) return NOERROR;
RandomFieldsUtils/src/solve.cc:		GERR("Matrix not definite. Try 'solve(M , diag(nrow(M)))' instead or add a small positive constant to the diagonal.")
RandomFieldsUtils/src/solve.cc:		    double *p_RESULT = MPT + pi[k] * size + k,
RandomFieldsUtils/src/solve.cc:		      double *pM = MPT + k + pi[k + i] * size;
RandomFieldsUtils/src/solve.cc:		      p_RESULT[i] = (-diagK * pM[0]
RandomFieldsUtils/src/solve.cc:				     -SCALAR(pM + 1, p_RESULT + 1, i -1)) / pM[i];
RandomFieldsUtils/src/solve.cc:		double *p_RESULT = MPT + pi[k] * size;
RandomFieldsUtils/src/solve.cc:		  double *pM = MPT + pi[i] * size,		    
RandomFieldsUtils/src/solve.cc:		    r = (p_RESULT[i] /= pM[i]);
RandomFieldsUtils/src/solve.cc:		  D[k] -= r * pM[k];
RandomFieldsUtils/src/solve.cc:		  LINEAR(pM + k + 1, -r, i-k-1, p_RESULT + k + 1);
RandomFieldsUtils/src/solve.cc:		  // for (int j=k+1; j<i; j++) p_RESULT[j] -= r * pM[j]; 
RandomFieldsUtils/src/solve.cc:		double *p_RESULT = MPT + pi[k] * size;
RandomFieldsUtils/src/solve.cc:		double *pM = MPT + pi[k] * size;	         
RandomFieldsUtils/src/solve.cc:		pM[k] = D[k] / pM[k];
RandomFieldsUtils/src/solve.cc:	      CMALLOC(xja, size, int);
RandomFieldsUtils/src/solve.cc:		  if (MPT[idx] == RF_INF) MPT[idx] = MPT[j + i * size];
RandomFieldsUtils/src/solve.cc:		  else MPT[j + i * size] = MPT[idx];
RandomFieldsUtils/src/solve.cc:		  double *pM = MPT + pii * size;
RandomFieldsUtils/src/solve.cc:		  p_RESULT[i] = (p_rhs[pii] - SCALAR(pM, p_RESULT, i)) / pM[i];
RandomFieldsUtils/src/solve.cc:		  double *pM = MPT + pii * size;
RandomFieldsUtils/src/solve.cc:		  if (FABS((p_rhs[pii] - SCALAR(pM, p_RESULT, i))) > eps) {
RandomFieldsUtils/src/solve.cc:			 p_rhs[pii] - SCALAR(pM, p_RESULT, i));
RandomFieldsUtils/src/solve.cc:		  double *pM = MPT + pii * size,
RandomFieldsUtils/src/solve.cc:		    r = (p_RESULT[i] /= pM[i]);
RandomFieldsUtils/src/solve.cc:		  LINEAR(pM, -r, i, p_RESULT);
RandomFieldsUtils/src/solve.cc:		  // for (int j=0; j<i; j++) p_RESULT[j] -= r * pM[j];
RandomFieldsUtils/src/solve.cc:	      CMALLOC(xja, size, int);
RandomFieldsUtils/src/solve.cc:      err = ERRORNOTPROGRAMMEDYET; /// to do: clarify transposed !
RandomFieldsUtils/src/solve.cc:      CMALLOC(w2, size, double);
RandomFieldsUtils/src/solve.cc:      CMALLOC(w3, size, double);
RandomFieldsUtils/src/solve.cc:		       MPT, &size, // aijmax, &irank, inc, w2, 
RandomFieldsUtils/src/solve.cc:    case Eigen : { //  M = U D UT
RandomFieldsUtils/src/solve.cc:      CMALLOC(U, sizeSq, double);
RandomFieldsUtils/src/solve.cc:      CMALLOC(D, size, double); 
RandomFieldsUtils/src/solve.cc:      CMALLOC(xja, 2 * size, int);
RandomFieldsUtils/src/solve.cc:			 MPT, &size, &dummy, &dummy, &k, &k, 
RandomFieldsUtils/src/solve.cc:			 &abstol,// or DLAMCH
RandomFieldsUtils/src/solve.cc:	CMALLOC(w2, lw2, double);
RandomFieldsUtils/src/solve.cc:	CMALLOC(iwork, lintwork, int);
RandomFieldsUtils/src/solve.cc:      if (calculate == MATRIXSQRT) {
RandomFieldsUtils/src/solve.cc:	  if (calculate == DETERMINANT) return NOERROR;
RandomFieldsUtils/src/solve.cc:	  CMALLOC(w2, tot, double);	
RandomFieldsUtils/src/solve.cc:	  CMALLOC(w2, sizeSq, double);
RandomFieldsUtils/src/solve.cc:    case SVD : {// SVD : M = U D VT
RandomFieldsUtils/src/solve.cc:      CMALLOC(w3, sizeSq, double);
RandomFieldsUtils/src/solve.cc:      CMALLOC(U, sizeSq, double);
RandomFieldsUtils/src/solve.cc:      CMALLOC(D, size, double); 
RandomFieldsUtils/src/solve.cc:      CMALLOC(iwork, size8, int);
RandomFieldsUtils/src/solve.cc:			 MPT, &size, D, U, &size, w3, &size, 
RandomFieldsUtils/src/solve.cc:	CMALLOC(w2, lw2, double);
RandomFieldsUtils/src/solve.cc:      if (calculate == MATRIXSQRT) {
RandomFieldsUtils/src/solve.cc:	      if (FABS(M0[i * size + k] - sum) > svdtol) {
RandomFieldsUtils/src/solve.cc:			 M0[i * size +k] - sum, i, k, M0[i*size+k], sum);
RandomFieldsUtils/src/solve.cc:		FERR3("required precision not attained  (%10e > %10e): probably invalid model. See also '%.50s'.", FABS(M0[i * size + k] - sum), svdtol,
RandomFieldsUtils/src/solve.cc:		err=ERRORM;
RandomFieldsUtils/src/solve.cc:	      } //else printf("ok (%d,%d) %10g %10g\n", i, k, M0[i*size+k],sum);
RandomFieldsUtils/src/solve.cc:	  if (calculate == DETERMINANT) return NOERROR;
RandomFieldsUtils/src/solve.cc:	  CMALLOC(w2, tot, double);	
RandomFieldsUtils/src/solve.cc:      if (calculate == MATRIXSQRT) {
RandomFieldsUtils/src/solve.cc:      CMALLOC(iwork, size, int);		    
RandomFieldsUtils/src/solve.cc:		       MPT, &size, iwork, &err);
RandomFieldsUtils/src/solve.cc:	*logdet = Determinant(MPT, size, sp->det_as_log);
RandomFieldsUtils/src/solve.cc:        if (calculate == DETERMINANT) return NOERROR;
RandomFieldsUtils/src/solve.cc:	if (result != NULL) MEMCOPY(RESULT, RHS, sizeof(double) * totalRHS);
RandomFieldsUtils/src/solve.cc:			 &rhs_cols, MPT, &size, iwork, 
RandomFieldsUtils/src/solve.cc:	  F77_CALL(dgetri)(&size, MPT, // LU solve
RandomFieldsUtils/src/solve.cc:	  CMALLOC(w2, lw2, double);
RandomFieldsUtils/src/solve.cc:      CMALLOC(pivotsparse, size, int);
RandomFieldsUtils/src/solve.cc:	for (int i=0; i<sizeSq; i++) nnzA += !(FABS(M0[i]) <= spam_tol);
RandomFieldsUtils/src/solve.cc:      CMALLOC(xlnz, sizeP1, int);
RandomFieldsUtils/src/solve.cc:      CMALLOC(snode, size, int);
RandomFieldsUtils/src/solve.cc:      CMALLOC(xsuper, sizeP1, int);
RandomFieldsUtils/src/solve.cc:      CMALLOC(iwork, sizeP1, int);
RandomFieldsUtils/src/solve.cc:      CMALLOC(invp, size, int);
RandomFieldsUtils/src/solve.cc:      CMALLOC(w3, size, double);
RandomFieldsUtils/src/solve.cc:      CMALLOC(cols, spam_zaehler, int);
RandomFieldsUtils/src/solve.cc:      CMALLOC(rows, sizeP1, int);
RandomFieldsUtils/src/solve.cc:      CMALLOC(D, nD, double);
RandomFieldsUtils/src/solve.cc:      F77_CALL(spamdnscsr)(&size, &size, M0, &size, D,
RandomFieldsUtils/src/solve.cc:	CMALLOC(lindx, nnzcolindices, int);	
RandomFieldsUtils/src/solve.cc:	CMALLOC(lnz, nnzR, double);
RandomFieldsUtils/src/solve.cc:      if (calculate == MATRIXSQRT) {
RandomFieldsUtils/src/solve.cc:	CMALLOC(xja, nnzR, int);
RandomFieldsUtils/src/solve.cc:	  if (calculate == DETERMINANT) return NOERROR;
RandomFieldsUtils/src/solve.cc:	    MEMCOPY(RESULT, RHS, size * rhs_cols * sizeof(double));
RandomFieldsUtils/src/solve.cc:    case NoInversionMethod: GERR("no inversion method given.");
RandomFieldsUtils/src/solve.cc:    case NoFurtherInversionMethod:
RandomFieldsUtils/src/solve.cc:SEXP doPosDef(SEXP M, SEXP rhs, SEXP logdet, int calculate,
RandomFieldsUtils/src/solve.cc:    size = ncols(M), 
RandomFieldsUtils/src/solve.cc:    rows = nrows(M);
RandomFieldsUtils/src/solve.cc:  bool deleteMM = false,
RandomFieldsUtils/src/solve.cc:  } else if (isMatrix(rhs)) {
RandomFieldsUtils/src/solve.cc:  //  res =  PROTECT(isReal(M) ? duplicate(M): coerceVector(M, REALSXP)); UNPROTECT(1); return res;
RandomFieldsUtils/src/solve.cc:  if (rhs_cols==0 || isMatrix(rhs)) {
RandomFieldsUtils/src/solve.cc:    res = PROTECT(allocMatrix(REALSXP, size, new_cols));
RandomFieldsUtils/src/solve.cc:  double *MM=NULL, 
RandomFieldsUtils/src/solve.cc:  if (TYPEOF(M) != REALSXP) {
RandomFieldsUtils/src/solve.cc:    if (TYPEOF(M) != INTSXP && TYPEOF(M) != LGLSXP) 
RandomFieldsUtils/src/solve.cc:    if ((deleteMM = rhs_cols != 0))
RandomFieldsUtils/src/solve.cc:      MM = (double*) MALLOC(total * sizeof(double));
RandomFieldsUtils/src/solve.cc:    else MM = REAL(res);
RandomFieldsUtils/src/solve.cc:    if (TYPEOF(M) == INTSXP) {
RandomFieldsUtils/src/solve.cc:	MM[i] = INTEGER(M)[i] == NA_INTEGER ? RF_NA : (double) INTEGER(M)[i];
RandomFieldsUtils/src/solve.cc:	MM[i] = LOGICAL(M)[i] == NA_LOGICAL ? RF_NA : (double) LOGICAL(M)[i];
RandomFieldsUtils/src/solve.cc:  } else MM = REAL(M); 
RandomFieldsUtils/src/solve.cc:      RHS = (double*) MALLOC(totalRHS * sizeof(double));
RandomFieldsUtils/src/solve.cc:  err = doPosDef(MM, size, true, // no PROTECT( needed
RandomFieldsUtils/src/solve.cc:		 (rhs_cols == 0 && TYPEOF(M) == REALSXP) ||
RandomFieldsUtils/src/solve.cc:  if (deleteMM) FREE(MM);
RandomFieldsUtils/src/solve.cc:    case ERRORMEMORYALLOCATION : STRCPY(msg, "memory allocation error"); break;
RandomFieldsUtils/src/solve.cc:    case ERRORNOTPROGRAMMEDYET : STRCPY(msg, "not programmed yet"); break;
RandomFieldsUtils/src/solve.cc:    case ERRORM : STRCPY(msg, pt->err_msg);
RandomFieldsUtils/src/solve.cc:SEXP SolvePosDef(SEXP M, SEXP rhs, SEXP logdet){
RandomFieldsUtils/src/solve.cc:  return doPosDef(M, rhs, logdet, SOLVE, NULL, &(GLOBAL.solve));
RandomFieldsUtils/src/solve.cc:int solvePosDefResult(double *M, int size, bool posdef, 
RandomFieldsUtils/src/solve.cc:  return doPosDef(M, size, posdef, rhs, rhs_cols, result, logdet, SOLVE,
RandomFieldsUtils/src/solve.cc:int solvePosDef(double *M, int size, bool posdef, 
RandomFieldsUtils/src/solve.cc:  return doPosDef(M, size, posdef, rhs, rhs_cols,
RandomFieldsUtils/src/solve.cc:		  NULL, // result, so result returned in M or rhs
RandomFieldsUtils/src/solve.cc:int solvePosDefSp(double *M, int size, bool posdef, 
RandomFieldsUtils/src/solve.cc:  return doPosDef(M, size, posdef, rhs, rhs_cols, NULL, logdet, SOLVE,
RandomFieldsUtils/src/solve.cc:int XCinvYdet(double *M, int size, bool posdef, double *X, double *Y, int cols, 
RandomFieldsUtils/src/solve.cc:  else result= (double *) MALLOC(sizeof(double) * size * cols);  
RandomFieldsUtils/src/solve.cc:  if (result == NULL) return ERRORMEMORYALLOCATION;
RandomFieldsUtils/src/solve.cc:  int err =  doPosDef(M,// no PROTECT( needed
RandomFieldsUtils/src/solve.cc:int XCinvXdet(double *M, int size, double *X, int X_cols,
RandomFieldsUtils/src/solve.cc:  return XCinvYdet(M, size, true, X, X, X_cols, XCinvX, det, log, PT);
RandomFieldsUtils/src/solve.cc:double XCinvXlogdet(double *M, int size, double *X, int X_cols,
RandomFieldsUtils/src/solve.cc:  else result = (double *) MALLOC(sizeof(double) * size * X_cols);
RandomFieldsUtils/src/solve.cc:  int err =  doPosDef(M, size, true, X, X_cols, result, &ans,// no PROTECT( needed
RandomFieldsUtils/src/solve.cc:double detPosDef(double *M, int size) {
RandomFieldsUtils/src/solve.cc:  //not that M will be destroyed!!
RandomFieldsUtils/src/solve.cc:  int err= doPosDef(M, size, true, NULL, 0, NULL, &det, DETERMINANT, // no PROTECT( needed
RandomFieldsUtils/src/solve.cc:int invertMatrix(double *M, int size) {
RandomFieldsUtils/src/solve.cc:  return doPosDef(M, size, false, NULL, 0, NULL, NULL, SOLVE, NULL, NULL);
RandomFieldsUtils/src/solve.cc:SEXP Chol(SEXP M) {
RandomFieldsUtils/src/solve.cc:  sp.Methods[0] = sp.Methods[1] = Cholesky;
RandomFieldsUtils/src/solve.cc:  PROTECT(Ans = doPosDef(M, R_NilValue, R_NilValue, MATRIXSQRT, &Pt, &sp));
RandomFieldsUtils/src/solve.cc:    MEMCOPY(INTEGER(Idx), Pt.pivot_idx, sizeof(int) * Pt.pivot_idx_n);
RandomFieldsUtils/src/solve.cc:    assert(Pt.pivot_idx_n == ncols(M));
RandomFieldsUtils/src/solve.cc:int chol(double *M, int size) {
RandomFieldsUtils/src/solve.cc:  sp.Methods[0] = sp.Methods[1] = Cholesky;
RandomFieldsUtils/src/solve.cc:  return doPosDef(M, size, true, NULL, 0, NULL, NULL, MATRIXSQRT, NULL, &sp);   
RandomFieldsUtils/src/solve.cc:  test = (double*) MALLOC(bytes);
RandomFieldsUtils/src/solve.cc:  MEMCOPY(test, C, bytes);
RandomFieldsUtils/src/solve.cc:  library(RandomFields, lib="~/TMP")
RandomFieldsUtils/src/solve.cc:  z = RFsimulate(RMspheric(), x, max_variab=10000, n=10000, spC=F ALSE)
RandomFieldsUtils/src/solve.cc:  c = RFcovmatrix(RMspheric(), x) #//
RandomFieldsUtils/src/solve.cc:int sqrtPosDefFree(double *M,  // in out
RandomFieldsUtils/src/solve.cc:  InversionMethod *Meth = sp->Methods;
RandomFieldsUtils/src/solve.cc:  bool extra_alloc = Meth[0] == NoInversionMethod ||
RandomFieldsUtils/src/solve.cc:    Meth[0] == NoFurtherInversionMethod ||
RandomFieldsUtils/src/solve.cc:    (Meth[1] != NoInversionMethod && Meth[1] != NoFurtherInversionMethod &&
RandomFieldsUtils/src/solve.cc:     Meth[1] != Meth[0]) ||
RandomFieldsUtils/src/solve.cc:    (Meth[0] != Cholesky && Meth[0] != Eigen && Meth[0] != SVD);
RandomFieldsUtils/src/solve.cc:    CMALLOC(result, sizeSq, double);
RandomFieldsUtils/src/solve.cc:    pt->result = M;
RandomFieldsUtils/src/solve.cc:  // printf("%ld %d %ld %d %ld %ld\n", M, size, res, MATRIXSQRT, pt, sp);
RandomFieldsUtils/src/solve.cc:  err = doPosDef(M, size, true, NULL, 0, res, NULL, MATRIXSQRT, pt, sp);// no PROTECT( needed
RandomFieldsUtils/src/solve.cc:    pt->to_be_deleted = M;
RandomFieldsUtils/src/solve.cc:      FREE(M);
RandomFieldsUtils/src/solve.cc:#pragma omp parallel for num_threads(CORES) if (MULTIMINSIZE(n_act_size)) schedule(dynamic, 8) 
RandomFieldsUtils/src/solve.cc:#pragma omp parallel for num_threads(CORES) if (MULTIMINSIZE(n_diff))
RandomFieldsUtils/src/solve.cc:#pragma omp parallel for num_threads(CORES) if (MULTIMINSIZE(nsize)) schedule(dynamic, 8) 
RandomFieldsUtils/src/solve.cc:    n = isMatrix(RHS) ? ncols(RHS) : 1,
RandomFieldsUtils/src/solve.cc:    rows = isMatrix(RHS) ? nrows(RHS) : length(RHS),
RandomFieldsUtils/src/solve.cc:    if (isMatrix(RHS)) PROTECT(Ans = allocMatrix(REALSXP, size, n));
RandomFieldsUtils/src/solve.cc:  else PROTECT(Ans = allocMatrix(REALSXP, size, n));
RandomFieldsUtils/src/solve.cc:  double *gauss = (double *) MALLOC(sizeof(double) * n_act_size);
RandomFieldsUtils/src/solve.cc:  for (int i=0; i<n_act_size; gauss[i++] = GAUSS_RANDOM(1.0));
RandomFieldsUtils/src/solve.cc:#pragma omp parallel for num_threads(CORES) if (MULTIMINSIZE(size))
RandomFieldsUtils/src/own.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/src/own.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFieldsUtils/src/own.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/src/own.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/src/sort.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/src/sort.cc: Copyright (C) 2017 -- 2017 Martin Schlather
RandomFieldsUtils/src/sort.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/src/sort.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/src/sort.cc:vergleichX SMALLERX=NULL, GREATERX=NULL;
RandomFieldsUtils/src/sort.cc:bool smaller(int i, int j, int ORDERDIM, void *O)
RandomFieldsUtils/src/sort.cc:  x = ORDERD + i * ORDERDIM;
RandomFieldsUtils/src/sort.cc:  y = ORDERD + j * ORDERDIM;
RandomFieldsUtils/src/sort.cc:  for(d=0; d<ORDERDIM; d++)
RandomFieldsUtils/src/sort.cc:bool greater(int i, int j, int ORDERDIM, void *O)
RandomFieldsUtils/src/sort.cc:  x = ORDERD + i * ORDERDIM;
RandomFieldsUtils/src/sort.cc:  y = ORDERD + j * ORDERDIM;
RandomFieldsUtils/src/sort.cc:  for(d=0; d<ORDERDIM; d++)
RandomFieldsUtils/src/sort.cc:bool smallerInt(int i, int j, int ORDERDIM, void *O)
RandomFieldsUtils/src/sort.cc:  x = ORDERDINT + i * ORDERDIM;
RandomFieldsUtils/src/sort.cc:  y = ORDERDINT + j * ORDERDIM;
RandomFieldsUtils/src/sort.cc:  for(d=0; d<ORDERDIM; d++) {
RandomFieldsUtils/src/sort.cc:bool greaterInt(int i, int j, int ORDERDIM, void *O)
RandomFieldsUtils/src/sort.cc:  x = ORDERDINT + i * ORDERDIM;
RandomFieldsUtils/src/sort.cc:  y = ORDERDINT + j * ORDERDIM;
RandomFieldsUtils/src/sort.cc:  for(d=0; d<ORDERDIM; d++)
RandomFieldsUtils/src/sort.cc:void order(int *pos, int start, int end, vergleich SMALLER, vergleich GREATER,
RandomFieldsUtils/src/sort.cc:    //Get RNGstate();randpos = start + (int) (UNIFORM_RANDOM * (end-start+1)); PutRNGstate(); // use Get/Put RNGstate with great care !!
RandomFieldsUtils/src/sort.cc:      while (++left < right && SMALLER(pos[left], pivot, ORDERD)) pivotpos++;
RandomFieldsUtils/src/sort.cc:      order(pos, start, pivotpos-1, SMALLER, GREATER,
RandomFieldsUtils/src/sort.cc:      order(pos, pivotpos + 1, end, SMALLER, GREATER,
RandomFieldsUtils/src/sort.cc:void Xorder(int *pos, int start, int end, vergleichX SMALLER,vergleichX GREATER,
RandomFieldsUtils/src/sort.cc:    //Get RNGstate();randpos = start + (int) (UNIFORM_RANDOM * (end-start+1)); PutRNGstate(); // use Get/Put RNGstate with great care !!
RandomFieldsUtils/src/sort.cc:      while (++left < right && SMALLER(pos[left], pivot, D, ORDERD)) pivotpos++;
RandomFieldsUtils/src/sort.cc:      Xorder(pos, start, pivotpos-1, SMALLER, GREATER,
RandomFieldsUtils/src/sort.cc:      Xorder(pos, pivotpos + 1, end, SMALLER, GREATER,
RandomFieldsUtils/src/sort.cc:    //Get RNGstate();randpos = start + (int) (UNIFORM_RANDOM * (end-start+1)); PutRNGstate(); // use Get/Put RNGstate with great care !!
RandomFieldsUtils/src/sort.cc:    //Get RNGstate();randpos = start + (int) (UNIFORM_RANDOM * (end-start+1)); PutRNGstate(); // use Get/Put RNGstate with great care !!
RandomFieldsUtils/src/sort.cc:    from = MAX(1, INTEGER(From)[0]),
RandomFieldsUtils/src/sort.cc:    to = MIN(INTEGER(To)[0], len);
RandomFieldsUtils/src/sort.cc:    if ((data = (double*) MALLOC(bytes)) == NULL) { 
RandomFieldsUtils/src/sort.cc:      err = ERRORMEMORYALLOCATION; goto ErrorHandling; 
RandomFieldsUtils/src/sort.cc:    MEMCOPY(data, REAL(Data), bytes);
RandomFieldsUtils/src/sort.cc:    if ((data = (int*) MALLOC(bytes)) == NULL) { 
RandomFieldsUtils/src/sort.cc:      err = ERRORMEMORYALLOCATION; goto ErrorHandling; 
RandomFieldsUtils/src/sort.cc:    MEMCOPY(data, INTEGER(Data), bytes);
RandomFieldsUtils/src/sort.cc:  case ERRORMEMORYALLOCATION : ERR("not enough memory");
RandomFieldsUtils/src/sort.cc:    from = MAX(1, INTEGER(From)[0]),
RandomFieldsUtils/src/sort.cc:    to = MIN(INTEGER(To)[0], len);
RandomFieldsUtils/src/sort.cc:    *pos = (int*) MALLOC(bytes);
RandomFieldsUtils/src/sort.cc:  if (pos == NULL) {err = ERRORMEMORYALLOCATION; goto ErrorHandling;}
RandomFieldsUtils/src/sort.cc:  case ERRORMEMORYALLOCATION : ERR("not enough memory");
RandomFieldsUtils/src/sort.cc:    *pos = (int*) MALLOC(len * sizeof(int));
Binary file RandomFieldsUtils/src/options.o matches
RandomFieldsUtils/src/RandomFieldsUtils.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/src/RandomFieldsUtils.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFieldsUtils/src/RandomFieldsUtils.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/src/RandomFieldsUtils.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/src/RandomFieldsUtils.h:  SEXP I0ML0(SEXP X);
RandomFieldsUtils/src/RandomFieldsUtils.h:  SEXP WMr(SEXP X, SEXP Nu, SEXP Derivative, SEXP Factor);
RandomFieldsUtils/src/RandomFieldsUtils.h:  SEXP logWMr(SEXP X, SEXP Nu1, SEXP Nu2, SEXP Factor);
RandomFieldsUtils/src/RandomFieldsUtils.h:  SEXP SolvePosDef(SEXP M, SEXP rhs, SEXP logdet);
RandomFieldsUtils/src/RandomFieldsUtils.h:  SEXP Chol(SEXP M);
RandomFieldsUtils/src/RandomFieldsUtils.h:  void sleepMicro(int *micro);
RandomFieldsUtils/src/RandomFieldsUtils.h:  void sleepMilli(int *milli);
RandomFieldsUtils/src/RandomFieldsUtils.h:  SEXP colMaxs(SEXP M);
RandomFieldsUtils/src/RandomFieldsUtils.h:  SEXP rowMeansX(SEXP M, SEXP Factor);
RandomFieldsUtils/src/RandomFieldsUtils.h:  SEXP rowProd(SEXP M);
RandomFieldsUtils/src/RandomFieldsUtils.h:  SEXP DivByRow(SEXP M, SEXP V);
RandomFieldsUtils/src/RandomFieldsUtils.h:  SEXP dotXV(SEXP M, SEXP V);
RandomFieldsUtils/src/cholmodified.f:c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/src/cholmodified.f:c Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/src/cholmodified.f:c     Modified chol routine  
RandomFieldsUtils/src/cholmodified.f:c699    FORMAT(1X,' FOUND ',I6,' RETURNING!')
RandomFieldsUtils/src/cholmodified.f:      IMPLICIT NONE
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C************     ASSMB .... INDEXED ASSEMBLY OPERATION     ************
RandomFieldsUtils/src/cholmodified.f:C       THIS ROUTINE PERFORMS AN INDEXED ASSEMBLY (I.E., SCATTER-ADD)
RandomFieldsUtils/src/cholmodified.f:C       OPERATION, ASSUMING DATA STRUCTURES USED IN SOME OF OUR SPARSE
RandomFieldsUtils/src/cholmodified.f:C   INPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       M               -   NUMBER OF ROWS IN Y.
RandomFieldsUtils/src/cholmodified.f:C       Q               -   NUMBER OF COLUMNS IN Y.
RandomFieldsUtils/src/cholmodified.f:C       RELIND          -   RELATIVE INDICES FOR MAPPING THE UPDATES
RandomFieldsUtils/src/cholmodified.f:C                           ONTO THE TARGET COLUMNS.
RandomFieldsUtils/src/cholmodified.f:C       XLNZ            -   POINTERS TO THE START OF EACH COLUMN IN THE
RandomFieldsUtils/src/cholmodified.f:C                           TARGET MATRIX.
RandomFieldsUtils/src/cholmodified.f:C   OUTPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       LNZ             -   CONTAINS COLUMNS MODIFIED BY THE UPDATE
RandomFieldsUtils/src/cholmodified.f:C                           MATRIX.
RandomFieldsUtils/src/cholmodified.f:      SUBROUTINE  ASSMB  (  M     , Q     , Y     , RELIND, XLNZ  ,
RandomFieldsUtils/src/cholmodified.f:C       PARAMETERS.
RandomFieldsUtils/src/cholmodified.f:        INTEGER             LDA   , M     , Q
RandomFieldsUtils/src/cholmodified.f:            DO  100  IR = ICOL, M
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C       TO DETERMINE THE BINARY TREE REPRESENTATION OF THE ELIMINATION
RandomFieldsUtils/src/cholmodified.f:C   INPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       NEQNS           -   NUMBER OF EQUATIONS.
RandomFieldsUtils/src/cholmodified.f:C       PARENT          -   THE PARENT VECTOR OF THE ELIMINATION TREE.
RandomFieldsUtils/src/cholmodified.f:C                           IT IS ASSUMED THAT PARENT(I) > I EXCEPT OF
RandomFieldsUtils/src/cholmodified.f:C   OUTPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C               OTHERWISE, BECOMES FIRST SON OF ITS PARENT.
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C       THIS SUBROUTINE COMPUTES ITEMS NEEDED BY THE LEFT-LOOKING
RandomFieldsUtils/src/cholmodified.f:C   INPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       NEQNS           -   NUMBER OF EQUATIONS.
RandomFieldsUtils/src/cholmodified.f:C       NSUPER          -   NUMBER OF SUPERNODES.
RandomFieldsUtils/src/cholmodified.f:C       SNODE           -   SUPERNODE MEMBERSHIP.
RandomFieldsUtils/src/cholmodified.f:C   OUTPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       TMPSIZ          -   SIZE OF WORKING STORAGE REQUIRED BY BLKFCT.
RandomFieldsUtils/src/cholmodified.f:     &                      LINDX , CACHSZ, TMPSIZ, SPLIT           )
RandomFieldsUtils/src/cholmodified.f:        INTEGER     CACHSZ, NEQNS , NSUPER, TMPSIZ
RandomFieldsUtils/src/cholmodified.f:C       DETERMINE FLOATING POINT WORKING SPACE REQUIREMENT.
RandomFieldsUtils/src/cholmodified.f:     &                  TMPSIZ                                  )
RandomFieldsUtils/src/cholmodified.f:C   Last modified:  March 6, 1995
RandomFieldsUtils/src/cholmodified.f:C                   RF eliminated dependence on SMXPY and MMPY
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratoy
RandomFieldsUtils/src/cholmodified.f:C       THIS SUBROUTINE FACTORS A SPARSE POSITIVE DEFINITE MATRIX.
RandomFieldsUtils/src/cholmodified.f:C       THE COMPUTATION IS ORGANIZED AROUND KERNELS THAT PERFORM
RandomFieldsUtils/src/cholmodified.f:C   INPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       NSUPER          -   NUMBER OF SUPERNODES.
RandomFieldsUtils/src/cholmodified.f:C       SNODE           -   MAPS EACH COLUMN TO THE SUPERNODE CONTAINING
RandomFieldsUtils/src/cholmodified.f:C                           THE DIAGONAL ELEMENTS).
RandomFieldsUtils/src/cholmodified.f:C       (XLNZ,LNZ)      -   ON INPUT, CONTAINS MATRIX TO BE FACTORED.
RandomFieldsUtils/src/cholmodified.f:C       TMPSIZ          -   SIZE OF TEMPORARY WORKING STORAGE.
RandomFieldsUtils/src/cholmodified.f:C   OUTPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C                                  MATRIX IS NOT POSITIVE DEFINITE.
RandomFieldsUtils/src/cholmodified.f:C                                  [TEMP(*)].
RandomFieldsUtils/src/cholmodified.f:C   WORKING PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       INDMAP          -   VECTOR OF SIZE NEQNS INTO WHICH THE GLOBAL
RandomFieldsUtils/src/cholmodified.f:C       RELIND          -   MAPS LOCATIONS IN THE UPDATING COLUMNS TO 
RandomFieldsUtils/src/cholmodified.f:C                           COLUMNS.  (RELIND IS GATHERED FROM INDMAP).
RandomFieldsUtils/src/cholmodified.f:C       TEMP            -   REAL VECTOR FOR ACCUMULATING UPDATES.  MUST
RandomFieldsUtils/src/cholmodified.f:C                           ACCOMODATE ALL COLUMNS OF A SUPERNODE. 
RandomFieldsUtils/src/cholmodified.f:     &                      INDMAP, RELIND, TMPSIZ, IFLAG )
RandomFieldsUtils/src/cholmodified.f:C       PARAMETERS.
RandomFieldsUtils/src/cholmodified.f:        INTEGER             INDMAP(*)     , LENGTH(*)     ,
RandomFieldsUtils/src/cholmodified.f:        INTEGER             IFLAG , NSUPER, TMPSIZ
RandomFieldsUtils/src/cholmodified.f:        DOUBLE PRECISION    TEMP(TMPSIZ) 
RandomFieldsUtils/src/cholmodified.f:C     RF: put TEMP(*) into a local variable
RandomFieldsUtils/src/cholmodified.f:        DOUBLE PRECISION MXDIAG
RandomFieldsUtils/src/cholmodified.f:C       INITIALIZE EMPTY ROW LISTS IN LINK(*) AND ZERO OUT TEMP(*).
RandomFieldsUtils/src/cholmodified.f:        DO  200  I = 1, TMPSIZ
RandomFieldsUtils/src/cholmodified.f:            TEMP(I) = 0.0D+00
RandomFieldsUtils/src/cholmodified.f:C       COMPUTE MAXIMUM DIAGONAL ELEMENT IN INPUT MATRIX
RandomFieldsUtils/src/cholmodified.f:        MXDIAG = 0.D0
RandomFieldsUtils/src/cholmodified.f:          MXDIAG = MAX(MXDIAG, LNZ(FJCOL))
RandomFieldsUtils/src/cholmodified.f:C           FJCOL  ...  FIRST COLUMN OF SUPERNODE JSUP.
RandomFieldsUtils/src/cholmodified.f:C           LJCOL  ...  LAST COLUMN OF SUPERNODE JSUP.
RandomFieldsUtils/src/cholmodified.f:C           NJCOLS ...  NUMBER OF COLUMNS IN SUPERNODE JSUP.
RandomFieldsUtils/src/cholmodified.f:C           JLEN   ...  LENGTH OF COLUMN FJCOL.
RandomFieldsUtils/src/cholmodified.f:C                       NONZERO IN COLUMN FJCOL.
RandomFieldsUtils/src/cholmodified.f:C           SET UP INDMAP(*) TO MAP THE ENTRIES IN UPDATE COLUMNS
RandomFieldsUtils/src/cholmodified.f:C           TO THEIR CORRESPONDING POSITIONS IN UPDATED COLUMNS, 
RandomFieldsUtils/src/cholmodified.f:C           RELATIVE THE THE BOTTOM OF EACH UPDATED COLUMN.
RandomFieldsUtils/src/cholmodified.f:            CALL  LDINDX ( JLEN, LINDX(JXPNT), INDMAP )
RandomFieldsUtils/src/cholmodified.f:C               GET INFO ABOUT THE CMOD(JSUP,KSUP) UPDATE.
RandomFieldsUtils/src/cholmodified.f:C               FKCOL  ...  FIRST COLUMN OF SUPERNODE KSUP.
RandomFieldsUtils/src/cholmodified.f:C               NKCOLS ...  NUMBER OF COLUMNS IN SUPERNODE KSUP.
RandomFieldsUtils/src/cholmodified.f:C               KLEN   ...  LENGTH OF ACTIVE PORTION OF COLUMN FKCOL.
RandomFieldsUtils/src/cholmodified.f:C                           PORTION OF COLUMN FJCOL.
RandomFieldsUtils/src/cholmodified.f:C               PERFORM CMOD(JSUP,KSUP), WITH SPECIAL CASES
RandomFieldsUtils/src/cholmodified.f:C                   SPARSE CMOD(JSUP,KSUP).
RandomFieldsUtils/src/cholmodified.f:C                   NCOLUP ... NUMBER OF COLUMNS TO BE UPDATED.
RandomFieldsUtils/src/cholmodified.f:C                       SUPERNODE (WITH ONE COLUMN).
RandomFieldsUtils/src/cholmodified.f:C                                   PORTION OF COLUMN FKCOL.
RandomFieldsUtils/src/cholmodified.f:                        CALL  MMPYI ( KLEN, NCOLUP, LINDX(KXPNT),
RandomFieldsUtils/src/cholmodified.f:     &                                LNZ(KLPNT), XLNZ, LNZ, INDMAP )
RandomFieldsUtils/src/cholmodified.f:C                                   SUPERNODE KSUP (FIRST COLUMN TO
RandomFieldsUtils/src/cholmodified.f:                        INDDIF = INDMAP(KFIRST) - INDMAP(KLAST)
RandomFieldsUtils/src/cholmodified.f:C                           DENSE CMOD(JSUP,KSUP).
RandomFieldsUtils/src/cholmodified.f:C                                       COLUMN KFIRST.
RandomFieldsUtils/src/cholmodified.f:C                           ILEN   ...  LENGTH OF COLUMN KFIRST.
RandomFieldsUtils/src/cholmodified.f:                            CALL  MMPY ( KLEN, NKCOLS, NCOLUP,
RandomFieldsUtils/src/cholmodified.f:C                           GENERAL SPARSE CMOD(JSUP,KSUP).
RandomFieldsUtils/src/cholmodified.f:C                           COMPUTE CMOD(JSUP,KSUP) UPDATE
RandomFieldsUtils/src/cholmodified.f:                            IF  ( STORE .GT. TMPSIZ )  THEN
RandomFieldsUtils/src/cholmodified.f:                            CALL  MMPY ( KLEN, NKCOLS, NCOLUP,
RandomFieldsUtils/src/cholmodified.f:     &                                   LNZ, TEMP, KLEN  )
RandomFieldsUtils/src/cholmodified.f:     &                                     INDMAP, RELIND )
RandomFieldsUtils/src/cholmodified.f:C                           INCORPORATE THE CMOD(JSUP,KSUP) BLOCK
RandomFieldsUtils/src/cholmodified.f:C                           UPDATE INTO THE TO APPROPRIATE COLUMNS
RandomFieldsUtils/src/cholmodified.f:                            CALL  ASSMB ( KLEN, NCOLUP, TEMP, RELIND,
RandomFieldsUtils/src/cholmodified.f:C                   DENSE CMOD(JSUP,KSUP).
RandomFieldsUtils/src/cholmodified.f:C                   JLPNT  ...  POINTER TO FIRST NONZERO IN COLUMN
RandomFieldsUtils/src/cholmodified.f:                    CALL  MMPY ( KLEN, NKCOLS, NJCOLS, SPLIT(FKCOL),
RandomFieldsUtils/src/cholmodified.f:C               IT WILL UPDATE AND DECREMENT KSUP'S ACTIVE
RandomFieldsUtils/src/cholmodified.f:C           APPLY PARTIAL CHOLESKY TO THE COLUMNS OF JSUP.
RandomFieldsUtils/src/cholmodified.f:     &                    MXDIAG, NTINY )
RandomFieldsUtils/src/cholmodified.f:C 699    FORMAT(1X,' FOUND ',I6,' TINY DIAGONALS; REPLACED WITH INF')
RandomFieldsUtils/src/cholmodified.f:C   Modified:       Sept 30, 1999 to improve efficiency in the case
RandomFieldsUtils/src/cholmodified.f:C       GIVEN THE CHOLESKY FACTORIZATION OF A SPARSE SYMMETRIC
RandomFieldsUtils/src/cholmodified.f:C       POSITIVE DEFINITE MATRIX, THIS SUBROUTINE PERFORMS THE
RandomFieldsUtils/src/cholmodified.f:C       BACKWARD TRIANGULAR SUBSTITUTION.  IT USES OUTPUT FROM BLKFCT.
RandomFieldsUtils/src/cholmodified.f:C   INPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       NSUPER          -   NUMBER OF SUPERNODES.
RandomFieldsUtils/src/cholmodified.f:C   UPDATED PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C   Modified:       Sept 30, 1999 to improve efficiency in the case
RandomFieldsUtils/src/cholmodified.f:C       GIVEN THE CHOLESKY FACTORIZATION OF A SPARSE SYMMETRIC
RandomFieldsUtils/src/cholmodified.f:C       POSITIVE DEFINITE MATRIX, THIS SUBROUTINE PERFORMS THE
RandomFieldsUtils/src/cholmodified.f:C       FORWARD TRIANGULAR SUBSTITUTIOn.  IT USES OUTPUT FROM BLKFCT.
RandomFieldsUtils/src/cholmodified.f:C   INPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       NSUPER          -   NUMBER OF SUPERNODES.
RandomFieldsUtils/src/cholmodified.f:C   UPDATED PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C   Modified:       Sept 30, 1999 to improve efficiency in the case
RandomFieldsUtils/src/cholmodified.f:C       GIVEN THE CHOLESKY FACTORIZATION OF A SPARSE SYMMETRIC
RandomFieldsUtils/src/cholmodified.f:C       POSITIVE DEFINITE MATRIX, THIS SUBROUTINE PERFORMS THE
RandomFieldsUtils/src/cholmodified.f:C       TRIANGULAR SOLUTION.  IT USES OUTPUT FROM BLKFCT.
RandomFieldsUtils/src/cholmodified.f:C   INPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       NSUPER          -   NUMBER OF SUPERNODES.
RandomFieldsUtils/src/cholmodified.f:C   UPDATED PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C       TO DETERMINE A BINARY TREE REPRESENTATION OF THE ELIMINATION 
RandomFieldsUtils/src/cholmodified.f:C       TREE, FOR WHICH EVERY "LAST CHILD" HAS THE MAXIMUM POSSIBLE
RandomFieldsUtils/src/cholmodified.f:C       COLUMN NONZERO COUNT IN THE FACTOR.  THE RETURNED REPRESENTATION 
RandomFieldsUtils/src/cholmodified.f:C   INPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       NEQNS           -   NUMBER OF EQUATIONS.
RandomFieldsUtils/src/cholmodified.f:C       PARENT          -   THE PARENT VECTOR OF THE ELIMINATION TREE.
RandomFieldsUtils/src/cholmodified.f:C                           IT IS ASSUMED THAT PARENT(I) > I EXCEPT OF
RandomFieldsUtils/src/cholmodified.f:C       COLCNT          -   COLUMN NONZERO COUNTS OF THE FACTOR.
RandomFieldsUtils/src/cholmodified.f:C   OUTPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C   WORKING PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C               OTHERWISE, BECOMES FIRST SON OF ITS PARENT.
RandomFieldsUtils/src/cholmodified.f:C   Modified by RF:   Eliminated the  MMPYN, SMXPY as arguments
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratoy
RandomFieldsUtils/src/cholmodified.f:C     PURPOSE - THIS ROUTINE PERFORMS CHOLESKY
RandomFieldsUtils/src/cholmodified.f:C               FACTORIZATION ON THE COLUMNS OF A SUPERNODE
RandomFieldsUtils/src/cholmodified.f:C               THAT HAVE RECEIVED ALL UPDATES FROM COLUMNS
RandomFieldsUtils/src/cholmodified.f:C     INPUT PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:C        M      - NUMBER OF ROWS (LENGTH OF THE FIRST COLUMN).
RandomFieldsUtils/src/cholmodified.f:C        N      - NUMBER OF COLUMNS IN THE SUPERNODE.
RandomFieldsUtils/src/cholmodified.f:C                 OF THE J-TH COLUMN OF THE SUPERNODE.
RandomFieldsUtils/src/cholmodified.f:C        X(*)   - CONTAINS THE COLUMNS OF OF THE SUPERNODE TO
RandomFieldsUtils/src/cholmodified.f:C        MMPY8  -  MATRIX-MATRIX MULTIPLY WITH 8 LOOP UNROLLING.
RandomFieldsUtils/src/cholmodified.f:C     OUTPUT PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:C        X(*)   - ON OUTPUT, CONTAINS THE FACTORED COLUMNS OF
RandomFieldsUtils/src/cholmodified.f:      SUBROUTINE  CHLSUP  ( M, N, SPLIT, XPNT, X, MXDIAG, NTINY
RandomFieldsUtils/src/cholmodified.f:C     PARAMETERS.
RandomFieldsUtils/src/cholmodified.f:      EXTERNAL            MMPY8
RandomFieldsUtils/src/cholmodified.f:      INTEGER             M, N
RandomFieldsUtils/src/cholmodified.f:      DOUBLE PRECISION    X(*), MXDIAG
RandomFieldsUtils/src/cholmodified.f:      INTEGER             FSTCOL, JBLK  , JPNT  , MM    , NN    ,
RandomFieldsUtils/src/cholmodified.f:        MM = M
RandomFieldsUtils/src/cholmodified.f:C           ... PERFORM PARTIAL CHOLESKY FACTORIZATION
RandomFieldsUtils/src/cholmodified.f:            CALL PCHOL ( MM, NN, XPNT(FSTCOL), X, MXDIAG, NTINY)
RandomFieldsUtils/src/cholmodified.f:C           ... APPLY THE COLUMNS IN JBLK TO ANY COLUMNS
RandomFieldsUtils/src/cholmodified.f:C               OF THE SUPERNODE REMAINING TO BE COMPUTED.
RandomFieldsUtils/src/cholmodified.f:            MM = MM - NN
RandomFieldsUtils/src/cholmodified.f:                CALL  MMPY8( MM, NN, Q, XPNT(FSTCOL), X, X(JPNT), MM )
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C       MAXIMIZES (AMONG THE CHILDREN) THE NUMBER OF NONZEROS IN THE 
RandomFieldsUtils/src/cholmodified.f:C       CORRESPONDING COLUMN OF L.  ALSO DETERMINE AN NEW POSTORDERING 
RandomFieldsUtils/src/cholmodified.f:C       BASED ON THE STRUCTURE OF THE MODIFIED ELIMINATION TREE.
RandomFieldsUtils/src/cholmodified.f:C   INPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       NEQNS           -   NUMBER OF EQUATIONS.
RandomFieldsUtils/src/cholmodified.f:C   UPDATED PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       (PERM,INVP)     -   ON INPUT, THE GIVEN PERM AND INVERSE PERM
RandomFieldsUtils/src/cholmodified.f:C                           VECTORS.  ON OUTPUT, THE NEW PERM AND
RandomFieldsUtils/src/cholmodified.f:C                           INVERSE PERM VECTORS OF THE NEW
RandomFieldsUtils/src/cholmodified.f:C       COLCNT          -   COLUMN COUNTS IN L UNDER INITIAL ORDERING;
RandomFieldsUtils/src/cholmodified.f:C                           MODIFIED TO REFLECT THE NEW ORDERING.
RandomFieldsUtils/src/cholmodified.f:C   OUTPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       PARENT          -   THE PARENT VECTOR OF THE ELIMINATION TREE
RandomFieldsUtils/src/cholmodified.f:C   WORKING PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       INVPOS          -   THE INVERSE PERM VECTOR FOR THE
RandomFieldsUtils/src/cholmodified.f:C   PROGRAM SUBROUTINES:
RandomFieldsUtils/src/cholmodified.f:      SUBROUTINE  CHORDR (  NEQNS , PERM  , INVP  ,
RandomFieldsUtils/src/cholmodified.f:     &                      PARENT(*)     , PERM(*)
RandomFieldsUtils/src/cholmodified.f:C       COMPUTE A BINARY REPRESENTATION OF THE ELIMINATION TREE, 
RandomFieldsUtils/src/cholmodified.f:C       SO THAT EACH "LAST CHILD" MAXIMIZES AMONG ITS SIBLINGS THE 
RandomFieldsUtils/src/cholmodified.f:C       NUMBER OF NONZEROS IN THE CORRESPONDING COLUMNS OF L.
RandomFieldsUtils/src/cholmodified.f:C       POSTORDER THE ELIMINATION TREE (USING THE NEW BINARY  
RandomFieldsUtils/src/cholmodified.f:     &                  COLCNT, PERM                            ) 
RandomFieldsUtils/src/cholmodified.f:C       COMPOSE THE ORIGINAL ORDERING WITH THE NEW POSTORDERING.
RandomFieldsUtils/src/cholmodified.f:        CALL  INVINV  ( NEQNS , INVP  , INVPOS, PERM    )
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C     PURPOSE - THIS ROUTINE COMPUTES A <-- AX, WHERE A IS A
RandomFieldsUtils/src/cholmodified.f:C     INPUT PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:C        A - SCALAR MULIPLIER.
RandomFieldsUtils/src/cholmodified.f:C     OUTPUT PARAMETERS - 
RandomFieldsUtils/src/cholmodified.f:C     PARAMETERS.
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C       ELIMINATION TREE, A POSTORDERING IS DETERMINED. THE
RandomFieldsUtils/src/cholmodified.f:C       CORRESPONDING PARENT AND COLCNT VECTORS ARE ALSO MODIFIED TO 
RandomFieldsUtils/src/cholmodified.f:C   INPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       ROOT            -   ROOT OF THE ELIMINATION TREE (USUALLY IT
RandomFieldsUtils/src/cholmodified.f:C   UPDATED PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       COLCNT          -   COLUMN NONZERO COUNTS OF THE FACTOR.
RandomFieldsUtils/src/cholmodified.f:C   OUTPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       INVPOS          -   INVERSE PERMUTATION FOR THE POSTORDERING.
RandomFieldsUtils/src/cholmodified.f:C   WORKING PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:        INTEGER(4)           ITOP  , NDPAR , NODE  , NUM   , NUNODE
RandomFieldsUtils/src/cholmodified.f:        NUM = 0
RandomFieldsUtils/src/cholmodified.f:C           IF POSSIBLE, POP A TREE NODE FROM THE STACK AND NUMBER IT.
RandomFieldsUtils/src/cholmodified.f:                NUM = NUM + 1
RandomFieldsUtils/src/cholmodified.f:                INVPOS(NODE) = NUM
RandomFieldsUtils/src/cholmodified.f:C       DETERMINE THE NEW PARENT VECTOR OF THE POSTORDERING.  BROTHR
RandomFieldsUtils/src/cholmodified.f:C       IS USED TEMPORARILY FOR THE NEW PARENT VECTOR.
RandomFieldsUtils/src/cholmodified.f:        DO  400  NODE = 1, NUM
RandomFieldsUtils/src/cholmodified.f:        DO  500  NUNODE = 1, NUM
RandomFieldsUtils/src/cholmodified.f:C       PERMUTE COLCNT(*) TO REFLECT THE NEW ORDERING.
RandomFieldsUtils/src/cholmodified.f:        DO  600  NODE = 1, NUM
RandomFieldsUtils/src/cholmodified.f:        DO  700  NODE = 1, NUM
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C**********     ETORDR ..... ELIMINATION TREE REORDERING     ***********
RandomFieldsUtils/src/cholmodified.f:C       TO DETERMINE AN EQUIVALENT REORDERING BASED ON THE STRUCTURE OF
RandomFieldsUtils/src/cholmodified.f:C       THE ELIMINATION TREE.  A POSTORDERING OF THE GIVEN ELIMINATION
RandomFieldsUtils/src/cholmodified.f:C   INPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       NEQNS           -   NUMBER OF EQUATIONS.
RandomFieldsUtils/src/cholmodified.f:C   UPDATED PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       (PERM,INVP)     -   ON INPUT, THE GIVEN PERM AND INVERSE PERM
RandomFieldsUtils/src/cholmodified.f:C                           VECTORS.  ON OUTPUT, THE NEW PERM AND
RandomFieldsUtils/src/cholmodified.f:C                           INVERSE PERM VECTORS OF THE EQUIVALENT
RandomFieldsUtils/src/cholmodified.f:C   OUTPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       PARENT          -   THE PARENT VECTOR OF THE ELIMINATION TREE
RandomFieldsUtils/src/cholmodified.f:C   WORKING PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       INVPOS          -   THE INVERSE PERM VECTOR FOR THE
RandomFieldsUtils/src/cholmodified.f:C   PROGRAM SUBROUTINES:
RandomFieldsUtils/src/cholmodified.f:      SUBROUTINE  ETORDR (  NEQNS , XADJ  , ADJNCY, PERM  , INVP  ,
RandomFieldsUtils/src/cholmodified.f:     &                      PERM(*)
RandomFieldsUtils/src/cholmodified.f:C       COMPUTE THE ELIMINATION TREE.
RandomFieldsUtils/src/cholmodified.f:        CALL  ETREE ( NEQNS, XADJ, ADJNCY, PERM, INVP, PARENT, INVPOS )
RandomFieldsUtils/src/cholmodified.f:C       COMPUTE A BINARY REPRESENTATION OF THE ELIMINATION TREE.
RandomFieldsUtils/src/cholmodified.f:C       POSTORDER THE ELIMINATION TREE.
RandomFieldsUtils/src/cholmodified.f:        CALL  ETPOST ( NEQNS, FSON, BROTHR, INVPOS, PARENT, PERM )
RandomFieldsUtils/src/cholmodified.f:C       COMPOSE THE ORIGINAL ORDERING WITH THE NEW POSTORDERING.
RandomFieldsUtils/src/cholmodified.f:        CALL  INVINV ( NEQNS, INVP, INVPOS, PERM )
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C       THE ELIMINATION TREE, A POSTORDERING IS DETERMINED. THE
RandomFieldsUtils/src/cholmodified.f:C       CORRESPONDING PARENT VECTOR IS ALSO MODIFIED TO REFLECT
RandomFieldsUtils/src/cholmodified.f:C   INPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       ROOT            -   ROOT OF THE ELIMINATION TREE (USUALLY IT
RandomFieldsUtils/src/cholmodified.f:C   UPDATED PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C   OUTPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       INVPOS          -   INVERSE PERMUTATION FOR THE POSTORDERING.
RandomFieldsUtils/src/cholmodified.f:C   WORKING PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:        INTEGER(4)           ITOP  , NDPAR , NODE  , NUM   , NUNODE
RandomFieldsUtils/src/cholmodified.f:        NUM = 0
RandomFieldsUtils/src/cholmodified.f:C           IF POSSIBLE, POP A TREE NODE FROM THE STACK AND NUMBER IT.
RandomFieldsUtils/src/cholmodified.f:                NUM = NUM + 1
RandomFieldsUtils/src/cholmodified.f:                INVPOS(NODE) = NUM
RandomFieldsUtils/src/cholmodified.f:C       DETERMINE THE NEW PARENT VECTOR OF THE POSTORDERING.  BROTHR
RandomFieldsUtils/src/cholmodified.f:C       IS USED TEMPORARILY FOR THE NEW PARENT VECTOR.
RandomFieldsUtils/src/cholmodified.f:        DO  400  NODE = 1, NUM
RandomFieldsUtils/src/cholmodified.f:        DO  500  NUNODE = 1, NUM
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C****************     ETREE ..... ELIMINATION TREE     *****************
RandomFieldsUtils/src/cholmodified.f:C       TO DETERMINE THE ELIMINATION TREE FROM A GIVEN ORDERING AND
RandomFieldsUtils/src/cholmodified.f:C   INPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       NEQNS           -   NUMBER OF EQUATIONS.
RandomFieldsUtils/src/cholmodified.f:C       (PERM,INVP)     -   PERMUTATION AND INVERSE PERMUTATION VECTORS
RandomFieldsUtils/src/cholmodified.f:C   OUTPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       PARENT          -   THE PARENT VECTOR OF THE ELIMINATION TREE.
RandomFieldsUtils/src/cholmodified.f:C   WORKING PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:      SUBROUTINE  ETREE (   NEQNS , XADJ  , ADJNCY, PERM  , INVP  ,
RandomFieldsUtils/src/cholmodified.f:     &                      PERM(*)
RandomFieldsUtils/src/cholmodified.f:            NODE = PERM(I)
RandomFieldsUtils/src/cholmodified.f:C                       ELIMINATION TREE.  PERFORM PATH COMPRESSION
RandomFieldsUtils/src/cholmodified.f:C                       NOW, NBR IS THE ROOT OF THE SUBTREE.  MAKE I
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C       THIS SUBROUTINE DETERMINES THE ROW COUNTS AND COLUMN COUNTS IN
RandomFieldsUtils/src/cholmodified.f:C       THE CHOLESKY FACTOR.  IT USES A DISJOINT SET UNION ALGORITHM.
RandomFieldsUtils/src/cholmodified.f:C       1) ASSUMES A POSTORDERING OF THE ELIMINATION TREE.
RandomFieldsUtils/src/cholmodified.f:C   INPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       (I) NEQNS       -   NUMBER OF EQUATIONS.
RandomFieldsUtils/src/cholmodified.f:C       (I) PERM(*)     -   ARRAY OF LENGTH NEQNS, CONTAINING THE
RandomFieldsUtils/src/cholmodified.f:C                           ELIMINATION TREE OF THE POSTORDERED MATRIX.
RandomFieldsUtils/src/cholmodified.f:C   OUTPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       (I) ROWCNT(*)   -   ARRAY OF LENGTH NEQNS, CONTAINING THE NUMBER
RandomFieldsUtils/src/cholmodified.f:C       (I) COLCNT(*)   -   ARRAY OF LENGTH NEQNS, CONTAINING THE NUMBER
RandomFieldsUtils/src/cholmodified.f:C                           OF NONZEROS IN EACH COLUMN OF THE FACTOR,
RandomFieldsUtils/src/cholmodified.f:C       (I) NLNZ        -   NUMBER OF NONZEROS IN THE FACTOR, INCLUDING
RandomFieldsUtils/src/cholmodified.f:C   WORK PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       (I) SET(*)      -   ARRAY OF LENGTH NEQNS USED TO MAINTAIN THE
RandomFieldsUtils/src/cholmodified.f:C                           (DISTANCE FROM THE ROOT).
RandomFieldsUtils/src/cholmodified.f:C                           USED TO COMPUTE COLUMN COUNTS.
RandomFieldsUtils/src/cholmodified.f:C                           FIRST (I.E., LOWEST-NUMBERED) DESCENDANT.
RandomFieldsUtils/src/cholmodified.f:C                           NUMBER OF CHILDREN.
RandomFieldsUtils/src/cholmodified.f:      SUBROUTINE FCNTHN  (  NEQNS , ADJLEN, XADJ  , ADJNCY, PERM  ,
RandomFieldsUtils/src/cholmodified.f:C       PARAMETERS.
RandomFieldsUtils/src/cholmodified.f:     &                      NCHILD(0:NEQNS) , PERM(NEQNS)   ,
RandomFieldsUtils/src/cholmodified.f:     &                      LOWNBR, OLDNBR, PARENT, PLEAF , TEMP  , 
RandomFieldsUtils/src/cholmodified.f:C       COMPUTE LEVEL(*), FDESC(*), NCHILD(*).
RandomFieldsUtils/src/cholmodified.f:            OLDNBR = PERM(LOWNBR)
RandomFieldsUtils/src/cholmodified.f:C                       INCREMENT WEIGHT(LOWNBR).
RandomFieldsUtils/src/cholmodified.f:C                           ... ACCUMULATE LOWNBR-->HINBR PATH LENGTH 
RandomFieldsUtils/src/cholmodified.f:C                               IS THE LEAST COMMON ANCESTOR OF PLEAF 
RandomFieldsUtils/src/cholmodified.f:C                           ACCUMULATE PLEAF-->LCA PATH LENGTH IN 
RandomFieldsUtils/src/cholmodified.f:C                           DECREMENT WEIGHT(LCA).
RandomFieldsUtils/src/cholmodified.f:C                       LOWNBR NOW BECOMES ``PREVIOUS LEAF'' OF HINBR.
RandomFieldsUtils/src/cholmodified.f:C                   LOWNBR NOW BECOMES ``PREVIOUS NEIGHBOR'' OF HINBR.
RandomFieldsUtils/src/cholmodified.f:C           DECREMENT WEIGHT ( PARENT(LOWNBR) ).
RandomFieldsUtils/src/cholmodified.f:C       USE WEIGHTS TO COMPUTE COLUMN (AND TOTAL) NONZERO COUNTS.
RandomFieldsUtils/src/cholmodified.f:            TEMP = COLCNT(K) + WEIGHT(K)
RandomFieldsUtils/src/cholmodified.f:            COLCNT(K) = TEMP
RandomFieldsUtils/src/cholmodified.f:            NLNZ = NLNZ + TEMP
RandomFieldsUtils/src/cholmodified.f:                COLCNT(PARENT) = COLCNT(PARENT) + TEMP
RandomFieldsUtils/src/cholmodified.f:C   Last modified:  May 26, 1995
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C****     FNSPLT ..... COMPUTE FINE PARTITIONING OF SUPERNODES     *****
RandomFieldsUtils/src/cholmodified.f:C       THIS SUBROUTINE DETERMINES A FINE PARTITIONING OF SUPERNODES
RandomFieldsUtils/src/cholmodified.f:C       WHEN THERE IS A CACHE AVAILABLE ON THE MACHINE.  THE FINE
RandomFieldsUtils/src/cholmodified.f:C       PARTITIONING IS CHOSEN SO THAT DATA RE-USE IS MAXIMIZED.
RandomFieldsUtils/src/cholmodified.f:C   INPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       NEQNS           -   NUMBER OF EQUATIONS.
RandomFieldsUtils/src/cholmodified.f:C       NSUPER          -   NUMBER OF SUPERNODES.
RandomFieldsUtils/src/cholmodified.f:C   OUTPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       PARAMETERS.
RandomFieldsUtils/src/cholmodified.f:C       COMPUTE THE NUMBER OF 8-BYTE WORDS IN CACHE.
RandomFieldsUtils/src/cholmodified.f:C           ... UNTIL ALL COLUMNS OF THE SUPERNODE 
RandomFieldsUtils/src/cholmodified.f:C               ... PLACE THE FIRST COLUMN(S) IN THE CACHE.
RandomFieldsUtils/src/cholmodified.f:C                   THERE ARE COLUMNS OF THE SUPERNODE 
RandomFieldsUtils/src/cholmodified.f:C                   REMAINING TO BE PROCESSED ...
RandomFieldsUtils/src/cholmodified.f:C                   ... ADD ANOTHER COLUMN TO CACHE.
RandomFieldsUtils/src/cholmodified.f:C               ... RECORD THE NUMBER OF COLUMNS THAT 
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C******     FNTSIZ ..... COMPUTE WORK STORAGE SIZE FOR BLKFCT     ******
RandomFieldsUtils/src/cholmodified.f:C       THIS SUBROUTINE DETERMINES THE SIZE OF THE WORKING STORAGE
RandomFieldsUtils/src/cholmodified.f:C   INPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       NSUPER          -   NUMBER OF SUPERNODES.
RandomFieldsUtils/src/cholmodified.f:C       SNODE           -   SUPERNODE MEMBERSHIP.
RandomFieldsUtils/src/cholmodified.f:C   OUTPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       TMPSIZ          -   SIZE OF WORKING STORAGE REQUIRED BY BLKFCT.
RandomFieldsUtils/src/cholmodified.f:     &                       LINDX , TMPSIZ  )
RandomFieldsUtils/src/cholmodified.f:        INTEGER     NSUPER, TMPSIZ
RandomFieldsUtils/src/cholmodified.f:C       RETURNS SIZE OF TEMP ARRAY USED BY BLKFCT FACTORIZATION ROUTINE.
RandomFieldsUtils/src/cholmodified.f:C       NOTE THAT THE VALUE RETURNED IS AN ESTIMATE, THOUGH IT IS USUALLY
RandomFieldsUtils/src/cholmodified.f:C       COMPUTE SIZE OF TEMPORARY STORAGE VECTOR
RandomFieldsUtils/src/cholmodified.f:        TMPSIZ = 0
RandomFieldsUtils/src/cholmodified.f:            IF  ( BOUND .GT. TMPSIZ )  THEN
RandomFieldsUtils/src/cholmodified.f:                                TMPSIZ = MAX ( TSIZE , TMPSIZ )
RandomFieldsUtils/src/cholmodified.f:                            TMPSIZ = MAX ( TSIZE , TMPSIZ )
RandomFieldsUtils/src/cholmodified.f:                        IF  ( BOUND .LE. TMPSIZ )  GO TO 500
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C       MAXIMAL SUPERNODE PARTITION.  IT RETURNS ONLY THE NUMBER OF
RandomFieldsUtils/src/cholmodified.f:C       SUPERNODES NSUPER AND THE SUPERNODE MEMBERSHIP VECTOR SNODE(*), 
RandomFieldsUtils/src/cholmodified.f:C       COMPUTED SUBSEQUENTLY BY THE COMPANION ROUTINE FSUP2.
RandomFieldsUtils/src/cholmodified.f:C   METHOD AND ASSUMPTIONS:
RandomFieldsUtils/src/cholmodified.f:C       THIS ROUTINE USES THE ELIMINATION TREE AND THE FACTOR COLUMN 
RandomFieldsUtils/src/cholmodified.f:C       COUNTS TO COMPUTE THE SUPERNODE PARTITION; IT ALSO ASSUMES A 
RandomFieldsUtils/src/cholmodified.f:C       POSTORDERING OF THE ELIMINATION TREE.
RandomFieldsUtils/src/cholmodified.f:C   INPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       (I) NEQNS       -   NUMBER OF EQUATIONS.
RandomFieldsUtils/src/cholmodified.f:C                           ELIMINATION TREE OF THE POSTORDERED MATRIX.
RandomFieldsUtils/src/cholmodified.f:C                           FACTOR COLUMN COUNTS: I.E., THE NUMBER OF 
RandomFieldsUtils/src/cholmodified.f:C                           NONZERO ENTRIES IN EACH COLUMN OF L
RandomFieldsUtils/src/cholmodified.f:C   OUTPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       (I) NOFSUB      -   NUMBER OF SUBSCRIPTS.
RandomFieldsUtils/src/cholmodified.f:C       (I) NSUPER      -   NUMBER OF SUPERNODES (<= NEQNS).
RandomFieldsUtils/src/cholmodified.f:C                           SUPERNODE MEMBERSHIP.
RandomFieldsUtils/src/cholmodified.f:C   LAST UPDATED ON     NOVEMBER 11, 1994.
RandomFieldsUtils/src/cholmodified.f:C       PARAMETERS.
RandomFieldsUtils/src/cholmodified.f:C       COMPUTE THE FUNDAMENTAL SUPERNODE PARTITION.
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C       MAXIMAL SUPERNODE PARTITION.  IT'S SOLE PURPOSE IS TO 
RandomFieldsUtils/src/cholmodified.f:C       FIRST ROUTINE FSUP1 COMPUTES THE NUMBER OF SUPERNODES AND THE 
RandomFieldsUtils/src/cholmodified.f:C       SUPERNODE MEMBERSHIP VECTOR SNODE(*), WHICH IS OF LENGTH NEQNS.
RandomFieldsUtils/src/cholmodified.f:C   ASSUMPTIONS:
RandomFieldsUtils/src/cholmodified.f:C       THIS ROUTINE ASSUMES A POSTORDERING OF THE ELIMINATION TREE.  IT
RandomFieldsUtils/src/cholmodified.f:C       ALSO ASSUMES THAT THE OUTPUT FROM FSUP1 IS AVAILABLE.
RandomFieldsUtils/src/cholmodified.f:C   INPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       (I) NEQNS       -   NUMBER OF EQUATIONS.
RandomFieldsUtils/src/cholmodified.f:C       (I) NSUPER      -   NUMBER OF SUPERNODES (<= NEQNS).
RandomFieldsUtils/src/cholmodified.f:C                           SUPERNODE MEMBERSHIP.
RandomFieldsUtils/src/cholmodified.f:C   OUTPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C   LAST UPDATED ON     NOVEMEBER 22, 1994.
RandomFieldsUtils/src/cholmodified.f:C       PARAMETERS.
RandomFieldsUtils/src/cholmodified.f:C       COMPUTE THE SUPERNODE PARTITION VECTOR XSUPER(*).
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C--- SPARSPAK-A (ANSI FORTRAN) RELEASE III --- NAME = GENMMD
RandomFieldsUtils/src/cholmodified.f:C****     GENMMD ..... MULTIPLE MINIMUM EXTERNAL DEGREE     ************
RandomFieldsUtils/src/cholmodified.f:C     PURPOSE - THIS ROUTINE IMPLEMENTS THE MINIMUM DEGREE
RandomFieldsUtils/src/cholmodified.f:C        ALGORITHM.  IT MAKES USE OF THE IMPLICIT REPRESENTATION
RandomFieldsUtils/src/cholmodified.f:C        OF ELIMINATION GRAPHS BY QUOTIENT GRAPHS, AND THE
RandomFieldsUtils/src/cholmodified.f:C        NOTION OF INDISTINGUISHABLE NODES.  IT ALSO IMPLEMENTS
RandomFieldsUtils/src/cholmodified.f:C        THE MODIFICATIONS BY MULTIPLE ELIMINATION AND MINIMUM
RandomFieldsUtils/src/cholmodified.f:C     INPUT PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:C        NEQNS  - NUMBER OF EQUATIONS.
RandomFieldsUtils/src/cholmodified.f:C        DELTA  - TOLERANCE VALUE FOR MULTIPLE ELIMINATION.
RandomFieldsUtils/src/cholmodified.f:C        MAXINT - MAXIMUM MACHINE REPRESENTABLE (SHORT) INTEGER
RandomFieldsUtils/src/cholmodified.f:C                 (ANY SMALLER ESTIMATE WILL DO) FOR MARKING
RandomFieldsUtils/src/cholmodified.f:C     OUTPUT PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:C        PERM   - THE MINIMUM DEGREE ORDERING.
RandomFieldsUtils/src/cholmodified.f:C        INVP   - THE INVERSE OF PERM.
RandomFieldsUtils/src/cholmodified.f:C        NOFSUB - AN UPPER BOUND ON THE NUMBER OF NONZERO
RandomFieldsUtils/src/cholmodified.f:C                 SUBSCRIPTS FOR THE COMPRESSED STORAGE SCHEME.
RandomFieldsUtils/src/cholmodified.f:C     WORKING PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:C        INVP   - USED TEMPORARILY FOR DEGREE FORWARD LINK.
RandomFieldsUtils/src/cholmodified.f:C        PERM   - USED TEMPORARILY FOR DEGREE BACKWARD LINK.
RandomFieldsUtils/src/cholmodified.f:C        LLIST  - VECTOR FOR TEMPORARY LINKED LISTS.
RandomFieldsUtils/src/cholmodified.f:C        MARKER - A TEMPORARY MARKER VECTOR.
RandomFieldsUtils/src/cholmodified.f:C     PROGRAM SUBROUTINES -
RandomFieldsUtils/src/cholmodified.f:C        MMDELM, MMDINT, MMDNUM, MMDUPD.
RandomFieldsUtils/src/cholmodified.f:      SUBROUTINE  GENMMD ( NEQNS, XADJ, ADJNCY, INVP, PERM,
RandomFieldsUtils/src/cholmodified.f:     1                     DELTA, DHEAD, QSIZE, LLIST, MARKER,
RandomFieldsUtils/src/cholmodified.f:     1                     MAXINT, NOFSUB )
RandomFieldsUtils/src/cholmodified.f:     1              MARKER(*), PERM(*)  , QSIZE(*)
RandomFieldsUtils/src/cholmodified.f:         INTEGER    DELTA , EHEAD , I     , MAXINT, MDEG  ,
RandomFieldsUtils/src/cholmodified.f:     1              MDLMT , MDNODE, NEQNS , NEXTMD, NOFSUB,
RandomFieldsUtils/src/cholmodified.f:     1              NUM, TAG
RandomFieldsUtils/src/cholmodified.f:C        INITIALIZATION FOR THE MINIMUM DEGREE ALGORITHM.
RandomFieldsUtils/src/cholmodified.f:         CALL  MMDINT ( NEQNS, XADJ, DHEAD, INVP, PERM,
RandomFieldsUtils/src/cholmodified.f:     1                  QSIZE, LLIST, MARKER )
RandomFieldsUtils/src/cholmodified.f:C        NUM COUNTS THE NUMBER OF ORDERED NODES PLUS 1.
RandomFieldsUtils/src/cholmodified.f:         NUM = 1
RandomFieldsUtils/src/cholmodified.f:C        ELIMINATE ALL ISOLATED NODES.
RandomFieldsUtils/src/cholmodified.f:         NEXTMD = DHEAD(1)
RandomFieldsUtils/src/cholmodified.f:             IF  ( NEXTMD .LE. 0 )  GO TO 200
RandomFieldsUtils/src/cholmodified.f:                 MDNODE = NEXTMD
RandomFieldsUtils/src/cholmodified.f:                 NEXTMD = INVP(MDNODE)
RandomFieldsUtils/src/cholmodified.f:                 MARKER(MDNODE) = MAXINT
RandomFieldsUtils/src/cholmodified.f:                 INVP(MDNODE) = - NUM
RandomFieldsUtils/src/cholmodified.f:                 NUM = NUM + 1
RandomFieldsUtils/src/cholmodified.f:C        SEARCH FOR NODE OF THE MINIMUM DEGREE.
RandomFieldsUtils/src/cholmodified.f:C        MDEG IS THE CURRENT MINIMUM DEGREE;
RandomFieldsUtils/src/cholmodified.f:C        TAG IS USED TO FACILITATE MARKING NODES.
RandomFieldsUtils/src/cholmodified.f:         IF  ( NUM .GT. NEQNS )  GO TO 1000
RandomFieldsUtils/src/cholmodified.f:         MDEG = 2
RandomFieldsUtils/src/cholmodified.f:             IF  ( DHEAD(MDEG) .GT. 0 )  GO TO 400
RandomFieldsUtils/src/cholmodified.f:                 MDEG = MDEG + 1
RandomFieldsUtils/src/cholmodified.f:C            USE VALUE OF DELTA TO SET UP MDLMT, WHICH GOVERNS
RandomFieldsUtils/src/cholmodified.f:C            WHEN A DEGREE UPDATE IS TO BE PERFORMED.
RandomFieldsUtils/src/cholmodified.f:             MDLMT = MDEG + DELTA
RandomFieldsUtils/src/cholmodified.f:                 MDNODE = DHEAD(MDEG)
RandomFieldsUtils/src/cholmodified.f:                 IF  ( MDNODE .GT. 0 )  GO TO 600
RandomFieldsUtils/src/cholmodified.f:                     MDEG = MDEG + 1
RandomFieldsUtils/src/cholmodified.f:                     IF  ( MDEG .GT. MDLMT )  GO TO 900
RandomFieldsUtils/src/cholmodified.f:C                REMOVE MDNODE FROM THE DEGREE STRUCTURE.
RandomFieldsUtils/src/cholmodified.f:                 NEXTMD = INVP(MDNODE)
RandomFieldsUtils/src/cholmodified.f:                 DHEAD(MDEG) = NEXTMD
RandomFieldsUtils/src/cholmodified.f:                 IF  ( NEXTMD .GT. 0 )  PERM(NEXTMD) = - MDEG
RandomFieldsUtils/src/cholmodified.f:                 INVP(MDNODE) = - NUM
RandomFieldsUtils/src/cholmodified.f:                 NOFSUB = NOFSUB + MDEG + QSIZE(MDNODE) - 2
RandomFieldsUtils/src/cholmodified.f:                 IF  ( NUM+QSIZE(MDNODE) .GT. NEQNS )  GO TO 1000
RandomFieldsUtils/src/cholmodified.f:C                ELIMINATE MDNODE AND PERFORM QUOTIENT GRAPH
RandomFieldsUtils/src/cholmodified.f:C                TRANSFORMATION.  RESET TAG VALUE IF NECESSARY.
RandomFieldsUtils/src/cholmodified.f:                 IF  ( TAG .LT. MAXINT )  GO TO 800
RandomFieldsUtils/src/cholmodified.f:                         IF  ( MARKER(I) .LT. MAXINT )  MARKER(I) = 0
RandomFieldsUtils/src/cholmodified.f:                 CALL  MMDELM ( MDNODE, XADJ, ADJNCY, DHEAD, INVP,
RandomFieldsUtils/src/cholmodified.f:     1                          PERM, QSIZE, LLIST, MARKER, MAXINT,
RandomFieldsUtils/src/cholmodified.f:                 NUM = NUM + QSIZE(MDNODE)
RandomFieldsUtils/src/cholmodified.f:                 LLIST(MDNODE) = EHEAD
RandomFieldsUtils/src/cholmodified.f:                 EHEAD = MDNODE
RandomFieldsUtils/src/cholmodified.f:C            MINIMUM DEGREE NODES ELIMINATION.
RandomFieldsUtils/src/cholmodified.f:             IF  ( NUM .GT. NEQNS )  GO TO 1000
RandomFieldsUtils/src/cholmodified.f:             CALL  MMDUPD ( EHEAD, NEQNS, XADJ, ADJNCY, DELTA, MDEG,
RandomFieldsUtils/src/cholmodified.f:     1                      DHEAD, INVP, PERM, QSIZE, LLIST, MARKER,
RandomFieldsUtils/src/cholmodified.f:     1                      MAXINT, TAG )
RandomFieldsUtils/src/cholmodified.f:         CALL  MMDNUM ( NEQNS, PERM, INVP, QSIZE )
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C     PURPOSE - THIS ROUTINE PERFORMS A STANDARD INTEGER GATHER
RandomFieldsUtils/src/cholmodified.f:C     INPUT PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:C        INDMAP - INDEXED BY GLOBAL INDICES, IT CONTAINS THE
RandomFieldsUtils/src/cholmodified.f:C     OUTPUT PARAMETERS - 
RandomFieldsUtils/src/cholmodified.f:      SUBROUTINE  IGATHR ( KLEN  , LINDX, INDMAP, RELIND )
RandomFieldsUtils/src/cholmodified.f:C     PARAMETERS.
RandomFieldsUtils/src/cholmodified.f:      INTEGER             INDMAP(*), LINDX (*), RELIND(*)
RandomFieldsUtils/src/cholmodified.f:          RELIND(I) = INDMAP(LINDX(I))
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C     INPUT NUMERICAL VALUES INTO SPARSE DATA STRUCTURES ...
RandomFieldsUtils/src/cholmodified.f:      SUBROUTINE  INPNV  (  XADJF, ADJF, ANZF, PERM, INVP,
RandomFieldsUtils/src/cholmodified.f:        INTEGER             PERM(*), INVP(*)
RandomFieldsUtils/src/cholmodified.f:C           FIRST GET OFFSET TO FACILITATE NUMERICAL INPUT.
RandomFieldsUtils/src/cholmodified.f:C               FOR EACH COLUMN IN THE CURRENT SUPERNODE,
RandomFieldsUtils/src/cholmodified.f:                OLDJ = PERM(J)
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C       TO PERFORM THE MAPPING OF
RandomFieldsUtils/src/cholmodified.f:C           ORIGINAL-INVP --> INTERMEDIATE-INVP --> NEW INVP
RandomFieldsUtils/src/cholmodified.f:C       AND THE RESULTING ORDERING REPLACES INVP.  THE NEW PERMUTATION
RandomFieldsUtils/src/cholmodified.f:C       VECTOR PERM IS ALSO COMPUTED.
RandomFieldsUtils/src/cholmodified.f:C   INPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       NEQNS           -   NUMBER OF EQUATIONS.
RandomFieldsUtils/src/cholmodified.f:C       INVP2           -   THE SECOND INVERSE PERMUTATION VECTOR.
RandomFieldsUtils/src/cholmodified.f:C   UPDATED PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       INVP            -   THE FIRST INVERSE PERMUTATION VECTOR.  ON
RandomFieldsUtils/src/cholmodified.f:C                           PERMUTATION.
RandomFieldsUtils/src/cholmodified.f:C   OUTPUT PARAMETER:
RandomFieldsUtils/src/cholmodified.f:C       PERM            -   NEW PERMUTATION VECTOR (CAN BE THE SAME AS
RandomFieldsUtils/src/cholmodified.f:      SUBROUTINE  INVINV (  NEQNS , INVP  , INVP2 , PERM            )
RandomFieldsUtils/src/cholmodified.f:     &                      PERM(*)
RandomFieldsUtils/src/cholmodified.f:        INTEGER(4)           I     , INTERM, NODE
RandomFieldsUtils/src/cholmodified.f:            INTERM = INVP(I)
RandomFieldsUtils/src/cholmodified.f:            INVP(I) = INVP2(INTERM)
RandomFieldsUtils/src/cholmodified.f:            PERM(NODE) = I
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C     PURPOSE - THIS ROUTINE COMPUTES THE SECOND INDEX VECTOR
RandomFieldsUtils/src/cholmodified.f:C               USED TO IMPLEMENT THE DOUBLY-INDIRECT SAXPY-LIKE
RandomFieldsUtils/src/cholmodified.f:C               LOOPS THAT ALLOW US TO ACCUMULATE UPDATE 
RandomFieldsUtils/src/cholmodified.f:C               COLUMNS DIRECTLY INTO FACTOR STORAGE.
RandomFieldsUtils/src/cholmodified.f:C     INPUT PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:C        JLEN   - LENGTH OF THE FIRST COLUMN OF THE SUPERNODE,
RandomFieldsUtils/src/cholmodified.f:C                 COLUMN OF THE SUPERNODE.
RandomFieldsUtils/src/cholmodified.f:C     OUTPUT PARAMETERS - 
RandomFieldsUtils/src/cholmodified.f:C        INDMAP - THIS INDEX VECTOR MAPS EVERY GLOBAL ROW INDEX
RandomFieldsUtils/src/cholmodified.f:C                 OF NONZERO ENTRIES IN THE FIRST COLUMN OF THE 
RandomFieldsUtils/src/cholmodified.f:C                 RELATIVE TO THE LAST INDEX IN THE LIST.  MORE
RandomFieldsUtils/src/cholmodified.f:C                 FROM THE LAST INDEX IN THE LIST.
RandomFieldsUtils/src/cholmodified.f:      SUBROUTINE  LDINDX ( JLEN, LINDX, INDMAP )
RandomFieldsUtils/src/cholmodified.f:C     PARAMETERS.
RandomFieldsUtils/src/cholmodified.f:      INTEGER             LINDX(*), INDMAP(*)
RandomFieldsUtils/src/cholmodified.f:          INDMAP(JSUB) = CURLEN
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C--- SPARSPAK-A (ANSI FORTRAN) RELEASE III --- NAME = MMDELM
RandomFieldsUtils/src/cholmodified.f:C**     MMDELM ..... MULTIPLE MINIMUM DEGREE ELIMINATION     ***********
RandomFieldsUtils/src/cholmodified.f:C     PURPOSE - THIS ROUTINE ELIMINATES THE NODE MDNODE OF
RandomFieldsUtils/src/cholmodified.f:C        MINIMUM DEGREE FROM THE ADJACENCY STRUCTURE, WHICH
RandomFieldsUtils/src/cholmodified.f:C        IS STORED IN THE QUOTIENT GRAPH FORMAT.  IT ALSO
RandomFieldsUtils/src/cholmodified.f:C        TRANSFORMS THE QUOTIENT GRAPH REPRESENTATION OF THE
RandomFieldsUtils/src/cholmodified.f:C        ELIMINATION GRAPH.
RandomFieldsUtils/src/cholmodified.f:C     INPUT PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:C        MDNODE - NODE OF MINIMUM DEGREE.
RandomFieldsUtils/src/cholmodified.f:C        MAXINT - ESTIMATE OF MAXIMUM REPRESENTABLE (SHORT)
RandomFieldsUtils/src/cholmodified.f:C     UPDATED PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:C        MARKER - MARKER VECTOR.
RandomFieldsUtils/src/cholmodified.f:C        LLIST  - TEMPORARY LINKED LIST OF ELIMINATED NABORS.
RandomFieldsUtils/src/cholmodified.f:      SUBROUTINE  MMDELM ( MDNODE, XADJ, ADJNCY, DHEAD, DFORW,
RandomFieldsUtils/src/cholmodified.f:     1                     DBAKW, QSIZE, LLIST, MARKER, MAXINT,
RandomFieldsUtils/src/cholmodified.f:     1              LLIST(*) , MARKER(*), QSIZE(*)
RandomFieldsUtils/src/cholmodified.f:         INTEGER    ELMNT , I     , ISTOP , ISTRT , J     ,
RandomFieldsUtils/src/cholmodified.f:     1              JSTOP , JSTRT , LINK  , MAXINT, MDNODE,
RandomFieldsUtils/src/cholmodified.f:     1              PVNODE, RLMT  , RLOC  , RNODE , TAG   ,
RandomFieldsUtils/src/cholmodified.f:         MARKER(MDNODE) = TAG
RandomFieldsUtils/src/cholmodified.f:         ISTRT = XADJ(MDNODE)
RandomFieldsUtils/src/cholmodified.f:         ISTOP = XADJ(MDNODE+1) - 1
RandomFieldsUtils/src/cholmodified.f:C        ELMNT POINTS TO THE BEGINNING OF THE LIST OF ELIMINATED
RandomFieldsUtils/src/cholmodified.f:C        NABORS OF MDNODE, AND RLOC GIVES THE STORAGE LOCATION
RandomFieldsUtils/src/cholmodified.f:         ELMNT = 0
RandomFieldsUtils/src/cholmodified.f:         RLMT = ISTOP
RandomFieldsUtils/src/cholmodified.f:                 IF  ( MARKER(NABOR) .GE. TAG )  GO TO 200
RandomFieldsUtils/src/cholmodified.f:                     MARKER(NABOR) = TAG
RandomFieldsUtils/src/cholmodified.f:                     LLIST(NABOR) = ELMNT
RandomFieldsUtils/src/cholmodified.f:                     ELMNT = NABOR
RandomFieldsUtils/src/cholmodified.f:C            MERGE WITH REACHABLE NODES FROM GENERALIZED ELEMENTS.
RandomFieldsUtils/src/cholmodified.f:             IF  ( ELMNT .LE. 0 )  GO TO 1000
RandomFieldsUtils/src/cholmodified.f:                 ADJNCY(RLMT) = - ELMNT
RandomFieldsUtils/src/cholmodified.f:                 LINK = ELMNT
RandomFieldsUtils/src/cholmodified.f:                         IF  ( MARKER(NODE) .GE. TAG  .OR.
RandomFieldsUtils/src/cholmodified.f:                             MARKER(NODE) = TAG
RandomFieldsUtils/src/cholmodified.f:C                            USE STORAGE FROM ELIMINATED NODES
RandomFieldsUtils/src/cholmodified.f:                                 IF  ( RLOC .LT. RLMT )  GO TO 700
RandomFieldsUtils/src/cholmodified.f:                                     LINK = - ADJNCY(RLMT)
RandomFieldsUtils/src/cholmodified.f:                                     RLMT = XADJ(LINK+1) - 1
RandomFieldsUtils/src/cholmodified.f:                 ELMNT = LLIST(ELMNT)
RandomFieldsUtils/src/cholmodified.f:         IF  ( RLOC .LE. RLMT )  ADJNCY(RLOC) = 0
RandomFieldsUtils/src/cholmodified.f:         LINK = MDNODE
RandomFieldsUtils/src/cholmodified.f:     1                 PVNODE .EQ. (-MAXINT) )  GO TO 1300
RandomFieldsUtils/src/cholmodified.f:C                    THEN REMOVE RNODE FROM THE STRUCTURE.
RandomFieldsUtils/src/cholmodified.f:                         IF  ( MARKER(NABOR) .GE. TAG )  GO TO 1400
RandomFieldsUtils/src/cholmodified.f:C                    THEN MERGE RNODE WITH MDNODE.
RandomFieldsUtils/src/cholmodified.f:                     QSIZE(MDNODE) = QSIZE(MDNODE) + QSIZE(RNODE)
RandomFieldsUtils/src/cholmodified.f:                     MARKER(RNODE) = MAXINT
RandomFieldsUtils/src/cholmodified.f:                     DFORW(RNODE) = - MDNODE
RandomFieldsUtils/src/cholmodified.f:                     DBAKW(RNODE) = - MAXINT
RandomFieldsUtils/src/cholmodified.f:C                ADD MDNODE AS A NABOR OF RNODE.
RandomFieldsUtils/src/cholmodified.f:                 ADJNCY(XQNBR) = MDNODE
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C--- SPARSPAK-A (ANSI FORTRAN) RELEASE III --- NAME = MMDINT
RandomFieldsUtils/src/cholmodified.f:C***     MMDINT ..... MULT MINIMUM DEGREE INITIALIZATION     ***********
RandomFieldsUtils/src/cholmodified.f:C     PURPOSE - THIS ROUTINE PERFORMS INITIALIZATION FOR THE
RandomFieldsUtils/src/cholmodified.f:C        MULTIPLE ELIMINATION VERSION OF THE MINIMUM DEGREE
RandomFieldsUtils/src/cholmodified.f:C        ALGORITHM.
RandomFieldsUtils/src/cholmodified.f:C     INPUT PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:C        NEQNS  - NUMBER OF EQUATIONS.
RandomFieldsUtils/src/cholmodified.f:C     OUTPUT PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:C        MARKER - MARKER VECTOR.
RandomFieldsUtils/src/cholmodified.f:      SUBROUTINE  MMDINT ( NEQNS, XADJ, DHEAD, DFORW,
RandomFieldsUtils/src/cholmodified.f:     1                     DBAKW, QSIZE, LLIST, MARKER )
RandomFieldsUtils/src/cholmodified.f:     1              LLIST(*) , MARKER(*), QSIZE(*)
RandomFieldsUtils/src/cholmodified.f:             MARKER(NODE) = 0
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C--- SPARSPAK-A (ANSI FORTRAN) RELEASE III --- NAME = MMDNUM
RandomFieldsUtils/src/cholmodified.f:C*****     MMDNUM ..... MULTI MINIMUM DEGREE NUMBERING     *************
RandomFieldsUtils/src/cholmodified.f:C     PURPOSE - THIS ROUTINE PERFORMS THE FINAL STEP IN
RandomFieldsUtils/src/cholmodified.f:C        PRODUCING THE PERMUTATION AND INVERSE PERMUTATION
RandomFieldsUtils/src/cholmodified.f:C        VECTORS IN THE MULTIPLE ELIMINATION VERSION OF THE
RandomFieldsUtils/src/cholmodified.f:C        MINIMUM DEGREE ORDERING ALGORITHM.
RandomFieldsUtils/src/cholmodified.f:C     INPUT PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:C        NEQNS  - NUMBER OF EQUATIONS.
RandomFieldsUtils/src/cholmodified.f:C        QSIZE  - SIZE OF SUPERNODES AT ELIMINATION.
RandomFieldsUtils/src/cholmodified.f:C     UPDATED PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:C        INVP   - INVERSE PERMUTATION VECTOR.  ON INPUT,
RandomFieldsUtils/src/cholmodified.f:C                 IF QSIZE(NODE)=0, THEN NODE HAS BEEN MERGED
RandomFieldsUtils/src/cholmodified.f:C     OUTPUT PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:C        PERM   - THE PERMUTATION VECTOR.
RandomFieldsUtils/src/cholmodified.f:      SUBROUTINE  MMDNUM ( NEQNS, PERM, INVP, QSIZE )
RandomFieldsUtils/src/cholmodified.f:         INTEGER    INVP(*)  , PERM(*)  , QSIZE(*)
RandomFieldsUtils/src/cholmodified.f:     1              NUM   , ROOT
RandomFieldsUtils/src/cholmodified.f:             IF  ( NQSIZE .LE. 0 )  PERM(NODE) = INVP(NODE)
RandomFieldsUtils/src/cholmodified.f:             IF  ( NQSIZE .GT. 0 )  PERM(NODE) = - INVP(NODE)
RandomFieldsUtils/src/cholmodified.f:C        FOR EACH NODE WHICH HAS BEEN MERGED, DO THE FOLLOWING.
RandomFieldsUtils/src/cholmodified.f:             IF  ( PERM(NODE) .GT. 0 )  GO TO 500
RandomFieldsUtils/src/cholmodified.f:C                TRACE THE MERGED TREE UNTIL ONE WHICH HAS
RandomFieldsUtils/src/cholmodified.f:C                NOT BEEN MERGED, CALL IT ROOT.
RandomFieldsUtils/src/cholmodified.f:                     IF  ( PERM(FATHER) .GT. 0 )  GO TO 300
RandomFieldsUtils/src/cholmodified.f:                         FATHER = - PERM(FATHER)
RandomFieldsUtils/src/cholmodified.f:C                NUMBER NODE AFTER ROOT.
RandomFieldsUtils/src/cholmodified.f:                 NUM = PERM(ROOT) + 1
RandomFieldsUtils/src/cholmodified.f:                 INVP(NODE) = - NUM
RandomFieldsUtils/src/cholmodified.f:                 PERM(ROOT) = NUM
RandomFieldsUtils/src/cholmodified.f:C                SHORTEN THE MERGED TREE.
RandomFieldsUtils/src/cholmodified.f:                     NEXTF = - PERM(FATHER)
RandomFieldsUtils/src/cholmodified.f:                         PERM(FATHER) = - ROOT
RandomFieldsUtils/src/cholmodified.f:C        READY TO COMPUTE PERM.
RandomFieldsUtils/src/cholmodified.f:             NUM = - INVP(NODE)
RandomFieldsUtils/src/cholmodified.f:             INVP(NODE) = NUM
RandomFieldsUtils/src/cholmodified.f:             PERM(NUM) = NODE
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C--- SPARSPAK-A (ANSI FORTRAN) RELEASE III --- NAME = MMDUPD
RandomFieldsUtils/src/cholmodified.f:C*****     MMDUPD ..... MULTIPLE MINIMUM DEGREE UPDATE     *************
RandomFieldsUtils/src/cholmodified.f:C        AFTER A MULTIPLE ELIMINATION STEP.
RandomFieldsUtils/src/cholmodified.f:C     INPUT PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:C        EHEAD  - THE BEGINNING OF THE LIST OF ELIMINATED
RandomFieldsUtils/src/cholmodified.f:C                 NODES (I.E., NEWLY FORMED ELEMENTS).
RandomFieldsUtils/src/cholmodified.f:C        NEQNS  - NUMBER OF EQUATIONS.
RandomFieldsUtils/src/cholmodified.f:C        DELTA  - TOLERANCE VALUE FOR MULTIPLE ELIMINATION.
RandomFieldsUtils/src/cholmodified.f:C        MAXINT - MAXIMUM MACHINE REPRESENTABLE (SHORT)
RandomFieldsUtils/src/cholmodified.f:C     UPDATED PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:C        MDEG   - NEW MINIMUM DEGREE AFTER DEGREE UPDATE.
RandomFieldsUtils/src/cholmodified.f:C        MARKER - MARKER VECTOR FOR DEGREE UPDATE.
RandomFieldsUtils/src/cholmodified.f:      SUBROUTINE  MMDUPD ( EHEAD, NEQNS, XADJ, ADJNCY, DELTA,
RandomFieldsUtils/src/cholmodified.f:     1                     MDEG, DHEAD, DFORW, DBAKW, QSIZE,
RandomFieldsUtils/src/cholmodified.f:     1                     LLIST, MARKER, MAXINT, TAG )
RandomFieldsUtils/src/cholmodified.f:     1              LLIST(*) , MARKER(*), QSIZE(*)
RandomFieldsUtils/src/cholmodified.f:         INTEGER    DEG   , DEG0  , DELTA , EHEAD , ELMNT ,
RandomFieldsUtils/src/cholmodified.f:     1              MAXINT, MDEG  , MDEG0 , MTAG  , NABOR ,
RandomFieldsUtils/src/cholmodified.f:         MDEG0 = MDEG + DELTA
RandomFieldsUtils/src/cholmodified.f:         ELMNT = EHEAD
RandomFieldsUtils/src/cholmodified.f:C            FOR EACH OF THE NEWLY FORMED ELEMENT, DO THE FOLLOWING.
RandomFieldsUtils/src/cholmodified.f:             IF  ( ELMNT .LE. 0 )  RETURN
RandomFieldsUtils/src/cholmodified.f:             MTAG = TAG + MDEG0
RandomFieldsUtils/src/cholmodified.f:             IF  ( MTAG .LT. MAXINT )  GO TO 300
RandomFieldsUtils/src/cholmodified.f:                     IF  ( MARKER(I) .LT. MAXINT )  MARKER(I) = 0
RandomFieldsUtils/src/cholmodified.f:                 MTAG = TAG + MDEG0
RandomFieldsUtils/src/cholmodified.f:C            CREATE TWO LINKED LISTS FROM NODES ASSOCIATED
RandomFieldsUtils/src/cholmodified.f:C            WITH ELMNT: ONE WITH TWO NABORS (Q2HEAD) IN
RandomFieldsUtils/src/cholmodified.f:C            ADJACENCY STRUCTURE, AND THE OTHER WITH MORE
RandomFieldsUtils/src/cholmodified.f:C            THAN TWO NABORS (QXHEAD).  ALSO COMPUTE DEG0,
RandomFieldsUtils/src/cholmodified.f:C            NUMBER OF NODES IN THIS ELEMENT.
RandomFieldsUtils/src/cholmodified.f:             LINK = ELMNT
RandomFieldsUtils/src/cholmodified.f:                         MARKER(ENODE) = MTAG
RandomFieldsUtils/src/cholmodified.f:C                    IDENTIFY THE OTHER ADJACENT ELEMENT NABOR.
RandomFieldsUtils/src/cholmodified.f:                     IF  ( NABOR .EQ. ELMNT )  NABOR = ADJNCY(ISTRT+1)
RandomFieldsUtils/src/cholmodified.f:C                    IF NABOR IS UNELIMINATED, INCREASE DEGREE COUNT.
RandomFieldsUtils/src/cholmodified.f:C                        OTHERWISE, FOR EACH NODE IN THE 2ND ELEMENT,
RandomFieldsUtils/src/cholmodified.f:                             IF  ( MARKER(NODE) .GE. TAG )  GO TO 1200
RandomFieldsUtils/src/cholmodified.f:                                 MARKER(NODE) = TAG
RandomFieldsUtils/src/cholmodified.f:C                            CASE WHEN NODE IS INDISTINGUISHABLE FROM
RandomFieldsUtils/src/cholmodified.f:C                            ENODE.  MERGE THEM INTO A NEW SUPERNODE.
RandomFieldsUtils/src/cholmodified.f:                                 MARKER(NODE) = MAXINT
RandomFieldsUtils/src/cholmodified.f:                                 DBAKW(NODE) = - MAXINT
RandomFieldsUtils/src/cholmodified.f:C                            CASE WHEN NODE IS OUTMATCHED BY ENODE.
RandomFieldsUtils/src/cholmodified.f:     1                             DBAKW(NODE) = - MAXINT
RandomFieldsUtils/src/cholmodified.f:C                        FOR EACH UNMARKED NABOR OF ENODE,
RandomFieldsUtils/src/cholmodified.f:                             IF  ( MARKER(NABOR) .GE. TAG )  GO TO 2000
RandomFieldsUtils/src/cholmodified.f:                                 MARKER(NABOR) = TAG
RandomFieldsUtils/src/cholmodified.f:C                                IF UNELIMINATED, INCLUDE IT IN
RandomFieldsUtils/src/cholmodified.f:C                                    IF ELIMINATED, INCLUDE UNMARKED
RandomFieldsUtils/src/cholmodified.f:C                                    NODES IN THIS ELEMENT INTO THE
RandomFieldsUtils/src/cholmodified.f:                                         IF  ( MARKER(NODE) .GE. TAG )
RandomFieldsUtils/src/cholmodified.f:                                             MARKER(NODE) = TAG
RandomFieldsUtils/src/cholmodified.f:C                    STRUCTURE, AND MDEG (MIN DEG) IF NECESSARY.
RandomFieldsUtils/src/cholmodified.f:                     IF  ( DEG .LT. MDEG )  MDEG = DEG
RandomFieldsUtils/src/cholmodified.f:C                    GET NEXT ENODE IN CURRENT ELEMENT.
RandomFieldsUtils/src/cholmodified.f:C            GET NEXT ELEMENT IN THE LIST.
RandomFieldsUtils/src/cholmodified.f:             TAG = MTAG
RandomFieldsUtils/src/cholmodified.f:             ELMNT = LLIST(ELMNT)
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C**************     MMPY  .... MATRIX-MATRIX MULTIPLY     **************
RandomFieldsUtils/src/cholmodified.f:C       THIS ROUTINE PERFORMS A MATRIX-MATRIX MULTIPLY, Y = Y + XA,
RandomFieldsUtils/src/cholmodified.f:C       ASSUMING DATA STRUCTURES USED IN SOME OF OUR SPARSE CHOLESKY
RandomFieldsUtils/src/cholmodified.f:C   INPUT PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:C       M               -   NUMBER OF ROWS IN X AND IN Y.
RandomFieldsUtils/src/cholmodified.f:C       N               -   NUMBER OF COLUMNS IN X AND NUMBER OF ROWS
RandomFieldsUtils/src/cholmodified.f:C       Q               -   NUMBER OF COLUMNS IN A AND Y.
RandomFieldsUtils/src/cholmodified.f:C                           END OF THE J-TH COLUMN OF X.  XPNT IS ALSO
RandomFieldsUtils/src/cholmodified.f:C       X(*)            -   CONTAINS THE COLUMNS OF X AND THE ROWS OF A.
RandomFieldsUtils/src/cholmodified.f:C       LDY             -   LENGTH OF FIRST COLUMN OF Y.
RandomFieldsUtils/src/cholmodified.f:C       MMPYN           -   MATRIX-MATRIX MULTIPLY,
RandomFieldsUtils/src/cholmodified.f:C   UPDATED PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:      SUBROUTINE  MMPY   (  M     , N     , Q     , SPLIT , XPNT  ,
RandomFieldsUtils/src/cholmodified.f:C       PARAMETERS.
RandomFieldsUtils/src/cholmodified.f:        EXTERNAL            MMPY8
RandomFieldsUtils/src/cholmodified.f:        INTEGER             LDY   , M     , N     , Q
RandomFieldsUtils/src/cholmodified.f:            CALL  MMPY8 ( M, NN, Q, XPNT(FSTCOL), X, Y, LDY )
RandomFieldsUtils/src/cholmodified.f:C   Last modified:  May 26, 1995
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C*************     MMPY8  .... MATRIX-MATRIX MULTIPLY     **************
RandomFieldsUtils/src/cholmodified.f:C       THIS ROUTINE PERFORMS A MATRIX-MATRIX MULTIPLY, Y = Y + XA,
RandomFieldsUtils/src/cholmodified.f:C       ASSUMING DATA STRUCTURES USED IN SOME OF OUR SPARSE CHOLESKY
RandomFieldsUtils/src/cholmodified.f:C       LOOP UNROLLING: LEVEL 8 UPDATING TWO COLUMNS AT A TIME
RandomFieldsUtils/src/cholmodified.f:C   INPUT PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:C       M               -   NUMBER OF ROWS IN X AND IN Y.
RandomFieldsUtils/src/cholmodified.f:C       N               -   NUMBER OF COLUMNS IN X AND NUMBER OF ROWS
RandomFieldsUtils/src/cholmodified.f:C       Q               -   NUMBER OF COLUMNS IN A AND Y.
RandomFieldsUtils/src/cholmodified.f:C                           END OF THE J-TH COLUMN OF X.  XPNT IS ALSO
RandomFieldsUtils/src/cholmodified.f:C       X(*)            -   CONTAINS THE COLUMNS OF X AND THE ROWS OF A.
RandomFieldsUtils/src/cholmodified.f:C       LDY             -   LENGTH OF FIRST COLUMN OF Y.
RandomFieldsUtils/src/cholmodified.f:C   UPDATED PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:        SUBROUTINE  MMPY8  (  M     , N     , Q     , XPNT  , X     ,
RandomFieldsUtils/src/cholmodified.f:C       PARAMETERS.
RandomFieldsUtils/src/cholmodified.f:        INTEGER               LDY   , M     , N     , Q
RandomFieldsUtils/src/cholmodified.f:        INTEGER               IYBEG , IYBEG1, IYBEG2, LENY  , MM    
RandomFieldsUtils/src/cholmodified.f:C       COMPUTE EACH DIAGONAL ENTRY OF THE ODD COLUMNS OF Y.
RandomFieldsUtils/src/cholmodified.f:        MM = M
RandomFieldsUtils/src/cholmodified.f:        QQ = MIN(M,Q)
RandomFieldsUtils/src/cholmodified.f:                I1 = XPNT(I+1) - MM
RandomFieldsUtils/src/cholmodified.f:            MM = MM - 2
RandomFieldsUtils/src/cholmodified.f:C       UPDATE TWO COLUMNS OF Y AT A TIME,  EXCEPT THE DIAGONAL 
RandomFieldsUtils/src/cholmodified.f:C       ELEMENT.
RandomFieldsUtils/src/cholmodified.f:C       NOTE: THE DIAGONAL ELEMENT OF THE ODD COLUMN HAS
RandomFieldsUtils/src/cholmodified.f:C             BEEN COMPUTED, SO WE COMPUTE THE SAME NUMBER OF
RandomFieldsUtils/src/cholmodified.f:C             ELEMENTS FOR THE TWO COLUMNS.
RandomFieldsUtils/src/cholmodified.f:        MM = M
RandomFieldsUtils/src/cholmodified.f:C               EIGHT COLUMNS UPDATING TWO COLUMNS.
RandomFieldsUtils/src/cholmodified.f:                I1 = XPNT(K+1) - MM
RandomFieldsUtils/src/cholmodified.f:                I2 = XPNT(K+2) - MM
RandomFieldsUtils/src/cholmodified.f:                I3 = XPNT(K+3) - MM
RandomFieldsUtils/src/cholmodified.f:                I4 = XPNT(K+4) - MM
RandomFieldsUtils/src/cholmodified.f:                I5 = XPNT(K+5) - MM
RandomFieldsUtils/src/cholmodified.f:                I6 = XPNT(K+6) - MM
RandomFieldsUtils/src/cholmodified.f:                I7 = XPNT(K+7) - MM
RandomFieldsUtils/src/cholmodified.f:                I8 = XPNT(K+8) - MM
RandomFieldsUtils/src/cholmodified.f:                DO  300  I = 2, MM-1
RandomFieldsUtils/src/cholmodified.f:C               SEVEN COLUMNS UPDATING TWO COLUMNS.
RandomFieldsUtils/src/cholmodified.f:                I1 = XPNT(K+1) - MM
RandomFieldsUtils/src/cholmodified.f:                I2 = XPNT(K+2) - MM
RandomFieldsUtils/src/cholmodified.f:                I3 = XPNT(K+3) - MM
RandomFieldsUtils/src/cholmodified.f:                I4 = XPNT(K+4) - MM
RandomFieldsUtils/src/cholmodified.f:                I5 = XPNT(K+5) - MM
RandomFieldsUtils/src/cholmodified.f:                I6 = XPNT(K+6) - MM
RandomFieldsUtils/src/cholmodified.f:                I7 = XPNT(K+7) - MM
RandomFieldsUtils/src/cholmodified.f:                DO  600  I = 2, MM-1
RandomFieldsUtils/src/cholmodified.f:C               SIX COLUMNS UPDATING TWO COLUMNS.
RandomFieldsUtils/src/cholmodified.f:                I1 = XPNT(K+1) - MM
RandomFieldsUtils/src/cholmodified.f:                I2 = XPNT(K+2) - MM
RandomFieldsUtils/src/cholmodified.f:                I3 = XPNT(K+3) - MM
RandomFieldsUtils/src/cholmodified.f:                I4 = XPNT(K+4) - MM
RandomFieldsUtils/src/cholmodified.f:                I5 = XPNT(K+5) - MM
RandomFieldsUtils/src/cholmodified.f:                I6 = XPNT(K+6) - MM
RandomFieldsUtils/src/cholmodified.f:                DO  800  I = 2, MM-1
RandomFieldsUtils/src/cholmodified.f:C               FIVE COLUMNS UPDATING TWO COLUMNS.
RandomFieldsUtils/src/cholmodified.f:                I1 = XPNT(K+1) - MM
RandomFieldsUtils/src/cholmodified.f:                I2 = XPNT(K+2) - MM
RandomFieldsUtils/src/cholmodified.f:                I3 = XPNT(K+3) - MM
RandomFieldsUtils/src/cholmodified.f:                I4 = XPNT(K+4) - MM
RandomFieldsUtils/src/cholmodified.f:                I5 = XPNT(K+5) - MM
RandomFieldsUtils/src/cholmodified.f:                DO  1000  I = 2, MM-1
RandomFieldsUtils/src/cholmodified.f:C               FOUR COLUMNS UPDATING TWO COLUMNS.
RandomFieldsUtils/src/cholmodified.f:                I1 = XPNT(K+1) - MM
RandomFieldsUtils/src/cholmodified.f:                I2 = XPNT(K+2) - MM
RandomFieldsUtils/src/cholmodified.f:                I3 = XPNT(K+3) - MM
RandomFieldsUtils/src/cholmodified.f:                I4 = XPNT(K+4) - MM
RandomFieldsUtils/src/cholmodified.f:                DO  1200  I = 2, MM-1
RandomFieldsUtils/src/cholmodified.f:C               THREE COLUMNS UPDATING TWO COLUMNS.
RandomFieldsUtils/src/cholmodified.f:                I1 = XPNT(K+1) - MM
RandomFieldsUtils/src/cholmodified.f:                I2 = XPNT(K+2) - MM
RandomFieldsUtils/src/cholmodified.f:                I3 = XPNT(K+3) - MM
RandomFieldsUtils/src/cholmodified.f:                DO  1400  I = 2, MM-1
RandomFieldsUtils/src/cholmodified.f:C               TWO COLUMNS UPDATING TWO COLUMNS.
RandomFieldsUtils/src/cholmodified.f:                I1 = XPNT(K+1) - MM
RandomFieldsUtils/src/cholmodified.f:                I2 = XPNT(K+2) - MM
RandomFieldsUtils/src/cholmodified.f:                DO  1600  I = 2, MM-1
RandomFieldsUtils/src/cholmodified.f:C               ONE COLUMN UPDATING TWO COLUMNS.
RandomFieldsUtils/src/cholmodified.f:                I1 = XPNT(K+1) - MM
RandomFieldsUtils/src/cholmodified.f:                DO  1800  I = 2, MM-1
RandomFieldsUtils/src/cholmodified.f:C           PREPARE FOR NEXT PAIR OF COLUMNS TO BE UPDATED.
RandomFieldsUtils/src/cholmodified.f:            MM = MM - 2
RandomFieldsUtils/src/cholmodified.f:            CALL  SMXPY8  ( MM, N, Y(IYBEG), XPNT, X )
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C*************     MMPYI  .... MATRIX-MATRIX MULTIPLY     **************
RandomFieldsUtils/src/cholmodified.f:C       THIS ROUTINE PERFORMS A MATRIX-MATRIX MULTIPLY, Y = Y + XA,
RandomFieldsUtils/src/cholmodified.f:C       ASSUMING DATA STRUCTURES USED IN SOME OF OUR SPARSE CHOLESKY
RandomFieldsUtils/src/cholmodified.f:C       MATRIX X HAS ONLY 1 COLUMN.
RandomFieldsUtils/src/cholmodified.f:C   INPUT PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:C       M               -   NUMBER OF ROWS IN X AND IN Y.
RandomFieldsUtils/src/cholmodified.f:C       Q               -   NUMBER OF COLUMNS IN A AND Y.
RandomFieldsUtils/src/cholmodified.f:C                           END OF THE J-TH COLUMN OF X.  XPNT IS ALSO
RandomFieldsUtils/src/cholmodified.f:C       X(*)            -   CONTAINS THE COLUMNS OF X AND THE ROWS OF A.
RandomFieldsUtils/src/cholmodified.f:C       IY(*)           -   IY(COL) POINTS TO THE BEGINNING OF COLUMN
RandomFieldsUtils/src/cholmodified.f:C   UPDATED PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:      SUBROUTINE  MMPYI  (  M     , Q     , XPNT  , X     , IY    ,
RandomFieldsUtils/src/cholmodified.f:C       PARAMETERS.
RandomFieldsUtils/src/cholmodified.f:        INTEGER             M     , Q
RandomFieldsUtils/src/cholmodified.f:            DO  100  I = K, M
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C****     ORDMMD ..... MULTIPLE MINIMUM EXTERNAL DEGREE     ************
RandomFieldsUtils/src/cholmodified.f:C     PURPOSE - THIS ROUTINE CALLS LIU'S MULTIPLE MINIMUM DEGREE
RandomFieldsUtils/src/cholmodified.f:C     INPUT PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:C        NEQNS  - NUMBER OF EQUATIONS.
RandomFieldsUtils/src/cholmodified.f:C     OUTPUT PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:C        PERM   - THE MINIMUM DEGREE ORDERING.
RandomFieldsUtils/src/cholmodified.f:C        INVP   - THE INVERSE OF PERM.
RandomFieldsUtils/src/cholmodified.f:C        NOFSUB - AN UPPER BOUND ON THE NUMBER OF NONZERO
RandomFieldsUtils/src/cholmodified.f:C                 SUBSCRIPTS FOR THE COMPRESSED STORAGE SCHEME.
RandomFieldsUtils/src/cholmodified.f:C     WORKING PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:      SUBROUTINE ORDMMD  (  NEQNS , XADJ  , ADJNCY, INVP  , PERM  ,
RandomFieldsUtils/src/cholmodified.f:         INTEGER    ADJNCY(*), INVP(*)  , IWORK(*) , PERM(*)
RandomFieldsUtils/src/cholmodified.f:         INTEGER    DELTA , IFLAG , IWSIZ , MAXINT, NEQNS , 
RandomFieldsUtils/src/cholmodified.f:C       DELTA  - TOLERANCE VALUE FOR MULTIPLE ELIMINATION.
RandomFieldsUtils/src/cholmodified.f:C       MAXINT - MAXIMUM MACHINE REPRESENTABLE (SHORT) INTEGER
RandomFieldsUtils/src/cholmodified.f:C                (ANY SMALLER ESTIMATE WILL DO) FOR MARKING
RandomFieldsUtils/src/cholmodified.f:        MAXINT = 32767
RandomFieldsUtils/src/cholmodified.f:        CALL GENMMD  (  NEQNS , XADJ  , ADJNCY, INVP  , PERM  ,
RandomFieldsUtils/src/cholmodified.f:     1                  MAXINT, NOFSUB          )
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratoy
RandomFieldsUtils/src/cholmodified.f:C     PURPOSE - THIS ROUTINE PERFORMS CHOLESKY
RandomFieldsUtils/src/cholmodified.f:C               FACTORIZATION ON THE COLUMNS OF A SUPERNODE
RandomFieldsUtils/src/cholmodified.f:C               THAT HAVE RECEIVED ALL UPDATES FROM COLUMNS
RandomFieldsUtils/src/cholmodified.f:C     INPUT PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:C        M      - NUMBER OF ROWS (LENGTH OF THE FIRST COLUMN).
RandomFieldsUtils/src/cholmodified.f:C        N      - NUMBER OF COLUMNS IN THE SUPERNODE.
RandomFieldsUtils/src/cholmodified.f:C                 OF THE J-TH COLUMN OF THE SUPERNODE.
RandomFieldsUtils/src/cholmodified.f:C        X(*)   - CONTAINS THE COLUMNS OF OF THE SUPERNODE TO
RandomFieldsUtils/src/cholmodified.f:C        SMXPY8 -  MATRIX-VECTOR MULTIPLY WITH 8 LOOP UNROLLING.
RandomFieldsUtils/src/cholmodified.f:C     OUTPUT PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:C        X(*)   - ON OUTPUT, CONTAINS THE FACTORED COLUMNS OF
RandomFieldsUtils/src/cholmodified.f:      SUBROUTINE  PCHOL  ( M, N, XPNT, X, MXDIAG, NTINY )
RandomFieldsUtils/src/cholmodified.f:C     PARAMETERS.
RandomFieldsUtils/src/cholmodified.f:      EXTERNAL            SMXPY8
RandomFieldsUtils/src/cholmodified.f:      INTEGER             M, N
RandomFieldsUtils/src/cholmodified.f:      DOUBLE PRECISION    X(*), MXDIAG
RandomFieldsUtils/src/cholmodified.f:      INTEGER             JPNT  , JCOL  , MM
RandomFieldsUtils/src/cholmodified.f:C       FOR EVERY COLUMN JCOL IN THE SUPERNODE ...
RandomFieldsUtils/src/cholmodified.f:        MM     = M
RandomFieldsUtils/src/cholmodified.f:C           UPDATE JCOL WITH PREVIOUS COLUMNS.
RandomFieldsUtils/src/cholmodified.f:                CALL SMXPY8 ( MM, JCOL-1, X(JPNT), XPNT, X )
RandomFieldsUtils/src/cholmodified.f:C           COMPUTE THE DIAGONAL ENTRY.
RandomFieldsUtils/src/cholmodified.f:            IF (DIAG .LE. 1.0D-30*MXDIAG) THEN
RandomFieldsUtils/src/cholmodified.f:C           SCALE COLUMN JCOL WITH RECIPROCAL OF DIAGONAL ENTRY.
RandomFieldsUtils/src/cholmodified.f:            MM = MM - 1
RandomFieldsUtils/src/cholmodified.f:            CALL DSCAL1 ( MM, DIAG, X(JPNT) )
RandomFieldsUtils/src/cholmodified.f:            JPNT = JPNT + MM
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C**************    SFINIT  ..... SET UP FOR SYMB. FACT.     ************
RandomFieldsUtils/src/cholmodified.f:C       THIS SUBROUTINE COMPUTES THE STORAGE REQUIREMENTS AND SETS UP 
RandomFieldsUtils/src/cholmodified.f:C       PRELIMINARY DATA STRUCTURES FOR THE SYMBOLIC FACTORIZATION.
RandomFieldsUtils/src/cholmodified.f:C       THIS VERSION PRODUCES THE MAXIMAL SUPERNODE PARTITION (I.E.,
RandomFieldsUtils/src/cholmodified.f:C   INPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       NEQNS       -   NUMBER OF EQUATIONS.
RandomFieldsUtils/src/cholmodified.f:C       PERM(*)     -   ARRAY OF LENGTH NEQNS, CONTAINING THE
RandomFieldsUtils/src/cholmodified.f:C   OUTPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       COLCNT(*)   -   ARRAY OF LENGTH NEQNS, CONTAINING THE NUMBER
RandomFieldsUtils/src/cholmodified.f:C                       OF NONZEROS IN EACH COLUMN OF THE FACTOR,
RandomFieldsUtils/src/cholmodified.f:C       NNZL        -   NUMBER OF NONZEROS IN THE FACTOR, INCLUDING
RandomFieldsUtils/src/cholmodified.f:C       NSUB        -   NUMBER OF SUBSCRIPTS.
RandomFieldsUtils/src/cholmodified.f:C       NSUPER      -   NUMBER OF SUPERNODES (<= NEQNS).
RandomFieldsUtils/src/cholmodified.f:C                       SUPERNODE MEMBERSHIP.
RandomFieldsUtils/src/cholmodified.f:C   WORK PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C   FIRST CREATED ON    NOVEMEBER 14, 1994.
RandomFieldsUtils/src/cholmodified.f:      SUBROUTINE  SFINIT (  NEQNS , NNZA  , XADJ  , ADJNCY, PERM  ,
RandomFieldsUtils/src/cholmodified.f:C       PARAMETERS.  
RandomFieldsUtils/src/cholmodified.f:     &                      PERM(NEQNS)     , SNODE(NEQNS)    , 
RandomFieldsUtils/src/cholmodified.f:C       COMPUTE ELIMINATION TREE AND POSTORDERING.
RandomFieldsUtils/src/cholmodified.f:        CALL  ETORDR (  NEQNS , XADJ  , ADJNCY, PERM  , INVP  ,
RandomFieldsUtils/src/cholmodified.f:C       COMPUTE ROW AND COLUMN FACTOR NONZERO COUNTS.
RandomFieldsUtils/src/cholmodified.f:        CALL  FCNTHN (  NEQNS , NNZA  , XADJ  , ADJNCY, PERM  , 
RandomFieldsUtils/src/cholmodified.f:C       REARRANGE CHILDREN SO THAT THE LAST CHILD HAS THE MAXIMUM 
RandomFieldsUtils/src/cholmodified.f:C       NUMBER OF NONZEROS IN ITS COLUMN OF L.
RandomFieldsUtils/src/cholmodified.f:        CALL  CHORDR (  NEQNS , PERM  , INVP  ,
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C******     SMXPY8 .... MATRIX-VECTOR MULTIPLY            **************
RandomFieldsUtils/src/cholmodified.f:C     PURPOSE - THIS ROUTINE PERFORMS A MATRIX-VECTOR MULTIPLY,
RandomFieldsUtils/src/cholmodified.f:C               Y = Y + AX, ASSUMING DATA STRUCTURES USED IN
RandomFieldsUtils/src/cholmodified.f:C     INPUT PARAMETERS -
RandomFieldsUtils/src/cholmodified.f:C        M      - NUMBER OF ROWS.
RandomFieldsUtils/src/cholmodified.f:C        N      - NUMBER OF COLUMNS.
RandomFieldsUtils/src/cholmodified.f:C        Y      - M-VECTOR TO WHICH AX WILL BE ADDED.
RandomFieldsUtils/src/cholmodified.f:C                 FIRST NONZERO IN COLUMN I OF A.
RandomFieldsUtils/src/cholmodified.f:      SUBROUTINE  SMXPY8 ( M, N, Y, APNT, A )
RandomFieldsUtils/src/cholmodified.f:C     PARAMETERS.
RandomFieldsUtils/src/cholmodified.f:      INTEGER             M, N, LEVEL
RandomFieldsUtils/src/cholmodified.f:      PARAMETER           ( LEVEL = 8 )
RandomFieldsUtils/src/cholmodified.f:     &                    J, REMAIN
RandomFieldsUtils/src/cholmodified.f:      REMAIN = MOD ( N, LEVEL )
RandomFieldsUtils/src/cholmodified.f:C     &         400, 500, 600, 700  ), REMAIN+1
RandomFieldsUtils/src/cholmodified.f:      if (REMAIN .eq. 0) go to 2000
RandomFieldsUtils/src/cholmodified.f:C      if (REMAIN .eq. 1) go to 100
RandomFieldsUtils/src/cholmodified.f:      if (REMAIN .eq. 2) go to 200
RandomFieldsUtils/src/cholmodified.f:      if (REMAIN .eq. 3) go to 300
RandomFieldsUtils/src/cholmodified.f:      if (REMAIN .eq. 4) go to 400
RandomFieldsUtils/src/cholmodified.f:      if (REMAIN .eq. 5) go to 500
RandomFieldsUtils/src/cholmodified.f:      if (REMAIN .eq. 6) go to 600
RandomFieldsUtils/src/cholmodified.f:      if (REMAIN .eq. 7) go to 700
RandomFieldsUtils/src/cholmodified.f:      I1 = APNT(1+1) - M
RandomFieldsUtils/src/cholmodified.f:      DO  150  I = 1, M
RandomFieldsUtils/src/cholmodified.f:      I1 = APNT(1+1) - M
RandomFieldsUtils/src/cholmodified.f:      I2 = APNT(1+2) - M
RandomFieldsUtils/src/cholmodified.f:      DO  250  I = 1, M
RandomFieldsUtils/src/cholmodified.f:      I1 = APNT(1+1) - M
RandomFieldsUtils/src/cholmodified.f:      I2 = APNT(1+2) - M
RandomFieldsUtils/src/cholmodified.f:      I3 = APNT(1+3) - M
RandomFieldsUtils/src/cholmodified.f:      DO  350  I = 1, M
RandomFieldsUtils/src/cholmodified.f:      I1 = APNT(1+1) - M
RandomFieldsUtils/src/cholmodified.f:      I2 = APNT(1+2) - M
RandomFieldsUtils/src/cholmodified.f:      I3 = APNT(1+3) - M
RandomFieldsUtils/src/cholmodified.f:      I4 = APNT(1+4) - M
RandomFieldsUtils/src/cholmodified.f:      DO  450  I = 1, M
RandomFieldsUtils/src/cholmodified.f:      I1 = APNT(1+1) - M
RandomFieldsUtils/src/cholmodified.f:      I2 = APNT(1+2) - M
RandomFieldsUtils/src/cholmodified.f:      I3 = APNT(1+3) - M
RandomFieldsUtils/src/cholmodified.f:      I4 = APNT(1+4) - M
RandomFieldsUtils/src/cholmodified.f:      I5 = APNT(1+5) - M
RandomFieldsUtils/src/cholmodified.f:      DO  550  I = 1, M
RandomFieldsUtils/src/cholmodified.f:      I1 = APNT(1+1) - M
RandomFieldsUtils/src/cholmodified.f:      I2 = APNT(1+2) - M
RandomFieldsUtils/src/cholmodified.f:      I3 = APNT(1+3) - M
RandomFieldsUtils/src/cholmodified.f:      I4 = APNT(1+4) - M
RandomFieldsUtils/src/cholmodified.f:      I5 = APNT(1+5) - M
RandomFieldsUtils/src/cholmodified.f:      I6 = APNT(1+6) - M
RandomFieldsUtils/src/cholmodified.f:      DO  650  I = 1, M
RandomFieldsUtils/src/cholmodified.f:      I1 = APNT(1+1) - M
RandomFieldsUtils/src/cholmodified.f:      I2 = APNT(1+2) - M
RandomFieldsUtils/src/cholmodified.f:      I3 = APNT(1+3) - M
RandomFieldsUtils/src/cholmodified.f:      I4 = APNT(1+4) - M
RandomFieldsUtils/src/cholmodified.f:      I5 = APNT(1+5) - M
RandomFieldsUtils/src/cholmodified.f:      I6 = APNT(1+6) - M
RandomFieldsUtils/src/cholmodified.f:      I7 = APNT(1+7) - M
RandomFieldsUtils/src/cholmodified.f:      DO  750  I = 1, M
RandomFieldsUtils/src/cholmodified.f:      DO  4000  J = REMAIN+1, N, LEVEL
RandomFieldsUtils/src/cholmodified.f:          I1 = APNT(J+1) - M
RandomFieldsUtils/src/cholmodified.f:          I2 = APNT(J+2) - M
RandomFieldsUtils/src/cholmodified.f:          I3 = APNT(J+3) - M
RandomFieldsUtils/src/cholmodified.f:          I4 = APNT(J+4) - M
RandomFieldsUtils/src/cholmodified.f:          I5 = APNT(J+5) - M
RandomFieldsUtils/src/cholmodified.f:          I6 = APNT(J+6) - M
RandomFieldsUtils/src/cholmodified.f:          I7 = APNT(J+7) - M
RandomFieldsUtils/src/cholmodified.f:          I8 = APNT(J+8) - M
RandomFieldsUtils/src/cholmodified.f:          DO  3000  I = 1, M
RandomFieldsUtils/src/cholmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/cholmodified.f:C*************     SYMFC2 ..... SYMBOLIC FACTORIZATION    **************
RandomFieldsUtils/src/cholmodified.f:C       THIS ROUTINE PERFORMS SUPERNODAL SYMBOLIC FACTORIZATION ON A 
RandomFieldsUtils/src/cholmodified.f:C       REORDERED LINEAR SYSTEM.  IT ASSUMES ACCESS TO THE COLUMNS 
RandomFieldsUtils/src/cholmodified.f:C       COUNTS, SUPERNODE PARTITION, AND SUPERNODAL ELIMINATION TREE
RandomFieldsUtils/src/cholmodified.f:C       ASSOCIATED WITH THE FACTOR MATRIX L.
RandomFieldsUtils/src/cholmodified.f:C   INPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       (I) NEQNS       -   NUMBER OF EQUATIONS
RandomFieldsUtils/src/cholmodified.f:C       (I) PERM(*)     -   ARRAY OF LENGTH NEQNS CONTAINING THE
RandomFieldsUtils/src/cholmodified.f:C       (I) COLCNT(*)   -   ARRAY OF LENGTH NEQNS, CONTAINING THE NUMBER
RandomFieldsUtils/src/cholmodified.f:C                           OF NONZEROS IN EACH COLUMN OF THE FACTOR,
RandomFieldsUtils/src/cholmodified.f:C       (I) NSUPER      -   NUMBER OF SUPERNODES.
RandomFieldsUtils/src/cholmodified.f:C                           FIRST COLUMN OF EACH SUPERNODE.
RandomFieldsUtils/src/cholmodified.f:C                           SUPERNODE MEMBERSHIP.
RandomFieldsUtils/src/cholmodified.f:C       (I) NOFSUB      -   NUMBER OF SUBSCRIPTS TO BE STORED IN
RandomFieldsUtils/src/cholmodified.f:C   OUTPUT PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       (I) LINDX       -   ARRAY OF LENGTH MAXSUB, CONTAINING THE
RandomFieldsUtils/src/cholmodified.f:C                           COMPRESSED SUBSCRIPTS.
RandomFieldsUtils/src/cholmodified.f:C       (I) XLNZ        -   COLUMN POINTERS FOR L.
RandomFieldsUtils/src/cholmodified.f:C   WORKING PARAMETERS:
RandomFieldsUtils/src/cholmodified.f:C       (I) MRGLNK      -   ARRAY OF LENGTH NSUPER, CONTAINING THE 
RandomFieldsUtils/src/cholmodified.f:C                           CURRENT LINKED LIST OF MERGED INDICES (THE 
RandomFieldsUtils/src/cholmodified.f:C       (I) MARKER      -   ARRAY OF LENGTH NEQNS USED TO MARK INDICES
RandomFieldsUtils/src/cholmodified.f:      SUBROUTINE  SYMFC2 (  NEQNS , ADJLEN, XADJ  , ADJNCY, PERM  , 
RandomFieldsUtils/src/cholmodified.f:     &                      NOFSUB, XLINDX, LINDX , XLNZ  , MRGLNK,
RandomFieldsUtils/src/cholmodified.f:     &                      RCHLNK, MARKER, FLAG    )
RandomFieldsUtils/src/cholmodified.f:C       PARAMETERS.
RandomFieldsUtils/src/cholmodified.f:     &                      INVP(NEQNS)   , MARKER(NEQNS) ,
RandomFieldsUtils/src/cholmodified.f:     &                      MRGLNK(NSUPER), LINDX(NOFSUB) , 
RandomFieldsUtils/src/cholmodified.f:     &                      PERM(NEQNS)   , RCHLNK(0:NEQNS), 
RandomFieldsUtils/src/cholmodified.f:C                    (IN RCHLNK(*), NOT MRGLNK(*)).
RandomFieldsUtils/src/cholmodified.f:C           MRGLNK : CREATE EMPTY LISTS.
RandomFieldsUtils/src/cholmodified.f:C           MARKER : "UNMARK" THE INDICES.
RandomFieldsUtils/src/cholmodified.f:            MARKER(I) = 0
RandomFieldsUtils/src/cholmodified.f:            MRGLNK(KSUP) = 0
RandomFieldsUtils/src/cholmodified.f:C               FSTCOL : FIRST COLUMN OF SUPERNODE KSUP.
RandomFieldsUtils/src/cholmodified.f:C               LSTCOL : LAST COLUMN OF SUPERNODE KSUP.
RandomFieldsUtils/src/cholmodified.f:C               KNZ    : WILL COUNT THE NONZEROS OF L IN COLUMN KCOL.
RandomFieldsUtils/src/cholmodified.f:C               RCHLNK : INITIALIZE EMPTY INDEX LIST FOR KCOL.
RandomFieldsUtils/src/cholmodified.f:            JSUP = MRGLNK(KSUP)
RandomFieldsUtils/src/cholmodified.f:C               THE LINKED LIST, AND MARK EACH WITH THE VALUE 
RandomFieldsUtils/src/cholmodified.f:                    MARKER(NEWI) = KSUP
RandomFieldsUtils/src/cholmodified.f:                JSUP = MRGLNK(JSUP)
RandomFieldsUtils/src/cholmodified.f:C                   MERGE THE INDICES OF JSUP INTO THE LIST,
RandomFieldsUtils/src/cholmodified.f:C                   AND MARK NEW INDICES WITH VALUE KSUP.
RandomFieldsUtils/src/cholmodified.f:                            MARKER(NEWI) = KSUP
RandomFieldsUtils/src/cholmodified.f:                    JSUP = MRGLNK(JSUP)
RandomFieldsUtils/src/cholmodified.f:C           STRUCTURE OF A(*,FSTCOL) HAS NOT BEEN EXAMINED YET.  
RandomFieldsUtils/src/cholmodified.f:                NODE = PERM(FSTCOL)
RandomFieldsUtils/src/cholmodified.f:     &                    MARKER(NEWI) .NE. KSUP )  THEN
RandomFieldsUtils/src/cholmodified.f:C                       AND MARK IT WITH KCOL.
RandomFieldsUtils/src/cholmodified.f:                        MARKER(NEWI) = KSUP
RandomFieldsUtils/src/cholmodified.f:C           COPY INDICES FROM LINKED LIST INTO LINDX(*).
RandomFieldsUtils/src/cholmodified.f:C           "MERGE" LIST.
RandomFieldsUtils/src/cholmodified.f:                MRGLNK(KSUP) = MRGLNK(PSUP)
RandomFieldsUtils/src/cholmodified.f:                MRGLNK(PSUP) = KSUP
RandomFieldsUtils/src/cholmodified.f:!! GENRCM finds the reverse Cuthill-Mckee ordering for a general graph.
RandomFieldsUtils/src/cholmodified.f:!    an ordering by calling RCM.
RandomFieldsUtils/src/cholmodified.f:!  Modified:
RandomFieldsUtils/src/cholmodified.f:!    Input, integer NODE_NUM, the number of nodes.
RandomFieldsUtils/src/cholmodified.f:!    Input, integer ADJ_NUM, the number of adjacency entries.
RandomFieldsUtils/src/cholmodified.f:!    Input, integer ADJ_ROW(NODE_NUM+1).  Information about row I is stored
RandomFieldsUtils/src/cholmodified.f:!    Input, integer ADJ(ADJ_NUM), the adjacency structure.
RandomFieldsUtils/src/cholmodified.f:!    Output, integer PERM(NODE_NUM), the RCM ordering.
RandomFieldsUtils/src/cholmodified.f:!    Local, integer LEVEL_ROW(NODE_NUM+1), the index vector for a level
RandomFieldsUtils/src/cholmodified.f:!    spaces in the permutation vector PERM.
RandomFieldsUtils/src/cholmodified.f:!    Local, integer MASK(NODE_NUM), marks variables that have been numbered.
RandomFieldsUtils/src/cholmodified.f:!  ROOT_FIND is stored starting at PERM(NUM).
RandomFieldsUtils/src/cholmodified.f:!  RCM orders the component using ROOT as the starting node.
RandomFieldsUtils/src/cholmodified.f:!! RCM renumbers a connected component by the reverse Cuthill McKee algorithm.
RandomFieldsUtils/src/cholmodified.f:!  Modified:
RandomFieldsUtils/src/cholmodified.f:!    It is used as the starting point for the RCM ordering.
RandomFieldsUtils/src/cholmodified.f:!    Input, integer ADJ_NUM, the number of adjacency entries.
RandomFieldsUtils/src/cholmodified.f:!    Input, integer ADJ_ROW(NODE_NUM+1).  Information about row I is stored
RandomFieldsUtils/src/cholmodified.f:!    Input, integer ADJ(ADJ_NUM), the adjacency structure.
RandomFieldsUtils/src/cholmodified.f:!    Input/output, integer MASK(NODE_NUM), a mask for the nodes.  Only 
RandomFieldsUtils/src/cholmodified.f:!    routine.  The nodes numbered by RCM will have their mask values 
RandomFieldsUtils/src/cholmodified.f:!    Output, integer PERM(NODE_NUM), the RCM ordering.
RandomFieldsUtils/src/cholmodified.f:!    Input, integer NODE_NUM, the number of nodes.
RandomFieldsUtils/src/cholmodified.f:!    Workspace, integer DEG(NODE_NUM), a temporary vector used to hold 
RandomFieldsUtils/src/cholmodified.f:!  Find the degrees of the nodes in the component specified by MASK and ROOT.
RandomFieldsUtils/src/cholmodified.f:!  of the current node in PERM.
RandomFieldsUtils/src/cholmodified.f:!  We now have the Cuthill-McKee ordering.  Reverse it.
RandomFieldsUtils/src/cholmodified.f:!    specified by MASK and ROOT.
RandomFieldsUtils/src/cholmodified.f:!    NODE_NUM-1 from the pseudo-peripheral node.
RandomFieldsUtils/src/cholmodified.f:!  Modified:
RandomFieldsUtils/src/cholmodified.f:!    An Algorithm for Reducing the Bandwidth and Profile of a Sparse Matrix,
RandomFieldsUtils/src/cholmodified.f:!    SIAM Journal on Numerical Analysis,
RandomFieldsUtils/src/cholmodified.f:!    ACM Transactions on Mathematical Software,
RandomFieldsUtils/src/cholmodified.f:!    Input, integer ADJ_NUM, the number of adjacency entries.
RandomFieldsUtils/src/cholmodified.f:!    Input, integer ADJ_ROW(NODE_NUM+1).  Information about row I is stored
RandomFieldsUtils/src/cholmodified.f:!    Input, integer ADJ(ADJ_NUM), the adjacency structure.
RandomFieldsUtils/src/cholmodified.f:!    Input, integer MASK(NODE_NUM), specifies a section subgraph.  Nodes 
RandomFieldsUtils/src/cholmodified.f:!    for which MASK is zero are ignored by FNROOT.
RandomFieldsUtils/src/cholmodified.f:!    Output, integer LEVEL_NUM, is the number of levels in the level structure
RandomFieldsUtils/src/cholmodified.f:!    Output, integer LEVEL_ROW(NODE_NUM+1), LEVEL(NODE_NUM), the 
RandomFieldsUtils/src/cholmodified.f:!    Input, integer NODE_NUM, the number of nodes.
RandomFieldsUtils/src/cholmodified.f:!    Only nodes for which MASK is nonzero will be considered.
RandomFieldsUtils/src/cholmodified.f:!    The number of levels may vary between 2 and NODE_NUM.
RandomFieldsUtils/src/cholmodified.f:!  Modified:
RandomFieldsUtils/src/cholmodified.f:!    Input, integer ADJ_NUM, the number of adjacency entries.
RandomFieldsUtils/src/cholmodified.f:!    Input, integer ADJ_ROW(NODE_NUM+1).  Information about row I is stored
RandomFieldsUtils/src/cholmodified.f:!    Input, integer ADJ(ADJ_NUM), the adjacency structure.
RandomFieldsUtils/src/cholmodified.f:!    Input/output, integer MASK(NODE_NUM).  On input, only nodes with nonzero
RandomFieldsUtils/src/cholmodified.f:!    MASK are to be processed.  On output, those nodes which were included
RandomFieldsUtils/src/cholmodified.f:!    in the level set have MASK set to 1.
RandomFieldsUtils/src/cholmodified.f:!    Output, integer LEVEL_NUM, the number of levels in the level
RandomFieldsUtils/src/cholmodified.f:!    Output, integer LEVEL_ROW(NODE_NUM+1), LEVEL(NODE_NUM), the rooted 
RandomFieldsUtils/src/cholmodified.f:!    Input, integer NODE_NUM, the number of nodes.
RandomFieldsUtils/src/cholmodified.f:!  Reset MASK to 1 for the nodes in the level structure.
RandomFieldsUtils/src/cholmodified.f:!    The connected component is specified by MASK and ROOT.
RandomFieldsUtils/src/cholmodified.f:!    Nodes for which MASK is zero are ignored.
RandomFieldsUtils/src/cholmodified.f:!  Modified:
RandomFieldsUtils/src/cholmodified.f:!    Input, integer ADJ_NUM, the number of adjacency entries.
RandomFieldsUtils/src/cholmodified.f:!    Input, integer ADJ_ROW(NODE_NUM+1).  Information about row I is stored
RandomFieldsUtils/src/cholmodified.f:!    Input, integer ADJ(ADJ_NUM), the adjacency structure.
RandomFieldsUtils/src/cholmodified.f:!    Input, integer MASK(NODE_NUM), is nonzero for those nodes which are
RandomFieldsUtils/src/cholmodified.f:!    Output, integer DEG(NODE_NUM), contains, for each  node in the connected
RandomFieldsUtils/src/cholmodified.f:!    Output, integer LS(NODE_NUM), stores in entries 1 through ICCSIZE the nodes
RandomFieldsUtils/src/cholmodified.f:!    Input, integer NODE_NUM, the number of nodes.
RandomFieldsUtils/src/solve_gpu.h:#define PADDIM 4L
RandomFieldsUtils/src/intrinsics.h:// PKG_CXXFLAGS =  $(SHLIB_OPENMP_CXXFLAGS) -mavx ODER -march=native 
RandomFieldsUtils/src/intrinsics.h:#define SSEMODE 30
RandomFieldsUtils/src/intrinsics.h:#define SSEMODE 20
RandomFieldsUtils/src/intrinsics.h:#define SSEMODE 10
RandomFieldsUtils/src/intrinsics.h:#define SSEMODE 0
RandomFieldsUtils/src/intrinsics.h:// #define FMA_AVAILABLE __FMA__
RandomFieldsUtils/src/intrinsics.h:  (__GNUC__ == 4 && (__GNUC_MINOR__ > 9 ||				\
RandomFieldsUtils/src/intrinsics.h:		     (__GNUC_MINOR__ == 9 &&  __GNUC_PATCHLEVEL__ >= 1)))
RandomFieldsUtils/src/intrinsics.h://#define OpenMP4 1
RandomFieldsUtils/src/intrinsics.h:#define MAXDOUBLE _mm256_max_pd
RandomFieldsUtils/src/intrinsics.h:#define MAXINTEGER _mm256_max_epi32
RandomFieldsUtils/src/intrinsics.h:#define MULTDOUBLE _mm256_mul_pd 
RandomFieldsUtils/src/intrinsics.h:#define MAXDOUBLE _mm_max_pd
RandomFieldsUtils/src/intrinsics.h:#define MAXINTEGER _mm_max_epi32
RandomFieldsUtils/src/intrinsics.h:#define MULTDOUBLE _mm_mul_pd 
RandomFieldsUtils/src/intrinsics.h:#define SCALAR_DEFAULT SCALAR_NEARFMA
RandomFieldsUtils/src/errors_messages.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/src/errors_messages.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFieldsUtils/src/errors_messages.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/src/errors_messages.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/src/errors_messages.h:#define ERRORMEMORYALLOCATION 1 
RandomFieldsUtils/src/errors_messages.h:#define ERRORNOTPROGRAMMEDYET 3
RandomFieldsUtils/src/errors_messages.h:#define ERRORM 4          /* a single error message */
RandomFieldsUtils/src/errors_messages.h:#define ERRORMEND 12      /* a single error message -- und alles dazwischen */
RandomFieldsUtils/src/errors_messages.h:#define LENMSG 1000
RandomFieldsUtils/src/errors_messages.h:#define MAXERRORSTRING 1000
RandomFieldsUtils/src/errors_messages.h:#define LENERRMSG 1000
RandomFieldsUtils/src/errors_messages.h:typedef char errorstring_type[MAXERRORSTRING];
RandomFieldsUtils/src/errors_messages.h:  #define LOCAL_ERRMSG2 char MSG2[LENERRMSG]
RandomFieldsUtils/src/errors_messages.h:  #ifndef LOCAL_ERRLOC_MSG
RandomFieldsUtils/src/errors_messages.h:    #define LOCAL_ERRLOC_MSG errorloc_type ERROR_LOC=""; char ERRMSG[LENERRMSG];
RandomFieldsUtils/src/errors_messages.h:  #define LOCAL_ERRMSG2
RandomFieldsUtils/src/errors_messages.h:  #ifndef LOCAL_ERRLOC_MSG
RandomFieldsUtils/src/errors_messages.h:    #define LOCAL_ERRLOC_MSG
RandomFieldsUtils/src/errors_messages.h:  extern char ERRMSG[LENERRMSG], // used by Error_utils.h. Never use elsewhere
RandomFieldsUtils/src/errors_messages.h:    MSG2[LENERRMSG];// used at the same time with MSG and ERR()
RandomFieldsUtils/src/errors_messages.h:  extern errorstring_type ERRORSTRING; // used by ERRORM in RandomFields
RandomFieldsUtils/src/errors_messages.h://  extern char   MSG[LENERRMSG]; // used by RandomFields in intermediate steps
RandomFieldsUtils/src/errors_messages.h:#ifdef SCHLATHERS_MACHINE
RandomFieldsUtils/src/errors_messages.h:  #define ERRLINE0 PRINTF("(ERROR in %s, line %d)\n", __FILE__, __LINE__); LOCAL_ERRLOC_MSG
RandomFieldsUtils/src/errors_messages.h://#define ERRLINE ERRLINE0; LOCAL_ERRMSG2
RandomFieldsUtils/src/errors_messages.h:  #define ERRLINE0 LOCAL_ERRLOC_MSG
RandomFieldsUtils/src/errors_messages.h:#define ERRLINE ERRLINE0; LOCAL_ERRMSG2
RandomFieldsUtils/src/errors_messages.h:#define W_ERRLINE0 char W_ERRMSG[LENERRMSG]
RandomFieldsUtils/src/errors_messages.h:#define W_ERRLINE  char W_MSG2[LENERRMSG]
RandomFieldsUtils/src/errors_messages.h:#define ERR(X) {ERRLINE0;SPRINTF(ERRMSG, "%.90s %.790s",ERROR_LOC,X);RFERROR(ERRMSG);}
RandomFieldsUtils/src/errors_messages.h:#define ERR00(X) ERRLINE;SPRINTF(ERRMSG, "%.90s %.790s", ERROR_LOC, X)
RandomFieldsUtils/src/errors_messages.h:#define ERR1(X, Y) {ERR00(X); SPRINTF(MSG2, ERRMSG, Y); RFERROR(MSG2);}
RandomFieldsUtils/src/errors_messages.h:#define ERR2(X, Y, Z) {ERR00(X); SPRINTF(MSG2, ERRMSG, Y, Z); RFERROR(MSG2);}
RandomFieldsUtils/src/errors_messages.h:#define ERR3(X, Y, Z, A) {ERR00(X); SPRINTF(MSG2, ERRMSG,Y,Z,A); RFERROR(MSG2);}
RandomFieldsUtils/src/errors_messages.h:#define ERR4(X, Y, Z, A, B) {ERR00(X); SPRINTF(MSG2,ERRMSG,Y,Z,A,B);	\
RandomFieldsUtils/src/errors_messages.h:    RFERROR(MSG2);}
RandomFieldsUtils/src/errors_messages.h:#define ERR5(X, Y, Z, A, B, C) {ERR00(X); SPRINTF(MSG2, ERRMSG,Y,Z,A,B,C); \
RandomFieldsUtils/src/errors_messages.h:    RFERROR(MSG2);}
RandomFieldsUtils/src/errors_messages.h:#define ERR6(X, Y, Z, A, B,C,D) {ERR00(X); SPRINTF(MSG2, ERRMSG,Y,Z,A,B,C,D); \
RandomFieldsUtils/src/errors_messages.h:    RFERROR(MSG2);}
RandomFieldsUtils/src/errors_messages.h:#define ERR7(X, Y, Z,A,B,C,D,E) {ERR00(X); SPRINTF(MSG2,ERRMSG,Y,Z,A,B,C,D,E); \
RandomFieldsUtils/src/errors_messages.h:    RFERROR(MSG2);}
RandomFieldsUtils/src/errors_messages.h:#define ERR8(X,Y,Z,A,B,C,D,E,F){ERR00(X);SPRINTF(MSG2,ERRMSG,Y,Z,A,B,C,D,E,F); \
RandomFieldsUtils/src/errors_messages.h:    RFERROR(MSG2);}
RandomFieldsUtils/src/errors_messages.h:#define SERR(X) NERR(ERRORM, X)
RandomFieldsUtils/src/errors_messages.h:#define SERR1(X,Y) NERR1(ERRORM, X, Y)
RandomFieldsUtils/src/errors_messages.h:#define SERR2(X,Y,Z) NERR2(ERRORM, X, Y, Z)
RandomFieldsUtils/src/errors_messages.h:#define SERR3(X,Y,Z, A) NERR3(ERRORM, X, Y, Z, A)
RandomFieldsUtils/src/errors_messages.h:#define SERR4(X,Y,Z, A, B) NERR4(ERRORM, X, Y, Z, A, B)
RandomFieldsUtils/src/errors_messages.h:#define SERR5(X,Y,Z, A, B, C) NERR5(ERRORM, X, Y, Z, A, B, C)
RandomFieldsUtils/src/errors_messages.h:#define SERR6(X,Y,Z, A, B, C, D) NERR6(ERRORM, X, Y, Z, A, B, C, D)
RandomFieldsUtils/src/errors_messages.h:#define SERR7(X,Y,Z, A, B, C, D, E) NERR7(ERRORM, X, Y, Z, A, B, C, D, E)
RandomFieldsUtils/src/errors_messages.h:#define CERR00 err=ERRORM; continue;
RandomFieldsUtils/src/errors_messages.h:#define GERR00 LOCAL_ERROR(ERRORM); err = ERRORM; goto ErrorHandling;
RandomFieldsUtils/src/errors_messages.h:    SPRINTF(W_MSG2, X, Y); RFWARNING(W_MSG2);}
RandomFieldsUtils/src/errors_messages.h:    SPRINTF(W_MSG2, X, Y, Z); RFWARNING(W_MSG2);}
RandomFieldsUtils/src/errors_messages.h:    SPRINTF(W_MSG2, X, Y, Z, A); RFWARNING(W_MSG2);}
RandomFieldsUtils/src/errors_messages.h:    SPRINTF(W_MSG2, X, Y, Z, A, B); RFWARNING(W_MSG2);}
RandomFieldsUtils/src/errors_messages.h:    SPRINTF(W_MSG2, X, Y, Z, A, B, C); RFWARNING(W_MSG2);}
RandomFieldsUtils/src/errors_messages.h:    SPRINTF(W_MSG2, X, Y, Z, A, B, C, D); RFWARNING(W_MSG2);}
RandomFieldsUtils/src/errors_messages.h:    SPRINTF(W_MSG2, X, Y, Z, A, B, C, D, E); RFWARNING(W_MSG2);}
RandomFieldsUtils/src/errors_messages.h:#define RFERROR1(M,A) {errorstring_type ERR_STR; \
RandomFieldsUtils/src/errors_messages.h:    SPRINTF(ERR_STR, M, A); RFERROR(ERR_STR);}
RandomFieldsUtils/src/errors_messages.h:#define RFERROR2(M,A,B) {errorstring_type ERR_STR; \
RandomFieldsUtils/src/errors_messages.h:    SPRINTF(ERR_STR, M, A,B); RFERROR(ERR_STR);}
RandomFieldsUtils/src/errors_messages.h:#define RFERROR3(M,A,B,C) {errorstring_type ERR_STR;\
RandomFieldsUtils/src/errors_messages.h:    SPRINTF(ERR_STR, M, A,B,C); RFERROR(ERR_STR);}
RandomFieldsUtils/src/errors_messages.h:#define RFERROR4(M,A,B,C,D) {errorstring_type ERR_STR; \
RandomFieldsUtils/src/errors_messages.h:    SPRINTF(ERR_STR, M, A,B,C,D); RFERROR(ERR_STR);}
RandomFieldsUtils/src/errors_messages.h:#define RFERROR5(M,A,B,C,D,E) {errorstring_type ERR_STR; \
RandomFieldsUtils/src/errors_messages.h:    SPRINTF(ERR_STR, M, A,B,C,D,E); RFERROR(ERR_STR);}
RandomFieldsUtils/src/errors_messages.h:#define RFERROR6(M,A,B,C,D,E,F) {errorstring_type ERR_STR;\
RandomFieldsUtils/src/errors_messages.h:    SPRINTF(ERR_STR, M, A,B,C,D,E,F); RFERROR(ERR_STR);}
RandomFieldsUtils/src/errors_messages.h:#define RFERROR7(M,A,B,C,D,E,F,G) {errorstring_type ERR_STR;\
RandomFieldsUtils/src/errors_messages.h:    SPRINTF(ERR_STR, M, A,B,C,D,E,F,G); RFERROR(ERR_STR);}
RandomFieldsUtils/src/RFoptions.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/src/RFoptions.cc: Copyright (C) 2016 -- 2017 Martin Schlather
RandomFieldsUtils/src/RFoptions.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/src/RFoptions.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/src/RFoptions.cc:	     char VARIABLE_IS_NOT_USED  name[LEN_OPTIONNAME], 
RandomFieldsUtils/src/RFoptions.cc:#define MAXNLIST 5
RandomFieldsUtils/src/RFoptions.cc:  AllprefixN[MAXNLIST] = {ownprefixN, 0, 0, 0, 0},
RandomFieldsUtils/src/RFoptions.cc:  *AllallN[MAXNLIST] = {ownallN, NULL, NULL, NULL, NULL};
RandomFieldsUtils/src/RFoptions.cc:const char  *basic_options[MAXNLIST] = {ownprefixlist[1], NULL, NULL, NULL},
RandomFieldsUtils/src/RFoptions.cc:  **Allprefix[MAXNLIST] = {ownprefixlist, NULL, NULL, NULL, NULL},
RandomFieldsUtils/src/RFoptions.cc:  ***Allall[MAXNLIST] = { ownall, NULL, NULL, NULL, NULL};
RandomFieldsUtils/src/RFoptions.cc:setparameterfct setparam[MAXNLIST] = 
RandomFieldsUtils/src/RFoptions.cc:getparameterfct getparam[MAXNLIST] = 
RandomFieldsUtils/src/RFoptions.cc:finalsetparameterfct finalparam[MAXNLIST] = { NULL, NULL, NULL, NULL, NULL };
RandomFieldsUtils/src/RFoptions.cc:deleteparameterfct delparam[MAXNLIST] = { NULL, NULL, NULL, NULL, NULL };
RandomFieldsUtils/src/RFoptions.cc:    j = NOMATCHING,
RandomFieldsUtils/src/RFoptions.cc:    i = NOMATCHING,
RandomFieldsUtils/src/RFoptions.cc:    ListNr = NOMATCHING;
RandomFieldsUtils/src/RFoptions.cc:  char name[LEN_OPTIONNAME];
RandomFieldsUtils/src/RFoptions.cc:  if (STRCMP(prefix, "")) {
RandomFieldsUtils/src/RFoptions.cc:      i = Match(prefix, Allprefix[ListNr], AllprefixN[ListNr]);
RandomFieldsUtils/src/RFoptions.cc:      if (i != NOMATCHING) break;
RandomFieldsUtils/src/RFoptions.cc:    if (i == NOMATCHING) ERR1("option prefix name '%.50s' not found.", prefix); 
RandomFieldsUtils/src/RFoptions.cc:    if (i < 0 || STRCMP(prefix, Allprefix[ListNr][i])) {
RandomFieldsUtils/src/RFoptions.cc:	int ii = Match(prefix, Allprefix[ListNr], AllprefixN[ListNr]);
RandomFieldsUtils/src/RFoptions.cc:	if (ii == NOMATCHING) continue;
RandomFieldsUtils/src/RFoptions.cc:	i = MULTIPLEMATCHING;
RandomFieldsUtils/src/RFoptions.cc:	if (ii >= 0 && STRCMP(prefix, Allprefix[k][ii])==0) {
RandomFieldsUtils/src/RFoptions.cc:      if (i == MULTIPLEMATCHING) 
RandomFieldsUtils/src/RFoptions.cc:    j = Match(mainname, Allall[ListNr][i], AllallN[ListNr][i]);
RandomFieldsUtils/src/RFoptions.cc:#define MinNameLength 3
RandomFieldsUtils/src/RFoptions.cc:	j = Match(mainname, Allall[ListNr][i], AllallN[ListNr][i]);
RandomFieldsUtils/src/RFoptions.cc:	if (j != NOMATCHING) break;     
RandomFieldsUtils/src/RFoptions.cc:      if (j != NOMATCHING) break;
RandomFieldsUtils/src/RFoptions.cc:    if (j==NOMATCHING) {
RandomFieldsUtils/src/RFoptions.cc:    if (j < 0  || STRCMP(mainname, Allall[ListNr][i][j])) {
RandomFieldsUtils/src/RFoptions.cc:	  int jj = Match(mainname, Allall[k][ii], AllallN[k][ii]);
RandomFieldsUtils/src/RFoptions.cc:	  if (jj == NOMATCHING) continue;
RandomFieldsUtils/src/RFoptions.cc:	  j = MULTIPLEMATCHING;
RandomFieldsUtils/src/RFoptions.cc:	  if (jj >= 0 && STRCMP(mainname, Allall[k][ii][jj])==0) {
RandomFieldsUtils/src/RFoptions.cc:  if (j<0) ERR1("Multiple partial matching for option '%.50s'.", name); 
RandomFieldsUtils/src/RFoptions.cc:      totalN += STRCMP(Allprefix[ListNr][i], OBSOLETENAME) != 0;
RandomFieldsUtils/src/RFoptions.cc:      if (STRCMP(Allprefix[ListNr][i], OBSOLETENAME) == 0) continue;
RandomFieldsUtils/src/RFoptions.cc:      if (STRCMP(Allprefix[ListNr][i], z) == 0) break;
RandomFieldsUtils/src/RFoptions.cc:  char prefix[LEN_OPTIONNAME / 2], mainname[LEN_OPTIONNAME / 2];   
RandomFieldsUtils/src/RFoptions.cc:    strcopyN(mainname, name, LEN_OPTIONNAME / 2);
RandomFieldsUtils/src/RFoptions.cc:    strcopyN(prefix, name, MIN(i + 1, LEN_OPTIONNAME / 2));
RandomFieldsUtils/src/RFoptions.cc:    strcopyN(mainname, name+i+1, MIN(STRLEN(name) - i, LEN_OPTIONNAME / 2) );
RandomFieldsUtils/src/RFoptions.cc:    if (!isNull(TAG(options))) name = (char*) CHAR(PRINTNAME(TAG(options)));
RandomFieldsUtils/src/RFoptions.cc:    if (STRCMP(name, "LOCAL")==0) {
RandomFieldsUtils/src/RFoptions.cc:  if (options == R_NilValue || STRCMP(name, "") ==0)
RandomFieldsUtils/src/RFoptions.cc:  if (!isNull(TAG(options))) name = (char*) CHAR(PRINTNAME(TAG(options)));
RandomFieldsUtils/src/RFoptions.cc:  if (STRCMP(name, "WARN_UNKNOWN")==0) {
RandomFieldsUtils/src/RFoptions.cc:  if (!isNull(TAG(options))) name = (char*) CHAR(PRINTNAME(TAG(options)));
RandomFieldsUtils/src/RFoptions.cc:  if ((isList = STRCMP(name, "LIST")==0)) {   
RandomFieldsUtils/src/RFoptions.cc:    if ((save = STRCMP(name, "SAVEOPTIONS")==0 ) ||
RandomFieldsUtils/src/RFoptions.cc:	STRCMP(name, "GETOPTIONS")==0) {
RandomFieldsUtils/src/RFoptions.cc:	getlist = (getlist_type *) MALLOC(sizeof(getlist_type) * (len + 1));
RandomFieldsUtils/src/RFoptions.cc:	name = (char*) CHAR(PRINTNAME(TAG(options)));
RandomFieldsUtils/src/RFoptions.cc:	STRCMP(Allprefix[ListNr][0], prefixlist[0]) == 0) {
RandomFieldsUtils/src/RFoptions.cc:  if (NList >= MAXNLIST) BUG;
RandomFieldsUtils/src/RFoptions.cc:	STRCMP(Allprefix[ListNr][0], prefixlist[0]) == 0) break;
RandomFieldsUtils/src/RFoptions.cc:    if (STRCMP(basic_options[i], prefixlist[0]) == 0) break;
RandomFieldsUtils/src/Solve.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/src/Solve.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFieldsUtils/src/Solve.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/src/Solve.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/src/Solve.h:typedef enum InversionMethod { 
RandomFieldsUtils/src/Solve.h:  NoInversionMethod, // 4, last user available method
RandomFieldsUtils/src/Solve.h:  NoFurtherInversionMethod, // 7, local values
RandomFieldsUtils/src/Solve.h:} InversionMethod;
RandomFieldsUtils/src/Solve.h:#define nr_InversionMethods ((int) Diagonal + 1)
RandomFieldsUtils/src/Solve.h:#define nr_user_InversionMethods ((int) NoFurtherInversionMethod + 1)
RandomFieldsUtils/src/Solve.h:#define SOLVE_METHODS 3
RandomFieldsUtils/src/Solve.h:  InversionMethod method, newMethods[SOLVE_METHODS];
RandomFieldsUtils/src/Solve.h:  //   SICH_n, MM_n, VT_n, U_n, D_n, 
RandomFieldsUtils/src/Solve.h:#define MATRIXSQRT 1
RandomFieldsUtils/src/Solve.h:#define DETERMINANT 2
RandomFieldsUtils/src/kleinkram.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/src/kleinkram.cc: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFieldsUtils/src/kleinkram.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/src/kleinkram.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/src/kleinkram.cc://const char *RTYPE_NAMES[LAST_R_TYPE_NAME + 1] = {
RandomFieldsUtils/src/kleinkram.cc:const char *RTYPE_NAMES[LAST_R_TYPE_NAME + 1] = {
RandomFieldsUtils/src/kleinkram.cc:  "SYMSXP", "LISTSXP", "CLOSXP", "ENVSXP", "PROMSXP",
RandomFieldsUtils/src/kleinkram.cc:#pragma omp parallel for num_threads(CORES) if (MULTIMINSIZE(ncol)) schedule(dynamic, 20)
RandomFieldsUtils/src/kleinkram.cc:    MEMCOPY(y, x, sizeof(double) * nrow);
RandomFieldsUtils/src/kleinkram.cc:    MEMCOPY(y, x, sizeof(double) * nrow);
RandomFieldsUtils/src/kleinkram.cc:#pragma omp parallel for num_threads(CORES) if (MULTIMINSIZE(ncol) && MULTIMINSIZE(nrow))
RandomFieldsUtils/src/kleinkram.cc:    MEMCOPY(y1, x1, sizeof(double) * nrow);
RandomFieldsUtils/src/kleinkram.cc:    MEMCOPY(y2, x2, sizeof(double) * nrow);
RandomFieldsUtils/src/kleinkram.cc:#pragma omp parallel for num_threads(CORES) reduction(+:sum) if (MULTIMINSIZE(nrow) && MULTIMINSIZE(nrow))
RandomFieldsUtils/src/kleinkram.cc:    MEMCOPY(y, x, sizeof(double) * nrow);
RandomFieldsUtils/src/kleinkram.cc:#pragma omp parallel for num_threads(CORES) if (MULTIMINSIZE(ncol) && MULTIMINSIZE(nrow))
RandomFieldsUtils/src/kleinkram.cc:    MEMCOPY(y1, x1, sizeof(double) * nrow);
RandomFieldsUtils/src/kleinkram.cc:    MEMCOPY(y2, x2, sizeof(double) * nrow);
RandomFieldsUtils/src/kleinkram.cc:    *dummy = (double*) MALLOC(sizeof(double) * size); // dummy = XC
RandomFieldsUtils/src/kleinkram.cc:  int    dimM1 = dim - 1;
RandomFieldsUtils/src/kleinkram.cc:#pragma omp parallel for num_threads(CORES) if (MULTIMINSIZE(dim)) reduction(+:xVy) 
RandomFieldsUtils/src/kleinkram.cc:    for (j += dimM1; i<dim; i++, j+=dim) dummy += x[i] * U[j];
RandomFieldsUtils/src/kleinkram.cc:  int   dimM1 = dim - 1;
RandomFieldsUtils/src/kleinkram.cc:#pragma omp parallel for num_threads(CORES) if (MULTIMINSIZE(dim))
RandomFieldsUtils/src/kleinkram.cc:    for (j += dimM1; i<dim; i++, j+=dim) dummy += x[i] * U[j];
RandomFieldsUtils/src/kleinkram.cc:  int dimM1 = dim - 1;
RandomFieldsUtils/src/kleinkram.cc:    for (j += dimM1; i<dim; i++, j+=dim) dummy += x[i] * U[j];
RandomFieldsUtils/src/kleinkram.cc:  int    dimM1 = dim - 1;
RandomFieldsUtils/src/kleinkram.cc:    for (j += dimM1; i<dim; i++, j+=dim) dummy += x[i] * U[j];
RandomFieldsUtils/src/kleinkram.cc:  double *m0 = (double*) MALLOC(sizeof(double) * dim1 * dim3);
RandomFieldsUtils/src/kleinkram.cc:SEXP Mat(double* V, int row, int col, int max) {
RandomFieldsUtils/src/kleinkram.cc:  if (V==NULL) return allocMatrix(REALSXP, 0, 0);
RandomFieldsUtils/src/kleinkram.cc:  PROTECT(dummy=allocMatrix(REALSXP, row, col));
RandomFieldsUtils/src/kleinkram.cc:SEXP Mat(double* V, int row, int col) {
RandomFieldsUtils/src/kleinkram.cc:  return Mat(V, row, col, MAXINT);
RandomFieldsUtils/src/kleinkram.cc:SEXP Mat_t(double* V, int row, int col, int max) {
RandomFieldsUtils/src/kleinkram.cc:  if (V==NULL) return allocMatrix(REALSXP, 0, 0);
RandomFieldsUtils/src/kleinkram.cc:  PROTECT(dummy=allocMatrix(REALSXP, row, col));
RandomFieldsUtils/src/kleinkram.cc:SEXP Mat_t(double* V, int row, int col) {
RandomFieldsUtils/src/kleinkram.cc:  return Mat_t(V, row, col, MAXINT);
RandomFieldsUtils/src/kleinkram.cc:SEXP MatString(char **V, int row, int col, int max) {
RandomFieldsUtils/src/kleinkram.cc:  if (V==NULL) return allocMatrix(STRSXP, 0, 0);
RandomFieldsUtils/src/kleinkram.cc:  PROTECT(dummy=allocMatrix(STRSXP, row, col));
RandomFieldsUtils/src/kleinkram.cc:SEXP MatString(char** V, int row, int col) {
RandomFieldsUtils/src/kleinkram.cc:  return MatString(V, row, col, MAXINT);
RandomFieldsUtils/src/kleinkram.cc:SEXP MatInt(int* V, int row, int col, int max) {
RandomFieldsUtils/src/kleinkram.cc:  if (V==NULL) return allocMatrix(INTSXP, 0, 0);
RandomFieldsUtils/src/kleinkram.cc:  PROTECT(dummy=allocMatrix(INTSXP, row, col));
RandomFieldsUtils/src/kleinkram.cc:SEXP MatInt(int* V, int row, int col) {
RandomFieldsUtils/src/kleinkram.cc:  return MatInt(V, row, col, MAXINT);
RandomFieldsUtils/src/kleinkram.cc:  return Array3D(V, depth, row, col, MAXINT);
RandomFieldsUtils/src/kleinkram.cc:SEXP String(char V[][MAXCHAR], int n, int max) {
RandomFieldsUtils/src/kleinkram.cc:SEXP String(char V[][MAXCHAR], int n) {return String(V, n, n);}
RandomFieldsUtils/src/kleinkram.cc:	   name, R_TYPE_NAME(TYPEOF(p)));  
RandomFieldsUtils/src/kleinkram.cc:	   name, R_TYPE_NAME(TYPEOF(p)));
RandomFieldsUtils/src/kleinkram.cc:void String(SEXP el, char *name, char names[][MAXCHAR], int maxlen) {
RandomFieldsUtils/src/kleinkram.cc:      strcopyN(names[i], CHAR(STRING_ELT(el, i)), MAXCHAR);
RandomFieldsUtils/src/kleinkram.cc:  num = NUM;
RandomFieldsUtils/src/kleinkram.cc:  num = NUM;
RandomFieldsUtils/src/kleinkram.cc:  num = NUM;
RandomFieldsUtils/src/kleinkram.cc:int Match(char *name, name_type List, int n) {
RandomFieldsUtils/src/kleinkram.cc:  // == NOMATCHING, -1, if no matching function is found
RandomFieldsUtils/src/kleinkram.cc:  // == MULTIPLEMATCHING,-2, if multiple matching fctns are found,  
RandomFieldsUtils/src/kleinkram.cc:  //  print("Match %d %d %.50s %.50s %d\n", Nr, n, name, List[Nr], ln);
RandomFieldsUtils/src/kleinkram.cc:  while ( Nr < n  && STRNCMP(name, List[Nr], ln)) {
RandomFieldsUtils/src/kleinkram.cc:      while ( (j<n) && STRNCMP(name, List[j], ln)) {j++;}
RandomFieldsUtils/src/kleinkram.cc:    if (multiplematching) {return MULTIPLEMATCHING;}
RandomFieldsUtils/src/kleinkram.cc:  } else return NOMATCHING;
RandomFieldsUtils/src/kleinkram.cc:int Match(char *name, const char * List[], int n) {
RandomFieldsUtils/src/kleinkram.cc:  // printf("Matching\n");
RandomFieldsUtils/src/kleinkram.cc:  //    print("Matchx %d %d %.50s %.50s %d\n", Nr, n, name, List[Nr], ln);
RandomFieldsUtils/src/kleinkram.cc:  while ( Nr < n  && STRNCMP(name, List[Nr], ln)) {
RandomFieldsUtils/src/kleinkram.cc:      while ( (j<n) && STRNCMP(name, List[j], ln)) {j++;}
RandomFieldsUtils/src/kleinkram.cc:    if (multiplematching) {return MULTIPLEMATCHING;}
RandomFieldsUtils/src/kleinkram.cc:  } else return NOMATCHING;
RandomFieldsUtils/src/kleinkram.cc:    RFERROR2("option '%.50s' is too lengthy. Maximum length is %d.",
RandomFieldsUtils/src/kleinkram.cc:      ans[k] = Match((char*) CHAR(STRING_ELT(el, k)), List, n);
RandomFieldsUtils/src/kleinkram.cc:	if (STRCMP((char*) CHAR(STRING_ELT(el, k)), " ") == 0 ||
RandomFieldsUtils/src/kleinkram.cc:	    STRCMP((char*) CHAR(STRING_ELT(el, k)), "") == 0) {
RandomFieldsUtils/src/kleinkram.cc:  return Mod(y, modulus) - halfmodulus;
RandomFieldsUtils/src/kleinkram.cc:#ifndef RANDOMFIELDS_DEBUGGING  
Binary file RandomFieldsUtils/src/RandomFieldsUtils.so matches
Binary file RandomFieldsUtils/src/own.o matches
Binary file RandomFieldsUtils/src/maths.o matches
RandomFieldsUtils/src/win_linux_aux.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/src/win_linux_aux.cc: Copyright (C) 2001 -- 2017 Martin Schlather, 
RandomFieldsUtils/src/win_linux_aux.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURSE.  See the
RandomFieldsUtils/src/win_linux_aux.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFieldsUtils/src/win_linux_aux.cc:// #define WIN32_LEAN_AND_MEAN
RandomFieldsUtils/src/win_linux_aux.cc:void sleepMilli(int *milli) {
RandomFieldsUtils/src/win_linux_aux.cc:void sleepMicro(int *micro) {
RandomFieldsUtils/src/bckslvmodified.f:c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/src/bckslvmodified.f:c Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/src/bckslvmodified.f:C   Mathematical Sciences Section, Oak Ridge National Laboratory
RandomFieldsUtils/src/bckslvmodified.f:c MODIFIED, overwritting b now!! (M.Schlather, 4.4.15)
RandomFieldsUtils/src/brdomain.cc: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/src/brdomain.cc: Copyright (C) 2001 -- 2017 Martin Schlather, 
RandomFieldsUtils/src/brdomain.cc:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURSE.  See the
RandomFieldsUtils/src/brdomain.cc:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
RandomFieldsUtils/src/brdomain.cc:// #define SIMD_AVAIALBLE 1
RandomFieldsUtils/src/brdomain.cc:#ifdef SCHLATHERS_MACHINE
RandomFieldsUtils/src/brdomain.cc:	x0 = (int) (UNIFORM_RANDOM * nloc);
RandomFieldsUtils/src/brdomain.cc:	*field = rf + nloc * (int) (UNIFORM_RANDOM * N),
RandomFieldsUtils/src/brdomain.cc:#endif // SCHLATHERS_MACHINE
Binary file RandomFieldsUtils/src/utils.o matches
RandomFieldsUtils/src/win_linux_aux.h: Martin Schlather, schlather@math.uni-mannheim.de
RandomFieldsUtils/src/win_linux_aux.h: Copyright (C) 2015 -- 2017 Martin Schlather
RandomFieldsUtils/src/win_linux_aux.h:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
RandomFieldsUtils/src/win_linux_aux.h:Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  
RandomFieldsUtils/src/win_linux_aux.h:extern "C" void sleepMilli(int *milli);
RandomFieldsUtils/src/win_linux_aux.h:extern "C" void sleepMicro(int *milli);
RandomFieldsUtils/NAMESPACE:       colMax, rowMeansx, rowProd, SelfDivByRow, quadratic, dotXV,
Binary file Rplots.pdf matches
